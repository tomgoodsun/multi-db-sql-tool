/*! For license information please see vendor.js.LICENSE.txt */
((window) => {
  var e = {
      237: function(e) {
        e.exports = function() {
          "use strict";
          var e = navigator.userAgent,
            t = navigator.platform,
            i = /gecko\/\d/i.test(e),
            r = /MSIE \d/.test(e),
            s = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e),
            n = /Edge\/(\d+)/.exec(e),
            o = r || s || n,
            a = o && (r ? document.documentMode || 6 : +(n || s)[1]),
            l = !n && /WebKit\//.test(e),
            c = l && /Qt\/\d+\.\d+/.test(e),
            h = !n && /Chrome\/(\d+)/.exec(e),
            u = h && +h[1],
            d = /Opera\//.test(e),
            p = /Apple Computer/.test(navigator.vendor),
            E = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e),
            g = /PhantomJS/.test(e),
            f = p && (/Mobile\/\w+/.test(e) || navigator.maxTouchPoints > 2),
            T = /Android/.test(e),
            m = f || T || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e),
            C = f || /Mac/.test(t),
            S = /\bCrOS\b/.test(e),
            R = /win/i.test(t),
            A = d && e.match(/Version\/(\d*\.\d*)/);
          A && (A = Number(A[1])), A && A >= 15 && (d = !1, l = !0);
          var v = C && (c || d && (null == A || A < 12.11)),
            N = i || o && a >= 9;

          function I(e) {
            return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
          }
          var O, L = function(e, t) {
            var i = e.className,
              r = I(t).exec(i);
            if (r) {
              var s = i.slice(r.index + r[0].length);
              e.className = i.slice(0, r.index) + (s ? r[1] + s : "")
            }
          };

          function _(e) {
            for (var t = e.childNodes.length; t > 0; --t) e.removeChild(e.firstChild);
            return e
          }

          function y(e, t) {
            return _(e).appendChild(t)
          }

          function w(e, t, i, r) {
            var s = document.createElement(e);
            if (i && (s.className = i), r && (s.style.cssText = r), "string" == typeof t) s.appendChild(document.createTextNode(t));
            else if (t)
              for (var n = 0; n < t.length; ++n) s.appendChild(t[n]);
            return s
          }

          function D(e, t, i, r) {
            var s = w(e, t, i, r);
            return s.setAttribute("role", "presentation"), s
          }

          function P(e, t) {
            if (3 == t.nodeType && (t = t.parentNode), e.contains) return e.contains(t);
            do {
              if (11 == t.nodeType && (t = t.host), t == e) return !0
            } while (t = t.parentNode)
          }

          function b(e) {
            var t, i = e.ownerDocument || e;
            try {
              t = e.activeElement
            } catch (e) {
              t = i.body || null
            }
            for (; t && t.shadowRoot && t.shadowRoot.activeElement;) t = t.shadowRoot.activeElement;
            return t
          }

          function M(e, t) {
            var i = e.className;
            I(t).test(i) || (e.className += (i ? " " : "") + t)
          }

          function F(e, t) {
            for (var i = e.split(" "), r = 0; r < i.length; r++) i[r] && !I(i[r]).test(t) && (t += " " + i[r]);
            return t
          }
          O = document.createRange ? function(e, t, i, r) {
            var s = document.createRange();
            return s.setEnd(r || e, i), s.setStart(e, t), s
          } : function(e, t, i) {
            var r = document.body.createTextRange();
            try {
              r.moveToElementText(e.parentNode)
            } catch (e) {
              return r
            }
            return r.collapse(!0), r.moveEnd("character", i), r.moveStart("character", t), r
          };
          var x = function(e) {
            e.select()
          };

          function G(e) {
            return e.display.wrapper.ownerDocument
          }

          function U(e) {
            return H(e.display.wrapper)
          }

          function H(e) {
            return e.getRootNode ? e.getRootNode() : e.ownerDocument
          }

          function k(e) {
            return G(e).defaultView
          }

          function B(e) {
            var t = Array.prototype.slice.call(arguments, 1);
            return function() {
              return e.apply(null, t)
            }
          }

          function V(e, t, i) {
            for (var r in t || (t = {}), e) !e.hasOwnProperty(r) || !1 === i && t.hasOwnProperty(r) || (t[r] = e[r]);
            return t
          }

          function W(e, t, i, r, s) {
            null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length);
            for (var n = r || 0, o = s || 0;;) {
              var a = e.indexOf("\t", n);
              if (a < 0 || a >= t) return o + (t - n);
              o += a - n, o += i - o % i, n = a + 1
            }
          }
          f ? x = function(e) {
            e.selectionStart = 0, e.selectionEnd = e.value.length
          } : o && (x = function(e) {
            try {
              e.select()
            } catch (e) {}
          });
          var Y = function() {
            this.id = null, this.f = null, this.time = 0, this.handler = B(this.onTimeout, this)
          };

          function K(e, t) {
            for (var i = 0; i < e.length; ++i)
              if (e[i] == t) return i;
            return -1
          }
          Y.prototype.onTimeout = function(e) {
            e.id = 0, e.time <= +new Date ? e.f() : setTimeout(e.handler, e.time - +new Date)
          }, Y.prototype.set = function(e, t) {
            this.f = t;
            var i = +new Date + e;
            (!this.id || i < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = i)
          };
          var X = 50,
            z = {
              toString: function() {
                return "CodeMirror.Pass"
              }
            },
            $ = {
              scroll: !1
            },
            j = {
              origin: "*mouse"
            },
            J = {
              origin: "+move"
            };

          function q(e, t, i) {
            for (var r = 0, s = 0;;) {
              var n = e.indexOf("\t", r); - 1 == n && (n = e.length);
              var o = n - r;
              if (n == e.length || s + o >= t) return r + Math.min(o, t - s);
              if (s += n - r, r = n + 1, (s += i - s % i) >= t) return r
            }
          }
          var Q = [""];

          function Z(e) {
            for (; Q.length <= e;) Q.push(ee(Q) + " ");
            return Q[e]
          }

          function ee(e) {
            return e[e.length - 1]
          }

          function te(e, t) {
            for (var i = [], r = 0; r < e.length; r++) i[r] = t(e[r], r);
            return i
          }

          function ie(e, t, i) {
            for (var r = 0, s = i(t); r < e.length && i(e[r]) <= s;) r++;
            e.splice(r, 0, t)
          }

          function re() {}

          function se(e, t) {
            var i;
            return Object.create ? i = Object.create(e) : (re.prototype = e, i = new re), t && V(t, i), i
          }
          var ne = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

          function oe(e) {
            return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || ne.test(e))
          }

          function ae(e, t) {
            return t ? !!(t.source.indexOf("\\w") > -1 && oe(e)) || t.test(e) : oe(e)
          }

          function le(e) {
            for (var t in e)
              if (e.hasOwnProperty(t) && e[t]) return !1;
            return !0
          }
          var ce = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

          function he(e) {
            return e.charCodeAt(0) >= 768 && ce.test(e)
          }

          function ue(e, t, i) {
            for (;
              (i < 0 ? t > 0 : t < e.length) && he(e.charAt(t));) t += i;
            return t
          }

          function de(e, t, i) {
            for (var r = t > i ? -1 : 1;;) {
              if (t == i) return t;
              var s = (t + i) / 2,
                n = r < 0 ? Math.ceil(s) : Math.floor(s);
              if (n == t) return e(n) ? t : i;
              e(n) ? i = n : t = n + r
            }
          }

          function pe(e, t, i, r) {
            if (!e) return r(t, i, "ltr", 0);
            for (var s = !1, n = 0; n < e.length; ++n) {
              var o = e[n];
              (o.from < i && o.to > t || t == i && o.to == t) && (r(Math.max(o.from, t), Math.min(o.to, i), 1 == o.level ? "rtl" : "ltr", n), s = !0)
            }
            s || r(t, i, "ltr")
          }
          var Ee = null;

          function ge(e, t, i) {
            var r;
            Ee = null;
            for (var s = 0; s < e.length; ++s) {
              var n = e[s];
              if (n.from < t && n.to > t) return s;
              n.to == t && (n.from != n.to && "before" == i ? r = s : Ee = s), n.from == t && (n.from != n.to && "before" != i ? r = s : Ee = s)
            }
            return null != r ? r : Ee
          }
          var fe = function() {
            var e = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",
              t = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

            function i(i) {
              return i <= 247 ? e.charAt(i) : 1424 <= i && i <= 1524 ? "R" : 1536 <= i && i <= 1785 ? t.charAt(i - 1536) : 1774 <= i && i <= 2220 ? "r" : 8192 <= i && i <= 8203 ? "w" : 8204 == i ? "b" : "L"
            }
            var r = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,
              s = /[stwN]/,
              n = /[LRr]/,
              o = /[Lb1n]/,
              a = /[1n]/;

            function l(e, t, i) {
              this.level = e, this.from = t, this.to = i
            }
            return function(e, t) {
              var c = "ltr" == t ? "L" : "R";
              if (0 == e.length || "ltr" == t && !r.test(e)) return !1;
              for (var h = e.length, u = [], d = 0; d < h; ++d) u.push(i(e.charCodeAt(d)));
              for (var p = 0, E = c; p < h; ++p) {
                var g = u[p];
                "m" == g ? u[p] = E : E = g
              }
              for (var f = 0, T = c; f < h; ++f) {
                var m = u[f];
                "1" == m && "r" == T ? u[f] = "n" : n.test(m) && (T = m, "r" == m && (u[f] = "R"))
              }
              for (var C = 1, S = u[0]; C < h - 1; ++C) {
                var R = u[C];
                "+" == R && "1" == S && "1" == u[C + 1] ? u[C] = "1" : "," != R || S != u[C + 1] || "1" != S && "n" != S || (u[C] = S), S = R
              }
              for (var A = 0; A < h; ++A) {
                var v = u[A];
                if ("," == v) u[A] = "N";
                else if ("%" == v) {
                  var N = void 0;
                  for (N = A + 1; N < h && "%" == u[N]; ++N);
                  for (var I = A && "!" == u[A - 1] || N < h && "1" == u[N] ? "1" : "N", O = A; O < N; ++O) u[O] = I;
                  A = N - 1
                }
              }
              for (var L = 0, _ = c; L < h; ++L) {
                var y = u[L];
                "L" == _ && "1" == y ? u[L] = "L" : n.test(y) && (_ = y)
              }
              for (var w = 0; w < h; ++w)
                if (s.test(u[w])) {
                  var D = void 0;
                  for (D = w + 1; D < h && s.test(u[D]); ++D);
                  for (var P = "L" == (w ? u[w - 1] : c), b = P == ("L" == (D < h ? u[D] : c)) ? P ? "L" : "R" : c, M = w; M < D; ++M) u[M] = b;
                  w = D - 1
                } for (var F, x = [], G = 0; G < h;)
                if (o.test(u[G])) {
                  var U = G;
                  for (++G; G < h && o.test(u[G]); ++G);
                  x.push(new l(0, U, G))
                } else {
                  var H = G,
                    k = x.length,
                    B = "rtl" == t ? 1 : 0;
                  for (++G; G < h && "L" != u[G]; ++G);
                  for (var V = H; V < G;)
                    if (a.test(u[V])) {
                      H < V && (x.splice(k, 0, new l(1, H, V)), k += B);
                      var W = V;
                      for (++V; V < G && a.test(u[V]); ++V);
                      x.splice(k, 0, new l(2, W, V)), k += B, H = V
                    } else ++V;
                  H < G && x.splice(k, 0, new l(1, H, G))
                } return "ltr" == t && (1 == x[0].level && (F = e.match(/^\s+/)) && (x[0].from = F[0].length, x.unshift(new l(0, 0, F[0].length))), 1 == ee(x).level && (F = e.match(/\s+$/)) && (ee(x).to -= F[0].length, x.push(new l(0, h - F[0].length, h)))), "rtl" == t ? x.reverse() : x
            }
          }();

          function Te(e, t) {
            var i = e.order;
            return null == i && (i = e.order = fe(e.text, t)), i
          }
          var me = [],
            Ce = function(e, t, i) {
              if (e.addEventListener) e.addEventListener(t, i, !1);
              else if (e.attachEvent) e.attachEvent("on" + t, i);
              else {
                var r = e._handlers || (e._handlers = {});
                r[t] = (r[t] || me).concat(i)
              }
            };

          function Se(e, t) {
            return e._handlers && e._handlers[t] || me
          }

          function Re(e, t, i) {
            if (e.removeEventListener) e.removeEventListener(t, i, !1);
            else if (e.detachEvent) e.detachEvent("on" + t, i);
            else {
              var r = e._handlers,
                s = r && r[t];
              if (s) {
                var n = K(s, i);
                n > -1 && (r[t] = s.slice(0, n).concat(s.slice(n + 1)))
              }
            }
          }

          function Ae(e, t) {
            var i = Se(e, t);
            if (i.length)
              for (var r = Array.prototype.slice.call(arguments, 2), s = 0; s < i.length; ++s) i[s].apply(null, r)
          }

          function ve(e, t, i) {
            return "string" == typeof t && (t = {
              type: t,
              preventDefault: function() {
                this.defaultPrevented = !0
              }
            }), Ae(e, i || t.type, e, t), ye(t) || t.codemirrorIgnore
          }

          function Ne(e) {
            var t = e._handlers && e._handlers.cursorActivity;
            if (t)
              for (var i = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r) - 1 == K(i, t[r]) && i.push(t[r])
          }

          function Ie(e, t) {
            return Se(e, t).length > 0
          }

          function Oe(e) {
            e.prototype.on = function(e, t) {
              Ce(this, e, t)
            }, e.prototype.off = function(e, t) {
              Re(this, e, t)
            }
          }

          function Le(e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
          }

          function _e(e) {
            e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
          }

          function ye(e) {
            return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
          }

          function we(e) {
            Le(e), _e(e)
          }

          function De(e) {
            return e.target || e.srcElement
          }

          function Pe(e) {
            var t = e.which;
            return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), C && e.ctrlKey && 1 == t && (t = 3), t
          }
          var be, Me, Fe = function() {
            if (o && a < 9) return !1;
            var e = w("div");
            return "draggable" in e || "dragDrop" in e
          }();

          function xe(e) {
            if (null == be) {
              var t = w("span", "​");
              y(e, w("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (be = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(o && a < 8))
            }
            var i = be ? w("span", "​") : w("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
            return i.setAttribute("cm-text", ""), i
          }

          function Ge(e) {
            if (null != Me) return Me;
            var t = y(e, document.createTextNode("AخA")),
              i = O(t, 0, 1).getBoundingClientRect(),
              r = O(t, 1, 2).getBoundingClientRect();
            return _(e), !(!i || i.left == i.right) && (Me = r.right - i.right < 3)
          }
          var Ue, He = 3 != "\n\nb".split(/\n/).length ? function(e) {
              for (var t = 0, i = [], r = e.length; t <= r;) {
                var s = e.indexOf("\n", t); - 1 == s && (s = e.length);
                var n = e.slice(t, "\r" == e.charAt(s - 1) ? s - 1 : s),
                  o = n.indexOf("\r"); - 1 != o ? (i.push(n.slice(0, o)), t += o + 1) : (i.push(n), t = s + 1)
              }
              return i
            } : function(e) {
              return e.split(/\r\n?|\n/)
            },
            ke = window.getSelection ? function(e) {
              try {
                return e.selectionStart != e.selectionEnd
              } catch (e) {
                return !1
              }
            } : function(e) {
              var t;
              try {
                t = e.ownerDocument.selection.createRange()
              } catch (e) {}
              return !(!t || t.parentElement() != e) && 0 != t.compareEndPoints("StartToEnd", t)
            },
            Be = "oncopy" in (Ue = w("div")) || (Ue.setAttribute("oncopy", "return;"), "function" == typeof Ue.oncopy),
            Ve = null;

          function We(e) {
            if (null != Ve) return Ve;
            var t = y(e, w("span", "x")),
              i = t.getBoundingClientRect(),
              r = O(t, 0, 1).getBoundingClientRect();
            return Ve = Math.abs(i.left - r.left) > 1
          }
          var Ye = {},
            Ke = {};

          function Xe(e, t) {
            arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), Ye[e] = t
          }

          function ze(e, t) {
            Ke[e] = t
          }

          function $e(e) {
            if ("string" == typeof e && Ke.hasOwnProperty(e)) e = Ke[e];
            else if (e && "string" == typeof e.name && Ke.hasOwnProperty(e.name)) {
              var t = Ke[e.name];
              "string" == typeof t && (t = {
                name: t
              }), (e = se(t, e)).name = t.name
            } else {
              if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) return $e("application/xml");
              if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) return $e("application/json")
            }
            return "string" == typeof e ? {
              name: e
            } : e || {
              name: "null"
            }
          }

          function je(e, t) {
            t = $e(t);
            var i = Ye[t.name];
            if (!i) return je(e, "text/plain");
            var r = i(e, t);
            if (Je.hasOwnProperty(t.name)) {
              var s = Je[t.name];
              for (var n in s) s.hasOwnProperty(n) && (r.hasOwnProperty(n) && (r["_" + n] = r[n]), r[n] = s[n])
            }
            if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps)
              for (var o in t.modeProps) r[o] = t.modeProps[o];
            return r
          }
          var Je = {};

          function qe(e, t) {
            V(t, Je.hasOwnProperty(e) ? Je[e] : Je[e] = {})
          }

          function Qe(e, t) {
            if (!0 === t) return t;
            if (e.copyState) return e.copyState(t);
            var i = {};
            for (var r in t) {
              var s = t[r];
              s instanceof Array && (s = s.concat([])), i[r] = s
            }
            return i
          }

          function Ze(e, t) {
            for (var i; e.innerMode && (i = e.innerMode(t)) && i.mode != e;) t = i.state, e = i.mode;
            return i || {
              mode: e,
              state: t
            }
          }

          function et(e, t, i) {
            return !e.startState || e.startState(t, i)
          }
          var tt = function(e, t, i) {
            this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = i
          };

          function it(e, t) {
            if ((t -= e.first) < 0 || t >= e.size) throw new Error("There is no line " + (t + e.first) + " in the document.");
            for (var i = e; !i.lines;)
              for (var r = 0;; ++r) {
                var s = i.children[r],
                  n = s.chunkSize();
                if (t < n) {
                  i = s;
                  break
                }
                t -= n
              }
            return i.lines[t]
          }

          function rt(e, t, i) {
            var r = [],
              s = t.line;
            return e.iter(t.line, i.line + 1, function(e) {
              var n = e.text;
              s == i.line && (n = n.slice(0, i.ch)), s == t.line && (n = n.slice(t.ch)), r.push(n), ++s
            }), r
          }

          function st(e, t, i) {
            var r = [];
            return e.iter(t, i, function(e) {
              r.push(e.text)
            }), r
          }

          function nt(e, t) {
            var i = t - e.height;
            if (i)
              for (var r = e; r; r = r.parent) r.height += i
          }

          function ot(e) {
            if (null == e.parent) return null;
            for (var t = e.parent, i = K(t.lines, e), r = t.parent; r; t = r, r = r.parent)
              for (var s = 0; r.children[s] != t; ++s) i += r.children[s].chunkSize();
            return i + t.first
          }

          function at(e, t) {
            var i = e.first;
            e: do {
              for (var r = 0; r < e.children.length; ++r) {
                var s = e.children[r],
                  n = s.height;
                if (t < n) {
                  e = s;
                  continue e
                }
                t -= n, i += s.chunkSize()
              }
              return i
            } while (!e.lines);
            for (var o = 0; o < e.lines.length; ++o) {
              var a = e.lines[o].height;
              if (t < a) break;
              t -= a
            }
            return i + o
          }

          function lt(e, t) {
            return t >= e.first && t < e.first + e.size
          }

          function ct(e, t) {
            return String(e.lineNumberFormatter(t + e.firstLineNumber))
          }

          function ht(e, t, i) {
            if (void 0 === i && (i = null), !(this instanceof ht)) return new ht(e, t, i);
            this.line = e, this.ch = t, this.sticky = i
          }

          function ut(e, t) {
            return e.line - t.line || e.ch - t.ch
          }

          function dt(e, t) {
            return e.sticky == t.sticky && 0 == ut(e, t)
          }

          function pt(e) {
            return ht(e.line, e.ch)
          }

          function Et(e, t) {
            return ut(e, t) < 0 ? t : e
          }

          function gt(e, t) {
            return ut(e, t) < 0 ? e : t
          }

          function ft(e, t) {
            return Math.max(e.first, Math.min(t, e.first + e.size - 1))
          }

          function Tt(e, t) {
            if (t.line < e.first) return ht(e.first, 0);
            var i = e.first + e.size - 1;
            return t.line > i ? ht(i, it(e, i).text.length) : mt(t, it(e, t.line).text.length)
          }

          function mt(e, t) {
            var i = e.ch;
            return null == i || i > t ? ht(e.line, t) : i < 0 ? ht(e.line, 0) : e
          }

          function Ct(e, t) {
            for (var i = [], r = 0; r < t.length; r++) i[r] = Tt(e, t[r]);
            return i
          }
          tt.prototype.eol = function() {
            return this.pos >= this.string.length
          }, tt.prototype.sol = function() {
            return this.pos == this.lineStart
          }, tt.prototype.peek = function() {
            return this.string.charAt(this.pos) || void 0
          }, tt.prototype.next = function() {
            if (this.pos < this.string.length) return this.string.charAt(this.pos++)
          }, tt.prototype.eat = function(e) {
            var t = this.string.charAt(this.pos);
            if ("string" == typeof e ? t == e : t && (e.test ? e.test(t) : e(t))) return ++this.pos, t
          }, tt.prototype.eatWhile = function(e) {
            for (var t = this.pos; this.eat(e););
            return this.pos > t
          }, tt.prototype.eatSpace = function() {
            for (var e = this.pos;
              /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this.pos;
            return this.pos > e
          }, tt.prototype.skipToEnd = function() {
            this.pos = this.string.length
          }, tt.prototype.skipTo = function(e) {
            var t = this.string.indexOf(e, this.pos);
            if (t > -1) return this.pos = t, !0
          }, tt.prototype.backUp = function(e) {
            this.pos -= e
          }, tt.prototype.column = function() {
            return this.lastColumnPos < this.start && (this.lastColumnValue = W(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? W(this.string, this.lineStart, this.tabSize) : 0)
          }, tt.prototype.indentation = function() {
            return W(this.string, null, this.tabSize) - (this.lineStart ? W(this.string, this.lineStart, this.tabSize) : 0)
          }, tt.prototype.match = function(e, t, i) {
            if ("string" != typeof e) {
              var r = this.string.slice(this.pos).match(e);
              return r && r.index > 0 ? null : (r && !1 !== t && (this.pos += r[0].length), r)
            }
            var s = function(e) {
              return i ? e.toLowerCase() : e
            };
            if (s(this.string.substr(this.pos, e.length)) == s(e)) return !1 !== t && (this.pos += e.length), !0
          }, tt.prototype.current = function() {
            return this.string.slice(this.start, this.pos)
          }, tt.prototype.hideFirstChars = function(e, t) {
            this.lineStart += e;
            try {
              return t()
            } finally {
              this.lineStart -= e
            }
          }, tt.prototype.lookAhead = function(e) {
            var t = this.lineOracle;
            return t && t.lookAhead(e)
          }, tt.prototype.baseToken = function() {
            var e = this.lineOracle;
            return e && e.baseToken(this.pos)
          };
          var St = function(e, t) {
              this.state = e, this.lookAhead = t
            },
            Rt = function(e, t, i, r) {
              this.state = t, this.doc = e, this.line = i, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1
            };

          function At(e, t, i, r) {
            var s = [e.state.modeGen],
              n = {};
            Dt(e, t.text, e.doc.mode, i, function(e, t) {
              return s.push(e, t)
            }, n, r);
            for (var o = i.state, a = function(r) {
                i.baseTokens = s;
                var a = e.state.overlays[r],
                  l = 1,
                  c = 0;
                i.state = !0, Dt(e, t.text, a.mode, i, function(e, t) {
                  for (var i = l; c < e;) {
                    var r = s[l];
                    r > e && s.splice(l, 1, e, s[l + 1], r), l += 2, c = Math.min(e, r)
                  }
                  if (t)
                    if (a.opaque) s.splice(i, l - i, e, "overlay " + t), l = i + 2;
                    else
                      for (; i < l; i += 2) {
                        var n = s[i + 1];
                        s[i + 1] = (n ? n + " " : "") + "overlay " + t
                      }
                }, n), i.state = o, i.baseTokens = null, i.baseTokenPos = 1
              }, l = 0; l < e.state.overlays.length; ++l) a(l);
            return {
              styles: s,
              classes: n.bgClass || n.textClass ? n : null
            }
          }

          function vt(e, t, i) {
            if (!t.styles || t.styles[0] != e.state.modeGen) {
              var r = Nt(e, ot(t)),
                s = t.text.length > e.options.maxHighlightLength && Qe(e.doc.mode, r.state),
                n = At(e, t, r);
              s && (r.state = s), t.stateAfter = r.save(!s), t.styles = n.styles, n.classes ? t.styleClasses = n.classes : t.styleClasses && (t.styleClasses = null), i === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier))
            }
            return t.styles
          }

          function Nt(e, t, i) {
            var r = e.doc,
              s = e.display;
            if (!r.mode.startState) return new Rt(r, !0, t);
            var n = Pt(e, t, i),
              o = n > r.first && it(r, n - 1).stateAfter,
              a = o ? Rt.fromSaved(r, o, n) : new Rt(r, et(r.mode), n);
            return r.iter(n, t, function(i) {
              It(e, i.text, a);
              var r = a.line;
              i.stateAfter = r == t - 1 || r % 5 == 0 || r >= s.viewFrom && r < s.viewTo ? a.save() : null, a.nextLine()
            }), i && (r.modeFrontier = a.line), a
          }

          function It(e, t, i, r) {
            var s = e.doc.mode,
              n = new tt(t, e.options.tabSize, i);
            for (n.start = n.pos = r || 0, "" == t && Ot(s, i.state); !n.eol();) Lt(s, n, i.state), n.start = n.pos
          }

          function Ot(e, t) {
            if (e.blankLine) return e.blankLine(t);
            if (e.innerMode) {
              var i = Ze(e, t);
              return i.mode.blankLine ? i.mode.blankLine(i.state) : void 0
            }
          }

          function Lt(e, t, i, r) {
            for (var s = 0; s < 10; s++) {
              r && (r[0] = Ze(e, i).mode);
              var n = e.token(t, i);
              if (t.pos > t.start) return n
            }
            throw new Error("Mode " + e.name + " failed to advance stream.")
          }
          Rt.prototype.lookAhead = function(e) {
            var t = this.doc.getLine(this.line + e);
            return null != t && e > this.maxLookAhead && (this.maxLookAhead = e), t
          }, Rt.prototype.baseToken = function(e) {
            if (!this.baseTokens) return null;
            for (; this.baseTokens[this.baseTokenPos] <= e;) this.baseTokenPos += 2;
            var t = this.baseTokens[this.baseTokenPos + 1];
            return {
              type: t && t.replace(/( |^)overlay .*/, ""),
              size: this.baseTokens[this.baseTokenPos] - e
            }
          }, Rt.prototype.nextLine = function() {
            this.line++, this.maxLookAhead > 0 && this.maxLookAhead--
          }, Rt.fromSaved = function(e, t, i) {
            return t instanceof St ? new Rt(e, Qe(e.mode, t.state), i, t.lookAhead) : new Rt(e, Qe(e.mode, t), i)
          }, Rt.prototype.save = function(e) {
            var t = !1 !== e ? Qe(this.doc.mode, this.state) : this.state;
            return this.maxLookAhead > 0 ? new St(t, this.maxLookAhead) : t
          };
          var _t = function(e, t, i) {
            this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = i
          };

          function yt(e, t, i, r) {
            var s, n, o = e.doc,
              a = o.mode,
              l = it(o, (t = Tt(o, t)).line),
              c = Nt(e, t.line, i),
              h = new tt(l.text, e.options.tabSize, c);
            for (r && (n = []);
              (r || h.pos < t.ch) && !h.eol();) h.start = h.pos, s = Lt(a, h, c.state), r && n.push(new _t(h, s, Qe(o.mode, c.state)));
            return r ? n : new _t(h, s, c.state)
          }

          function wt(e, t) {
            if (e)
              for (;;) {
                var i = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!i) break;
                e = e.slice(0, i.index) + e.slice(i.index + i[0].length);
                var r = i[1] ? "bgClass" : "textClass";
                null == t[r] ? t[r] = i[2] : new RegExp("(?:^|\\s)" + i[2] + "(?:$|\\s)").test(t[r]) || (t[r] += " " + i[2])
              }
            return e
          }

          function Dt(e, t, i, r, s, n, o) {
            var a = i.flattenSpans;
            null == a && (a = e.options.flattenSpans);
            var l, c = 0,
              h = null,
              u = new tt(t, e.options.tabSize, r),
              d = e.options.addModeClass && [null];
            for ("" == t && wt(Ot(i, r.state), n); !u.eol();) {
              if (u.pos > e.options.maxHighlightLength ? (a = !1, o && It(e, t, r, u.pos), u.pos = t.length, l = null) : l = wt(Lt(i, u, r.state, d), n), d) {
                var p = d[0].name;
                p && (l = "m-" + (l ? p + " " + l : p))
              }
              if (!a || h != l) {
                for (; c < u.start;) s(c = Math.min(u.start, c + 5e3), h);
                h = l
              }
              u.start = u.pos
            }
            for (; c < u.pos;) {
              var E = Math.min(u.pos, c + 5e3);
              s(E, h), c = E
            }
          }

          function Pt(e, t, i) {
            for (var r, s, n = e.doc, o = i ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), a = t; a > o; --a) {
              if (a <= n.first) return n.first;
              var l = it(n, a - 1),
                c = l.stateAfter;
              if (c && (!i || a + (c instanceof St ? c.lookAhead : 0) <= n.modeFrontier)) return a;
              var h = W(l.text, null, e.options.tabSize);
              (null == s || r > h) && (s = a - 1, r = h)
            }
            return s
          }

          function bt(e, t) {
            if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) {
              for (var i = e.first, r = t - 1; r > i; r--) {
                var s = it(e, r).stateAfter;
                if (s && (!(s instanceof St) || r + s.lookAhead < t)) {
                  i = r + 1;
                  break
                }
              }
              e.highlightFrontier = Math.min(e.highlightFrontier, i)
            }
          }
          var Mt = !1,
            Ft = !1;

          function xt() {
            Mt = !0
          }

          function Gt() {
            Ft = !0
          }

          function Ut(e, t, i) {
            this.marker = e, this.from = t, this.to = i
          }

          function Ht(e, t) {
            if (e)
              for (var i = 0; i < e.length; ++i) {
                var r = e[i];
                if (r.marker == t) return r
              }
          }

          function kt(e, t) {
            for (var i, r = 0; r < e.length; ++r) e[r] != t && (i || (i = [])).push(e[r]);
            return i
          }

          function Bt(e, t, i) {
            var r = i && window.WeakSet && (i.markedSpans || (i.markedSpans = new WeakSet));
            r && e.markedSpans && r.has(e.markedSpans) ? e.markedSpans.push(t) : (e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], r && r.add(e.markedSpans)), t.marker.attachLine(e)
          }

          function Vt(e, t, i) {
            var r;
            if (e)
              for (var s = 0; s < e.length; ++s) {
                var n = e[s],
                  o = n.marker;
                if (null == n.from || (o.inclusiveLeft ? n.from <= t : n.from < t) || n.from == t && "bookmark" == o.type && (!i || !n.marker.insertLeft)) {
                  var a = null == n.to || (o.inclusiveRight ? n.to >= t : n.to > t);
                  (r || (r = [])).push(new Ut(o, n.from, a ? null : n.to))
                }
              }
            return r
          }

          function Wt(e, t, i) {
            var r;
            if (e)
              for (var s = 0; s < e.length; ++s) {
                var n = e[s],
                  o = n.marker;
                if (null == n.to || (o.inclusiveRight ? n.to >= t : n.to > t) || n.from == t && "bookmark" == o.type && (!i || n.marker.insertLeft)) {
                  var a = null == n.from || (o.inclusiveLeft ? n.from <= t : n.from < t);
                  (r || (r = [])).push(new Ut(o, a ? null : n.from - t, null == n.to ? null : n.to - t))
                }
              }
            return r
          }

          function Yt(e, t) {
            if (t.full) return null;
            var i = lt(e, t.from.line) && it(e, t.from.line).markedSpans,
              r = lt(e, t.to.line) && it(e, t.to.line).markedSpans;
            if (!i && !r) return null;
            var s = t.from.ch,
              n = t.to.ch,
              o = 0 == ut(t.from, t.to),
              a = Vt(i, s, o),
              l = Wt(r, n, o),
              c = 1 == t.text.length,
              h = ee(t.text).length + (c ? s : 0);
            if (a)
              for (var u = 0; u < a.length; ++u) {
                var d = a[u];
                if (null == d.to) {
                  var p = Ht(l, d.marker);
                  p ? c && (d.to = null == p.to ? null : p.to + h) : d.to = s
                }
              }
            if (l)
              for (var E = 0; E < l.length; ++E) {
                var g = l[E];
                null != g.to && (g.to += h), null == g.from ? Ht(a, g.marker) || (g.from = h, c && (a || (a = [])).push(g)) : (g.from += h, c && (a || (a = [])).push(g))
              }
            a && (a = Kt(a)), l && l != a && (l = Kt(l));
            var f = [a];
            if (!c) {
              var T, m = t.text.length - 2;
              if (m > 0 && a)
                for (var C = 0; C < a.length; ++C) null == a[C].to && (T || (T = [])).push(new Ut(a[C].marker, null, null));
              for (var S = 0; S < m; ++S) f.push(T);
              f.push(l)
            }
            return f
          }

          function Kt(e) {
            for (var t = 0; t < e.length; ++t) {
              var i = e[t];
              null != i.from && i.from == i.to && !1 !== i.marker.clearWhenEmpty && e.splice(t--, 1)
            }
            return e.length ? e : null
          }

          function Xt(e, t, i) {
            var r = null;
            if (e.iter(t.line, i.line + 1, function(e) {
                if (e.markedSpans)
                  for (var t = 0; t < e.markedSpans.length; ++t) {
                    var i = e.markedSpans[t].marker;
                    !i.readOnly || r && -1 != K(r, i) || (r || (r = [])).push(i)
                  }
              }), !r) return null;
            for (var s = [{
                from: t,
                to: i
              }], n = 0; n < r.length; ++n)
              for (var o = r[n], a = o.find(0), l = 0; l < s.length; ++l) {
                var c = s[l];
                if (!(ut(c.to, a.from) < 0 || ut(c.from, a.to) > 0)) {
                  var h = [l, 1],
                    u = ut(c.from, a.from),
                    d = ut(c.to, a.to);
                  (u < 0 || !o.inclusiveLeft && !u) && h.push({
                    from: c.from,
                    to: a.from
                  }), (d > 0 || !o.inclusiveRight && !d) && h.push({
                    from: a.to,
                    to: c.to
                  }), s.splice.apply(s, h), l += h.length - 3
                }
              }
            return s
          }

          function zt(e) {
            var t = e.markedSpans;
            if (t) {
              for (var i = 0; i < t.length; ++i) t[i].marker.detachLine(e);
              e.markedSpans = null
            }
          }

          function $t(e, t) {
            if (t) {
              for (var i = 0; i < t.length; ++i) t[i].marker.attachLine(e);
              e.markedSpans = t
            }
          }

          function jt(e) {
            return e.inclusiveLeft ? -1 : 0
          }

          function Jt(e) {
            return e.inclusiveRight ? 1 : 0
          }

          function qt(e, t) {
            var i = e.lines.length - t.lines.length;
            if (0 != i) return i;
            var r = e.find(),
              s = t.find(),
              n = ut(r.from, s.from) || jt(e) - jt(t);
            if (n) return -n;
            var o = ut(r.to, s.to) || Jt(e) - Jt(t);
            return o || t.id - e.id
          }

          function Qt(e, t) {
            var i, r = Ft && e.markedSpans;
            if (r)
              for (var s = void 0, n = 0; n < r.length; ++n)(s = r[n]).marker.collapsed && null == (t ? s.from : s.to) && (!i || qt(i, s.marker) < 0) && (i = s.marker);
            return i
          }

          function Zt(e) {
            return Qt(e, !0)
          }

          function ei(e) {
            return Qt(e, !1)
          }

          function ti(e, t) {
            var i, r = Ft && e.markedSpans;
            if (r)
              for (var s = 0; s < r.length; ++s) {
                var n = r[s];
                n.marker.collapsed && (null == n.from || n.from < t) && (null == n.to || n.to > t) && (!i || qt(i, n.marker) < 0) && (i = n.marker)
              }
            return i
          }

          function ii(e, t, i, r, s) {
            var n = it(e, t),
              o = Ft && n.markedSpans;
            if (o)
              for (var a = 0; a < o.length; ++a) {
                var l = o[a];
                if (l.marker.collapsed) {
                  var c = l.marker.find(0),
                    h = ut(c.from, i) || jt(l.marker) - jt(s),
                    u = ut(c.to, r) || Jt(l.marker) - Jt(s);
                  if (!(h >= 0 && u <= 0 || h <= 0 && u >= 0) && (h <= 0 && (l.marker.inclusiveRight && s.inclusiveLeft ? ut(c.to, i) >= 0 : ut(c.to, i) > 0) || h >= 0 && (l.marker.inclusiveRight && s.inclusiveLeft ? ut(c.from, r) <= 0 : ut(c.from, r) < 0))) return !0
                }
              }
          }

          function ri(e) {
            for (var t; t = Zt(e);) e = t.find(-1, !0).line;
            return e
          }

          function si(e) {
            for (var t; t = ei(e);) e = t.find(1, !0).line;
            return e
          }

          function ni(e) {
            for (var t, i; t = ei(e);) e = t.find(1, !0).line, (i || (i = [])).push(e);
            return i
          }

          function oi(e, t) {
            var i = it(e, t),
              r = ri(i);
            return i == r ? t : ot(r)
          }

          function ai(e, t) {
            if (t > e.lastLine()) return t;
            var i, r = it(e, t);
            if (!li(e, r)) return t;
            for (; i = ei(r);) r = i.find(1, !0).line;
            return ot(r) + 1
          }

          function li(e, t) {
            var i = Ft && t.markedSpans;
            if (i)
              for (var r = void 0, s = 0; s < i.length; ++s)
                if ((r = i[s]).marker.collapsed) {
                  if (null == r.from) return !0;
                  if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && ci(e, t, r)) return !0
                }
          }

          function ci(e, t, i) {
            if (null == i.to) {
              var r = i.marker.find(1, !0);
              return ci(e, r.line, Ht(r.line.markedSpans, i.marker))
            }
            if (i.marker.inclusiveRight && i.to == t.text.length) return !0;
            for (var s = void 0, n = 0; n < t.markedSpans.length; ++n)
              if ((s = t.markedSpans[n]).marker.collapsed && !s.marker.widgetNode && s.from == i.to && (null == s.to || s.to != i.from) && (s.marker.inclusiveLeft || i.marker.inclusiveRight) && ci(e, t, s)) return !0
          }

          function hi(e) {
            for (var t = 0, i = (e = ri(e)).parent, r = 0; r < i.lines.length; ++r) {
              var s = i.lines[r];
              if (s == e) break;
              t += s.height
            }
            for (var n = i.parent; n; n = (i = n).parent)
              for (var o = 0; o < n.children.length; ++o) {
                var a = n.children[o];
                if (a == i) break;
                t += a.height
              }
            return t
          }

          function ui(e) {
            if (0 == e.height) return 0;
            for (var t, i = e.text.length, r = e; t = Zt(r);) {
              var s = t.find(0, !0);
              r = s.from.line, i += s.from.ch - s.to.ch
            }
            for (r = e; t = ei(r);) {
              var n = t.find(0, !0);
              i -= r.text.length - n.from.ch, i += (r = n.to.line).text.length - n.to.ch
            }
            return i
          }

          function di(e) {
            var t = e.display,
              i = e.doc;
            t.maxLine = it(i, i.first), t.maxLineLength = ui(t.maxLine), t.maxLineChanged = !0, i.iter(function(e) {
              var i = ui(e);
              i > t.maxLineLength && (t.maxLineLength = i, t.maxLine = e)
            })
          }
          var pi = function(e, t, i) {
            this.text = e, $t(this, t), this.height = i ? i(this) : 1
          };

          function Ei(e, t, i, r) {
            e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), zt(e), $t(e, i);
            var s = r ? r(e) : 1;
            s != e.height && nt(e, s)
          }

          function gi(e) {
            e.parent = null, zt(e)
          }
          pi.prototype.lineNo = function() {
            return ot(this)
          }, Oe(pi);
          var fi = {},
            Ti = {};

          function mi(e, t) {
            if (!e || /^\s*$/.test(e)) return null;
            var i = t.addModeClass ? Ti : fi;
            return i[e] || (i[e] = e.replace(/\S+/g, "cm-$&"))
          }

          function Ci(e, t) {
            var i = D("span", null, null, l ? "padding-right: .1px" : null),
              r = {
                pre: D("pre", [i], "CodeMirror-line"),
                content: i,
                col: 0,
                pos: 0,
                cm: e,
                trailingSpace: !1,
                splitSpaces: e.getOption("lineWrapping")
              };
            t.measure = {};
            for (var s = 0; s <= (t.rest ? t.rest.length : 0); s++) {
              var n = s ? t.rest[s - 1] : t.line,
                o = void 0;
              r.pos = 0, r.addToken = Ri, Ge(e.display.measure) && (o = Te(n, e.doc.direction)) && (r.addToken = vi(r.addToken, o)), r.map = [], Ii(n, r, vt(e, n, t != e.display.externalMeasured && ot(n))), n.styleClasses && (n.styleClasses.bgClass && (r.bgClass = F(n.styleClasses.bgClass, r.bgClass || "")), n.styleClasses.textClass && (r.textClass = F(n.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild(xe(e.display.measure))), 0 == s ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({}))
            }
            if (l) {
              var a = r.content.lastChild;
              (/\bcm-tab\b/.test(a.className) || a.querySelector && a.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack")
            }
            return Ae(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = F(r.pre.className, r.textClass || "")), r
          }

          function Si(e) {
            var t = w("span", "•", "cm-invalidchar");
            return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t
          }

          function Ri(e, t, i, r, s, n, l) {
            if (t) {
              var c, h = e.splitSpaces ? Ai(t, e.trailingSpace) : t,
                u = e.cm.state.specialChars,
                d = !1;
              if (u.test(t)) {
                c = document.createDocumentFragment();
                for (var p = 0;;) {
                  u.lastIndex = p;
                  var E = u.exec(t),
                    g = E ? E.index - p : t.length - p;
                  if (g) {
                    var f = document.createTextNode(h.slice(p, p + g));
                    o && a < 9 ? c.appendChild(w("span", [f])) : c.appendChild(f), e.map.push(e.pos, e.pos + g, f), e.col += g, e.pos += g
                  }
                  if (!E) break;
                  p += g + 1;
                  var T = void 0;
                  if ("\t" == E[0]) {
                    var m = e.cm.options.tabSize,
                      C = m - e.col % m;
                    (T = c.appendChild(w("span", Z(C), "cm-tab"))).setAttribute("role", "presentation"), T.setAttribute("cm-text", "\t"), e.col += C
                  } else "\r" == E[0] || "\n" == E[0] ? ((T = c.appendChild(w("span", "\r" == E[0] ? "␍" : "␤", "cm-invalidchar"))).setAttribute("cm-text", E[0]), e.col += 1) : ((T = e.cm.options.specialCharPlaceholder(E[0])).setAttribute("cm-text", E[0]), o && a < 9 ? c.appendChild(w("span", [T])) : c.appendChild(T), e.col += 1);
                  e.map.push(e.pos, e.pos + 1, T), e.pos++
                }
              } else e.col += t.length, c = document.createTextNode(h), e.map.push(e.pos, e.pos + t.length, c), o && a < 9 && (d = !0), e.pos += t.length;
              if (e.trailingSpace = 32 == h.charCodeAt(t.length - 1), i || r || s || d || n || l) {
                var S = i || "";
                r && (S += r), s && (S += s);
                var R = w("span", [c], S, n);
                if (l)
                  for (var A in l) l.hasOwnProperty(A) && "style" != A && "class" != A && R.setAttribute(A, l[A]);
                return e.content.appendChild(R)
              }
              e.content.appendChild(c)
            }
          }

          function Ai(e, t) {
            if (e.length > 1 && !/  /.test(e)) return e;
            for (var i = t, r = "", s = 0; s < e.length; s++) {
              var n = e.charAt(s);
              " " != n || !i || s != e.length - 1 && 32 != e.charCodeAt(s + 1) || (n = " "), r += n, i = " " == n
            }
            return r
          }

          function vi(e, t) {
            return function(i, r, s, n, o, a, l) {
              s = s ? s + " cm-force-border" : "cm-force-border";
              for (var c = i.pos, h = c + r.length;;) {
                for (var u = void 0, d = 0; d < t.length && !((u = t[d]).to > c && u.from <= c); d++);
                if (u.to >= h) return e(i, r, s, n, o, a, l);
                e(i, r.slice(0, u.to - c), s, n, null, a, l), n = null, r = r.slice(u.to - c), c = u.to
              }
            }
          }

          function Ni(e, t, i, r) {
            var s = !r && i.widgetNode;
            s && e.map.push(e.pos, e.pos + t, s), !r && e.cm.display.input.needsContentAttribute && (s || (s = e.content.appendChild(document.createElement("span"))), s.setAttribute("cm-marker", i.id)), s && (e.cm.display.input.setUneditable(s), e.content.appendChild(s)), e.pos += t, e.trailingSpace = !1
          }

          function Ii(e, t, i) {
            var r = e.markedSpans,
              s = e.text,
              n = 0;
            if (r)
              for (var o, a, l, c, h, u, d, p = s.length, E = 0, g = 1, f = "", T = 0;;) {
                if (T == E) {
                  l = c = h = a = "", d = null, u = null, T = 1 / 0;
                  for (var m = [], C = void 0, S = 0; S < r.length; ++S) {
                    var R = r[S],
                      A = R.marker;
                    if ("bookmark" == A.type && R.from == E && A.widgetNode) m.push(A);
                    else if (R.from <= E && (null == R.to || R.to > E || A.collapsed && R.to == E && R.from == E)) {
                      if (null != R.to && R.to != E && T > R.to && (T = R.to, c = ""), A.className && (l += " " + A.className), A.css && (a = (a ? a + ";" : "") + A.css), A.startStyle && R.from == E && (h += " " + A.startStyle), A.endStyle && R.to == T && (C || (C = [])).push(A.endStyle, R.to), A.title && ((d || (d = {})).title = A.title), A.attributes)
                        for (var v in A.attributes)(d || (d = {}))[v] = A.attributes[v];
                      A.collapsed && (!u || qt(u.marker, A) < 0) && (u = R)
                    } else R.from > E && T > R.from && (T = R.from)
                  }
                  if (C)
                    for (var N = 0; N < C.length; N += 2) C[N + 1] == T && (c += " " + C[N]);
                  if (!u || u.from == E)
                    for (var I = 0; I < m.length; ++I) Ni(t, 0, m[I]);
                  if (u && (u.from || 0) == E) {
                    if (Ni(t, (null == u.to ? p + 1 : u.to) - E, u.marker, null == u.from), null == u.to) return;
                    u.to == E && (u = !1)
                  }
                }
                if (E >= p) break;
                for (var O = Math.min(p, T);;) {
                  if (f) {
                    var L = E + f.length;
                    if (!u) {
                      var _ = L > O ? f.slice(0, O - E) : f;
                      t.addToken(t, _, o ? o + l : l, h, E + _.length == T ? c : "", a, d)
                    }
                    if (L >= O) {
                      f = f.slice(O - E), E = O;
                      break
                    }
                    E = L, h = ""
                  }
                  f = s.slice(n, n = i[g++]), o = mi(i[g++], t.cm.options)
                }
              } else
                for (var y = 1; y < i.length; y += 2) t.addToken(t, s.slice(n, n = i[y]), mi(i[y + 1], t.cm.options))
          }

          function Oi(e, t, i) {
            this.line = t, this.rest = ni(t), this.size = this.rest ? ot(ee(this.rest)) - i + 1 : 1, this.node = this.text = null, this.hidden = li(e, t)
          }

          function Li(e, t, i) {
            for (var r, s = [], n = t; n < i; n = r) {
              var o = new Oi(e.doc, it(e.doc, n), n);
              r = n + o.size, s.push(o)
            }
            return s
          }
          var _i = null;

          function yi(e) {
            _i ? _i.ops.push(e) : e.ownsGroup = _i = {
              ops: [e],
              delayedCallbacks: []
            }
          }

          function wi(e) {
            var t = e.delayedCallbacks,
              i = 0;
            do {
              for (; i < t.length; i++) t[i].call(null);
              for (var r = 0; r < e.ops.length; r++) {
                var s = e.ops[r];
                if (s.cursorActivityHandlers)
                  for (; s.cursorActivityCalled < s.cursorActivityHandlers.length;) s.cursorActivityHandlers[s.cursorActivityCalled++].call(null, s.cm)
              }
            } while (i < t.length)
          }

          function Di(e, t) {
            var i = e.ownsGroup;
            if (i) try {
              wi(i)
            } finally {
              _i = null, t(i)
            }
          }
          var Pi = null;

          function bi(e, t) {
            var i = Se(e, t);
            if (i.length) {
              var r, s = Array.prototype.slice.call(arguments, 2);
              _i ? r = _i.delayedCallbacks : Pi ? r = Pi : (r = Pi = [], setTimeout(Mi, 0));
              for (var n = function(e) {
                  r.push(function() {
                    return i[e].apply(null, s)
                  })
                }, o = 0; o < i.length; ++o) n(o)
            }
          }

          function Mi() {
            var e = Pi;
            Pi = null;
            for (var t = 0; t < e.length; ++t) e[t]()
          }

          function Fi(e, t, i, r) {
            for (var s = 0; s < t.changes.length; s++) {
              var n = t.changes[s];
              "text" == n ? Hi(e, t) : "gutter" == n ? Bi(e, t, i, r) : "class" == n ? ki(e, t) : "widget" == n && Vi(e, t, r)
            }
            t.changes = null
          }

          function xi(e) {
            return e.node == e.text && (e.node = w("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), o && a < 8 && (e.node.style.zIndex = 2)), e.node
          }

          function Gi(e, t) {
            var i = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
            if (i && (i += " CodeMirror-linebackground"), t.background) i ? t.background.className = i : (t.background.parentNode.removeChild(t.background), t.background = null);
            else if (i) {
              var r = xi(t);
              t.background = r.insertBefore(w("div", null, i), r.firstChild), e.display.input.setUneditable(t.background)
            }
          }

          function Ui(e, t) {
            var i = e.display.externalMeasured;
            return i && i.line == t.line ? (e.display.externalMeasured = null, t.measure = i.measure, i.built) : Ci(e, t)
          }

          function Hi(e, t) {
            var i = t.text.className,
              r = Ui(e, t);
            t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, ki(e, t)) : i && (t.text.className = i)
          }

          function ki(e, t) {
            Gi(e, t), t.line.wrapClass ? xi(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
            var i = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
            t.text.className = i || ""
          }

          function Bi(e, t, i, r) {
            if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
              var s = xi(t);
              t.gutterBackground = w("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), e.display.input.setUneditable(t.gutterBackground), s.insertBefore(t.gutterBackground, t.text)
            }
            var n = t.line.gutterMarkers;
            if (e.options.lineNumbers || n) {
              var o = xi(t),
                a = t.gutter = w("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px");
              if (a.setAttribute("aria-hidden", "true"), e.display.input.setUneditable(a), o.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), !e.options.lineNumbers || n && n["CodeMirror-linenumbers"] || (t.lineNumber = a.appendChild(w("div", ct(e.options, i), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), n)
                for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
                  var c = e.display.gutterSpecs[l].className,
                    h = n.hasOwnProperty(c) && n[c];
                  h && a.appendChild(w("div", [h], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[c] + "px; width: " + r.gutterWidth[c] + "px"))
                }
            }
          }

          function Vi(e, t, i) {
            t.alignable && (t.alignable = null);
            for (var r = I("CodeMirror-linewidget"), s = t.node.firstChild, n = void 0; s; s = n) n = s.nextSibling, r.test(s.className) && t.node.removeChild(s);
            Yi(e, t, i)
          }

          function Wi(e, t, i, r) {
            var s = Ui(e, t);
            return t.text = t.node = s.pre, s.bgClass && (t.bgClass = s.bgClass), s.textClass && (t.textClass = s.textClass), ki(e, t), Bi(e, t, i, r), Yi(e, t, r), t.node
          }

          function Yi(e, t, i) {
            if (Ki(e, t.line, t, i, !0), t.rest)
              for (var r = 0; r < t.rest.length; r++) Ki(e, t.rest[r], t, i, !1)
          }

          function Ki(e, t, i, r, s) {
            if (t.widgets)
              for (var n = xi(i), o = 0, a = t.widgets; o < a.length; ++o) {
                var l = a[o],
                  c = w("div", [l.node], "CodeMirror-linewidget" + (l.className ? " " + l.className : ""));
                l.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"), Xi(l, c, i, r), e.display.input.setUneditable(c), s && l.above ? n.insertBefore(c, i.gutter || i.text) : n.appendChild(c), bi(l, "redraw")
              }
          }

          function Xi(e, t, i, r) {
            if (e.noHScroll) {
              (i.alignable || (i.alignable = [])).push(t);
              var s = r.wrapperWidth;
              t.style.left = r.fixedPos + "px", e.coverGutter || (s -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"), t.style.width = s + "px"
            }
            e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px"))
          }

          function zi(e) {
            if (null != e.height) return e.height;
            var t = e.doc.cm;
            if (!t) return 0;
            if (!P(document.body, e.node)) {
              var i = "position: relative;";
              e.coverGutter && (i += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (i += "width: " + t.display.wrapper.clientWidth + "px;"), y(t.display.measure, w("div", [e.node], null, i))
            }
            return e.height = e.node.parentNode.offsetHeight
          }

          function $i(e, t) {
            for (var i = De(t); i != e.wrapper; i = i.parentNode)
              if (!i || 1 == i.nodeType && "true" == i.getAttribute("cm-ignore-events") || i.parentNode == e.sizer && i != e.mover) return !0
          }

          function ji(e) {
            return e.lineSpace.offsetTop
          }

          function Ji(e) {
            return e.mover.offsetHeight - e.lineSpace.offsetHeight
          }

          function qi(e) {
            if (e.cachedPaddingH) return e.cachedPaddingH;
            var t = y(e.measure, w("pre", "x", "CodeMirror-line-like")),
              i = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle,
              r = {
                left: parseInt(i.paddingLeft),
                right: parseInt(i.paddingRight)
              };
            return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r
          }

          function Qi(e) {
            return X - e.display.nativeBarWidth
          }

          function Zi(e) {
            return e.display.scroller.clientWidth - Qi(e) - e.display.barWidth
          }

          function er(e) {
            return e.display.scroller.clientHeight - Qi(e) - e.display.barHeight
          }

          function tr(e, t, i) {
            var r = e.options.lineWrapping,
              s = r && Zi(e);
            if (!t.measure.heights || r && t.measure.width != s) {
              var n = t.measure.heights = [];
              if (r) {
                t.measure.width = s;
                for (var o = t.text.firstChild.getClientRects(), a = 0; a < o.length - 1; a++) {
                  var l = o[a],
                    c = o[a + 1];
                  Math.abs(l.bottom - c.bottom) > 2 && n.push((l.bottom + c.top) / 2 - i.top)
                }
              }
              n.push(i.bottom - i.top)
            }
          }

          function ir(e, t, i) {
            if (e.line == t) return {
              map: e.measure.map,
              cache: e.measure.cache
            };
            if (e.rest) {
              for (var r = 0; r < e.rest.length; r++)
                if (e.rest[r] == t) return {
                  map: e.measure.maps[r],
                  cache: e.measure.caches[r]
                };
              for (var s = 0; s < e.rest.length; s++)
                if (ot(e.rest[s]) > i) return {
                  map: e.measure.maps[s],
                  cache: e.measure.caches[s],
                  before: !0
                }
            }
          }

          function rr(e, t) {
            var i = ot(t = ri(t)),
              r = e.display.externalMeasured = new Oi(e.doc, t, i);
            r.lineN = i;
            var s = r.built = Ci(e, r);
            return r.text = s.pre, y(e.display.lineMeasure, s.pre), r
          }

          function sr(e, t, i, r) {
            return ar(e, or(e, t), i, r)
          }

          function nr(e, t) {
            if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[kr(e, t)];
            var i = e.display.externalMeasured;
            return i && t >= i.lineN && t < i.lineN + i.size ? i : void 0
          }

          function or(e, t) {
            var i = ot(t),
              r = nr(e, i);
            r && !r.text ? r = null : r && r.changes && (Fi(e, r, i, Fr(e)), e.curOp.forceUpdate = !0), r || (r = rr(e, t));
            var s = ir(r, t, i);
            return {
              line: t,
              view: r,
              rect: null,
              map: s.map,
              cache: s.cache,
              before: s.before,
              hasHeights: !1
            }
          }

          function ar(e, t, i, r, s) {
            t.before && (i = -1);
            var n, o = i + (r || "");
            return t.cache.hasOwnProperty(o) ? n = t.cache[o] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (tr(e, t.view, t.rect), t.hasHeights = !0), (n = dr(e, t, i, r)).bogus || (t.cache[o] = n)), {
              left: n.left,
              right: n.right,
              top: s ? n.rtop : n.top,
              bottom: s ? n.rbottom : n.bottom
            }
          }
          var lr, cr = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };

          function hr(e, t, i) {
            for (var r, s, n, o, a, l, c = 0; c < e.length; c += 3)
              if (a = e[c], l = e[c + 1], t < a ? (s = 0, n = 1, o = "left") : t < l ? n = 1 + (s = t - a) : (c == e.length - 3 || t == l && e[c + 3] > t) && (s = (n = l - a) - 1, t >= l && (o = "right")), null != s) {
                if (r = e[c + 2], a == l && i == (r.insertLeft ? "left" : "right") && (o = i), "left" == i && 0 == s)
                  for (; c && e[c - 2] == e[c - 3] && e[c - 1].insertLeft;) r = e[2 + (c -= 3)], o = "left";
                if ("right" == i && s == l - a)
                  for (; c < e.length - 3 && e[c + 3] == e[c + 4] && !e[c + 5].insertLeft;) r = e[(c += 3) + 2], o = "right";
                break
              } return {
              node: r,
              start: s,
              end: n,
              collapse: o,
              coverStart: a,
              coverEnd: l
            }
          }

          function ur(e, t) {
            var i = cr;
            if ("left" == t)
              for (var r = 0; r < e.length && (i = e[r]).left == i.right; r++);
            else
              for (var s = e.length - 1; s >= 0 && (i = e[s]).left == i.right; s--);
            return i
          }

          function dr(e, t, i, r) {
            var s, n = hr(t.map, i, r),
              l = n.node,
              c = n.start,
              h = n.end,
              u = n.collapse;
            if (3 == l.nodeType) {
              for (var d = 0; d < 4; d++) {
                for (; c && he(t.line.text.charAt(n.coverStart + c));) --c;
                for (; n.coverStart + h < n.coverEnd && he(t.line.text.charAt(n.coverStart + h));) ++h;
                if ((s = o && a < 9 && 0 == c && h == n.coverEnd - n.coverStart ? l.parentNode.getBoundingClientRect() : ur(O(l, c, h).getClientRects(), r)).left || s.right || 0 == c) break;
                h = c, c -= 1, u = "right"
              }
              o && a < 11 && (s = pr(e.display.measure, s))
            } else {
              var p;
              c > 0 && (u = r = "right"), s = e.options.lineWrapping && (p = l.getClientRects()).length > 1 ? p["right" == r ? p.length - 1 : 0] : l.getBoundingClientRect()
            }
            if (o && a < 9 && !c && (!s || !s.left && !s.right)) {
              var E = l.parentNode.getClientRects()[0];
              s = E ? {
                left: E.left,
                right: E.left + Mr(e.display),
                top: E.top,
                bottom: E.bottom
              } : cr
            }
            for (var g = s.top - t.rect.top, f = s.bottom - t.rect.top, T = (g + f) / 2, m = t.view.measure.heights, C = 0; C < m.length - 1 && !(T < m[C]); C++);
            var S = C ? m[C - 1] : 0,
              R = m[C],
              A = {
                left: ("right" == u ? s.right : s.left) - t.rect.left,
                right: ("left" == u ? s.left : s.right) - t.rect.left,
                top: S,
                bottom: R
              };
            return s.left || s.right || (A.bogus = !0), e.options.singleCursorHeightPerLine || (A.rtop = g, A.rbottom = f), A
          }

          function pr(e, t) {
            if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !We(e)) return t;
            var i = screen.logicalXDPI / screen.deviceXDPI,
              r = screen.logicalYDPI / screen.deviceYDPI;
            return {
              left: t.left * i,
              right: t.right * i,
              top: t.top * r,
              bottom: t.bottom * r
            }
          }

          function Er(e) {
            if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))
              for (var t = 0; t < e.rest.length; t++) e.measure.caches[t] = {}
          }

          function gr(e) {
            e.display.externalMeasure = null, _(e.display.lineMeasure);
            for (var t = 0; t < e.display.view.length; t++) Er(e.display.view[t])
          }

          function fr(e) {
            gr(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null
          }

          function Tr(e) {
            return h && T ? -(e.body.getBoundingClientRect().left - parseInt(getComputedStyle(e.body).marginLeft)) : e.defaultView.pageXOffset || (e.documentElement || e.body).scrollLeft
          }

          function mr(e) {
            return h && T ? -(e.body.getBoundingClientRect().top - parseInt(getComputedStyle(e.body).marginTop)) : e.defaultView.pageYOffset || (e.documentElement || e.body).scrollTop
          }

          function Cr(e) {
            var t = ri(e).widgets,
              i = 0;
            if (t)
              for (var r = 0; r < t.length; ++r) t[r].above && (i += zi(t[r]));
            return i
          }

          function Sr(e, t, i, r, s) {
            if (!s) {
              var n = Cr(t);
              i.top += n, i.bottom += n
            }
            if ("line" == r) return i;
            r || (r = "local");
            var o = hi(t);
            if ("local" == r ? o += ji(e.display) : o -= e.display.viewOffset, "page" == r || "window" == r) {
              var a = e.display.lineSpace.getBoundingClientRect();
              o += a.top + ("window" == r ? 0 : mr(G(e)));
              var l = a.left + ("window" == r ? 0 : Tr(G(e)));
              i.left += l, i.right += l
            }
            return i.top += o, i.bottom += o, i
          }

          function Rr(e, t, i) {
            if ("div" == i) return t;
            var r = t.left,
              s = t.top;
            if ("page" == i) r -= Tr(G(e)), s -= mr(G(e));
            else if ("local" == i || !i) {
              var n = e.display.sizer.getBoundingClientRect();
              r += n.left, s += n.top
            }
            var o = e.display.lineSpace.getBoundingClientRect();
            return {
              left: r - o.left,
              top: s - o.top
            }
          }

          function Ar(e, t, i, r, s) {
            return r || (r = it(e.doc, t.line)), Sr(e, r, sr(e, r, t.ch, s), i)
          }

          function vr(e, t, i, r, s, n) {
            function o(t, o) {
              var a = ar(e, s, t, o ? "right" : "left", n);
              return o ? a.left = a.right : a.right = a.left, Sr(e, r, a, i)
            }
            r = r || it(e.doc, t.line), s || (s = or(e, r));
            var a = Te(r, e.doc.direction),
              l = t.ch,
              c = t.sticky;
            if (l >= r.text.length ? (l = r.text.length, c = "before") : l <= 0 && (l = 0, c = "after"), !a) return o("before" == c ? l - 1 : l, "before" == c);

            function h(e, t, i) {
              return o(i ? e - 1 : e, 1 == a[t].level != i)
            }
            var u = ge(a, l, c),
              d = Ee,
              p = h(l, u, "before" == c);
            return null != d && (p.other = h(l, d, "before" != c)), p
          }

          function Nr(e, t) {
            var i = 0;
            t = Tt(e.doc, t), e.options.lineWrapping || (i = Mr(e.display) * t.ch);
            var r = it(e.doc, t.line),
              s = hi(r) + ji(e.display);
            return {
              left: i,
              right: i,
              top: s,
              bottom: s + r.height
            }
          }

          function Ir(e, t, i, r, s) {
            var n = ht(e, t, i);
            return n.xRel = s, r && (n.outside = r), n
          }

          function Or(e, t, i) {
            var r = e.doc;
            if ((i += e.display.viewOffset) < 0) return Ir(r.first, 0, null, -1, -1);
            var s = at(r, i),
              n = r.first + r.size - 1;
            if (s > n) return Ir(r.first + r.size - 1, it(r, n).text.length, null, 1, 1);
            t < 0 && (t = 0);
            for (var o = it(r, s);;) {
              var a = wr(e, o, s, t, i),
                l = ti(o, a.ch + (a.xRel > 0 || a.outside > 0 ? 1 : 0));
              if (!l) return a;
              var c = l.find(1);
              if (c.line == s) return c;
              o = it(r, s = c.line)
            }
          }

          function Lr(e, t, i, r) {
            r -= Cr(t);
            var s = t.text.length,
              n = de(function(t) {
                return ar(e, i, t - 1).bottom <= r
              }, s, 0);
            return {
              begin: n,
              end: s = de(function(t) {
                return ar(e, i, t).top > r
              }, n, s)
            }
          }

          function _r(e, t, i, r) {
            return i || (i = or(e, t)), Lr(e, t, i, Sr(e, t, ar(e, i, r), "line").top)
          }

          function yr(e, t, i, r) {
            return !(e.bottom <= i) && (e.top > i || (r ? e.left : e.right) > t)
          }

          function wr(e, t, i, r, s) {
            s -= hi(t);
            var n = or(e, t),
              o = Cr(t),
              a = 0,
              l = t.text.length,
              c = !0,
              h = Te(t, e.doc.direction);
            if (h) {
              var u = (e.options.lineWrapping ? Pr : Dr)(e, t, i, n, h, r, s);
              a = (c = 1 != u.level) ? u.from : u.to - 1, l = c ? u.to : u.from - 1
            }
            var d, p, E = null,
              g = null,
              f = de(function(t) {
                var i = ar(e, n, t);
                return i.top += o, i.bottom += o, !!yr(i, r, s, !1) && (i.top <= s && i.left <= r && (E = t, g = i), !0)
              }, a, l),
              T = !1;
            if (g) {
              var m = r - g.left < g.right - r,
                C = m == c;
              f = E + (C ? 0 : 1), p = C ? "after" : "before", d = m ? g.left : g.right
            } else {
              c || f != l && f != a || f++, p = 0 == f ? "after" : f == t.text.length ? "before" : ar(e, n, f - (c ? 1 : 0)).bottom + o <= s == c ? "after" : "before";
              var S = vr(e, ht(i, f, p), "line", t, n);
              d = S.left, T = s < S.top ? -1 : s >= S.bottom ? 1 : 0
            }
            return Ir(i, f = ue(t.text, f, 1), p, T, r - d)
          }

          function Dr(e, t, i, r, s, n, o) {
            var a = de(function(a) {
                var l = s[a],
                  c = 1 != l.level;
                return yr(vr(e, ht(i, c ? l.to : l.from, c ? "before" : "after"), "line", t, r), n, o, !0)
              }, 0, s.length - 1),
              l = s[a];
            if (a > 0) {
              var c = 1 != l.level,
                h = vr(e, ht(i, c ? l.from : l.to, c ? "after" : "before"), "line", t, r);
              yr(h, n, o, !0) && h.top > o && (l = s[a - 1])
            }
            return l
          }

          function Pr(e, t, i, r, s, n, o) {
            var a = Lr(e, t, r, o),
              l = a.begin,
              c = a.end;
            /\s/.test(t.text.charAt(c - 1)) && c--;
            for (var h = null, u = null, d = 0; d < s.length; d++) {
              var p = s[d];
              if (!(p.from >= c || p.to <= l)) {
                var E = ar(e, r, 1 != p.level ? Math.min(c, p.to) - 1 : Math.max(l, p.from)).right,
                  g = E < n ? n - E + 1e9 : E - n;
                (!h || u > g) && (h = p, u = g)
              }
            }
            return h || (h = s[s.length - 1]), h.from < l && (h = {
              from: l,
              to: h.to,
              level: h.level
            }), h.to > c && (h = {
              from: h.from,
              to: c,
              level: h.level
            }), h
          }

          function br(e) {
            if (null != e.cachedTextHeight) return e.cachedTextHeight;
            if (null == lr) {
              lr = w("pre", null, "CodeMirror-line-like");
              for (var t = 0; t < 49; ++t) lr.appendChild(document.createTextNode("x")), lr.appendChild(w("br"));
              lr.appendChild(document.createTextNode("x"))
            }
            y(e.measure, lr);
            var i = lr.offsetHeight / 50;
            return i > 3 && (e.cachedTextHeight = i), _(e.measure), i || 1
          }

          function Mr(e) {
            if (null != e.cachedCharWidth) return e.cachedCharWidth;
            var t = w("span", "xxxxxxxxxx"),
              i = w("pre", [t], "CodeMirror-line-like");
            y(e.measure, i);
            var r = t.getBoundingClientRect(),
              s = (r.right - r.left) / 10;
            return s > 2 && (e.cachedCharWidth = s), s || 10
          }

          function Fr(e) {
            for (var t = e.display, i = {}, r = {}, s = t.gutters.clientLeft, n = t.gutters.firstChild, o = 0; n; n = n.nextSibling, ++o) {
              var a = e.display.gutterSpecs[o].className;
              i[a] = n.offsetLeft + n.clientLeft + s, r[a] = n.clientWidth
            }
            return {
              fixedPos: xr(t),
              gutterTotalWidth: t.gutters.offsetWidth,
              gutterLeft: i,
              gutterWidth: r,
              wrapperWidth: t.wrapper.clientWidth
            }
          }

          function xr(e) {
            return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left
          }

          function Gr(e) {
            var t = br(e.display),
              i = e.options.lineWrapping,
              r = i && Math.max(5, e.display.scroller.clientWidth / Mr(e.display) - 3);
            return function(s) {
              if (li(e.doc, s)) return 0;
              var n = 0;
              if (s.widgets)
                for (var o = 0; o < s.widgets.length; o++) s.widgets[o].height && (n += s.widgets[o].height);
              return i ? n + (Math.ceil(s.text.length / r) || 1) * t : n + t
            }
          }

          function Ur(e) {
            var t = e.doc,
              i = Gr(e);
            t.iter(function(e) {
              var t = i(e);
              t != e.height && nt(e, t)
            })
          }

          function Hr(e, t, i, r) {
            var s = e.display;
            if (!i && "true" == De(t).getAttribute("cm-not-content")) return null;
            var n, o, a = s.lineSpace.getBoundingClientRect();
            try {
              n = t.clientX - a.left, o = t.clientY - a.top
            } catch (e) {
              return null
            }
            var l, c = Or(e, n, o);
            if (r && c.xRel > 0 && (l = it(e.doc, c.line).text).length == c.ch) {
              var h = W(l, l.length, e.options.tabSize) - l.length;
              c = ht(c.line, Math.max(0, Math.round((n - qi(e.display).left) / Mr(e.display)) - h))
            }
            return c
          }

          function kr(e, t) {
            if (t >= e.display.viewTo) return null;
            if ((t -= e.display.viewFrom) < 0) return null;
            for (var i = e.display.view, r = 0; r < i.length; r++)
              if ((t -= i[r].size) < 0) return r
          }

          function Br(e, t, i, r) {
            null == t && (t = e.doc.first), null == i && (i = e.doc.first + e.doc.size), r || (r = 0);
            var s = e.display;
            if (r && i < s.viewTo && (null == s.updateLineNumbers || s.updateLineNumbers > t) && (s.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= s.viewTo) Ft && oi(e.doc, t) < s.viewTo && Wr(e);
            else if (i <= s.viewFrom) Ft && ai(e.doc, i + r) > s.viewFrom ? Wr(e) : (s.viewFrom += r, s.viewTo += r);
            else if (t <= s.viewFrom && i >= s.viewTo) Wr(e);
            else if (t <= s.viewFrom) {
              var n = Yr(e, i, i + r, 1);
              n ? (s.view = s.view.slice(n.index), s.viewFrom = n.lineN, s.viewTo += r) : Wr(e)
            } else if (i >= s.viewTo) {
              var o = Yr(e, t, t, -1);
              o ? (s.view = s.view.slice(0, o.index), s.viewTo = o.lineN) : Wr(e)
            } else {
              var a = Yr(e, t, t, -1),
                l = Yr(e, i, i + r, 1);
              a && l ? (s.view = s.view.slice(0, a.index).concat(Li(e, a.lineN, l.lineN)).concat(s.view.slice(l.index)), s.viewTo += r) : Wr(e)
            }
            var c = s.externalMeasured;
            c && (i < c.lineN ? c.lineN += r : t < c.lineN + c.size && (s.externalMeasured = null))
          }

          function Vr(e, t, i) {
            e.curOp.viewChanged = !0;
            var r = e.display,
              s = e.display.externalMeasured;
            if (s && t >= s.lineN && t < s.lineN + s.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) {
              var n = r.view[kr(e, t)];
              if (null != n.node) {
                var o = n.changes || (n.changes = []); - 1 == K(o, i) && o.push(i)
              }
            }
          }

          function Wr(e) {
            e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0
          }

          function Yr(e, t, i, r) {
            var s, n = kr(e, t),
              o = e.display.view;
            if (!Ft || i == e.doc.first + e.doc.size) return {
              index: n,
              lineN: i
            };
            for (var a = e.display.viewFrom, l = 0; l < n; l++) a += o[l].size;
            if (a != t) {
              if (r > 0) {
                if (n == o.length - 1) return null;
                s = a + o[n].size - t, n++
              } else s = a - t;
              t += s, i += s
            }
            for (; oi(e.doc, i) != i;) {
              if (n == (r < 0 ? 0 : o.length - 1)) return null;
              i += r * o[n - (r < 0 ? 1 : 0)].size, n += r
            }
            return {
              index: n,
              lineN: i
            }
          }

          function Kr(e, t, i) {
            var r = e.display;
            0 == r.view.length || t >= r.viewTo || i <= r.viewFrom ? (r.view = Li(e, t, i), r.viewFrom = t) : (r.viewFrom > t ? r.view = Li(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(kr(e, t))), r.viewFrom = t, r.viewTo < i ? r.view = r.view.concat(Li(e, r.viewTo, i)) : r.viewTo > i && (r.view = r.view.slice(0, kr(e, i)))), r.viewTo = i
          }

          function Xr(e) {
            for (var t = e.display.view, i = 0, r = 0; r < t.length; r++) {
              var s = t[r];
              s.hidden || s.node && !s.changes || ++i
            }
            return i
          }

          function zr(e) {
            e.display.input.showSelection(e.display.input.prepareSelection())
          }

          function $r(e, t) {
            void 0 === t && (t = !0);
            var i = e.doc,
              r = {},
              s = r.cursors = document.createDocumentFragment(),
              n = r.selection = document.createDocumentFragment(),
              o = e.options.$customCursor;
            o && (t = !0);
            for (var a = 0; a < i.sel.ranges.length; a++)
              if (t || a != i.sel.primIndex) {
                var l = i.sel.ranges[a];
                if (!(l.from().line >= e.display.viewTo || l.to().line < e.display.viewFrom)) {
                  var c = l.empty();
                  if (o) {
                    var h = o(e, l);
                    h && jr(e, h, s)
                  } else(c || e.options.showCursorWhenSelecting) && jr(e, l.head, s);
                  c || qr(e, l, n)
                }
              } return r
          }

          function jr(e, t, i) {
            var r = vr(e, t, "div", null, null, !e.options.singleCursorHeightPerLine),
              s = i.appendChild(w("div", " ", "CodeMirror-cursor"));
            if (s.style.left = r.left + "px", s.style.top = r.top + "px", s.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(e.getWrapperElement().className)) {
              var n = Ar(e, t, "div", null, null),
                o = n.right - n.left;
              s.style.width = (o > 0 ? o : e.defaultCharWidth()) + "px"
            }
            if (r.other) {
              var a = i.appendChild(w("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
              a.style.display = "", a.style.left = r.other.left + "px", a.style.top = r.other.top + "px", a.style.height = .85 * (r.other.bottom - r.other.top) + "px"
            }
          }

          function Jr(e, t) {
            return e.top - t.top || e.left - t.left
          }

          function qr(e, t, i) {
            var r = e.display,
              s = e.doc,
              n = document.createDocumentFragment(),
              o = qi(e.display),
              a = o.left,
              l = Math.max(r.sizerWidth, Zi(e) - r.sizer.offsetLeft) - o.right,
              c = "ltr" == s.direction;

            function h(e, t, i, r) {
              t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), n.appendChild(w("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px;\n                             top: " + t + "px; width: " + (null == i ? l - e : i) + "px;\n                             height: " + (r - t) + "px"))
            }

            function u(t, i, r) {
              var n, o, u = it(s, t),
                d = u.text.length;

              function p(i, r) {
                return Ar(e, ht(t, i), "div", u, r)
              }

              function E(t, i, r) {
                var s = _r(e, u, null, t),
                  n = "ltr" == i == ("after" == r) ? "left" : "right";
                return p("after" == r ? s.begin : s.end - (/\s/.test(u.text.charAt(s.end - 1)) ? 2 : 1), n)[n]
              }
              var g = Te(u, s.direction);
              return pe(g, i || 0, null == r ? d : r, function(e, t, s, u) {
                var f = "ltr" == s,
                  T = p(e, f ? "left" : "right"),
                  m = p(t - 1, f ? "right" : "left"),
                  C = null == i && 0 == e,
                  S = null == r && t == d,
                  R = 0 == u,
                  A = !g || u == g.length - 1;
                if (m.top - T.top <= 3) {
                  var v = (c ? S : C) && A,
                    N = (c ? C : S) && R ? a : (f ? T : m).left,
                    I = v ? l : (f ? m : T).right;
                  h(N, T.top, I - N, T.bottom)
                } else {
                  var O, L, _, y;
                  f ? (O = c && C && R ? a : T.left, L = c ? l : E(e, s, "before"), _ = c ? a : E(t, s, "after"), y = c && S && A ? l : m.right) : (O = c ? E(e, s, "before") : a, L = !c && C && R ? l : T.right, _ = !c && S && A ? a : m.left, y = c ? E(t, s, "after") : l), h(O, T.top, L - O, T.bottom), T.bottom < m.top && h(a, T.bottom, null, m.top), h(_, m.top, y - _, m.bottom)
                }(!n || Jr(T, n) < 0) && (n = T), Jr(m, n) < 0 && (n = m), (!o || Jr(T, o) < 0) && (o = T), Jr(m, o) < 0 && (o = m)
              }), {
                start: n,
                end: o
              }
            }
            var d = t.from(),
              p = t.to();
            if (d.line == p.line) u(d.line, d.ch, p.ch);
            else {
              var E = it(s, d.line),
                g = it(s, p.line),
                f = ri(E) == ri(g),
                T = u(d.line, d.ch, f ? E.text.length + 1 : null).end,
                m = u(p.line, f ? 0 : null, p.ch).start;
              f && (T.top < m.top - 2 ? (h(T.right, T.top, null, T.bottom), h(a, m.top, m.left, m.bottom)) : h(T.right, T.top, m.left - T.right, T.bottom)), T.bottom < m.top && h(a, T.bottom, null, m.top)
            }
            i.appendChild(n)
          }

          function Qr(e) {
            if (e.state.focused) {
              var t = e.display;
              clearInterval(t.blinker);
              var i = !0;
              t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function() {
                e.hasFocus() || is(e), t.cursorDiv.style.visibility = (i = !i) ? "" : "hidden"
              }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")
            }
          }

          function Zr(e) {
            e.hasFocus() || (e.display.input.focus(), e.state.focused || ts(e))
          }

          function es(e) {
            e.state.delayingBlurEvent = !0, setTimeout(function() {
              e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && is(e))
            }, 100)
          }

          function ts(e, t) {
            e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (Ae(e, "focus", e, t), e.state.focused = !0, M(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), l && setTimeout(function() {
              return e.display.input.reset(!0)
            }, 20)), e.display.input.receivedFocus()), Qr(e))
          }

          function is(e, t) {
            e.state.delayingBlurEvent || (e.state.focused && (Ae(e, "blur", e, t), e.state.focused = !1, L(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(function() {
              e.state.focused || (e.display.shift = !1)
            }, 150))
          }

          function rs(e) {
            for (var t = e.display, i = t.lineDiv.offsetTop, r = Math.max(0, t.scroller.getBoundingClientRect().top), s = t.lineDiv.getBoundingClientRect().top, n = 0, l = 0; l < t.view.length; l++) {
              var c = t.view[l],
                h = e.options.lineWrapping,
                u = void 0,
                d = 0;
              if (!c.hidden) {
                if (s += c.line.height, o && a < 8) {
                  var p = c.node.offsetTop + c.node.offsetHeight;
                  u = p - i, i = p
                } else {
                  var E = c.node.getBoundingClientRect();
                  u = E.bottom - E.top, !h && c.text.firstChild && (d = c.text.firstChild.getBoundingClientRect().right - E.left - 1)
                }
                var g = c.line.height - u;
                if ((g > .005 || g < -.005) && (s < r && (n -= g), nt(c.line, u), ss(c.line), c.rest))
                  for (var f = 0; f < c.rest.length; f++) ss(c.rest[f]);
                if (d > e.display.sizerWidth) {
                  var T = Math.ceil(d / Mr(e.display));
                  T > e.display.maxLineLength && (e.display.maxLineLength = T, e.display.maxLine = c.line, e.display.maxLineChanged = !0)
                }
              }
            }
            Math.abs(n) > 2 && (t.scroller.scrollTop += n)
          }

          function ss(e) {
            if (e.widgets)
              for (var t = 0; t < e.widgets.length; ++t) {
                var i = e.widgets[t],
                  r = i.node.parentNode;
                r && (i.height = r.offsetHeight)
              }
          }

          function ns(e, t, i) {
            var r = i && null != i.top ? Math.max(0, i.top) : e.scroller.scrollTop;
            r = Math.floor(r - ji(e));
            var s = i && null != i.bottom ? i.bottom : r + e.wrapper.clientHeight,
              n = at(t, r),
              o = at(t, s);
            if (i && i.ensure) {
              var a = i.ensure.from.line,
                l = i.ensure.to.line;
              a < n ? (n = a, o = at(t, hi(it(t, a)) + e.wrapper.clientHeight)) : Math.min(l, t.lastLine()) >= o && (n = at(t, hi(it(t, l)) - e.wrapper.clientHeight), o = l)
            }
            return {
              from: n,
              to: Math.max(o, n + 1)
            }
          }

          function os(e, t) {
            if (!ve(e, "scrollCursorIntoView")) {
              var i = e.display,
                r = i.sizer.getBoundingClientRect(),
                s = null,
                n = i.wrapper.ownerDocument;
              if (t.top + r.top < 0 ? s = !0 : t.bottom + r.top > (n.defaultView.innerHeight || n.documentElement.clientHeight) && (s = !1), null != s && !g) {
                var o = w("div", "​", null, "position: absolute;\n                         top: " + (t.top - i.viewOffset - ji(e.display)) + "px;\n                         height: " + (t.bottom - t.top + Qi(e) + i.barHeight) + "px;\n                         left: " + t.left + "px; width: " + Math.max(2, t.right - t.left) + "px;");
                e.display.lineSpace.appendChild(o), o.scrollIntoView(s), e.display.lineSpace.removeChild(o)
              }
            }
          }

          function as(e, t, i, r) {
            var s;
            null == r && (r = 0), e.options.lineWrapping || t != i || (i = "before" == t.sticky ? ht(t.line, t.ch + 1, "before") : t, t = t.ch ? ht(t.line, "before" == t.sticky ? t.ch - 1 : t.ch, "after") : t);
            for (var n = 0; n < 5; n++) {
              var o = !1,
                a = vr(e, t),
                l = i && i != t ? vr(e, i) : a,
                c = cs(e, s = {
                  left: Math.min(a.left, l.left),
                  top: Math.min(a.top, l.top) - r,
                  right: Math.max(a.left, l.left),
                  bottom: Math.max(a.bottom, l.bottom) + r
                }),
                h = e.doc.scrollTop,
                u = e.doc.scrollLeft;
              if (null != c.scrollTop && (fs(e, c.scrollTop), Math.abs(e.doc.scrollTop - h) > 1 && (o = !0)), null != c.scrollLeft && (ms(e, c.scrollLeft), Math.abs(e.doc.scrollLeft - u) > 1 && (o = !0)), !o) break
            }
            return s
          }

          function ls(e, t) {
            var i = cs(e, t);
            null != i.scrollTop && fs(e, i.scrollTop), null != i.scrollLeft && ms(e, i.scrollLeft)
          }

          function cs(e, t) {
            var i = e.display,
              r = br(e.display);
            t.top < 0 && (t.top = 0);
            var s = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : i.scroller.scrollTop,
              n = er(e),
              o = {};
            t.bottom - t.top > n && (t.bottom = t.top + n);
            var a = e.doc.height + Ji(i),
              l = t.top < r,
              c = t.bottom > a - r;
            if (t.top < s) o.scrollTop = l ? 0 : t.top;
            else if (t.bottom > s + n) {
              var h = Math.min(t.top, (c ? a : t.bottom) - n);
              h != s && (o.scrollTop = h)
            }
            var u = e.options.fixedGutter ? 0 : i.gutters.offsetWidth,
              d = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : i.scroller.scrollLeft - u,
              p = Zi(e) - i.gutters.offsetWidth,
              E = t.right - t.left > p;
            return E && (t.right = t.left + p), t.left < 10 ? o.scrollLeft = 0 : t.left < d ? o.scrollLeft = Math.max(0, t.left + u - (E ? 0 : 10)) : t.right > p + d - 3 && (o.scrollLeft = t.right + (E ? 0 : 10) - p), o
          }

          function hs(e, t) {
            null != t && (Es(e), e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + t)
          }

          function us(e) {
            Es(e);
            var t = e.getCursor();
            e.curOp.scrollToPos = {
              from: t,
              to: t,
              margin: e.options.cursorScrollMargin
            }
          }

          function ds(e, t, i) {
            null == t && null == i || Es(e), null != t && (e.curOp.scrollLeft = t), null != i && (e.curOp.scrollTop = i)
          }

          function ps(e, t) {
            Es(e), e.curOp.scrollToPos = t
          }

          function Es(e) {
            var t = e.curOp.scrollToPos;
            t && (e.curOp.scrollToPos = null, gs(e, Nr(e, t.from), Nr(e, t.to), t.margin))
          }

          function gs(e, t, i, r) {
            var s = cs(e, {
              left: Math.min(t.left, i.left),
              top: Math.min(t.top, i.top) - r,
              right: Math.max(t.right, i.right),
              bottom: Math.max(t.bottom, i.bottom) + r
            });
            ds(e, s.scrollLeft, s.scrollTop)
          }

          function fs(e, t) {
            Math.abs(e.doc.scrollTop - t) < 2 || (i || zs(e, {
              top: t
            }), Ts(e, t, !0), i && zs(e), Hs(e, 100))
          }

          function Ts(e, t, i) {
            t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), (e.display.scroller.scrollTop != t || i) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t))
          }

          function ms(e, t, i, r) {
            t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), (i ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, qs(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t))
          }

          function Cs(e) {
            var t = e.display,
              i = t.gutters.offsetWidth,
              r = Math.round(e.doc.height + Ji(e.display));
            return {
              clientHeight: t.scroller.clientHeight,
              viewHeight: t.wrapper.clientHeight,
              scrollWidth: t.scroller.scrollWidth,
              clientWidth: t.scroller.clientWidth,
              viewWidth: t.wrapper.clientWidth,
              barLeft: e.options.fixedGutter ? i : 0,
              docHeight: r,
              scrollHeight: r + Qi(e) + t.barHeight,
              nativeBarWidth: t.nativeBarWidth,
              gutterWidth: i
            }
          }
          var Ss = function(e, t, i) {
            this.cm = i;
            var r = this.vert = w("div", [w("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
              s = this.horiz = w("div", [w("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
            r.tabIndex = s.tabIndex = -1, e(r), e(s), Ce(r, "scroll", function() {
              r.clientHeight && t(r.scrollTop, "vertical")
            }), Ce(s, "scroll", function() {
              s.clientWidth && t(s.scrollLeft, "horizontal")
            }), this.checkedZeroWidth = !1, o && a < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
          };
          Ss.prototype.update = function(e) {
            var t = e.scrollWidth > e.clientWidth + 1,
              i = e.scrollHeight > e.clientHeight + 1,
              r = e.nativeBarWidth;
            if (i) {
              this.vert.style.display = "block", this.vert.style.bottom = t ? r + "px" : "0";
              var s = e.viewHeight - (t ? r : 0);
              this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + s) + "px"
            } else this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0";
            if (t) {
              this.horiz.style.display = "block", this.horiz.style.right = i ? r + "px" : "0", this.horiz.style.left = e.barLeft + "px";
              var n = e.viewWidth - e.barLeft - (i ? r : 0);
              this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + n) + "px"
            } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
            return !this.checkedZeroWidth && e.clientHeight > 0 && (0 == r && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
              right: i ? r : 0,
              bottom: t ? r : 0
            }
          }, Ss.prototype.setScrollLeft = function(e) {
            this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
          }, Ss.prototype.setScrollTop = function(e) {
            this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
          }, Ss.prototype.zeroWidthHack = function() {
            var e = C && !E ? "12px" : "18px";
            this.horiz.style.height = this.vert.style.width = e, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new Y, this.disableVert = new Y
          }, Ss.prototype.enableZeroWidthBar = function(e, t, i) {
            function r() {
              var s = e.getBoundingClientRect();
              ("vert" == i ? document.elementFromPoint(s.right - 1, (s.top + s.bottom) / 2) : document.elementFromPoint((s.right + s.left) / 2, s.bottom - 1)) != e ? e.style.visibility = "hidden" : t.set(1e3, r)
            }
            e.style.visibility = "", t.set(1e3, r)
          }, Ss.prototype.clear = function() {
            var e = this.horiz.parentNode;
            e.removeChild(this.horiz), e.removeChild(this.vert)
          };
          var Rs = function() {};

          function As(e, t) {
            t || (t = Cs(e));
            var i = e.display.barWidth,
              r = e.display.barHeight;
            vs(e, t);
            for (var s = 0; s < 4 && i != e.display.barWidth || r != e.display.barHeight; s++) i != e.display.barWidth && e.options.lineWrapping && rs(e), vs(e, Cs(e)), i = e.display.barWidth, r = e.display.barHeight
          }

          function vs(e, t) {
            var i = e.display,
              r = i.scrollbars.update(t);
            i.sizer.style.paddingRight = (i.barWidth = r.right) + "px", i.sizer.style.paddingBottom = (i.barHeight = r.bottom) + "px", i.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (i.scrollbarFiller.style.display = "block", i.scrollbarFiller.style.height = r.bottom + "px", i.scrollbarFiller.style.width = r.right + "px") : i.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (i.gutterFiller.style.display = "block", i.gutterFiller.style.height = r.bottom + "px", i.gutterFiller.style.width = t.gutterWidth + "px") : i.gutterFiller.style.display = ""
          }
          Rs.prototype.update = function() {
            return {
              bottom: 0,
              right: 0
            }
          }, Rs.prototype.setScrollLeft = function() {}, Rs.prototype.setScrollTop = function() {}, Rs.prototype.clear = function() {};
          var Ns = {
            native: Ss,
            null: Rs
          };

          function Is(e) {
            e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && L(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new Ns[e.options.scrollbarStyle](function(t) {
              e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), Ce(t, "mousedown", function() {
                e.state.focused && setTimeout(function() {
                  return e.display.input.focus()
                }, 0)
              }), t.setAttribute("cm-not-content", "true")
            }, function(t, i) {
              "horizontal" == i ? ms(e, t) : fs(e, t)
            }, e), e.display.scrollbars.addClass && M(e.display.wrapper, e.display.scrollbars.addClass)
          }
          var Os = 0;

          function Ls(e) {
            e.curOp = {
              cm: e,
              viewChanged: !1,
              startHeight: e.doc.height,
              forceUpdate: !1,
              updateInput: 0,
              typing: !1,
              changeObjs: null,
              cursorActivityHandlers: null,
              cursorActivityCalled: 0,
              selectionChanged: !1,
              updateMaxLine: !1,
              scrollLeft: null,
              scrollTop: null,
              scrollToPos: null,
              focus: !1,
              id: ++Os,
              markArrays: null
            }, yi(e.curOp)
          }

          function _s(e) {
            var t = e.curOp;
            t && Di(t, function(e) {
              for (var t = 0; t < e.ops.length; t++) e.ops[t].cm.curOp = null;
              ys(e)
            })
          }

          function ys(e) {
            for (var t = e.ops, i = 0; i < t.length; i++) ws(t[i]);
            for (var r = 0; r < t.length; r++) Ds(t[r]);
            for (var s = 0; s < t.length; s++) Ps(t[s]);
            for (var n = 0; n < t.length; n++) bs(t[n]);
            for (var o = 0; o < t.length; o++) Ms(t[o])
          }

          function ws(e) {
            var t = e.cm,
              i = t.display;
            Vs(t), e.updateMaxLine && di(t), e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < i.viewFrom || e.scrollToPos.to.line >= i.viewTo) || i.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new Bs(t, e.mustUpdate && {
              top: e.scrollTop,
              ensure: e.scrollToPos
            }, e.forceUpdate)
          }

          function Ds(e) {
            e.updatedDisplay = e.mustUpdate && Ks(e.cm, e.update)
          }

          function Ps(e) {
            var t = e.cm,
              i = t.display;
            e.updatedDisplay && rs(t), e.barMeasure = Cs(t), i.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = sr(t, i.maxLine, i.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(i.scroller.clientWidth, i.sizer.offsetLeft + e.adjustWidthTo + Qi(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, i.sizer.offsetLeft + e.adjustWidthTo - Zi(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = i.input.prepareSelection())
          }

          function bs(e) {
            var t = e.cm;
            null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && ms(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
            var i = e.focus && e.focus == b(U(t));
            e.preparedSelection && t.display.input.showSelection(e.preparedSelection, i), (e.updatedDisplay || e.startHeight != t.doc.height) && As(t, e.barMeasure), e.updatedDisplay && Js(t, e.barMeasure), e.selectionChanged && Qr(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), i && Zr(e.cm)
          }

          function Ms(e) {
            var t = e.cm,
              i = t.display,
              r = t.doc;
            e.updatedDisplay && Xs(t, e.update), null == i.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (i.wheelStartX = i.wheelStartY = null), null != e.scrollTop && Ts(t, e.scrollTop, e.forceScroll), null != e.scrollLeft && ms(t, e.scrollLeft, !0, !0), e.scrollToPos && os(t, as(t, Tt(r, e.scrollToPos.from), Tt(r, e.scrollToPos.to), e.scrollToPos.margin));
            var s = e.maybeHiddenMarkers,
              n = e.maybeUnhiddenMarkers;
            if (s)
              for (var o = 0; o < s.length; ++o) s[o].lines.length || Ae(s[o], "hide");
            if (n)
              for (var a = 0; a < n.length; ++a) n[a].lines.length && Ae(n[a], "unhide");
            i.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Ae(t, "changes", t, e.changeObjs), e.update && e.update.finish()
          }

          function Fs(e, t) {
            if (e.curOp) return t();
            Ls(e);
            try {
              return t()
            } finally {
              _s(e)
            }
          }

          function xs(e, t) {
            return function() {
              if (e.curOp) return t.apply(e, arguments);
              Ls(e);
              try {
                return t.apply(e, arguments)
              } finally {
                _s(e)
              }
            }
          }

          function Gs(e) {
            return function() {
              if (this.curOp) return e.apply(this, arguments);
              Ls(this);
              try {
                return e.apply(this, arguments)
              } finally {
                _s(this)
              }
            }
          }

          function Us(e) {
            return function() {
              var t = this.cm;
              if (!t || t.curOp) return e.apply(this, arguments);
              Ls(t);
              try {
                return e.apply(this, arguments)
              } finally {
                _s(t)
              }
            }
          }

          function Hs(e, t) {
            e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, B(ks, e))
          }

          function ks(e) {
            var t = e.doc;
            if (!(t.highlightFrontier >= e.display.viewTo)) {
              var i = +new Date + e.options.workTime,
                r = Nt(e, t.highlightFrontier),
                s = [];
              t.iter(r.line, Math.min(t.first + t.size, e.display.viewTo + 500), function(n) {
                if (r.line >= e.display.viewFrom) {
                  var o = n.styles,
                    a = n.text.length > e.options.maxHighlightLength ? Qe(t.mode, r.state) : null,
                    l = At(e, n, r, !0);
                  a && (r.state = a), n.styles = l.styles;
                  var c = n.styleClasses,
                    h = l.classes;
                  h ? n.styleClasses = h : c && (n.styleClasses = null);
                  for (var u = !o || o.length != n.styles.length || c != h && (!c || !h || c.bgClass != h.bgClass || c.textClass != h.textClass), d = 0; !u && d < o.length; ++d) u = o[d] != n.styles[d];
                  u && s.push(r.line), n.stateAfter = r.save(), r.nextLine()
                } else n.text.length <= e.options.maxHighlightLength && It(e, n.text, r), n.stateAfter = r.line % 5 == 0 ? r.save() : null, r.nextLine();
                if (+new Date > i) return Hs(e, e.options.workDelay), !0
              }), t.highlightFrontier = r.line, t.modeFrontier = Math.max(t.modeFrontier, r.line), s.length && Fs(e, function() {
                for (var t = 0; t < s.length; t++) Vr(e, s[t], "text")
              })
            }
          }
          var Bs = function(e, t, i) {
            var r = e.display;
            this.viewport = t, this.visible = ns(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = Zi(e), this.force = i, this.dims = Fr(e), this.events = []
          };

          function Vs(e) {
            var t = e.display;
            !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Qi(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Qi(e) + "px", t.scrollbarsClipped = !0)
          }

          function Ws(e) {
            if (e.hasFocus()) return null;
            var t = b(U(e));
            if (!t || !P(e.display.lineDiv, t)) return null;
            var i = {
              activeElt: t
            };
            if (window.getSelection) {
              var r = k(e).getSelection();
              r.anchorNode && r.extend && P(e.display.lineDiv, r.anchorNode) && (i.anchorNode = r.anchorNode, i.anchorOffset = r.anchorOffset, i.focusNode = r.focusNode, i.focusOffset = r.focusOffset)
            }
            return i
          }

          function Ys(e) {
            if (e && e.activeElt && e.activeElt != b(H(e.activeElt)) && (e.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(e.activeElt.nodeName) && e.anchorNode && P(document.body, e.anchorNode) && P(document.body, e.focusNode))) {
              var t = e.activeElt.ownerDocument,
                i = t.defaultView.getSelection(),
                r = t.createRange();
              r.setEnd(e.anchorNode, e.anchorOffset), r.collapse(!1), i.removeAllRanges(), i.addRange(r), i.extend(e.focusNode, e.focusOffset)
            }
          }

          function Ks(e, t) {
            var i = e.display,
              r = e.doc;
            if (t.editorIsHidden) return Wr(e), !1;
            if (!t.force && t.visible.from >= i.viewFrom && t.visible.to <= i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers >= i.viewTo) && i.renderedView == i.view && 0 == Xr(e)) return !1;
            Qs(e) && (Wr(e), t.dims = Fr(e));
            var s = r.first + r.size,
              n = Math.max(t.visible.from - e.options.viewportMargin, r.first),
              o = Math.min(s, t.visible.to + e.options.viewportMargin);
            i.viewFrom < n && n - i.viewFrom < 20 && (n = Math.max(r.first, i.viewFrom)), i.viewTo > o && i.viewTo - o < 20 && (o = Math.min(s, i.viewTo)), Ft && (n = oi(e.doc, n), o = ai(e.doc, o));
            var a = n != i.viewFrom || o != i.viewTo || i.lastWrapHeight != t.wrapperHeight || i.lastWrapWidth != t.wrapperWidth;
            Kr(e, n, o), i.viewOffset = hi(it(e.doc, i.viewFrom)), e.display.mover.style.top = i.viewOffset + "px";
            var l = Xr(e);
            if (!a && 0 == l && !t.force && i.renderedView == i.view && (null == i.updateLineNumbers || i.updateLineNumbers >= i.viewTo)) return !1;
            var c = Ws(e);
            return l > 4 && (i.lineDiv.style.display = "none"), $s(e, i.updateLineNumbers, t.dims), l > 4 && (i.lineDiv.style.display = ""), i.renderedView = i.view, Ys(c), _(i.cursorDiv), _(i.selectionDiv), i.gutters.style.height = i.sizer.style.minHeight = 0, a && (i.lastWrapHeight = t.wrapperHeight, i.lastWrapWidth = t.wrapperWidth, Hs(e, 400)), i.updateLineNumbers = null, !0
          }

          function Xs(e, t) {
            for (var i = t.viewport, r = !0;; r = !1) {
              if (r && e.options.lineWrapping && t.oldDisplayWidth != Zi(e)) r && (t.visible = ns(e.display, e.doc, i));
              else if (i && null != i.top && (i = {
                  top: Math.min(e.doc.height + Ji(e.display) - er(e), i.top)
                }), t.visible = ns(e.display, e.doc, i), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo) break;
              if (!Ks(e, t)) break;
              rs(e);
              var s = Cs(e);
              zr(e), As(e, s), Js(e, s), t.force = !1
            }
            t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo)
          }

          function zs(e, t) {
            var i = new Bs(e, t);
            if (Ks(e, i)) {
              rs(e), Xs(e, i);
              var r = Cs(e);
              zr(e), As(e, r), Js(e, r), i.finish()
            }
          }

          function $s(e, t, i) {
            var r = e.display,
              s = e.options.lineNumbers,
              n = r.lineDiv,
              o = n.firstChild;

            function a(t) {
              var i = t.nextSibling;
              return l && C && e.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t), i
            }
            for (var c = r.view, h = r.viewFrom, u = 0; u < c.length; u++) {
              var d = c[u];
              if (d.hidden);
              else if (d.node && d.node.parentNode == n) {
                for (; o != d.node;) o = a(o);
                var p = s && null != t && t <= h && d.lineNumber;
                d.changes && (K(d.changes, "gutter") > -1 && (p = !1), Fi(e, d, h, i)), p && (_(d.lineNumber), d.lineNumber.appendChild(document.createTextNode(ct(e.options, h)))), o = d.node.nextSibling
              } else {
                var E = Wi(e, d, h, i);
                n.insertBefore(E, o)
              }
              h += d.size
            }
            for (; o;) o = a(o)
          }

          function js(e) {
            var t = e.gutters.offsetWidth;
            e.sizer.style.marginLeft = t + "px", bi(e, "gutterChanged", e)
          }

          function Js(e, t) {
            e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Qi(e) + "px"
          }

          function qs(e) {
            var t = e.display,
              i = t.view;
            if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
              for (var r = xr(t) - t.scroller.scrollLeft + e.doc.scrollLeft, s = t.gutters.offsetWidth, n = r + "px", o = 0; o < i.length; o++)
                if (!i[o].hidden) {
                  e.options.fixedGutter && (i[o].gutter && (i[o].gutter.style.left = n), i[o].gutterBackground && (i[o].gutterBackground.style.left = n));
                  var a = i[o].alignable;
                  if (a)
                    for (var l = 0; l < a.length; l++) a[l].style.left = n
                } e.options.fixedGutter && (t.gutters.style.left = r + s + "px")
            }
          }

          function Qs(e) {
            if (!e.options.lineNumbers) return !1;
            var t = e.doc,
              i = ct(e.options, t.first + t.size - 1),
              r = e.display;
            if (i.length != r.lineNumChars) {
              var s = r.measure.appendChild(w("div", [w("div", i)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                n = s.firstChild.offsetWidth,
                o = s.offsetWidth - n;
              return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(n, r.lineGutter.offsetWidth - o) + 1, r.lineNumWidth = r.lineNumInnerWidth + o, r.lineNumChars = r.lineNumInnerWidth ? i.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", js(e.display), !0
            }
            return !1
          }

          function Zs(e, t) {
            for (var i = [], r = !1, s = 0; s < e.length; s++) {
              var n = e[s],
                o = null;
              if ("string" != typeof n && (o = n.style, n = n.className), "CodeMirror-linenumbers" == n) {
                if (!t) continue;
                r = !0
              }
              i.push({
                className: n,
                style: o
              })
            }
            return t && !r && i.push({
              className: "CodeMirror-linenumbers",
              style: null
            }), i
          }

          function en(e) {
            var t = e.gutters,
              i = e.gutterSpecs;
            _(t), e.lineGutter = null;
            for (var r = 0; r < i.length; ++r) {
              var s = i[r],
                n = s.className,
                o = s.style,
                a = t.appendChild(w("div", null, "CodeMirror-gutter " + n));
              o && (a.style.cssText = o), "CodeMirror-linenumbers" == n && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + "px")
            }
            t.style.display = i.length ? "" : "none", js(e)
          }

          function tn(e) {
            en(e.display), Br(e), qs(e)
          }

          function rn(e, t, r, s) {
            var n = this;
            this.input = r, n.scrollbarFiller = w("div", null, "CodeMirror-scrollbar-filler"), n.scrollbarFiller.setAttribute("cm-not-content", "true"), n.gutterFiller = w("div", null, "CodeMirror-gutter-filler"), n.gutterFiller.setAttribute("cm-not-content", "true"), n.lineDiv = D("div", null, "CodeMirror-code"), n.selectionDiv = w("div", null, null, "position: relative; z-index: 1"), n.cursorDiv = w("div", null, "CodeMirror-cursors"), n.measure = w("div", null, "CodeMirror-measure"), n.lineMeasure = w("div", null, "CodeMirror-measure"), n.lineSpace = D("div", [n.measure, n.lineMeasure, n.selectionDiv, n.cursorDiv, n.lineDiv], null, "position: relative; outline: none");
            var c = D("div", [n.lineSpace], "CodeMirror-lines");
            n.mover = w("div", [c], null, "position: relative"), n.sizer = w("div", [n.mover], "CodeMirror-sizer"), n.sizerWidth = null, n.heightForcer = w("div", null, null, "position: absolute; height: " + X + "px; width: 1px;"), n.gutters = w("div", null, "CodeMirror-gutters"), n.lineGutter = null, n.scroller = w("div", [n.sizer, n.heightForcer, n.gutters], "CodeMirror-scroll"), n.scroller.setAttribute("tabIndex", "-1"), n.wrapper = w("div", [n.scrollbarFiller, n.gutterFiller, n.scroller], "CodeMirror"), h && 105 === u && (n.wrapper.style.clipPath = "inset(0px)"), n.wrapper.setAttribute("translate", "no"), o && a < 8 && (n.gutters.style.zIndex = -1, n.scroller.style.paddingRight = 0), l || i && m || (n.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(n.wrapper) : e(n.wrapper)), n.viewFrom = n.viewTo = t.first, n.reportedViewFrom = n.reportedViewTo = t.first, n.view = [], n.renderedView = null, n.externalMeasured = null, n.viewOffset = 0, n.lastWrapHeight = n.lastWrapWidth = 0, n.updateLineNumbers = null, n.nativeBarWidth = n.barHeight = n.barWidth = 0, n.scrollbarsClipped = !1, n.lineNumWidth = n.lineNumInnerWidth = n.lineNumChars = null, n.alignWidgets = !1, n.cachedCharWidth = n.cachedTextHeight = n.cachedPaddingH = null, n.maxLine = null, n.maxLineLength = 0, n.maxLineChanged = !1, n.wheelDX = n.wheelDY = n.wheelStartX = n.wheelStartY = null, n.shift = !1, n.selForContextMenu = null, n.activeTouch = null, n.gutterSpecs = Zs(s.gutters, s.lineNumbers), en(n), r.init(n)
          }
          Bs.prototype.signal = function(e, t) {
            Ie(e, t) && this.events.push(arguments)
          }, Bs.prototype.finish = function() {
            for (var e = 0; e < this.events.length; e++) Ae.apply(null, this.events[e])
          };
          var sn = 0,
            nn = null;

          function on(e) {
            var t = e.wheelDeltaX,
              i = e.wheelDeltaY;
            return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == i && e.detail && e.axis == e.VERTICAL_AXIS ? i = e.detail : null == i && (i = e.wheelDelta), {
              x: t,
              y: i
            }
          }

          function an(e) {
            var t = on(e);
            return t.x *= nn, t.y *= nn, t
          }

          function ln(e, t) {
            h && 102 == u && (null == e.display.chromeScrollHack ? e.display.sizer.style.pointerEvents = "none" : clearTimeout(e.display.chromeScrollHack), e.display.chromeScrollHack = setTimeout(function() {
              e.display.chromeScrollHack = null, e.display.sizer.style.pointerEvents = ""
            }, 100));
            var r = on(t),
              s = r.x,
              n = r.y,
              o = nn;
            0 === t.deltaMode && (s = t.deltaX, n = t.deltaY, o = 1);
            var a = e.display,
              c = a.scroller,
              p = c.scrollWidth > c.clientWidth,
              E = c.scrollHeight > c.clientHeight;
            if (s && p || n && E) {
              if (n && C && l) e: for (var g = t.target, f = a.view; g != c; g = g.parentNode)
                for (var T = 0; T < f.length; T++)
                  if (f[T].node == g) {
                    e.display.currentWheelTarget = g;
                    break e
                  } if (s && !i && !d && null != o) return n && E && fs(e, Math.max(0, c.scrollTop + n * o)), ms(e, Math.max(0, c.scrollLeft + s * o)), (!n || n && E) && Le(t), void(a.wheelStartX = null);
              if (n && null != o) {
                var m = n * o,
                  S = e.doc.scrollTop,
                  R = S + a.wrapper.clientHeight;
                m < 0 ? S = Math.max(0, S + m - 50) : R = Math.min(e.doc.height, R + m + 50), zs(e, {
                  top: S,
                  bottom: R
                })
              }
              sn < 20 && 0 !== t.deltaMode && (null == a.wheelStartX ? (a.wheelStartX = c.scrollLeft, a.wheelStartY = c.scrollTop, a.wheelDX = s, a.wheelDY = n, setTimeout(function() {
                if (null != a.wheelStartX) {
                  var e = c.scrollLeft - a.wheelStartX,
                    t = c.scrollTop - a.wheelStartY,
                    i = t && a.wheelDY && t / a.wheelDY || e && a.wheelDX && e / a.wheelDX;
                  a.wheelStartX = a.wheelStartY = null, i && (nn = (nn * sn + i) / (sn + 1), ++sn)
                }
              }, 200)) : (a.wheelDX += s, a.wheelDY += n))
            }
          }
          o ? nn = -.53 : i ? nn = 15 : h ? nn = -.7 : p && (nn = -1 / 3);
          var cn = function(e, t) {
            this.ranges = e, this.primIndex = t
          };
          cn.prototype.primary = function() {
            return this.ranges[this.primIndex]
          }, cn.prototype.equals = function(e) {
            if (e == this) return !0;
            if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1;
            for (var t = 0; t < this.ranges.length; t++) {
              var i = this.ranges[t],
                r = e.ranges[t];
              if (!dt(i.anchor, r.anchor) || !dt(i.head, r.head)) return !1
            }
            return !0
          }, cn.prototype.deepCopy = function() {
            for (var e = [], t = 0; t < this.ranges.length; t++) e[t] = new hn(pt(this.ranges[t].anchor), pt(this.ranges[t].head));
            return new cn(e, this.primIndex)
          }, cn.prototype.somethingSelected = function() {
            for (var e = 0; e < this.ranges.length; e++)
              if (!this.ranges[e].empty()) return !0;
            return !1
          }, cn.prototype.contains = function(e, t) {
            t || (t = e);
            for (var i = 0; i < this.ranges.length; i++) {
              var r = this.ranges[i];
              if (ut(t, r.from()) >= 0 && ut(e, r.to()) <= 0) return i
            }
            return -1
          };
          var hn = function(e, t) {
            this.anchor = e, this.head = t
          };

          function un(e, t, i) {
            var r = e && e.options.selectionsMayTouch,
              s = t[i];
            t.sort(function(e, t) {
              return ut(e.from(), t.from())
            }), i = K(t, s);
            for (var n = 1; n < t.length; n++) {
              var o = t[n],
                a = t[n - 1],
                l = ut(a.to(), o.from());
              if (r && !o.empty() ? l > 0 : l >= 0) {
                var c = gt(a.from(), o.from()),
                  h = Et(a.to(), o.to()),
                  u = a.empty() ? o.from() == o.head : a.from() == a.head;
                n <= i && --i, t.splice(--n, 2, new hn(u ? h : c, u ? c : h))
              }
            }
            return new cn(t, i)
          }

          function dn(e, t) {
            return new cn([new hn(e, t || e)], 0)
          }

          function pn(e) {
            return e.text ? ht(e.from.line + e.text.length - 1, ee(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
          }

          function En(e, t) {
            if (ut(e, t.from) < 0) return e;
            if (ut(e, t.to) <= 0) return pn(t);
            var i = e.line + t.text.length - (t.to.line - t.from.line) - 1,
              r = e.ch;
            return e.line == t.to.line && (r += pn(t).ch - t.to.ch), ht(i, r)
          }

          function gn(e, t) {
            for (var i = [], r = 0; r < e.sel.ranges.length; r++) {
              var s = e.sel.ranges[r];
              i.push(new hn(En(s.anchor, t), En(s.head, t)))
            }
            return un(e.cm, i, e.sel.primIndex)
          }

          function fn(e, t, i) {
            return e.line == t.line ? ht(i.line, e.ch - t.ch + i.ch) : ht(i.line + (e.line - t.line), e.ch)
          }

          function Tn(e, t, i) {
            for (var r = [], s = ht(e.first, 0), n = s, o = 0; o < t.length; o++) {
              var a = t[o],
                l = fn(a.from, s, n),
                c = fn(pn(a), s, n);
              if (s = a.to, n = c, "around" == i) {
                var h = e.sel.ranges[o],
                  u = ut(h.head, h.anchor) < 0;
                r[o] = new hn(u ? c : l, u ? l : c)
              } else r[o] = new hn(l, l)
            }
            return new cn(r, e.sel.primIndex)
          }

          function mn(e) {
            e.doc.mode = je(e.options, e.doc.modeOption), Cn(e)
          }

          function Cn(e) {
            e.doc.iter(function(e) {
              e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null)
            }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, Hs(e, 100), e.state.modeGen++, e.curOp && Br(e)
          }

          function Sn(e, t) {
            return 0 == t.from.ch && 0 == t.to.ch && "" == ee(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore)
          }

          function Rn(e, t, i, r) {
            function s(e) {
              return i ? i[e] : null
            }

            function n(e, i, s) {
              Ei(e, i, s, r), bi(e, "change", e, t)
            }

            function o(e, t) {
              for (var i = [], n = e; n < t; ++n) i.push(new pi(c[n], s(n), r));
              return i
            }
            var a = t.from,
              l = t.to,
              c = t.text,
              h = it(e, a.line),
              u = it(e, l.line),
              d = ee(c),
              p = s(c.length - 1),
              E = l.line - a.line;
            if (t.full) e.insert(0, o(0, c.length)), e.remove(c.length, e.size - c.length);
            else if (Sn(e, t)) {
              var g = o(0, c.length - 1);
              n(u, u.text, p), E && e.remove(a.line, E), g.length && e.insert(a.line, g)
            } else if (h == u)
              if (1 == c.length) n(h, h.text.slice(0, a.ch) + d + h.text.slice(l.ch), p);
              else {
                var f = o(1, c.length - 1);
                f.push(new pi(d + h.text.slice(l.ch), p, r)), n(h, h.text.slice(0, a.ch) + c[0], s(0)), e.insert(a.line + 1, f)
              }
            else if (1 == c.length) n(h, h.text.slice(0, a.ch) + c[0] + u.text.slice(l.ch), s(0)), e.remove(a.line + 1, E);
            else {
              n(h, h.text.slice(0, a.ch) + c[0], s(0)), n(u, d + u.text.slice(l.ch), p);
              var T = o(1, c.length - 1);
              E > 1 && e.remove(a.line + 1, E - 1), e.insert(a.line + 1, T)
            }
            bi(e, "change", e, t)
          }

          function An(e, t, i) {
            function r(e, s, n) {
              if (e.linked)
                for (var o = 0; o < e.linked.length; ++o) {
                  var a = e.linked[o];
                  if (a.doc != s) {
                    var l = n && a.sharedHist;
                    i && !l || (t(a.doc, l), r(a.doc, e, l))
                  }
                }
            }
            r(e, null, !0)
          }

          function vn(e, t) {
            if (t.cm) throw new Error("This document is already in use.");
            e.doc = t, t.cm = e, Ur(e), mn(e), Nn(e), e.options.direction = t.direction, e.options.lineWrapping || di(e), e.options.mode = t.modeOption, Br(e)
          }

          function Nn(e) {
            ("rtl" == e.doc.direction ? M : L)(e.display.lineDiv, "CodeMirror-rtl")
          }

          function In(e) {
            Fs(e, function() {
              Nn(e), Br(e)
            })
          }

          function On(e) {
            this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1
          }

          function Ln(e, t) {
            var i = {
              from: pt(t.from),
              to: pn(t),
              text: rt(e, t.from, t.to)
            };
            return Mn(e, i, t.from.line, t.to.line + 1), An(e, function(e) {
              return Mn(e, i, t.from.line, t.to.line + 1)
            }, !0), i
          }

          function _n(e) {
            for (; e.length && ee(e).ranges;) e.pop()
          }

          function yn(e, t) {
            return t ? (_n(e.done), ee(e.done)) : e.done.length && !ee(e.done).ranges ? ee(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), ee(e.done)) : void 0
          }

          function wn(e, t, i, r) {
            var s = e.history;
            s.undone.length = 0;
            var n, o, a = +new Date;
            if ((s.lastOp == r || s.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && s.lastModTime > a - (e.cm ? e.cm.options.historyEventDelay : 500) || "*" == t.origin.charAt(0))) && (n = yn(s, s.lastOp == r))) o = ee(n.changes), 0 == ut(t.from, t.to) && 0 == ut(t.from, o.to) ? o.to = pn(t) : n.changes.push(Ln(e, t));
            else {
              var l = ee(s.done);
              for (l && l.ranges || bn(e.sel, s.done), n = {
                  changes: [Ln(e, t)],
                  generation: s.generation
                }, s.done.push(n); s.done.length > s.undoDepth;) s.done.shift(), s.done[0].ranges || s.done.shift()
            }
            s.done.push(i), s.generation = ++s.maxGeneration, s.lastModTime = s.lastSelTime = a, s.lastOp = s.lastSelOp = r, s.lastOrigin = s.lastSelOrigin = t.origin, o || Ae(e, "historyAdded")
          }

          function Dn(e, t, i, r) {
            var s = t.charAt(0);
            return "*" == s || "+" == s && i.ranges.length == r.ranges.length && i.somethingSelected() == r.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500)
          }

          function Pn(e, t, i, r) {
            var s = e.history,
              n = r && r.origin;
            i == s.lastSelOp || n && s.lastSelOrigin == n && (s.lastModTime == s.lastSelTime && s.lastOrigin == n || Dn(e, n, ee(s.done), t)) ? s.done[s.done.length - 1] = t : bn(t, s.done), s.lastSelTime = +new Date, s.lastSelOrigin = n, s.lastSelOp = i, r && !1 !== r.clearRedo && _n(s.undone)
          }

          function bn(e, t) {
            var i = ee(t);
            i && i.ranges && i.equals(e) || t.push(e)
          }

          function Mn(e, t, i, r) {
            var s = t["spans_" + e.id],
              n = 0;
            e.iter(Math.max(e.first, i), Math.min(e.first + e.size, r), function(i) {
              i.markedSpans && ((s || (s = t["spans_" + e.id] = {}))[n] = i.markedSpans), ++n
            })
          }

          function Fn(e) {
            if (!e) return null;
            for (var t, i = 0; i < e.length; ++i) e[i].marker.explicitlyCleared ? t || (t = e.slice(0, i)) : t && t.push(e[i]);
            return t ? t.length ? t : null : e
          }

          function xn(e, t) {
            var i = t["spans_" + e.id];
            if (!i) return null;
            for (var r = [], s = 0; s < t.text.length; ++s) r.push(Fn(i[s]));
            return r
          }

          function Gn(e, t) {
            var i = xn(e, t),
              r = Yt(e, t);
            if (!i) return r;
            if (!r) return i;
            for (var s = 0; s < i.length; ++s) {
              var n = i[s],
                o = r[s];
              if (n && o) e: for (var a = 0; a < o.length; ++a) {
                for (var l = o[a], c = 0; c < n.length; ++c)
                  if (n[c].marker == l.marker) continue e;
                n.push(l)
              } else o && (i[s] = o)
            }
            return i
          }

          function Un(e, t, i) {
            for (var r = [], s = 0; s < e.length; ++s) {
              var n = e[s];
              if (n.ranges) r.push(i ? cn.prototype.deepCopy.call(n) : n);
              else {
                var o = n.changes,
                  a = [];
                r.push({
                  changes: a
                });
                for (var l = 0; l < o.length; ++l) {
                  var c = o[l],
                    h = void 0;
                  if (a.push({
                      from: c.from,
                      to: c.to,
                      text: c.text
                    }), t)
                    for (var u in c)(h = u.match(/^spans_(\d+)$/)) && K(t, Number(h[1])) > -1 && (ee(a)[u] = c[u], delete c[u])
                }
              }
            }
            return r
          }

          function Hn(e, t, i, r) {
            if (r) {
              var s = e.anchor;
              if (i) {
                var n = ut(t, s) < 0;
                n != ut(i, s) < 0 ? (s = t, t = i) : n != ut(t, i) < 0 && (t = i)
              }
              return new hn(s, t)
            }
            return new hn(i || t, t)
          }

          function kn(e, t, i, r, s) {
            null == s && (s = e.cm && (e.cm.display.shift || e.extend)), Xn(e, new cn([Hn(e.sel.primary(), t, i, s)], 0), r)
          }

          function Bn(e, t, i) {
            for (var r = [], s = e.cm && (e.cm.display.shift || e.extend), n = 0; n < e.sel.ranges.length; n++) r[n] = Hn(e.sel.ranges[n], t[n], null, s);
            Xn(e, un(e.cm, r, e.sel.primIndex), i)
          }

          function Vn(e, t, i, r) {
            var s = e.sel.ranges.slice(0);
            s[t] = i, Xn(e, un(e.cm, s, e.sel.primIndex), r)
          }

          function Wn(e, t, i, r) {
            Xn(e, dn(t, i), r)
          }

          function Yn(e, t, i) {
            var r = {
              ranges: t.ranges,
              update: function(t) {
                this.ranges = [];
                for (var i = 0; i < t.length; i++) this.ranges[i] = new hn(Tt(e, t[i].anchor), Tt(e, t[i].head))
              },
              origin: i && i.origin
            };
            return Ae(e, "beforeSelectionChange", e, r), e.cm && Ae(e.cm, "beforeSelectionChange", e.cm, r), r.ranges != t.ranges ? un(e.cm, r.ranges, r.ranges.length - 1) : t
          }

          function Kn(e, t, i) {
            var r = e.history.done,
              s = ee(r);
            s && s.ranges ? (r[r.length - 1] = t, zn(e, t, i)) : Xn(e, t, i)
          }

          function Xn(e, t, i) {
            zn(e, t, i), Pn(e, e.sel, e.cm ? e.cm.curOp.id : NaN, i)
          }

          function zn(e, t, i) {
            (Ie(e, "beforeSelectionChange") || e.cm && Ie(e.cm, "beforeSelectionChange")) && (t = Yn(e, t, i));
            var r = i && i.bias || (ut(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
            $n(e, Jn(e, t, r, !0)), i && !1 === i.scroll || !e.cm || "nocursor" == e.cm.getOption("readOnly") || us(e.cm)
          }

          function $n(e, t) {
            t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, Ne(e.cm)), bi(e, "cursorActivity", e))
          }

          function jn(e) {
            $n(e, Jn(e, e.sel, null, !1))
          }

          function Jn(e, t, i, r) {
            for (var s, n = 0; n < t.ranges.length; n++) {
              var o = t.ranges[n],
                a = t.ranges.length == e.sel.ranges.length && e.sel.ranges[n],
                l = Qn(e, o.anchor, a && a.anchor, i, r),
                c = o.head == o.anchor ? l : Qn(e, o.head, a && a.head, i, r);
              (s || l != o.anchor || c != o.head) && (s || (s = t.ranges.slice(0, n)), s[n] = new hn(l, c))
            }
            return s ? un(e.cm, s, t.primIndex) : t
          }

          function qn(e, t, i, r, s) {
            var n = it(e, t.line);
            if (n.markedSpans)
              for (var o = 0; o < n.markedSpans.length; ++o) {
                var a = n.markedSpans[o],
                  l = a.marker,
                  c = "selectLeft" in l ? !l.selectLeft : l.inclusiveLeft,
                  h = "selectRight" in l ? !l.selectRight : l.inclusiveRight;
                if ((null == a.from || (c ? a.from <= t.ch : a.from < t.ch)) && (null == a.to || (h ? a.to >= t.ch : a.to > t.ch))) {
                  if (s && (Ae(l, "beforeCursorEnter"), l.explicitlyCleared)) {
                    if (n.markedSpans) {
                      --o;
                      continue
                    }
                    break
                  }
                  if (!l.atomic) continue;
                  if (i) {
                    var u = l.find(r < 0 ? 1 : -1),
                      d = void 0;
                    if ((r < 0 ? h : c) && (u = Zn(e, u, -r, u && u.line == t.line ? n : null)), u && u.line == t.line && (d = ut(u, i)) && (r < 0 ? d < 0 : d > 0)) return qn(e, u, t, r, s)
                  }
                  var p = l.find(r < 0 ? -1 : 1);
                  return (r < 0 ? c : h) && (p = Zn(e, p, r, p.line == t.line ? n : null)), p ? qn(e, p, t, r, s) : null
                }
              }
            return t
          }

          function Qn(e, t, i, r, s) {
            var n = r || 1,
              o = qn(e, t, i, n, s) || !s && qn(e, t, i, n, !0) || qn(e, t, i, -n, s) || !s && qn(e, t, i, -n, !0);
            return o || (e.cantEdit = !0, ht(e.first, 0))
          }

          function Zn(e, t, i, r) {
            return i < 0 && 0 == t.ch ? t.line > e.first ? Tt(e, ht(t.line - 1)) : null : i > 0 && t.ch == (r || it(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? ht(t.line + 1, 0) : null : new ht(t.line, t.ch + i)
          }

          function eo(e) {
            e.setSelection(ht(e.firstLine(), 0), ht(e.lastLine()), $)
          }

          function to(e, t, i) {
            var r = {
              canceled: !1,
              from: t.from,
              to: t.to,
              text: t.text,
              origin: t.origin,
              cancel: function() {
                return r.canceled = !0
              }
            };
            return i && (r.update = function(t, i, s, n) {
              t && (r.from = Tt(e, t)), i && (r.to = Tt(e, i)), s && (r.text = s), void 0 !== n && (r.origin = n)
            }), Ae(e, "beforeChange", e, r), e.cm && Ae(e.cm, "beforeChange", e.cm, r), r.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : {
              from: r.from,
              to: r.to,
              text: r.text,
              origin: r.origin
            }
          }

          function io(e, t, i) {
            if (e.cm) {
              if (!e.cm.curOp) return xs(e.cm, io)(e, t, i);
              if (e.cm.state.suppressEdits) return
            }
            if (!(Ie(e, "beforeChange") || e.cm && Ie(e.cm, "beforeChange")) || (t = to(e, t, !0))) {
              var r = Mt && !i && Xt(e, t.from, t.to);
              if (r)
                for (var s = r.length - 1; s >= 0; --s) ro(e, {
                  from: r[s].from,
                  to: r[s].to,
                  text: s ? [""] : t.text,
                  origin: t.origin
                });
              else ro(e, t)
            }
          }

          function ro(e, t) {
            if (1 != t.text.length || "" != t.text[0] || 0 != ut(t.from, t.to)) {
              var i = gn(e, t);
              wn(e, t, i, e.cm ? e.cm.curOp.id : NaN), oo(e, t, i, Yt(e, t));
              var r = [];
              An(e, function(e, i) {
                i || -1 != K(r, e.history) || (uo(e.history, t), r.push(e.history)), oo(e, t, null, Yt(e, t))
              })
            }
          }

          function so(e, t, i) {
            var r = e.cm && e.cm.state.suppressEdits;
            if (!r || i) {
              for (var s, n = e.history, o = e.sel, a = "undo" == t ? n.done : n.undone, l = "undo" == t ? n.undone : n.done, c = 0; c < a.length && (s = a[c], i ? !s.ranges || s.equals(e.sel) : s.ranges); c++);
              if (c != a.length) {
                for (n.lastOrigin = n.lastSelOrigin = null;;) {
                  if (!(s = a.pop()).ranges) {
                    if (r) return void a.push(s);
                    break
                  }
                  if (bn(s, l), i && !s.equals(e.sel)) return void Xn(e, s, {
                    clearRedo: !1
                  });
                  o = s
                }
                var h = [];
                bn(o, l), l.push({
                  changes: h,
                  generation: n.generation
                }), n.generation = s.generation || ++n.maxGeneration;
                for (var u = Ie(e, "beforeChange") || e.cm && Ie(e.cm, "beforeChange"), d = function(i) {
                    var r = s.changes[i];
                    if (r.origin = t, u && !to(e, r, !1)) return a.length = 0, {};
                    h.push(Ln(e, r));
                    var n = i ? gn(e, r) : ee(a);
                    oo(e, r, n, Gn(e, r)), !i && e.cm && e.cm.scrollIntoView({
                      from: r.from,
                      to: pn(r)
                    });
                    var o = [];
                    An(e, function(e, t) {
                      t || -1 != K(o, e.history) || (uo(e.history, r), o.push(e.history)), oo(e, r, null, Gn(e, r))
                    })
                  }, p = s.changes.length - 1; p >= 0; --p) {
                  var E = d(p);
                  if (E) return E.v
                }
              }
            }
          }

          function no(e, t) {
            if (0 != t && (e.first += t, e.sel = new cn(te(e.sel.ranges, function(e) {
                return new hn(ht(e.anchor.line + t, e.anchor.ch), ht(e.head.line + t, e.head.ch))
              }), e.sel.primIndex), e.cm)) {
              Br(e.cm, e.first, e.first - t, t);
              for (var i = e.cm.display, r = i.viewFrom; r < i.viewTo; r++) Vr(e.cm, r, "gutter")
            }
          }

          function oo(e, t, i, r) {
            if (e.cm && !e.cm.curOp) return xs(e.cm, oo)(e, t, i, r);
            if (t.to.line < e.first) no(e, t.text.length - 1 - (t.to.line - t.from.line));
            else if (!(t.from.line > e.lastLine())) {
              if (t.from.line < e.first) {
                var s = t.text.length - 1 - (e.first - t.from.line);
                no(e, s), t = {
                  from: ht(e.first, 0),
                  to: ht(t.to.line + s, t.to.ch),
                  text: [ee(t.text)],
                  origin: t.origin
                }
              }
              var n = e.lastLine();
              t.to.line > n && (t = {
                from: t.from,
                to: ht(n, it(e, n).text.length),
                text: [t.text[0]],
                origin: t.origin
              }), t.removed = rt(e, t.from, t.to), i || (i = gn(e, t)), e.cm ? ao(e.cm, t, r) : Rn(e, t, r), zn(e, i, $), e.cantEdit && Qn(e, ht(e.firstLine(), 0)) && (e.cantEdit = !1)
            }
          }

          function ao(e, t, i) {
            var r = e.doc,
              s = e.display,
              n = t.from,
              o = t.to,
              a = !1,
              l = n.line;
            e.options.lineWrapping || (l = ot(ri(it(r, n.line))), r.iter(l, o.line + 1, function(e) {
              if (e == s.maxLine) return a = !0, !0
            })), r.sel.contains(t.from, t.to) > -1 && Ne(e), Rn(r, t, i, Gr(e)), e.options.lineWrapping || (r.iter(l, n.line + t.text.length, function(e) {
              var t = ui(e);
              t > s.maxLineLength && (s.maxLine = e, s.maxLineLength = t, s.maxLineChanged = !0, a = !1)
            }), a && (e.curOp.updateMaxLine = !0)), bt(r, n.line), Hs(e, 400);
            var c = t.text.length - (o.line - n.line) - 1;
            t.full ? Br(e) : n.line != o.line || 1 != t.text.length || Sn(e.doc, t) ? Br(e, n.line, o.line + 1, c) : Vr(e, n.line, "text");
            var h = Ie(e, "changes"),
              u = Ie(e, "change");
            if (u || h) {
              var d = {
                from: n,
                to: o,
                text: t.text,
                removed: t.removed,
                origin: t.origin
              };
              u && bi(e, "change", e, d), h && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(d)
            }
            e.display.selForContextMenu = null
          }

          function lo(e, t, i, r, s) {
            var n;
            r || (r = i), ut(r, i) < 0 && (i = (n = [r, i])[0], r = n[1]), "string" == typeof t && (t = e.splitLines(t)), io(e, {
              from: i,
              to: r,
              text: t,
              origin: s
            })
          }

          function co(e, t, i, r) {
            i < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0)
          }

          function ho(e, t, i, r) {
            for (var s = 0; s < e.length; ++s) {
              var n = e[s],
                o = !0;
              if (n.ranges) {
                n.copied || ((n = e[s] = n.deepCopy()).copied = !0);
                for (var a = 0; a < n.ranges.length; a++) co(n.ranges[a].anchor, t, i, r), co(n.ranges[a].head, t, i, r)
              } else {
                for (var l = 0; l < n.changes.length; ++l) {
                  var c = n.changes[l];
                  if (i < c.from.line) c.from = ht(c.from.line + r, c.from.ch), c.to = ht(c.to.line + r, c.to.ch);
                  else if (t <= c.to.line) {
                    o = !1;
                    break
                  }
                }
                o || (e.splice(0, s + 1), s = 0)
              }
            }
          }

          function uo(e, t) {
            var i = t.from.line,
              r = t.to.line,
              s = t.text.length - (r - i) - 1;
            ho(e.done, i, r, s), ho(e.undone, i, r, s)
          }

          function po(e, t, i, r) {
            var s = t,
              n = t;
            return "number" == typeof t ? n = it(e, ft(e, t)) : s = ot(t), null == s ? null : (r(n, s) && e.cm && Vr(e.cm, s, i), n)
          }

          function Eo(e) {
            this.lines = e, this.parent = null;
            for (var t = 0, i = 0; i < e.length; ++i) e[i].parent = this, t += e[i].height;
            this.height = t
          }

          function go(e) {
            this.children = e;
            for (var t = 0, i = 0, r = 0; r < e.length; ++r) {
              var s = e[r];
              t += s.chunkSize(), i += s.height, s.parent = this
            }
            this.size = t, this.height = i, this.parent = null
          }
          hn.prototype.from = function() {
            return gt(this.anchor, this.head)
          }, hn.prototype.to = function() {
            return Et(this.anchor, this.head)
          }, hn.prototype.empty = function() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
          }, Eo.prototype = {
            chunkSize: function() {
              return this.lines.length
            },
            removeInner: function(e, t) {
              for (var i = e, r = e + t; i < r; ++i) {
                var s = this.lines[i];
                this.height -= s.height, gi(s), bi(s, "delete")
              }
              this.lines.splice(e, t)
            },
            collapse: function(e) {
              e.push.apply(e, this.lines)
            },
            insertInner: function(e, t, i) {
              this.height += i, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
              for (var r = 0; r < t.length; ++r) t[r].parent = this
            },
            iterN: function(e, t, i) {
              for (var r = e + t; e < r; ++e)
                if (i(this.lines[e])) return !0
            }
          }, go.prototype = {
            chunkSize: function() {
              return this.size
            },
            removeInner: function(e, t) {
              this.size -= t;
              for (var i = 0; i < this.children.length; ++i) {
                var r = this.children[i],
                  s = r.chunkSize();
                if (e < s) {
                  var n = Math.min(t, s - e),
                    o = r.height;
                  if (r.removeInner(e, n), this.height -= o - r.height, s == n && (this.children.splice(i--, 1), r.parent = null), 0 == (t -= n)) break;
                  e = 0
                } else e -= s
              }
              if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof Eo))) {
                var a = [];
                this.collapse(a), this.children = [new Eo(a)], this.children[0].parent = this
              }
            },
            collapse: function(e) {
              for (var t = 0; t < this.children.length; ++t) this.children[t].collapse(e)
            },
            insertInner: function(e, t, i) {
              this.size += t.length, this.height += i;
              for (var r = 0; r < this.children.length; ++r) {
                var s = this.children[r],
                  n = s.chunkSize();
                if (e <= n) {
                  if (s.insertInner(e, t, i), s.lines && s.lines.length > 50) {
                    for (var o = s.lines.length % 25 + 25, a = o; a < s.lines.length;) {
                      var l = new Eo(s.lines.slice(a, a += 25));
                      s.height -= l.height, this.children.splice(++r, 0, l), l.parent = this
                    }
                    s.lines = s.lines.slice(0, o), this.maybeSpill()
                  }
                  break
                }
                e -= n
              }
            },
            maybeSpill: function() {
              if (!(this.children.length <= 10)) {
                var e = this;
                do {
                  var t = new go(e.children.splice(e.children.length - 5, 5));
                  if (e.parent) {
                    e.size -= t.size, e.height -= t.height;
                    var i = K(e.parent.children, e);
                    e.parent.children.splice(i + 1, 0, t)
                  } else {
                    var r = new go(e.children);
                    r.parent = e, e.children = [r, t], e = r
                  }
                  t.parent = e.parent
                } while (e.children.length > 10);
                e.parent.maybeSpill()
              }
            },
            iterN: function(e, t, i) {
              for (var r = 0; r < this.children.length; ++r) {
                var s = this.children[r],
                  n = s.chunkSize();
                if (e < n) {
                  var o = Math.min(t, n - e);
                  if (s.iterN(e, o, i)) return !0;
                  if (0 == (t -= o)) break;
                  e = 0
                } else e -= n
              }
            }
          };
          var fo = function(e, t, i) {
            if (i)
              for (var r in i) i.hasOwnProperty(r) && (this[r] = i[r]);
            this.doc = e, this.node = t
          };

          function To(e, t, i) {
            hi(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && hs(e, i)
          }

          function mo(e, t, i, r) {
            var s = new fo(e, i, r),
              n = e.cm;
            return n && s.noHScroll && (n.display.alignWidgets = !0), po(e, t, "widget", function(t) {
              var i = t.widgets || (t.widgets = []);
              if (null == s.insertAt ? i.push(s) : i.splice(Math.min(i.length, Math.max(0, s.insertAt)), 0, s), s.line = t, n && !li(e, t)) {
                var r = hi(t) < e.scrollTop;
                nt(t, t.height + zi(s)), r && hs(n, s.height), n.curOp.forceUpdate = !0
              }
              return !0
            }), n && bi(n, "lineWidgetAdded", n, s, "number" == typeof t ? t : ot(t)), s
          }
          fo.prototype.clear = function() {
            var e = this.doc.cm,
              t = this.line.widgets,
              i = this.line,
              r = ot(i);
            if (null != r && t) {
              for (var s = 0; s < t.length; ++s) t[s] == this && t.splice(s--, 1);
              t.length || (i.widgets = null);
              var n = zi(this);
              nt(i, Math.max(0, i.height - n)), e && (Fs(e, function() {
                To(e, i, -n), Vr(e, r, "widget")
              }), bi(e, "lineWidgetCleared", e, this, r))
            }
          }, fo.prototype.changed = function() {
            var e = this,
              t = this.height,
              i = this.doc.cm,
              r = this.line;
            this.height = null;
            var s = zi(this) - t;
            s && (li(this.doc, r) || nt(r, r.height + s), i && Fs(i, function() {
              i.curOp.forceUpdate = !0, To(i, r, s), bi(i, "lineWidgetChanged", i, e, ot(r))
            }))
          }, Oe(fo);
          var Co = 0,
            So = function(e, t) {
              this.lines = [], this.type = t, this.doc = e, this.id = ++Co
            };

          function Ro(e, t, i, r, s) {
            if (r && r.shared) return vo(e, t, i, r, s);
            if (e.cm && !e.cm.curOp) return xs(e.cm, Ro)(e, t, i, r, s);
            var n = new So(e, s),
              o = ut(t, i);
            if (r && V(r, n, !1), o > 0 || 0 == o && !1 !== n.clearWhenEmpty) return n;
            if (n.replacedWith && (n.collapsed = !0, n.widgetNode = D("span", [n.replacedWith], "CodeMirror-widget"), r.handleMouseEvents || n.widgetNode.setAttribute("cm-ignore-events", "true"), r.insertLeft && (n.widgetNode.insertLeft = !0)), n.collapsed) {
              if (ii(e, t.line, t, i, n) || t.line != i.line && ii(e, i.line, t, i, n)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
              Gt()
            }
            n.addToHistory && wn(e, {
              from: t,
              to: i,
              origin: "markText"
            }, e.sel, NaN);
            var a, l = t.line,
              c = e.cm;
            if (e.iter(l, i.line + 1, function(r) {
                c && n.collapsed && !c.options.lineWrapping && ri(r) == c.display.maxLine && (a = !0), n.collapsed && l != t.line && nt(r, 0), Bt(r, new Ut(n, l == t.line ? t.ch : null, l == i.line ? i.ch : null), e.cm && e.cm.curOp), ++l
              }), n.collapsed && e.iter(t.line, i.line + 1, function(t) {
                li(e, t) && nt(t, 0)
              }), n.clearOnEnter && Ce(n, "beforeCursorEnter", function() {
                return n.clear()
              }), n.readOnly && (xt(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), n.collapsed && (n.id = ++Co, n.atomic = !0), c) {
              if (a && (c.curOp.updateMaxLine = !0), n.collapsed) Br(c, t.line, i.line + 1);
              else if (n.className || n.startStyle || n.endStyle || n.css || n.attributes || n.title)
                for (var h = t.line; h <= i.line; h++) Vr(c, h, "text");
              n.atomic && jn(c.doc), bi(c, "markerAdded", c, n)
            }
            return n
          }
          So.prototype.clear = function() {
            if (!this.explicitlyCleared) {
              var e = this.doc.cm,
                t = e && !e.curOp;
              if (t && Ls(e), Ie(this, "clear")) {
                var i = this.find();
                i && bi(this, "clear", i.from, i.to)
              }
              for (var r = null, s = null, n = 0; n < this.lines.length; ++n) {
                var o = this.lines[n],
                  a = Ht(o.markedSpans, this);
                e && !this.collapsed ? Vr(e, ot(o), "text") : e && (null != a.to && (s = ot(o)), null != a.from && (r = ot(o))), o.markedSpans = kt(o.markedSpans, a), null == a.from && this.collapsed && !li(this.doc, o) && e && nt(o, br(e.display))
              }
              if (e && this.collapsed && !e.options.lineWrapping)
                for (var l = 0; l < this.lines.length; ++l) {
                  var c = ri(this.lines[l]),
                    h = ui(c);
                  h > e.display.maxLineLength && (e.display.maxLine = c, e.display.maxLineLength = h, e.display.maxLineChanged = !0)
                }
              null != r && e && this.collapsed && Br(e, r, s + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && jn(e.doc)), e && bi(e, "markerCleared", e, this, r, s), t && _s(e), this.parent && this.parent.clear()
            }
          }, So.prototype.find = function(e, t) {
            var i, r;
            null == e && "bookmark" == this.type && (e = 1);
            for (var s = 0; s < this.lines.length; ++s) {
              var n = this.lines[s],
                o = Ht(n.markedSpans, this);
              if (null != o.from && (i = ht(t ? n : ot(n), o.from), -1 == e)) return i;
              if (null != o.to && (r = ht(t ? n : ot(n), o.to), 1 == e)) return r
            }
            return i && {
              from: i,
              to: r
            }
          }, So.prototype.changed = function() {
            var e = this,
              t = this.find(-1, !0),
              i = this,
              r = this.doc.cm;
            t && r && Fs(r, function() {
              var s = t.line,
                n = ot(t.line),
                o = nr(r, n);
              if (o && (Er(o), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !li(i.doc, s) && null != i.height) {
                var a = i.height;
                i.height = null;
                var l = zi(i) - a;
                l && nt(s, s.height + l)
              }
              bi(r, "markerChanged", r, e)
            })
          }, So.prototype.attachLine = function(e) {
            if (!this.lines.length && this.doc.cm) {
              var t = this.doc.cm.curOp;
              t.maybeHiddenMarkers && -1 != K(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
            }
            this.lines.push(e)
          }, So.prototype.detachLine = function(e) {
            if (this.lines.splice(K(this.lines, e), 1), !this.lines.length && this.doc.cm) {
              var t = this.doc.cm.curOp;
              (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
            }
          }, Oe(So);
          var Ao = function(e, t) {
            this.markers = e, this.primary = t;
            for (var i = 0; i < e.length; ++i) e[i].parent = this
          };

          function vo(e, t, i, r, s) {
            (r = V(r)).shared = !1;
            var n = [Ro(e, t, i, r, s)],
              o = n[0],
              a = r.widgetNode;
            return An(e, function(e) {
              a && (r.widgetNode = a.cloneNode(!0)), n.push(Ro(e, Tt(e, t), Tt(e, i), r, s));
              for (var l = 0; l < e.linked.length; ++l)
                if (e.linked[l].isParent) return;
              o = ee(n)
            }), new Ao(n, o)
          }

          function No(e) {
            return e.findMarks(ht(e.first, 0), e.clipPos(ht(e.lastLine())), function(e) {
              return e.parent
            })
          }

          function Io(e, t) {
            for (var i = 0; i < t.length; i++) {
              var r = t[i],
                s = r.find(),
                n = e.clipPos(s.from),
                o = e.clipPos(s.to);
              if (ut(n, o)) {
                var a = Ro(e, n, o, r.primary, r.primary.type);
                r.markers.push(a), a.parent = r
              }
            }
          }

          function Oo(e) {
            for (var t = function(t) {
                var i = e[t],
                  r = [i.primary.doc];
                An(i.primary.doc, function(e) {
                  return r.push(e)
                });
                for (var s = 0; s < i.markers.length; s++) {
                  var n = i.markers[s]; - 1 == K(r, n.doc) && (n.parent = null, i.markers.splice(s--, 1))
                }
              }, i = 0; i < e.length; i++) t(i)
          }
          Ao.prototype.clear = function() {
            if (!this.explicitlyCleared) {
              this.explicitlyCleared = !0;
              for (var e = 0; e < this.markers.length; ++e) this.markers[e].clear();
              bi(this, "clear")
            }
          }, Ao.prototype.find = function(e, t) {
            return this.primary.find(e, t)
          }, Oe(Ao);
          var Lo = 0,
            _o = function(e, t, i, r, s) {
              if (!(this instanceof _o)) return new _o(e, t, i, r, s);
              null == i && (i = 0), go.call(this, [new Eo([new pi("", null)])]), this.first = i, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = i;
              var n = ht(i, 0);
              this.sel = dn(n), this.history = new On(null), this.id = ++Lo, this.modeOption = t, this.lineSep = r, this.direction = "rtl" == s ? "rtl" : "ltr", this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), Rn(this, {
                from: n,
                to: n,
                text: e
              }), Xn(this, dn(n), $)
            };
          _o.prototype = se(go.prototype, {
            constructor: _o,
            iter: function(e, t, i) {
              i ? this.iterN(e - this.first, t - e, i) : this.iterN(this.first, this.first + this.size, e)
            },
            insert: function(e, t) {
              for (var i = 0, r = 0; r < t.length; ++r) i += t[r].height;
              this.insertInner(e - this.first, t, i)
            },
            remove: function(e, t) {
              this.removeInner(e - this.first, t)
            },
            getValue: function(e) {
              var t = st(this, this.first, this.first + this.size);
              return !1 === e ? t : t.join(e || this.lineSeparator())
            },
            setValue: Us(function(e) {
              var t = ht(this.first, 0),
                i = this.first + this.size - 1;
              io(this, {
                from: t,
                to: ht(i, it(this, i).text.length),
                text: this.splitLines(e),
                origin: "setValue",
                full: !0
              }, !0), this.cm && ds(this.cm, 0, 0), Xn(this, dn(t), $)
            }),
            replaceRange: function(e, t, i, r) {
              lo(this, e, t = Tt(this, t), i = i ? Tt(this, i) : t, r)
            },
            getRange: function(e, t, i) {
              var r = rt(this, Tt(this, e), Tt(this, t));
              return !1 === i ? r : "" === i ? r.join("") : r.join(i || this.lineSeparator())
            },
            getLine: function(e) {
              var t = this.getLineHandle(e);
              return t && t.text
            },
            getLineHandle: function(e) {
              if (lt(this, e)) return it(this, e)
            },
            getLineNumber: function(e) {
              return ot(e)
            },
            getLineHandleVisualStart: function(e) {
              return "number" == typeof e && (e = it(this, e)), ri(e)
            },
            lineCount: function() {
              return this.size
            },
            firstLine: function() {
              return this.first
            },
            lastLine: function() {
              return this.first + this.size - 1
            },
            clipPos: function(e) {
              return Tt(this, e)
            },
            getCursor: function(e) {
              var t = this.sel.primary();
              return null == e || "head" == e ? t.head : "anchor" == e ? t.anchor : "end" == e || "to" == e || !1 === e ? t.to() : t.from()
            },
            listSelections: function() {
              return this.sel.ranges
            },
            somethingSelected: function() {
              return this.sel.somethingSelected()
            },
            setCursor: Us(function(e, t, i) {
              Wn(this, Tt(this, "number" == typeof e ? ht(e, t || 0) : e), null, i)
            }),
            setSelection: Us(function(e, t, i) {
              Wn(this, Tt(this, e), Tt(this, t || e), i)
            }),
            extendSelection: Us(function(e, t, i) {
              kn(this, Tt(this, e), t && Tt(this, t), i)
            }),
            extendSelections: Us(function(e, t) {
              Bn(this, Ct(this, e), t)
            }),
            extendSelectionsBy: Us(function(e, t) {
              Bn(this, Ct(this, te(this.sel.ranges, e)), t)
            }),
            setSelections: Us(function(e, t, i) {
              if (e.length) {
                for (var r = [], s = 0; s < e.length; s++) r[s] = new hn(Tt(this, e[s].anchor), Tt(this, e[s].head || e[s].anchor));
                null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), Xn(this, un(this.cm, r, t), i)
              }
            }),
            addSelection: Us(function(e, t, i) {
              var r = this.sel.ranges.slice(0);
              r.push(new hn(Tt(this, e), Tt(this, t || e))), Xn(this, un(this.cm, r, r.length - 1), i)
            }),
            getSelection: function(e) {
              for (var t, i = this.sel.ranges, r = 0; r < i.length; r++) {
                var s = rt(this, i[r].from(), i[r].to());
                t = t ? t.concat(s) : s
              }
              return !1 === e ? t : t.join(e || this.lineSeparator())
            },
            getSelections: function(e) {
              for (var t = [], i = this.sel.ranges, r = 0; r < i.length; r++) {
                var s = rt(this, i[r].from(), i[r].to());
                !1 !== e && (s = s.join(e || this.lineSeparator())), t[r] = s
              }
              return t
            },
            replaceSelection: function(e, t, i) {
              for (var r = [], s = 0; s < this.sel.ranges.length; s++) r[s] = e;
              this.replaceSelections(r, t, i || "+input")
            },
            replaceSelections: Us(function(e, t, i) {
              for (var r = [], s = this.sel, n = 0; n < s.ranges.length; n++) {
                var o = s.ranges[n];
                r[n] = {
                  from: o.from(),
                  to: o.to(),
                  text: this.splitLines(e[n]),
                  origin: i
                }
              }
              for (var a = t && "end" != t && Tn(this, r, t), l = r.length - 1; l >= 0; l--) io(this, r[l]);
              a ? Kn(this, a) : this.cm && us(this.cm)
            }),
            undo: Us(function() {
              so(this, "undo")
            }),
            redo: Us(function() {
              so(this, "redo")
            }),
            undoSelection: Us(function() {
              so(this, "undo", !0)
            }),
            redoSelection: Us(function() {
              so(this, "redo", !0)
            }),
            setExtending: function(e) {
              this.extend = e
            },
            getExtending: function() {
              return this.extend
            },
            historySize: function() {
              for (var e = this.history, t = 0, i = 0, r = 0; r < e.done.length; r++) e.done[r].ranges || ++t;
              for (var s = 0; s < e.undone.length; s++) e.undone[s].ranges || ++i;
              return {
                undo: t,
                redo: i
              }
            },
            clearHistory: function() {
              var e = this;
              this.history = new On(this.history), An(this, function(t) {
                return t.history = e.history
              }, !0)
            },
            markClean: function() {
              this.cleanGeneration = this.changeGeneration(!0)
            },
            changeGeneration: function(e) {
              return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
            },
            isClean: function(e) {
              return this.history.generation == (e || this.cleanGeneration)
            },
            getHistory: function() {
              return {
                done: Un(this.history.done),
                undone: Un(this.history.undone)
              }
            },
            setHistory: function(e) {
              var t = this.history = new On(this.history);
              t.done = Un(e.done.slice(0), null, !0), t.undone = Un(e.undone.slice(0), null, !0)
            },
            setGutterMarker: Us(function(e, t, i) {
              return po(this, e, "gutter", function(e) {
                var r = e.gutterMarkers || (e.gutterMarkers = {});
                return r[t] = i, !i && le(r) && (e.gutterMarkers = null), !0
              })
            }),
            clearGutter: Us(function(e) {
              var t = this;
              this.iter(function(i) {
                i.gutterMarkers && i.gutterMarkers[e] && po(t, i, "gutter", function() {
                  return i.gutterMarkers[e] = null, le(i.gutterMarkers) && (i.gutterMarkers = null), !0
                })
              })
            }),
            lineInfo: function(e) {
              var t;
              if ("number" == typeof e) {
                if (!lt(this, e)) return null;
                if (t = e, !(e = it(this, e))) return null
              } else if (null == (t = ot(e))) return null;
              return {
                line: t,
                handle: e,
                text: e.text,
                gutterMarkers: e.gutterMarkers,
                textClass: e.textClass,
                bgClass: e.bgClass,
                wrapClass: e.wrapClass,
                widgets: e.widgets
              }
            },
            addLineClass: Us(function(e, t, i) {
              return po(this, e, "gutter" == t ? "gutter" : "class", function(e) {
                var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass";
                if (e[r]) {
                  if (I(i).test(e[r])) return !1;
                  e[r] += " " + i
                } else e[r] = i;
                return !0
              })
            }),
            removeLineClass: Us(function(e, t, i) {
              return po(this, e, "gutter" == t ? "gutter" : "class", function(e) {
                var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass",
                  s = e[r];
                if (!s) return !1;
                if (null == i) e[r] = null;
                else {
                  var n = s.match(I(i));
                  if (!n) return !1;
                  var o = n.index + n[0].length;
                  e[r] = s.slice(0, n.index) + (n.index && o != s.length ? " " : "") + s.slice(o) || null
                }
                return !0
              })
            }),
            addLineWidget: Us(function(e, t, i) {
              return mo(this, e, t, i)
            }),
            removeLineWidget: function(e) {
              e.clear()
            },
            markText: function(e, t, i) {
              return Ro(this, Tt(this, e), Tt(this, t), i, i && i.type || "range")
            },
            setBookmark: function(e, t) {
              var i = {
                replacedWith: t && (null == t.nodeType ? t.widget : t),
                insertLeft: t && t.insertLeft,
                clearWhenEmpty: !1,
                shared: t && t.shared,
                handleMouseEvents: t && t.handleMouseEvents
              };
              return Ro(this, e = Tt(this, e), e, i, "bookmark")
            },
            findMarksAt: function(e) {
              var t = [],
                i = it(this, (e = Tt(this, e)).line).markedSpans;
              if (i)
                for (var r = 0; r < i.length; ++r) {
                  var s = i[r];
                  (null == s.from || s.from <= e.ch) && (null == s.to || s.to >= e.ch) && t.push(s.marker.parent || s.marker)
                }
              return t
            },
            findMarks: function(e, t, i) {
              e = Tt(this, e), t = Tt(this, t);
              var r = [],
                s = e.line;
              return this.iter(e.line, t.line + 1, function(n) {
                var o = n.markedSpans;
                if (o)
                  for (var a = 0; a < o.length; a++) {
                    var l = o[a];
                    null != l.to && s == e.line && e.ch >= l.to || null == l.from && s != e.line || null != l.from && s == t.line && l.from >= t.ch || i && !i(l.marker) || r.push(l.marker.parent || l.marker)
                  }++s
              }), r
            },
            getAllMarks: function() {
              var e = [];
              return this.iter(function(t) {
                var i = t.markedSpans;
                if (i)
                  for (var r = 0; r < i.length; ++r) null != i[r].from && e.push(i[r].marker)
              }), e
            },
            posFromIndex: function(e) {
              var t, i = this.first,
                r = this.lineSeparator().length;
              return this.iter(function(s) {
                var n = s.text.length + r;
                if (n > e) return t = e, !0;
                e -= n, ++i
              }), Tt(this, ht(i, t))
            },
            indexFromPos: function(e) {
              var t = (e = Tt(this, e)).ch;
              if (e.line < this.first || e.ch < 0) return 0;
              var i = this.lineSeparator().length;
              return this.iter(this.first, e.line, function(e) {
                t += e.text.length + i
              }), t
            },
            copy: function(e) {
              var t = new _o(st(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
              return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t
            },
            linkedDoc: function(e) {
              e || (e = {});
              var t = this.first,
                i = this.first + this.size;
              null != e.from && e.from > t && (t = e.from), null != e.to && e.to < i && (i = e.to);
              var r = new _o(st(this, t, i), e.mode || this.modeOption, t, this.lineSep, this.direction);
              return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({
                doc: r,
                sharedHist: e.sharedHist
              }), r.linked = [{
                doc: this,
                isParent: !0,
                sharedHist: e.sharedHist
              }], Io(r, No(this)), r
            },
            unlinkDoc: function(e) {
              if (e instanceof Va && (e = e.doc), this.linked)
                for (var t = 0; t < this.linked.length; ++t)
                  if (this.linked[t].doc == e) {
                    this.linked.splice(t, 1), e.unlinkDoc(this), Oo(No(this));
                    break
                  } if (e.history == this.history) {
                var i = [e.id];
                An(e, function(e) {
                  return i.push(e.id)
                }, !0), e.history = new On(null), e.history.done = Un(this.history.done, i), e.history.undone = Un(this.history.undone, i)
              }
            },
            iterLinkedDocs: function(e) {
              An(this, e)
            },
            getMode: function() {
              return this.mode
            },
            getEditor: function() {
              return this.cm
            },
            splitLines: function(e) {
              return this.lineSep ? e.split(this.lineSep) : He(e)
            },
            lineSeparator: function() {
              return this.lineSep || "\n"
            },
            setDirection: Us(function(e) {
              "rtl" != e && (e = "ltr"), e != this.direction && (this.direction = e, this.iter(function(e) {
                return e.order = null
              }), this.cm && In(this.cm))
            })
          }), _o.prototype.eachLine = _o.prototype.iter;
          var yo = 0;

          function wo(e) {
            var t = this;
            if (bo(t), !ve(t, e) && !$i(t.display, e)) {
              Le(e), o && (yo = +new Date);
              var i = Hr(t, e, !0),
                r = e.dataTransfer.files;
              if (i && !t.isReadOnly())
                if (r && r.length && window.FileReader && window.File)
                  for (var s = r.length, n = Array(s), a = 0, l = function() {
                      ++a == s && xs(t, function() {
                        var e = {
                          from: i = Tt(t.doc, i),
                          to: i,
                          text: t.doc.splitLines(n.filter(function(e) {
                            return null != e
                          }).join(t.doc.lineSeparator())),
                          origin: "paste"
                        };
                        io(t.doc, e), Kn(t.doc, dn(Tt(t.doc, i), Tt(t.doc, pn(e))))
                      })()
                    }, c = function(e, i) {
                      if (t.options.allowDropFileTypes && -1 == K(t.options.allowDropFileTypes, e.type)) l();
                      else {
                        var r = new FileReader;
                        r.onerror = function() {
                          return l()
                        }, r.onload = function() {
                          var e = r.result;
                          /[\x00-\x08\x0e-\x1f]{2}/.test(e) || (n[i] = e), l()
                        }, r.readAsText(e)
                      }
                    }, h = 0; h < r.length; h++) c(r[h], h);
                else {
                  if (t.state.draggingText && t.doc.sel.contains(i) > -1) return t.state.draggingText(e), void setTimeout(function() {
                    return t.display.input.focus()
                  }, 20);
                  try {
                    var u = e.dataTransfer.getData("Text");
                    if (u) {
                      var d;
                      if (t.state.draggingText && !t.state.draggingText.copy && (d = t.listSelections()), zn(t.doc, dn(i, i)), d)
                        for (var p = 0; p < d.length; ++p) lo(t.doc, "", d[p].anchor, d[p].head, "drag");
                      t.replaceSelection(u, "around", "paste"), t.display.input.focus()
                    }
                  } catch (e) {}
                }
            }
          }

          function Do(e, t) {
            if (o && (!e.state.draggingText || +new Date - yo < 100)) we(t);
            else if (!ve(e, t) && !$i(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !p)) {
              var i = w("img", null, null, "position: fixed; left: 0; top: 0;");
              i.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", d && (i.width = i.height = 1, e.display.wrapper.appendChild(i), i._top = i.offsetTop), t.dataTransfer.setDragImage(i, 0, 0), d && i.parentNode.removeChild(i)
            }
          }

          function Po(e, t) {
            var i = Hr(e, t);
            if (i) {
              var r = document.createDocumentFragment();
              jr(e, i, r), e.display.dragCursor || (e.display.dragCursor = w("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), y(e.display.dragCursor, r)
            }
          }

          function bo(e) {
            e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null)
          }

          function Mo(e) {
            if (document.getElementsByClassName) {
              for (var t = document.getElementsByClassName("CodeMirror"), i = [], r = 0; r < t.length; r++) {
                var s = t[r].CodeMirror;
                s && i.push(s)
              }
              i.length && i[0].operation(function() {
                for (var t = 0; t < i.length; t++) e(i[t])
              })
            }
          }
          var Fo = !1;

          function xo() {
            Fo || (Go(), Fo = !0)
          }

          function Go() {
            var e;
            Ce(window, "resize", function() {
              null == e && (e = setTimeout(function() {
                e = null, Mo(Uo)
              }, 100))
            }), Ce(window, "blur", function() {
              return Mo(is)
            })
          }

          function Uo(e) {
            var t = e.display;
            t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize()
          }
          for (var Ho = {
              3: "Pause",
              8: "Backspace",
              9: "Tab",
              13: "Enter",
              16: "Shift",
              17: "Ctrl",
              18: "Alt",
              19: "Pause",
              20: "CapsLock",
              27: "Esc",
              32: "Space",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "Left",
              38: "Up",
              39: "Right",
              40: "Down",
              44: "PrintScrn",
              45: "Insert",
              46: "Delete",
              59: ";",
              61: "=",
              91: "Mod",
              92: "Mod",
              93: "Mod",
              106: "*",
              107: "=",
              109: "-",
              110: ".",
              111: "/",
              145: "ScrollLock",
              173: "-",
              186: ";",
              187: "=",
              188: ",",
              189: "-",
              190: ".",
              191: "/",
              192: "`",
              219: "[",
              220: "\\",
              221: "]",
              222: "'",
              224: "Mod",
              63232: "Up",
              63233: "Down",
              63234: "Left",
              63235: "Right",
              63272: "Delete",
              63273: "Home",
              63275: "End",
              63276: "PageUp",
              63277: "PageDown",
              63302: "Insert"
            }, ko = 0; ko < 10; ko++) Ho[ko + 48] = Ho[ko + 96] = String(ko);
          for (var Bo = 65; Bo <= 90; Bo++) Ho[Bo] = String.fromCharCode(Bo);
          for (var Vo = 1; Vo <= 12; Vo++) Ho[Vo + 111] = Ho[Vo + 63235] = "F" + Vo;
          var Wo = {};

          function Yo(e) {
            var t, i, r, s, n = e.split(/-(?!$)/);
            e = n[n.length - 1];
            for (var o = 0; o < n.length - 1; o++) {
              var a = n[o];
              if (/^(cmd|meta|m)$/i.test(a)) s = !0;
              else if (/^a(lt)?$/i.test(a)) t = !0;
              else if (/^(c|ctrl|control)$/i.test(a)) i = !0;
              else {
                if (!/^s(hift)?$/i.test(a)) throw new Error("Unrecognized modifier name: " + a);
                r = !0
              }
            }
            return t && (e = "Alt-" + e), i && (e = "Ctrl-" + e), s && (e = "Cmd-" + e), r && (e = "Shift-" + e), e
          }

          function Ko(e) {
            var t = {};
            for (var i in e)
              if (e.hasOwnProperty(i)) {
                var r = e[i];
                if (/^(name|fallthrough|(de|at)tach)$/.test(i)) continue;
                if ("..." == r) {
                  delete e[i];
                  continue
                }
                for (var s = te(i.split(" "), Yo), n = 0; n < s.length; n++) {
                  var o = void 0,
                    a = void 0;
                  n == s.length - 1 ? (a = s.join(" "), o = r) : (a = s.slice(0, n + 1).join(" "), o = "...");
                  var l = t[a];
                  if (l) {
                    if (l != o) throw new Error("Inconsistent bindings for " + a)
                  } else t[a] = o
                }
                delete e[i]
              } for (var c in t) e[c] = t[c];
            return e
          }

          function Xo(e, t, i, r) {
            var s = (t = Jo(t)).call ? t.call(e, r) : t[e];
            if (!1 === s) return "nothing";
            if ("..." === s) return "multi";
            if (null != s && i(s)) return "handled";
            if (t.fallthrough) {
              if ("[object Array]" != Object.prototype.toString.call(t.fallthrough)) return Xo(e, t.fallthrough, i, r);
              for (var n = 0; n < t.fallthrough.length; n++) {
                var o = Xo(e, t.fallthrough[n], i, r);
                if (o) return o
              }
            }
          }

          function zo(e) {
            var t = "string" == typeof e ? e : Ho[e.keyCode];
            return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
          }

          function $o(e, t, i) {
            var r = e;
            return t.altKey && "Alt" != r && (e = "Alt-" + e), (v ? t.metaKey : t.ctrlKey) && "Ctrl" != r && (e = "Ctrl-" + e), (v ? t.ctrlKey : t.metaKey) && "Mod" != r && (e = "Cmd-" + e), !i && t.shiftKey && "Shift" != r && (e = "Shift-" + e), e
          }

          function jo(e, t) {
            if (d && 34 == e.keyCode && e.char) return !1;
            var i = Ho[e.keyCode];
            return null != i && !e.altGraphKey && (3 == e.keyCode && e.code && (i = e.code), $o(i, e, t))
          }

          function Jo(e) {
            return "string" == typeof e ? Wo[e] : e
          }

          function qo(e, t) {
            for (var i = e.doc.sel.ranges, r = [], s = 0; s < i.length; s++) {
              for (var n = t(i[s]); r.length && ut(n.from, ee(r).to) <= 0;) {
                var o = r.pop();
                if (ut(o.from, n.from) < 0) {
                  n.from = o.from;
                  break
                }
              }
              r.push(n)
            }
            Fs(e, function() {
              for (var t = r.length - 1; t >= 0; t--) lo(e.doc, "", r[t].from, r[t].to, "+delete");
              us(e)
            })
          }

          function Qo(e, t, i) {
            var r = ue(e.text, t + i, i);
            return r < 0 || r > e.text.length ? null : r
          }

          function Zo(e, t, i) {
            var r = Qo(e, t.ch, i);
            return null == r ? null : new ht(t.line, r, i < 0 ? "after" : "before")
          }

          function ea(e, t, i, r, s) {
            if (e) {
              "rtl" == t.doc.direction && (s = -s);
              var n = Te(i, t.doc.direction);
              if (n) {
                var o, a = s < 0 ? ee(n) : n[0],
                  l = s < 0 == (1 == a.level) ? "after" : "before";
                if (a.level > 0 || "rtl" == t.doc.direction) {
                  var c = or(t, i);
                  o = s < 0 ? i.text.length - 1 : 0;
                  var h = ar(t, c, o).top;
                  o = de(function(e) {
                    return ar(t, c, e).top == h
                  }, s < 0 == (1 == a.level) ? a.from : a.to - 1, o), "before" == l && (o = Qo(i, o, 1))
                } else o = s < 0 ? a.to : a.from;
                return new ht(r, o, l)
              }
            }
            return new ht(r, s < 0 ? i.text.length : 0, s < 0 ? "before" : "after")
          }

          function ta(e, t, i, r) {
            var s = Te(t, e.doc.direction);
            if (!s) return Zo(t, i, r);
            i.ch >= t.text.length ? (i.ch = t.text.length, i.sticky = "before") : i.ch <= 0 && (i.ch = 0, i.sticky = "after");
            var n = ge(s, i.ch, i.sticky),
              o = s[n];
            if ("ltr" == e.doc.direction && o.level % 2 == 0 && (r > 0 ? o.to > i.ch : o.from < i.ch)) return Zo(t, i, r);
            var a, l = function(e, i) {
                return Qo(t, e instanceof ht ? e.ch : e, i)
              },
              c = function(i) {
                return e.options.lineWrapping ? (a = a || or(e, t), _r(e, t, a, i)) : {
                  begin: 0,
                  end: t.text.length
                }
              },
              h = c("before" == i.sticky ? l(i, -1) : i.ch);
            if ("rtl" == e.doc.direction || 1 == o.level) {
              var u = 1 == o.level == r < 0,
                d = l(i, u ? 1 : -1);
              if (null != d && (u ? d <= o.to && d <= h.end : d >= o.from && d >= h.begin)) {
                var p = u ? "before" : "after";
                return new ht(i.line, d, p)
              }
            }
            var E = function(e, t, r) {
                for (var n = function(e, t) {
                    return t ? new ht(i.line, l(e, 1), "before") : new ht(i.line, e, "after")
                  }; e >= 0 && e < s.length; e += t) {
                  var o = s[e],
                    a = t > 0 == (1 != o.level),
                    c = a ? r.begin : l(r.end, -1);
                  if (o.from <= c && c < o.to) return n(c, a);
                  if (c = a ? o.from : l(o.to, -1), r.begin <= c && c < r.end) return n(c, a)
                }
              },
              g = E(n + r, r, h);
            if (g) return g;
            var f = r > 0 ? h.end : l(h.begin, -1);
            return null == f || r > 0 && f == t.text.length || !(g = E(r > 0 ? 0 : s.length - 1, r, c(f))) ? null : g
          }
          Wo.basic = {
            Left: "goCharLeft",
            Right: "goCharRight",
            Up: "goLineUp",
            Down: "goLineDown",
            End: "goLineEnd",
            Home: "goLineStartSmart",
            PageUp: "goPageUp",
            PageDown: "goPageDown",
            Delete: "delCharAfter",
            Backspace: "delCharBefore",
            "Shift-Backspace": "delCharBefore",
            Tab: "defaultTab",
            "Shift-Tab": "indentAuto",
            Enter: "newlineAndIndent",
            Insert: "toggleOverwrite",
            Esc: "singleSelection"
          }, Wo.pcDefault = {
            "Ctrl-A": "selectAll",
            "Ctrl-D": "deleteLine",
            "Ctrl-Z": "undo",
            "Shift-Ctrl-Z": "redo",
            "Ctrl-Y": "redo",
            "Ctrl-Home": "goDocStart",
            "Ctrl-End": "goDocEnd",
            "Ctrl-Up": "goLineUp",
            "Ctrl-Down": "goLineDown",
            "Ctrl-Left": "goGroupLeft",
            "Ctrl-Right": "goGroupRight",
            "Alt-Left": "goLineStart",
            "Alt-Right": "goLineEnd",
            "Ctrl-Backspace": "delGroupBefore",
            "Ctrl-Delete": "delGroupAfter",
            "Ctrl-S": "save",
            "Ctrl-F": "find",
            "Ctrl-G": "findNext",
            "Shift-Ctrl-G": "findPrev",
            "Shift-Ctrl-F": "replace",
            "Shift-Ctrl-R": "replaceAll",
            "Ctrl-[": "indentLess",
            "Ctrl-]": "indentMore",
            "Ctrl-U": "undoSelection",
            "Shift-Ctrl-U": "redoSelection",
            "Alt-U": "redoSelection",
            fallthrough: "basic"
          }, Wo.emacsy = {
            "Ctrl-F": "goCharRight",
            "Ctrl-B": "goCharLeft",
            "Ctrl-P": "goLineUp",
            "Ctrl-N": "goLineDown",
            "Ctrl-A": "goLineStart",
            "Ctrl-E": "goLineEnd",
            "Ctrl-V": "goPageDown",
            "Shift-Ctrl-V": "goPageUp",
            "Ctrl-D": "delCharAfter",
            "Ctrl-H": "delCharBefore",
            "Alt-Backspace": "delWordBefore",
            "Ctrl-K": "killLine",
            "Ctrl-T": "transposeChars",
            "Ctrl-O": "openLine"
          }, Wo.macDefault = {
            "Cmd-A": "selectAll",
            "Cmd-D": "deleteLine",
            "Cmd-Z": "undo",
            "Shift-Cmd-Z": "redo",
            "Cmd-Y": "redo",
            "Cmd-Home": "goDocStart",
            "Cmd-Up": "goDocStart",
            "Cmd-End": "goDocEnd",
            "Cmd-Down": "goDocEnd",
            "Alt-Left": "goGroupLeft",
            "Alt-Right": "goGroupRight",
            "Cmd-Left": "goLineLeft",
            "Cmd-Right": "goLineRight",
            "Alt-Backspace": "delGroupBefore",
            "Ctrl-Alt-Backspace": "delGroupAfter",
            "Alt-Delete": "delGroupAfter",
            "Cmd-S": "save",
            "Cmd-F": "find",
            "Cmd-G": "findNext",
            "Shift-Cmd-G": "findPrev",
            "Cmd-Alt-F": "replace",
            "Shift-Cmd-Alt-F": "replaceAll",
            "Cmd-[": "indentLess",
            "Cmd-]": "indentMore",
            "Cmd-Backspace": "delWrappedLineLeft",
            "Cmd-Delete": "delWrappedLineRight",
            "Cmd-U": "undoSelection",
            "Shift-Cmd-U": "redoSelection",
            "Ctrl-Up": "goDocStart",
            "Ctrl-Down": "goDocEnd",
            fallthrough: ["basic", "emacsy"]
          }, Wo.default = C ? Wo.macDefault : Wo.pcDefault;
          var ia = {
            selectAll: eo,
            singleSelection: function(e) {
              return e.setSelection(e.getCursor("anchor"), e.getCursor("head"), $)
            },
            killLine: function(e) {
              return qo(e, function(t) {
                if (t.empty()) {
                  var i = it(e.doc, t.head.line).text.length;
                  return t.head.ch == i && t.head.line < e.lastLine() ? {
                    from: t.head,
                    to: ht(t.head.line + 1, 0)
                  } : {
                    from: t.head,
                    to: ht(t.head.line, i)
                  }
                }
                return {
                  from: t.from(),
                  to: t.to()
                }
              })
            },
            deleteLine: function(e) {
              return qo(e, function(t) {
                return {
                  from: ht(t.from().line, 0),
                  to: Tt(e.doc, ht(t.to().line + 1, 0))
                }
              })
            },
            delLineLeft: function(e) {
              return qo(e, function(e) {
                return {
                  from: ht(e.from().line, 0),
                  to: e.from()
                }
              })
            },
            delWrappedLineLeft: function(e) {
              return qo(e, function(t) {
                var i = e.charCoords(t.head, "div").top + 5;
                return {
                  from: e.coordsChar({
                    left: 0,
                    top: i
                  }, "div"),
                  to: t.from()
                }
              })
            },
            delWrappedLineRight: function(e) {
              return qo(e, function(t) {
                var i = e.charCoords(t.head, "div").top + 5,
                  r = e.coordsChar({
                    left: e.display.lineDiv.offsetWidth + 100,
                    top: i
                  }, "div");
                return {
                  from: t.from(),
                  to: r
                }
              })
            },
            undo: function(e) {
              return e.undo()
            },
            redo: function(e) {
              return e.redo()
            },
            undoSelection: function(e) {
              return e.undoSelection()
            },
            redoSelection: function(e) {
              return e.redoSelection()
            },
            goDocStart: function(e) {
              return e.extendSelection(ht(e.firstLine(), 0))
            },
            goDocEnd: function(e) {
              return e.extendSelection(ht(e.lastLine()))
            },
            goLineStart: function(e) {
              return e.extendSelectionsBy(function(t) {
                return ra(e, t.head.line)
              }, {
                origin: "+move",
                bias: 1
              })
            },
            goLineStartSmart: function(e) {
              return e.extendSelectionsBy(function(t) {
                return na(e, t.head)
              }, {
                origin: "+move",
                bias: 1
              })
            },
            goLineEnd: function(e) {
              return e.extendSelectionsBy(function(t) {
                return sa(e, t.head.line)
              }, {
                origin: "+move",
                bias: -1
              })
            },
            goLineRight: function(e) {
              return e.extendSelectionsBy(function(t) {
                var i = e.cursorCoords(t.head, "div").top + 5;
                return e.coordsChar({
                  left: e.display.lineDiv.offsetWidth + 100,
                  top: i
                }, "div")
              }, J)
            },
            goLineLeft: function(e) {
              return e.extendSelectionsBy(function(t) {
                var i = e.cursorCoords(t.head, "div").top + 5;
                return e.coordsChar({
                  left: 0,
                  top: i
                }, "div")
              }, J)
            },
            goLineLeftSmart: function(e) {
              return e.extendSelectionsBy(function(t) {
                var i = e.cursorCoords(t.head, "div").top + 5,
                  r = e.coordsChar({
                    left: 0,
                    top: i
                  }, "div");
                return r.ch < e.getLine(r.line).search(/\S/) ? na(e, t.head) : r
              }, J)
            },
            goLineUp: function(e) {
              return e.moveV(-1, "line")
            },
            goLineDown: function(e) {
              return e.moveV(1, "line")
            },
            goPageUp: function(e) {
              return e.moveV(-1, "page")
            },
            goPageDown: function(e) {
              return e.moveV(1, "page")
            },
            goCharLeft: function(e) {
              return e.moveH(-1, "char")
            },
            goCharRight: function(e) {
              return e.moveH(1, "char")
            },
            goColumnLeft: function(e) {
              return e.moveH(-1, "column")
            },
            goColumnRight: function(e) {
              return e.moveH(1, "column")
            },
            goWordLeft: function(e) {
              return e.moveH(-1, "word")
            },
            goGroupRight: function(e) {
              return e.moveH(1, "group")
            },
            goGroupLeft: function(e) {
              return e.moveH(-1, "group")
            },
            goWordRight: function(e) {
              return e.moveH(1, "word")
            },
            delCharBefore: function(e) {
              return e.deleteH(-1, "codepoint")
            },
            delCharAfter: function(e) {
              return e.deleteH(1, "char")
            },
            delWordBefore: function(e) {
              return e.deleteH(-1, "word")
            },
            delWordAfter: function(e) {
              return e.deleteH(1, "word")
            },
            delGroupBefore: function(e) {
              return e.deleteH(-1, "group")
            },
            delGroupAfter: function(e) {
              return e.deleteH(1, "group")
            },
            indentAuto: function(e) {
              return e.indentSelection("smart")
            },
            indentMore: function(e) {
              return e.indentSelection("add")
            },
            indentLess: function(e) {
              return e.indentSelection("subtract")
            },
            insertTab: function(e) {
              return e.replaceSelection("\t")
            },
            insertSoftTab: function(e) {
              for (var t = [], i = e.listSelections(), r = e.options.tabSize, s = 0; s < i.length; s++) {
                var n = i[s].from(),
                  o = W(e.getLine(n.line), n.ch, r);
                t.push(Z(r - o % r))
              }
              e.replaceSelections(t)
            },
            defaultTab: function(e) {
              e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab")
            },
            transposeChars: function(e) {
              return Fs(e, function() {
                for (var t = e.listSelections(), i = [], r = 0; r < t.length; r++)
                  if (t[r].empty()) {
                    var s = t[r].head,
                      n = it(e.doc, s.line).text;
                    if (n)
                      if (s.ch == n.length && (s = new ht(s.line, s.ch - 1)), s.ch > 0) s = new ht(s.line, s.ch + 1), e.replaceRange(n.charAt(s.ch - 1) + n.charAt(s.ch - 2), ht(s.line, s.ch - 2), s, "+transpose");
                      else if (s.line > e.doc.first) {
                      var o = it(e.doc, s.line - 1).text;
                      o && (s = new ht(s.line, 1), e.replaceRange(n.charAt(0) + e.doc.lineSeparator() + o.charAt(o.length - 1), ht(s.line - 1, o.length - 1), s, "+transpose"))
                    }
                    i.push(new hn(s, s))
                  } e.setSelections(i)
              })
            },
            newlineAndIndent: function(e) {
              return Fs(e, function() {
                for (var t = e.listSelections(), i = t.length - 1; i >= 0; i--) e.replaceRange(e.doc.lineSeparator(), t[i].anchor, t[i].head, "+input");
                t = e.listSelections();
                for (var r = 0; r < t.length; r++) e.indentLine(t[r].from().line, null, !0);
                us(e)
              })
            },
            openLine: function(e) {
              return e.replaceSelection("\n", "start")
            },
            toggleOverwrite: function(e) {
              return e.toggleOverwrite()
            }
          };

          function ra(e, t) {
            var i = it(e.doc, t),
              r = ri(i);
            return r != i && (t = ot(r)), ea(!0, e, r, t, 1)
          }

          function sa(e, t) {
            var i = it(e.doc, t),
              r = si(i);
            return r != i && (t = ot(r)), ea(!0, e, i, t, -1)
          }

          function na(e, t) {
            var i = ra(e, t.line),
              r = it(e.doc, i.line),
              s = Te(r, e.doc.direction);
            if (!s || 0 == s[0].level) {
              var n = Math.max(i.ch, r.text.search(/\S/)),
                o = t.line == i.line && t.ch <= n && t.ch;
              return ht(i.line, o ? 0 : n, i.sticky)
            }
            return i
          }

          function oa(e, t, i) {
            if ("string" == typeof t && !(t = ia[t])) return !1;
            e.display.input.ensurePolled();
            var r = e.display.shift,
              s = !1;
            try {
              e.isReadOnly() && (e.state.suppressEdits = !0), i && (e.display.shift = !1), s = t(e) != z
            } finally {
              e.display.shift = r, e.state.suppressEdits = !1
            }
            return s
          }

          function aa(e, t, i) {
            for (var r = 0; r < e.state.keyMaps.length; r++) {
              var s = Xo(t, e.state.keyMaps[r], i, e);
              if (s) return s
            }
            return e.options.extraKeys && Xo(t, e.options.extraKeys, i, e) || Xo(t, e.options.keyMap, i, e)
          }
          var la = new Y;

          function ca(e, t, i, r) {
            var s = e.state.keySeq;
            if (s) {
              if (zo(t)) return "handled";
              if (/\'$/.test(t) ? e.state.keySeq = null : la.set(50, function() {
                  e.state.keySeq == s && (e.state.keySeq = null, e.display.input.reset())
                }), ha(e, s + " " + t, i, r)) return !0
            }
            return ha(e, t, i, r)
          }

          function ha(e, t, i, r) {
            var s = aa(e, t, r);
            return "multi" == s && (e.state.keySeq = t), "handled" == s && bi(e, "keyHandled", e, t, i), "handled" != s && "multi" != s || (Le(i), Qr(e)), !!s
          }

          function ua(e, t) {
            var i = jo(t, !0);
            return !!i && (t.shiftKey && !e.state.keySeq ? ca(e, "Shift-" + i, t, function(t) {
              return oa(e, t, !0)
            }) || ca(e, i, t, function(t) {
              if ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion) return oa(e, t)
            }) : ca(e, i, t, function(t) {
              return oa(e, t)
            }))
          }

          function da(e, t, i) {
            return ca(e, "'" + i + "'", t, function(t) {
              return oa(e, t, !0)
            })
          }
          var pa = null;

          function Ea(e) {
            var t = this;
            if (!(e.target && e.target != t.display.input.getField() || (t.curOp.focus = b(U(t)), ve(t, e)))) {
              o && a < 11 && 27 == e.keyCode && (e.returnValue = !1);
              var r = e.keyCode;
              t.display.shift = 16 == r || e.shiftKey;
              var s = ua(t, e);
              d && (pa = s ? r : null, s || 88 != r || Be || !(C ? e.metaKey : e.ctrlKey) || t.replaceSelection("", null, "cut")), i && !C && !s && 46 == r && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"), 18 != r || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || ga(t)
            }
          }

          function ga(e) {
            var t = e.display.lineDiv;

            function i(e) {
              18 != e.keyCode && e.altKey || (L(t, "CodeMirror-crosshair"), Re(document, "keyup", i), Re(document, "mouseover", i))
            }
            M(t, "CodeMirror-crosshair"), Ce(document, "keyup", i), Ce(document, "mouseover", i)
          }

          function fa(e) {
            16 == e.keyCode && (this.doc.sel.shift = !1), ve(this, e)
          }

          function Ta(e) {
            var t = this;
            if (!(e.target && e.target != t.display.input.getField() || $i(t.display, e) || ve(t, e) || e.ctrlKey && !e.altKey || C && e.metaKey)) {
              var i = e.keyCode,
                r = e.charCode;
              if (d && i == pa) return pa = null, void Le(e);
              if (!d || e.which && !(e.which < 10) || !ua(t, e)) {
                var s = String.fromCharCode(null == r ? i : r);
                "\b" != s && (da(t, e, s) || t.display.input.onKeyPress(e))
              }
            }
          }
          var ma, Ca, Sa = 400,
            Ra = function(e, t, i) {
              this.time = e, this.pos = t, this.button = i
            };

          function Aa(e, t) {
            var i = +new Date;
            return Ca && Ca.compare(i, e, t) ? (ma = Ca = null, "triple") : ma && ma.compare(i, e, t) ? (Ca = new Ra(i, e, t), ma = null, "double") : (ma = new Ra(i, e, t), Ca = null, "single")
          }

          function va(e) {
            var t = this,
              i = t.display;
            if (!(ve(t, e) || i.activeTouch && i.input.supportsTouch()))
              if (i.input.ensurePolled(), i.shift = e.shiftKey, $i(i, e)) l || (i.scroller.draggable = !1, setTimeout(function() {
                return i.scroller.draggable = !0
              }, 100));
              else if (!Pa(t, e)) {
              var r = Hr(t, e),
                s = Pe(e),
                n = r ? Aa(r, s) : "single";
              k(t).focus(), 1 == s && t.state.selectingText && t.state.selectingText(e), r && Na(t, s, r, n, e) || (1 == s ? r ? Oa(t, r, n, e) : De(e) == i.scroller && Le(e) : 2 == s ? (r && kn(t.doc, r), setTimeout(function() {
                return i.input.focus()
              }, 20)) : 3 == s && (N ? t.display.input.onContextMenu(e) : es(t)))
            }
          }

          function Na(e, t, i, r, s) {
            var n = "Click";
            return "double" == r ? n = "Double" + n : "triple" == r && (n = "Triple" + n), ca(e, $o(n = (1 == t ? "Left" : 2 == t ? "Middle" : "Right") + n, s), s, function(t) {
              if ("string" == typeof t && (t = ia[t]), !t) return !1;
              var r = !1;
              try {
                e.isReadOnly() && (e.state.suppressEdits = !0), r = t(e, i) != z
              } finally {
                e.state.suppressEdits = !1
              }
              return r
            })
          }

          function Ia(e, t, i) {
            var r = e.getOption("configureMouse"),
              s = r ? r(e, t, i) : {};
            if (null == s.unit) {
              var n = S ? i.shiftKey && i.metaKey : i.altKey;
              s.unit = n ? "rectangle" : "single" == t ? "char" : "double" == t ? "word" : "line"
            }
            return (null == s.extend || e.doc.extend) && (s.extend = e.doc.extend || i.shiftKey), null == s.addNew && (s.addNew = C ? i.metaKey : i.ctrlKey), null == s.moveOnDrag && (s.moveOnDrag = !(C ? i.altKey : i.ctrlKey)), s
          }

          function Oa(e, t, i, r) {
            o ? setTimeout(B(Zr, e), 0) : e.curOp.focus = b(U(e));
            var s, n = Ia(e, i, r),
              a = e.doc.sel;
            e.options.dragDrop && Fe && !e.isReadOnly() && "single" == i && (s = a.contains(t)) > -1 && (ut((s = a.ranges[s]).from(), t) < 0 || t.xRel > 0) && (ut(s.to(), t) > 0 || t.xRel < 0) ? La(e, r, t, n) : ya(e, r, t, n)
          }

          function La(e, t, i, r) {
            var s = e.display,
              n = !1,
              c = xs(e, function(t) {
                l && (s.scroller.draggable = !1), e.state.draggingText = !1, e.state.delayingBlurEvent && (e.hasFocus() ? e.state.delayingBlurEvent = !1 : es(e)), Re(s.wrapper.ownerDocument, "mouseup", c), Re(s.wrapper.ownerDocument, "mousemove", h), Re(s.scroller, "dragstart", u), Re(s.scroller, "drop", c), n || (Le(t), r.addNew || kn(e.doc, i, null, null, r.extend), l && !p || o && 9 == a ? setTimeout(function() {
                  s.wrapper.ownerDocument.body.focus({
                    preventScroll: !0
                  }), s.input.focus()
                }, 20) : s.input.focus())
              }),
              h = function(e) {
                n = n || Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) >= 10
              },
              u = function() {
                return n = !0
              };
            l && (s.scroller.draggable = !0), e.state.draggingText = c, c.copy = !r.moveOnDrag, Ce(s.wrapper.ownerDocument, "mouseup", c), Ce(s.wrapper.ownerDocument, "mousemove", h), Ce(s.scroller, "dragstart", u), Ce(s.scroller, "drop", c), e.state.delayingBlurEvent = !0, setTimeout(function() {
              return s.input.focus()
            }, 20), s.scroller.dragDrop && s.scroller.dragDrop()
          }

          function _a(e, t, i) {
            if ("char" == i) return new hn(t, t);
            if ("word" == i) return e.findWordAt(t);
            if ("line" == i) return new hn(ht(t.line, 0), Tt(e.doc, ht(t.line + 1, 0)));
            var r = i(e, t);
            return new hn(r.from, r.to)
          }

          function ya(e, t, i, r) {
            o && es(e);
            var s = e.display,
              n = e.doc;
            Le(t);
            var a, l, c = n.sel,
              h = c.ranges;
            if (r.addNew && !r.extend ? (l = n.sel.contains(i), a = l > -1 ? h[l] : new hn(i, i)) : (a = n.sel.primary(), l = n.sel.primIndex), "rectangle" == r.unit) r.addNew || (a = new hn(i, i)), i = Hr(e, t, !0, !0), l = -1;
            else {
              var u = _a(e, i, r.unit);
              a = r.extend ? Hn(a, u.anchor, u.head, r.extend) : u
            }
            r.addNew ? -1 == l ? (l = h.length, Xn(n, un(e, h.concat([a]), l), {
              scroll: !1,
              origin: "*mouse"
            })) : h.length > 1 && h[l].empty() && "char" == r.unit && !r.extend ? (Xn(n, un(e, h.slice(0, l).concat(h.slice(l + 1)), 0), {
              scroll: !1,
              origin: "*mouse"
            }), c = n.sel) : Vn(n, l, a, j) : (l = 0, Xn(n, new cn([a], 0), j), c = n.sel);
            var d = i;

            function p(t) {
              if (0 != ut(d, t))
                if (d = t, "rectangle" == r.unit) {
                  for (var s = [], o = e.options.tabSize, h = W(it(n, i.line).text, i.ch, o), u = W(it(n, t.line).text, t.ch, o), p = Math.min(h, u), E = Math.max(h, u), g = Math.min(i.line, t.line), f = Math.min(e.lastLine(), Math.max(i.line, t.line)); g <= f; g++) {
                    var T = it(n, g).text,
                      m = q(T, p, o);
                    p == E ? s.push(new hn(ht(g, m), ht(g, m))) : T.length > m && s.push(new hn(ht(g, m), ht(g, q(T, E, o))))
                  }
                  s.length || s.push(new hn(i, i)), Xn(n, un(e, c.ranges.slice(0, l).concat(s), l), {
                    origin: "*mouse",
                    scroll: !1
                  }), e.scrollIntoView(t)
                } else {
                  var C, S = a,
                    R = _a(e, t, r.unit),
                    A = S.anchor;
                  ut(R.anchor, A) > 0 ? (C = R.head, A = gt(S.from(), R.anchor)) : (C = R.anchor, A = Et(S.to(), R.head));
                  var v = c.ranges.slice(0);
                  v[l] = wa(e, new hn(Tt(n, A), C)), Xn(n, un(e, v, l), j)
                }
            }
            var E = s.wrapper.getBoundingClientRect(),
              g = 0;

            function f(t) {
              var i = ++g,
                o = Hr(e, t, !0, "rectangle" == r.unit);
              if (o)
                if (0 != ut(o, d)) {
                  e.curOp.focus = b(U(e)), p(o);
                  var a = ns(s, n);
                  (o.line >= a.to || o.line < a.from) && setTimeout(xs(e, function() {
                    g == i && f(t)
                  }), 150)
                } else {
                  var l = t.clientY < E.top ? -20 : t.clientY > E.bottom ? 20 : 0;
                  l && setTimeout(xs(e, function() {
                    g == i && (s.scroller.scrollTop += l, f(t))
                  }), 50)
                }
            }

            function T(t) {
              e.state.selectingText = !1, g = 1 / 0, t && (Le(t), s.input.focus()), Re(s.wrapper.ownerDocument, "mousemove", m), Re(s.wrapper.ownerDocument, "mouseup", C), n.history.lastSelOrigin = null
            }
            var m = xs(e, function(e) {
                0 !== e.buttons && Pe(e) ? f(e) : T(e)
              }),
              C = xs(e, T);
            e.state.selectingText = C, Ce(s.wrapper.ownerDocument, "mousemove", m), Ce(s.wrapper.ownerDocument, "mouseup", C)
          }

          function wa(e, t) {
            var i = t.anchor,
              r = t.head,
              s = it(e.doc, i.line);
            if (0 == ut(i, r) && i.sticky == r.sticky) return t;
            var n = Te(s);
            if (!n) return t;
            var o = ge(n, i.ch, i.sticky),
              a = n[o];
            if (a.from != i.ch && a.to != i.ch) return t;
            var l, c = o + (a.from == i.ch == (1 != a.level) ? 0 : 1);
            if (0 == c || c == n.length) return t;
            if (r.line != i.line) l = (r.line - i.line) * ("ltr" == e.doc.direction ? 1 : -1) > 0;
            else {
              var h = ge(n, r.ch, r.sticky),
                u = h - o || (r.ch - i.ch) * (1 == a.level ? -1 : 1);
              l = h == c - 1 || h == c ? u < 0 : u > 0
            }
            var d = n[c + (l ? -1 : 0)],
              p = l == (1 == d.level),
              E = p ? d.from : d.to,
              g = p ? "after" : "before";
            return i.ch == E && i.sticky == g ? t : new hn(new ht(i.line, E, g), r)
          }

          function Da(e, t, i, r) {
            var s, n;
            if (t.touches) s = t.touches[0].clientX, n = t.touches[0].clientY;
            else try {
              s = t.clientX, n = t.clientY
            } catch (e) {
              return !1
            }
            if (s >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1;
            r && Le(t);
            var o = e.display,
              a = o.lineDiv.getBoundingClientRect();
            if (n > a.bottom || !Ie(e, i)) return ye(t);
            n -= a.top - o.viewOffset;
            for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
              var c = o.gutters.childNodes[l];
              if (c && c.getBoundingClientRect().right >= s) return Ae(e, i, e, at(e.doc, n), e.display.gutterSpecs[l].className, t), ye(t)
            }
          }

          function Pa(e, t) {
            return Da(e, t, "gutterClick", !0)
          }

          function ba(e, t) {
            $i(e.display, t) || Ma(e, t) || ve(e, t, "contextmenu") || N || e.display.input.onContextMenu(t)
          }

          function Ma(e, t) {
            return !!Ie(e, "gutterContextMenu") && Da(e, t, "gutterContextMenu", !1)
          }

          function Fa(e) {
            e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), fr(e)
          }
          Ra.prototype.compare = function(e, t, i) {
            return this.time + Sa > e && 0 == ut(t, this.pos) && i == this.button
          };
          var xa = {
              toString: function() {
                return "CodeMirror.Init"
              }
            },
            Ga = {},
            Ua = {};

          function Ha(e) {
            var t = e.optionHandlers;

            function i(i, r, s, n) {
              e.defaults[i] = r, s && (t[i] = n ? function(e, t, i) {
                i != xa && s(e, t, i)
              } : s)
            }
            e.defineOption = i, e.Init = xa, i("value", "", function(e, t) {
              return e.setValue(t)
            }, !0), i("mode", null, function(e, t) {
              e.doc.modeOption = t, mn(e)
            }, !0), i("indentUnit", 2, mn, !0), i("indentWithTabs", !1), i("smartIndent", !0), i("tabSize", 4, function(e) {
              Cn(e), fr(e), Br(e)
            }, !0), i("lineSeparator", null, function(e, t) {
              if (e.doc.lineSep = t, t) {
                var i = [],
                  r = e.doc.first;
                e.doc.iter(function(e) {
                  for (var s = 0;;) {
                    var n = e.text.indexOf(t, s);
                    if (-1 == n) break;
                    s = n + t.length, i.push(ht(r, n))
                  }
                  r++
                });
                for (var s = i.length - 1; s >= 0; s--) lo(e.doc, t, i[s], ht(i[s].line, i[s].ch + t.length))
              }
            }), i("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(e, t, i) {
              e.state.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"), "g"), i != xa && e.refresh()
            }), i("specialCharPlaceholder", Si, function(e) {
              return e.refresh()
            }, !0), i("electricChars", !0), i("inputStyle", m ? "contenteditable" : "textarea", function() {
              throw new Error("inputStyle can not (yet) be changed in a running editor")
            }, !0), i("spellcheck", !1, function(e, t) {
              return e.getInputField().spellcheck = t
            }, !0), i("autocorrect", !1, function(e, t) {
              return e.getInputField().autocorrect = t
            }, !0), i("autocapitalize", !1, function(e, t) {
              return e.getInputField().autocapitalize = t
            }, !0), i("rtlMoveVisually", !R), i("wholeLineUpdateBefore", !0), i("theme", "default", function(e) {
              Fa(e), tn(e)
            }, !0), i("keyMap", "default", function(e, t, i) {
              var r = Jo(t),
                s = i != xa && Jo(i);
              s && s.detach && s.detach(e, r), r.attach && r.attach(e, s || null)
            }), i("extraKeys", null), i("configureMouse", null), i("lineWrapping", !1, Ba, !0), i("gutters", [], function(e, t) {
              e.display.gutterSpecs = Zs(t, e.options.lineNumbers), tn(e)
            }, !0), i("fixedGutter", !0, function(e, t) {
              e.display.gutters.style.left = t ? xr(e.display) + "px" : "0", e.refresh()
            }, !0), i("coverGutterNextToScrollbar", !1, function(e) {
              return As(e)
            }, !0), i("scrollbarStyle", "native", function(e) {
              Is(e), As(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)
            }, !0), i("lineNumbers", !1, function(e, t) {
              e.display.gutterSpecs = Zs(e.options.gutters, t), tn(e)
            }, !0), i("firstLineNumber", 1, tn, !0), i("lineNumberFormatter", function(e) {
              return e
            }, tn, !0), i("showCursorWhenSelecting", !1, zr, !0), i("resetSelectionOnContextMenu", !0), i("lineWiseCopyCut", !0), i("pasteLinesPerSelection", !0), i("selectionsMayTouch", !1), i("readOnly", !1, function(e, t) {
              "nocursor" == t && (is(e), e.display.input.blur()), e.display.input.readOnlyChanged(t)
            }), i("screenReaderLabel", null, function(e, t) {
              t = "" === t ? null : t, e.display.input.screenReaderLabelChanged(t)
            }), i("disableInput", !1, function(e, t) {
              t || e.display.input.reset()
            }, !0), i("dragDrop", !0, ka), i("allowDropFileTypes", null), i("cursorBlinkRate", 530), i("cursorScrollMargin", 0), i("cursorHeight", 1, zr, !0), i("singleCursorHeightPerLine", !0, zr, !0), i("workTime", 100), i("workDelay", 100), i("flattenSpans", !0, Cn, !0), i("addModeClass", !1, Cn, !0), i("pollInterval", 100), i("undoDepth", 200, function(e, t) {
              return e.doc.history.undoDepth = t
            }), i("historyEventDelay", 1250), i("viewportMargin", 10, function(e) {
              return e.refresh()
            }, !0), i("maxHighlightLength", 1e4, Cn, !0), i("moveInputWithCursor", !0, function(e, t) {
              t || e.display.input.resetPosition()
            }), i("tabindex", null, function(e, t) {
              return e.display.input.getField().tabIndex = t || ""
            }), i("autofocus", null), i("direction", "ltr", function(e, t) {
              return e.doc.setDirection(t)
            }, !0), i("phrases", null)
          }

          function ka(e, t, i) {
            if (!t != !(i && i != xa)) {
              var r = e.display.dragFunctions,
                s = t ? Ce : Re;
              s(e.display.scroller, "dragstart", r.start), s(e.display.scroller, "dragenter", r.enter), s(e.display.scroller, "dragover", r.over), s(e.display.scroller, "dragleave", r.leave), s(e.display.scroller, "drop", r.drop)
            }
          }

          function Ba(e) {
            e.options.lineWrapping ? (M(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (L(e.display.wrapper, "CodeMirror-wrap"), di(e)), Ur(e), Br(e), fr(e), setTimeout(function() {
              return As(e)
            }, 100)
          }

          function Va(e, t) {
            var i = this;
            if (!(this instanceof Va)) return new Va(e, t);
            this.options = t = t ? V(t) : {}, V(Ga, t, !1);
            var r = t.value;
            "string" == typeof r ? r = new _o(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;
            var s = new Va.inputStyles[t.inputStyle](this),
              n = this.display = new rn(e, r, s, t);
            for (var c in n.wrapper.CodeMirror = this, Fa(this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Is(this), this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: !1,
                delayingBlurEvent: !1,
                focused: !1,
                suppressEdits: !1,
                pasteIncoming: -1,
                cutIncoming: -1,
                selectingText: !1,
                draggingText: !1,
                highlight: new Y,
                keySeq: null,
                specialChars: null
              }, t.autofocus && !m && n.input.focus(), o && a < 11 && setTimeout(function() {
                return i.display.input.reset(!0)
              }, 20), Wa(this), xo(), Ls(this), this.curOp.forceUpdate = !0, vn(this, r), t.autofocus && !m || this.hasFocus() ? setTimeout(function() {
                i.hasFocus() && !i.state.focused && ts(i)
              }, 20) : is(this), Ua) Ua.hasOwnProperty(c) && Ua[c](this, t[c], xa);
            Qs(this), t.finishInit && t.finishInit(this);
            for (var h = 0; h < Ya.length; ++h) Ya[h](this);
            _s(this), l && t.lineWrapping && "optimizelegibility" == getComputedStyle(n.lineDiv).textRendering && (n.lineDiv.style.textRendering = "auto")
          }

          function Wa(e) {
            var t = e.display;
            Ce(t.scroller, "mousedown", xs(e, va)), Ce(t.scroller, "dblclick", o && a < 11 ? xs(e, function(t) {
              if (!ve(e, t)) {
                var i = Hr(e, t);
                if (i && !Pa(e, t) && !$i(e.display, t)) {
                  Le(t);
                  var r = e.findWordAt(i);
                  kn(e.doc, r.anchor, r.head)
                }
              }
            }) : function(t) {
              return ve(e, t) || Le(t)
            }), Ce(t.scroller, "contextmenu", function(t) {
              return ba(e, t)
            }), Ce(t.input.getField(), "contextmenu", function(i) {
              t.scroller.contains(i.target) || ba(e, i)
            });
            var i, r = {
              end: 0
            };

            function s() {
              t.activeTouch && (i = setTimeout(function() {
                return t.activeTouch = null
              }, 1e3), (r = t.activeTouch).end = +new Date)
            }

            function n(e) {
              if (1 != e.touches.length) return !1;
              var t = e.touches[0];
              return t.radiusX <= 1 && t.radiusY <= 1
            }

            function l(e, t) {
              if (null == t.left) return !0;
              var i = t.left - e.left,
                r = t.top - e.top;
              return i * i + r * r > 400
            }
            Ce(t.scroller, "touchstart", function(s) {
              if (!ve(e, s) && !n(s) && !Pa(e, s)) {
                t.input.ensurePolled(), clearTimeout(i);
                var o = +new Date;
                t.activeTouch = {
                  start: o,
                  moved: !1,
                  prev: o - r.end <= 300 ? r : null
                }, 1 == s.touches.length && (t.activeTouch.left = s.touches[0].pageX, t.activeTouch.top = s.touches[0].pageY)
              }
            }), Ce(t.scroller, "touchmove", function() {
              t.activeTouch && (t.activeTouch.moved = !0)
            }), Ce(t.scroller, "touchend", function(i) {
              var r = t.activeTouch;
              if (r && !$i(t, i) && null != r.left && !r.moved && new Date - r.start < 300) {
                var n, o = e.coordsChar(t.activeTouch, "page");
                n = !r.prev || l(r, r.prev) ? new hn(o, o) : !r.prev.prev || l(r, r.prev.prev) ? e.findWordAt(o) : new hn(ht(o.line, 0), Tt(e.doc, ht(o.line + 1, 0))), e.setSelection(n.anchor, n.head), e.focus(), Le(i)
              }
              s()
            }), Ce(t.scroller, "touchcancel", s), Ce(t.scroller, "scroll", function() {
              t.scroller.clientHeight && (fs(e, t.scroller.scrollTop), ms(e, t.scroller.scrollLeft, !0), Ae(e, "scroll", e))
            }), Ce(t.scroller, "mousewheel", function(t) {
              return ln(e, t)
            }), Ce(t.scroller, "DOMMouseScroll", function(t) {
              return ln(e, t)
            }), Ce(t.wrapper, "scroll", function() {
              return t.wrapper.scrollTop = t.wrapper.scrollLeft = 0
            }), t.dragFunctions = {
              enter: function(t) {
                ve(e, t) || we(t)
              },
              over: function(t) {
                ve(e, t) || (Po(e, t), we(t))
              },
              start: function(t) {
                return Do(e, t)
              },
              drop: xs(e, wo),
              leave: function(t) {
                ve(e, t) || bo(e)
              }
            };
            var c = t.input.getField();
            Ce(c, "keyup", function(t) {
              return fa.call(e, t)
            }), Ce(c, "keydown", xs(e, Ea)), Ce(c, "keypress", xs(e, Ta)), Ce(c, "focus", function(t) {
              return ts(e, t)
            }), Ce(c, "blur", function(t) {
              return is(e, t)
            })
          }
          Va.defaults = Ga, Va.optionHandlers = Ua;
          var Ya = [];

          function Ka(e, t, i, r) {
            var s, n = e.doc;
            null == i && (i = "add"), "smart" == i && (n.mode.indent ? s = Nt(e, t).state : i = "prev");
            var o = e.options.tabSize,
              a = it(n, t),
              l = W(a.text, null, o);
            a.stateAfter && (a.stateAfter = null);
            var c, h = a.text.match(/^\s*/)[0];
            if (r || /\S/.test(a.text)) {
              if ("smart" == i && ((c = n.mode.indent(s, a.text.slice(h.length), a.text)) == z || c > 150)) {
                if (!r) return;
                i = "prev"
              }
            } else c = 0, i = "not";
            "prev" == i ? c = t > n.first ? W(it(n, t - 1).text, null, o) : 0 : "add" == i ? c = l + e.options.indentUnit : "subtract" == i ? c = l - e.options.indentUnit : "number" == typeof i && (c = l + i), c = Math.max(0, c);
            var u = "",
              d = 0;
            if (e.options.indentWithTabs)
              for (var p = Math.floor(c / o); p; --p) d += o, u += "\t";
            if (d < c && (u += Z(c - d)), u != h) return lo(n, u, ht(t, 0), ht(t, h.length), "+input"), a.stateAfter = null, !0;
            for (var E = 0; E < n.sel.ranges.length; E++) {
              var g = n.sel.ranges[E];
              if (g.head.line == t && g.head.ch < h.length) {
                var f = ht(t, h.length);
                Vn(n, E, new hn(f, f));
                break
              }
            }
          }
          Va.defineInitHook = function(e) {
            return Ya.push(e)
          };
          var Xa = null;

          function za(e) {
            Xa = e
          }

          function $a(e, t, i, r, s) {
            var n = e.doc;
            e.display.shift = !1, r || (r = n.sel);
            var o = +new Date - 200,
              a = "paste" == s || e.state.pasteIncoming > o,
              l = He(t),
              c = null;
            if (a && r.ranges.length > 1)
              if (Xa && Xa.text.join("\n") == t) {
                if (r.ranges.length % Xa.text.length == 0) {
                  c = [];
                  for (var h = 0; h < Xa.text.length; h++) c.push(n.splitLines(Xa.text[h]))
                }
              } else l.length == r.ranges.length && e.options.pasteLinesPerSelection && (c = te(l, function(e) {
                return [e]
              }));
            for (var u = e.curOp.updateInput, d = r.ranges.length - 1; d >= 0; d--) {
              var p = r.ranges[d],
                E = p.from(),
                g = p.to();
              p.empty() && (i && i > 0 ? E = ht(E.line, E.ch - i) : e.state.overwrite && !a ? g = ht(g.line, Math.min(it(n, g.line).text.length, g.ch + ee(l).length)) : a && Xa && Xa.lineWise && Xa.text.join("\n") == l.join("\n") && (E = g = ht(E.line, 0)));
              var f = {
                from: E,
                to: g,
                text: c ? c[d % c.length] : l,
                origin: s || (a ? "paste" : e.state.cutIncoming > o ? "cut" : "+input")
              };
              io(e.doc, f), bi(e, "inputRead", e, f)
            }
            t && !a && Ja(e, t), us(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = u), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1
          }

          function ja(e, t) {
            var i = e.clipboardData && e.clipboardData.getData("Text");
            if (i) return e.preventDefault(), t.isReadOnly() || t.options.disableInput || !t.hasFocus() || Fs(t, function() {
              return $a(t, i, 0, null, "paste")
            }), !0
          }

          function Ja(e, t) {
            if (e.options.electricChars && e.options.smartIndent)
              for (var i = e.doc.sel, r = i.ranges.length - 1; r >= 0; r--) {
                var s = i.ranges[r];
                if (!(s.head.ch > 100 || r && i.ranges[r - 1].head.line == s.head.line)) {
                  var n = e.getModeAt(s.head),
                    o = !1;
                  if (n.electricChars) {
                    for (var a = 0; a < n.electricChars.length; a++)
                      if (t.indexOf(n.electricChars.charAt(a)) > -1) {
                        o = Ka(e, s.head.line, "smart");
                        break
                      }
                  } else n.electricInput && n.electricInput.test(it(e.doc, s.head.line).text.slice(0, s.head.ch)) && (o = Ka(e, s.head.line, "smart"));
                  o && bi(e, "electricInput", e, s.head.line)
                }
              }
          }

          function qa(e) {
            for (var t = [], i = [], r = 0; r < e.doc.sel.ranges.length; r++) {
              var s = e.doc.sel.ranges[r].head.line,
                n = {
                  anchor: ht(s, 0),
                  head: ht(s + 1, 0)
                };
              i.push(n), t.push(e.getRange(n.anchor, n.head))
            }
            return {
              text: t,
              ranges: i
            }
          }

          function Qa(e, t, i, r) {
            e.setAttribute("autocorrect", i ? "on" : "off"), e.setAttribute("autocapitalize", r ? "on" : "off"), e.setAttribute("spellcheck", !!t)
          }

          function Za() {
            var e = w("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"),
              t = w("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
            return l ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), f && (e.style.border = "1px solid black"), t
          }

          function el(e) {
            var t = e.optionHandlers,
              i = e.helpers = {};
            e.prototype = {
              constructor: e,
              focus: function() {
                k(this).focus(), this.display.input.focus()
              },
              setOption: function(e, i) {
                var r = this.options,
                  s = r[e];
                r[e] == i && "mode" != e || (r[e] = i, t.hasOwnProperty(e) && xs(this, t[e])(this, i, s), Ae(this, "optionChange", this, e))
              },
              getOption: function(e) {
                return this.options[e]
              },
              getDoc: function() {
                return this.doc
              },
              addKeyMap: function(e, t) {
                this.state.keyMaps[t ? "push" : "unshift"](Jo(e))
              },
              removeKeyMap: function(e) {
                for (var t = this.state.keyMaps, i = 0; i < t.length; ++i)
                  if (t[i] == e || t[i].name == e) return t.splice(i, 1), !0
              },
              addOverlay: Gs(function(t, i) {
                var r = t.token ? t : e.getMode(this.options, t);
                if (r.startState) throw new Error("Overlays may not be stateful.");
                ie(this.state.overlays, {
                  mode: r,
                  modeSpec: t,
                  opaque: i && i.opaque,
                  priority: i && i.priority || 0
                }, function(e) {
                  return e.priority
                }), this.state.modeGen++, Br(this)
              }),
              removeOverlay: Gs(function(e) {
                for (var t = this.state.overlays, i = 0; i < t.length; ++i) {
                  var r = t[i].modeSpec;
                  if (r == e || "string" == typeof e && r.name == e) return t.splice(i, 1), this.state.modeGen++, void Br(this)
                }
              }),
              indentLine: Gs(function(e, t, i) {
                "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), lt(this.doc, e) && Ka(this, e, t, i)
              }),
              indentSelection: Gs(function(e) {
                for (var t = this.doc.sel.ranges, i = -1, r = 0; r < t.length; r++) {
                  var s = t[r];
                  if (s.empty()) s.head.line > i && (Ka(this, s.head.line, e, !0), i = s.head.line, r == this.doc.sel.primIndex && us(this));
                  else {
                    var n = s.from(),
                      o = s.to(),
                      a = Math.max(i, n.line);
                    i = Math.min(this.lastLine(), o.line - (o.ch ? 0 : 1)) + 1;
                    for (var l = a; l < i; ++l) Ka(this, l, e);
                    var c = this.doc.sel.ranges;
                    0 == n.ch && t.length == c.length && c[r].from().ch > 0 && Vn(this.doc, r, new hn(n, c[r].to()), $)
                  }
                }
              }),
              getTokenAt: function(e, t) {
                return yt(this, e, t)
              },
              getLineTokens: function(e, t) {
                return yt(this, ht(e), t, !0)
              },
              getTokenTypeAt: function(e) {
                e = Tt(this.doc, e);
                var t, i = vt(this, it(this.doc, e.line)),
                  r = 0,
                  s = (i.length - 1) / 2,
                  n = e.ch;
                if (0 == n) t = i[2];
                else
                  for (;;) {
                    var o = r + s >> 1;
                    if ((o ? i[2 * o - 1] : 0) >= n) s = o;
                    else {
                      if (!(i[2 * o + 1] < n)) {
                        t = i[2 * o + 2];
                        break
                      }
                      r = o + 1
                    }
                  }
                var a = t ? t.indexOf("overlay ") : -1;
                return a < 0 ? t : 0 == a ? null : t.slice(0, a - 1)
              },
              getModeAt: function(t) {
                var i = this.doc.mode;
                return i.innerMode ? e.innerMode(i, this.getTokenAt(t).state).mode : i
              },
              getHelper: function(e, t) {
                return this.getHelpers(e, t)[0]
              },
              getHelpers: function(e, t) {
                var r = [];
                if (!i.hasOwnProperty(t)) return r;
                var s = i[t],
                  n = this.getModeAt(e);
                if ("string" == typeof n[t]) s[n[t]] && r.push(s[n[t]]);
                else if (n[t])
                  for (var o = 0; o < n[t].length; o++) {
                    var a = s[n[t][o]];
                    a && r.push(a)
                  } else n.helperType && s[n.helperType] ? r.push(s[n.helperType]) : s[n.name] && r.push(s[n.name]);
                for (var l = 0; l < s._global.length; l++) {
                  var c = s._global[l];
                  c.pred(n, this) && -1 == K(r, c.val) && r.push(c.val)
                }
                return r
              },
              getStateAfter: function(e, t) {
                var i = this.doc;
                return Nt(this, (e = ft(i, null == e ? i.first + i.size - 1 : e)) + 1, t).state
              },
              cursorCoords: function(e, t) {
                var i = this.doc.sel.primary();
                return vr(this, null == e ? i.head : "object" == typeof e ? Tt(this.doc, e) : e ? i.from() : i.to(), t || "page")
              },
              charCoords: function(e, t) {
                return Ar(this, Tt(this.doc, e), t || "page")
              },
              coordsChar: function(e, t) {
                return Or(this, (e = Rr(this, e, t || "page")).left, e.top)
              },
              lineAtHeight: function(e, t) {
                return e = Rr(this, {
                  top: e,
                  left: 0
                }, t || "page").top, at(this.doc, e + this.display.viewOffset)
              },
              heightAtLine: function(e, t, i) {
                var r, s = !1;
                if ("number" == typeof e) {
                  var n = this.doc.first + this.doc.size - 1;
                  e < this.doc.first ? e = this.doc.first : e > n && (e = n, s = !0), r = it(this.doc, e)
                } else r = e;
                return Sr(this, r, {
                  top: 0,
                  left: 0
                }, t || "page", i || s).top + (s ? this.doc.height - hi(r) : 0)
              },
              defaultTextHeight: function() {
                return br(this.display)
              },
              defaultCharWidth: function() {
                return Mr(this.display)
              },
              getViewport: function() {
                return {
                  from: this.display.viewFrom,
                  to: this.display.viewTo
                }
              },
              addWidget: function(e, t, i, r, s) {
                var n = this.display,
                  o = (e = vr(this, Tt(this.doc, e))).bottom,
                  a = e.left;
                if (t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), n.sizer.appendChild(t), "over" == r) o = e.top;
                else if ("above" == r || "near" == r) {
                  var l = Math.max(n.wrapper.clientHeight, this.doc.height),
                    c = Math.max(n.sizer.clientWidth, n.lineSpace.clientWidth);
                  ("above" == r || e.bottom + t.offsetHeight > l) && e.top > t.offsetHeight ? o = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= l && (o = e.bottom), a + t.offsetWidth > c && (a = c - t.offsetWidth)
                }
                t.style.top = o + "px", t.style.left = t.style.right = "", "right" == s ? (a = n.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == s ? a = 0 : "middle" == s && (a = (n.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = a + "px"), i && ls(this, {
                  left: a,
                  top: o,
                  right: a + t.offsetWidth,
                  bottom: o + t.offsetHeight
                })
              },
              triggerOnKeyDown: Gs(Ea),
              triggerOnKeyPress: Gs(Ta),
              triggerOnKeyUp: fa,
              triggerOnMouseDown: Gs(va),
              execCommand: function(e) {
                if (ia.hasOwnProperty(e)) return ia[e].call(null, this)
              },
              triggerElectric: Gs(function(e) {
                Ja(this, e)
              }),
              findPosH: function(e, t, i, r) {
                var s = 1;
                t < 0 && (s = -1, t = -t);
                for (var n = Tt(this.doc, e), o = 0; o < t && !(n = tl(this.doc, n, s, i, r)).hitSide; ++o);
                return n
              },
              moveH: Gs(function(e, t) {
                var i = this;
                this.extendSelectionsBy(function(r) {
                  return i.display.shift || i.doc.extend || r.empty() ? tl(i.doc, r.head, e, t, i.options.rtlMoveVisually) : e < 0 ? r.from() : r.to()
                }, J)
              }),
              deleteH: Gs(function(e, t) {
                var i = this.doc.sel,
                  r = this.doc;
                i.somethingSelected() ? r.replaceSelection("", null, "+delete") : qo(this, function(i) {
                  var s = tl(r, i.head, e, t, !1);
                  return e < 0 ? {
                    from: s,
                    to: i.head
                  } : {
                    from: i.head,
                    to: s
                  }
                })
              }),
              findPosV: function(e, t, i, r) {
                var s = 1,
                  n = r;
                t < 0 && (s = -1, t = -t);
                for (var o = Tt(this.doc, e), a = 0; a < t; ++a) {
                  var l = vr(this, o, "div");
                  if (null == n ? n = l.left : l.left = n, (o = il(this, l, s, i)).hitSide) break
                }
                return o
              },
              moveV: Gs(function(e, t) {
                var i = this,
                  r = this.doc,
                  s = [],
                  n = !this.display.shift && !r.extend && r.sel.somethingSelected();
                if (r.extendSelectionsBy(function(o) {
                    if (n) return e < 0 ? o.from() : o.to();
                    var a = vr(i, o.head, "div");
                    null != o.goalColumn && (a.left = o.goalColumn), s.push(a.left);
                    var l = il(i, a, e, t);
                    return "page" == t && o == r.sel.primary() && hs(i, Ar(i, l, "div").top - a.top), l
                  }, J), s.length)
                  for (var o = 0; o < r.sel.ranges.length; o++) r.sel.ranges[o].goalColumn = s[o]
              }),
              findWordAt: function(e) {
                var t = it(this.doc, e.line).text,
                  i = e.ch,
                  r = e.ch;
                if (t) {
                  var s = this.getHelper(e, "wordChars");
                  "before" != e.sticky && r != t.length || !i ? ++r : --i;
                  for (var n = t.charAt(i), o = ae(n, s) ? function(e) {
                      return ae(e, s)
                    } : /\s/.test(n) ? function(e) {
                      return /\s/.test(e)
                    } : function(e) {
                      return !/\s/.test(e) && !ae(e)
                    }; i > 0 && o(t.charAt(i - 1));) --i;
                  for (; r < t.length && o(t.charAt(r));) ++r
                }
                return new hn(ht(e.line, i), ht(e.line, r))
              },
              toggleOverwrite: function(e) {
                null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? M(this.display.cursorDiv, "CodeMirror-overwrite") : L(this.display.cursorDiv, "CodeMirror-overwrite"), Ae(this, "overwriteToggle", this, this.state.overwrite))
              },
              hasFocus: function() {
                return this.display.input.getField() == b(U(this))
              },
              isReadOnly: function() {
                return !(!this.options.readOnly && !this.doc.cantEdit)
              },
              scrollTo: Gs(function(e, t) {
                ds(this, e, t)
              }),
              getScrollInfo: function() {
                var e = this.display.scroller;
                return {
                  left: e.scrollLeft,
                  top: e.scrollTop,
                  height: e.scrollHeight - Qi(this) - this.display.barHeight,
                  width: e.scrollWidth - Qi(this) - this.display.barWidth,
                  clientHeight: er(this),
                  clientWidth: Zi(this)
                }
              },
              scrollIntoView: Gs(function(e, t) {
                null == e ? (e = {
                  from: this.doc.sel.primary().head,
                  to: null
                }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = {
                  from: ht(e, 0),
                  to: null
                } : null == e.from && (e = {
                  from: e,
                  to: null
                }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line ? ps(this, e) : gs(this, e.from, e.to, e.margin)
              }),
              setSize: Gs(function(e, t) {
                var i = this,
                  r = function(e) {
                    return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
                  };
                null != e && (this.display.wrapper.style.width = r(e)), null != t && (this.display.wrapper.style.height = r(t)), this.options.lineWrapping && gr(this);
                var s = this.display.viewFrom;
                this.doc.iter(s, this.display.viewTo, function(e) {
                  if (e.widgets)
                    for (var t = 0; t < e.widgets.length; t++)
                      if (e.widgets[t].noHScroll) {
                        Vr(i, s, "widget");
                        break
                      }++ s
                }), this.curOp.forceUpdate = !0, Ae(this, "refresh", this)
              }),
              operation: function(e) {
                return Fs(this, e)
              },
              startOperation: function() {
                return Ls(this)
              },
              endOperation: function() {
                return _s(this)
              },
              refresh: Gs(function() {
                var e = this.display.cachedTextHeight;
                Br(this), this.curOp.forceUpdate = !0, fr(this), ds(this, this.doc.scrollLeft, this.doc.scrollTop), js(this.display), (null == e || Math.abs(e - br(this.display)) > .5 || this.options.lineWrapping) && Ur(this), Ae(this, "refresh", this)
              }),
              swapDoc: Gs(function(e) {
                var t = this.doc;
                return t.cm = null, this.state.selectingText && this.state.selectingText(), vn(this, e), fr(this), this.display.input.reset(), ds(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, bi(this, "swapDoc", this, t), t
              }),
              phrase: function(e) {
                var t = this.options.phrases;
                return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e
              },
              getInputField: function() {
                return this.display.input.getField()
              },
              getWrapperElement: function() {
                return this.display.wrapper
              },
              getScrollerElement: function() {
                return this.display.scroller
              },
              getGutterElement: function() {
                return this.display.gutters
              }
            }, Oe(e), e.registerHelper = function(t, r, s) {
              i.hasOwnProperty(t) || (i[t] = e[t] = {
                _global: []
              }), i[t][r] = s
            }, e.registerGlobalHelper = function(t, r, s, n) {
              e.registerHelper(t, r, n), i[t]._global.push({
                pred: s,
                val: n
              })
            }
          }

          function tl(e, t, i, r, s) {
            var n = t,
              o = i,
              a = it(e, t.line),
              l = s && "rtl" == e.direction ? -i : i;

            function c() {
              var i = t.line + l;
              return !(i < e.first || i >= e.first + e.size) && (t = new ht(i, t.ch, t.sticky), a = it(e, i))
            }

            function h(n) {
              var o;
              if ("codepoint" == r) {
                var h = a.text.charCodeAt(t.ch + (i > 0 ? 0 : -1));
                if (isNaN(h)) o = null;
                else {
                  var u = i > 0 ? h >= 55296 && h < 56320 : h >= 56320 && h < 57343;
                  o = new ht(t.line, Math.max(0, Math.min(a.text.length, t.ch + i * (u ? 2 : 1))), -i)
                }
              } else o = s ? ta(e.cm, a, t, i) : Zo(a, t, i);
              if (null == o) {
                if (n || !c()) return !1;
                t = ea(s, e.cm, a, t.line, l)
              } else t = o;
              return !0
            }
            if ("char" == r || "codepoint" == r) h();
            else if ("column" == r) h(!0);
            else if ("word" == r || "group" == r)
              for (var u = null, d = "group" == r, p = e.cm && e.cm.getHelper(t, "wordChars"), E = !0; !(i < 0) || h(!E); E = !1) {
                var g = a.text.charAt(t.ch) || "\n",
                  f = ae(g, p) ? "w" : d && "\n" == g ? "n" : !d || /\s/.test(g) ? null : "p";
                if (!d || E || f || (f = "s"), u && u != f) {
                  i < 0 && (i = 1, h(), t.sticky = "after");
                  break
                }
                if (f && (u = f), i > 0 && !h(!E)) break
              }
            var T = Qn(e, t, n, o, !0);
            return dt(n, T) && (T.hitSide = !0), T
          }

          function il(e, t, i, r) {
            var s, n, o = e.doc,
              a = t.left;
            if ("page" == r) {
              var l = Math.min(e.display.wrapper.clientHeight, k(e).innerHeight || o(e).documentElement.clientHeight),
                c = Math.max(l - .5 * br(e.display), 3);
              s = (i > 0 ? t.bottom : t.top) + i * c
            } else "line" == r && (s = i > 0 ? t.bottom + 3 : t.top - 3);
            for (;
              (n = Or(e, a, s)).outside;) {
              if (i < 0 ? s <= 0 : s >= o.height) {
                n.hitSide = !0;
                break
              }
              s += 5 * i
            }
            return n
          }
          var rl = function(e) {
            this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new Y, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null
          };

          function sl(e, t) {
            var i = nr(e, t.line);
            if (!i || i.hidden) return null;
            var r = it(e.doc, t.line),
              s = ir(i, r, t.line),
              n = Te(r, e.doc.direction),
              o = "left";
            n && (o = ge(n, t.ch) % 2 ? "right" : "left");
            var a = hr(s.map, t.ch, o);
            return a.offset = "right" == a.collapse ? a.end : a.start, a
          }

          function nl(e) {
            for (var t = e; t; t = t.parentNode)
              if (/CodeMirror-gutter-wrapper/.test(t.className)) return !0;
            return !1
          }

          function ol(e, t) {
            return t && (e.bad = !0), e
          }

          function al(e, t, i, r, s) {
            var n = "",
              o = !1,
              a = e.doc.lineSeparator(),
              l = !1;

            function c(e) {
              return function(t) {
                return t.id == e
              }
            }

            function h() {
              o && (n += a, l && (n += a), o = l = !1)
            }

            function u(e) {
              e && (h(), n += e)
            }

            function d(t) {
              if (1 == t.nodeType) {
                var i = t.getAttribute("cm-text");
                if (i) return void u(i);
                var n, p = t.getAttribute("cm-marker");
                if (p) {
                  var E = e.findMarks(ht(r, 0), ht(s + 1, 0), c(+p));
                  return void(E.length && (n = E[0].find(0)) && u(rt(e.doc, n.from, n.to).join(a)))
                }
                if ("false" == t.getAttribute("contenteditable")) return;
                var g = /^(pre|div|p|li|table|br)$/i.test(t.nodeName);
                if (!/^br$/i.test(t.nodeName) && 0 == t.textContent.length) return;
                g && h();
                for (var f = 0; f < t.childNodes.length; f++) d(t.childNodes[f]);
                /^(pre|p)$/i.test(t.nodeName) && (l = !0), g && (o = !0)
              } else 3 == t.nodeType && u(t.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "))
            }
            for (; d(t), t != i;) t = t.nextSibling, l = !1;
            return n
          }

          function ll(e, t, i) {
            var r;
            if (t == e.display.lineDiv) {
              if (!(r = e.display.lineDiv.childNodes[i])) return ol(e.clipPos(ht(e.display.viewTo - 1)), !0);
              t = null, i = 0
            } else
              for (r = t;; r = r.parentNode) {
                if (!r || r == e.display.lineDiv) return null;
                if (r.parentNode && r.parentNode == e.display.lineDiv) break
              }
            for (var s = 0; s < e.display.view.length; s++) {
              var n = e.display.view[s];
              if (n.node == r) return cl(n, t, i)
            }
          }

          function cl(e, t, i) {
            var r = e.text.firstChild,
              s = !1;
            if (!t || !P(r, t)) return ol(ht(ot(e.line), 0), !0);
            if (t == r && (s = !0, t = r.childNodes[i], i = 0, !t)) {
              var n = e.rest ? ee(e.rest) : e.line;
              return ol(ht(ot(n), n.text.length), s)
            }
            var o = 3 == t.nodeType ? t : null,
              a = t;
            for (o || 1 != t.childNodes.length || 3 != t.firstChild.nodeType || (o = t.firstChild, i && (i = o.nodeValue.length)); a.parentNode != r;) a = a.parentNode;
            var l = e.measure,
              c = l.maps;

            function h(t, i, r) {
              for (var s = -1; s < (c ? c.length : 0); s++)
                for (var n = s < 0 ? l.map : c[s], o = 0; o < n.length; o += 3) {
                  var a = n[o + 2];
                  if (a == t || a == i) {
                    var h = ot(s < 0 ? e.line : e.rest[s]),
                      u = n[o] + r;
                    return (r < 0 || a != t) && (u = n[o + (r ? 1 : 0)]), ht(h, u)
                  }
                }
            }
            var u = h(o, a, i);
            if (u) return ol(u, s);
            for (var d = a.nextSibling, p = o ? o.nodeValue.length - i : 0; d; d = d.nextSibling) {
              if (u = h(d, d.firstChild, 0)) return ol(ht(u.line, u.ch - p), s);
              p += d.textContent.length
            }
            for (var E = a.previousSibling, g = i; E; E = E.previousSibling) {
              if (u = h(E, E.firstChild, -1)) return ol(ht(u.line, u.ch + g), s);
              g += E.textContent.length
            }
          }
          rl.prototype.init = function(e) {
            var t = this,
              i = this,
              r = i.cm,
              s = i.div = e.lineDiv;

            function n(e) {
              for (var t = e.target; t; t = t.parentNode) {
                if (t == s) return !0;
                if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) break
              }
              return !1
            }

            function o(e) {
              if (n(e) && !ve(r, e)) {
                if (r.somethingSelected()) za({
                  lineWise: !1,
                  text: r.getSelections()
                }), "cut" == e.type && r.replaceSelection("", null, "cut");
                else {
                  if (!r.options.lineWiseCopyCut) return;
                  var t = qa(r);
                  za({
                    lineWise: !0,
                    text: t.text
                  }), "cut" == e.type && r.operation(function() {
                    r.setSelections(t.ranges, 0, $), r.replaceSelection("", null, "cut")
                  })
                }
                if (e.clipboardData) {
                  e.clipboardData.clearData();
                  var o = Xa.text.join("\n");
                  if (e.clipboardData.setData("Text", o), e.clipboardData.getData("Text") == o) return void e.preventDefault()
                }
                var a = Za(),
                  l = a.firstChild;
                Qa(l), r.display.lineSpace.insertBefore(a, r.display.lineSpace.firstChild), l.value = Xa.text.join("\n");
                var c = b(H(s));
                x(l), setTimeout(function() {
                  r.display.lineSpace.removeChild(a), c.focus(), c == s && i.showPrimarySelection()
                }, 50)
              }
            }
            s.contentEditable = !0, Qa(s, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize), Ce(s, "paste", function(e) {
              !n(e) || ve(r, e) || ja(e, r) || a <= 11 && setTimeout(xs(r, function() {
                return t.updateFromDOM()
              }), 20)
            }), Ce(s, "compositionstart", function(e) {
              t.composing = {
                data: e.data,
                done: !1
              }
            }), Ce(s, "compositionupdate", function(e) {
              t.composing || (t.composing = {
                data: e.data,
                done: !1
              })
            }), Ce(s, "compositionend", function(e) {
              t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0)
            }), Ce(s, "touchstart", function() {
              return i.forceCompositionEnd()
            }), Ce(s, "input", function() {
              t.composing || t.readFromDOMSoon()
            }), Ce(s, "copy", o), Ce(s, "cut", o)
          }, rl.prototype.screenReaderLabelChanged = function(e) {
            e ? this.div.setAttribute("aria-label", e) : this.div.removeAttribute("aria-label")
          }, rl.prototype.prepareSelection = function() {
            var e = $r(this.cm, !1);
            return e.focus = b(H(this.div)) == this.div, e
          }, rl.prototype.showSelection = function(e, t) {
            e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e))
          }, rl.prototype.getSelection = function() {
            return this.cm.display.wrapper.ownerDocument.getSelection()
          }, rl.prototype.showPrimarySelection = function() {
            var e = this.getSelection(),
              t = this.cm,
              r = t.doc.sel.primary(),
              s = r.from(),
              n = r.to();
            if (t.display.viewTo == t.display.viewFrom || s.line >= t.display.viewTo || n.line < t.display.viewFrom) e.removeAllRanges();
            else {
              var o = ll(t, e.anchorNode, e.anchorOffset),
                a = ll(t, e.focusNode, e.focusOffset);
              if (!o || o.bad || !a || a.bad || 0 != ut(gt(o, a), s) || 0 != ut(Et(o, a), n)) {
                var l = t.display.view,
                  c = s.line >= t.display.viewFrom && sl(t, s) || {
                    node: l[0].measure.map[2],
                    offset: 0
                  },
                  h = n.line < t.display.viewTo && sl(t, n);
                if (!h) {
                  var u = l[l.length - 1].measure,
                    d = u.maps ? u.maps[u.maps.length - 1] : u.map;
                  h = {
                    node: d[d.length - 1],
                    offset: d[d.length - 2] - d[d.length - 3]
                  }
                }
                if (c && h) {
                  var p, E = e.rangeCount && e.getRangeAt(0);
                  try {
                    p = O(c.node, c.offset, h.offset, h.node)
                  } catch (e) {}
                  p && (!i && t.state.focused ? (e.collapse(c.node, c.offset), p.collapsed || (e.removeAllRanges(), e.addRange(p))) : (e.removeAllRanges(), e.addRange(p)), E && null == e.anchorNode ? e.addRange(E) : i && this.startGracePeriod()), this.rememberSelection()
                } else e.removeAllRanges()
              }
            }
          }, rl.prototype.startGracePeriod = function() {
            var e = this;
            clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
              e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function() {
                return e.cm.curOp.selectionChanged = !0
              })
            }, 20)
          }, rl.prototype.showMultipleSelections = function(e) {
            y(this.cm.display.cursorDiv, e.cursors), y(this.cm.display.selectionDiv, e.selection)
          }, rl.prototype.rememberSelection = function() {
            var e = this.getSelection();
            this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset
          }, rl.prototype.selectionInEditor = function() {
            var e = this.getSelection();
            if (!e.rangeCount) return !1;
            var t = e.getRangeAt(0).commonAncestorContainer;
            return P(this.div, t)
          }, rl.prototype.focus = function() {
            "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() && b(H(this.div)) == this.div || this.showSelection(this.prepareSelection(), !0), this.div.focus())
          }, rl.prototype.blur = function() {
            this.div.blur()
          }, rl.prototype.getField = function() {
            return this.div
          }, rl.prototype.supportsTouch = function() {
            return !0
          }, rl.prototype.receivedFocus = function() {
            var e = this,
              t = this;

            function i() {
              t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, i))
            }
            this.selectionInEditor() ? setTimeout(function() {
              return e.pollSelection()
            }, 20) : Fs(this.cm, function() {
              return t.cm.curOp.selectionChanged = !0
            }), this.polling.set(this.cm.options.pollInterval, i)
          }, rl.prototype.selectionChanged = function() {
            var e = this.getSelection();
            return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset
          }, rl.prototype.pollSelection = function() {
            if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
              var e = this.getSelection(),
                t = this.cm;
              if (T && h && this.cm.display.gutterSpecs.length && nl(e.anchorNode)) return this.cm.triggerOnKeyDown({
                type: "keydown",
                keyCode: 8,
                preventDefault: Math.abs
              }), this.blur(), void this.focus();
              if (!this.composing) {
                this.rememberSelection();
                var i = ll(t, e.anchorNode, e.anchorOffset),
                  r = ll(t, e.focusNode, e.focusOffset);
                i && r && Fs(t, function() {
                  Xn(t.doc, dn(i, r), $), (i.bad || r.bad) && (t.curOp.selectionChanged = !0)
                })
              }
            }
          }, rl.prototype.pollContent = function() {
            null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
            var e, t, i, r = this.cm,
              s = r.display,
              n = r.doc.sel.primary(),
              o = n.from(),
              a = n.to();
            if (0 == o.ch && o.line > r.firstLine() && (o = ht(o.line - 1, it(r.doc, o.line - 1).length)), a.ch == it(r.doc, a.line).text.length && a.line < r.lastLine() && (a = ht(a.line + 1, 0)), o.line < s.viewFrom || a.line > s.viewTo - 1) return !1;
            o.line == s.viewFrom || 0 == (e = kr(r, o.line)) ? (t = ot(s.view[0].line), i = s.view[0].node) : (t = ot(s.view[e].line), i = s.view[e - 1].node.nextSibling);
            var l, c, h = kr(r, a.line);
            if (h == s.view.length - 1 ? (l = s.viewTo - 1, c = s.lineDiv.lastChild) : (l = ot(s.view[h + 1].line) - 1, c = s.view[h + 1].node.previousSibling), !i) return !1;
            for (var u = r.doc.splitLines(al(r, i, c, t, l)), d = rt(r.doc, ht(t, 0), ht(l, it(r.doc, l).text.length)); u.length > 1 && d.length > 1;)
              if (ee(u) == ee(d)) u.pop(), d.pop(), l--;
              else {
                if (u[0] != d[0]) break;
                u.shift(), d.shift(), t++
              } for (var p = 0, E = 0, g = u[0], f = d[0], T = Math.min(g.length, f.length); p < T && g.charCodeAt(p) == f.charCodeAt(p);) ++p;
            for (var m = ee(u), C = ee(d), S = Math.min(m.length - (1 == u.length ? p : 0), C.length - (1 == d.length ? p : 0)); E < S && m.charCodeAt(m.length - E - 1) == C.charCodeAt(C.length - E - 1);) ++E;
            if (1 == u.length && 1 == d.length && t == o.line)
              for (; p && p > o.ch && m.charCodeAt(m.length - E - 1) == C.charCodeAt(C.length - E - 1);) p--, E++;
            u[u.length - 1] = m.slice(0, m.length - E).replace(/^\u200b+/, ""), u[0] = u[0].slice(p).replace(/\u200b+$/, "");
            var R = ht(t, p),
              A = ht(l, d.length ? ee(d).length - E : 0);
            return u.length > 1 || u[0] || ut(R, A) ? (lo(r.doc, u, R, A, "+input"), !0) : void 0
          }, rl.prototype.ensurePolled = function() {
            this.forceCompositionEnd()
          }, rl.prototype.reset = function() {
            this.forceCompositionEnd()
          }, rl.prototype.forceCompositionEnd = function() {
            this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus())
          }, rl.prototype.readFromDOMSoon = function() {
            var e = this;
            null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
              if (e.readDOMTimeout = null, e.composing) {
                if (!e.composing.done) return;
                e.composing = null
              }
              e.updateFromDOM()
            }, 80))
          }, rl.prototype.updateFromDOM = function() {
            var e = this;
            !this.cm.isReadOnly() && this.pollContent() || Fs(this.cm, function() {
              return Br(e.cm)
            })
          }, rl.prototype.setUneditable = function(e) {
            e.contentEditable = "false"
          }, rl.prototype.onKeyPress = function(e) {
            0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || xs(this.cm, $a)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0))
          }, rl.prototype.readOnlyChanged = function(e) {
            this.div.contentEditable = String("nocursor" != e)
          }, rl.prototype.onContextMenu = function() {}, rl.prototype.resetPosition = function() {}, rl.prototype.needsContentAttribute = !0;
          var hl = function(e) {
            this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new Y, this.hasSelection = !1, this.composing = null, this.resetting = !1
          };

          function ul(e, t) {
            if ((t = t ? V(t) : {}).value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), null == t.autofocus) {
              var i = b(H(e));
              t.autofocus = i == e || null != e.getAttribute("autofocus") && i == document.body
            }

            function r() {
              e.value = a.getValue()
            }
            var s;
            if (e.form && (Ce(e.form, "submit", r), !t.leaveSubmitMethodAlone)) {
              var n = e.form;
              s = n.submit;
              try {
                var o = n.submit = function() {
                  r(), n.submit = s, n.submit(), n.submit = o
                }
              } catch (e) {}
            }
            t.finishInit = function(i) {
              i.save = r, i.getTextArea = function() {
                return e
              }, i.toTextArea = function() {
                i.toTextArea = isNaN, r(), e.parentNode.removeChild(i.getWrapperElement()), e.style.display = "", e.form && (Re(e.form, "submit", r), t.leaveSubmitMethodAlone || "function" != typeof e.form.submit || (e.form.submit = s))
              }
            }, e.style.display = "none";
            var a = Va(function(t) {
              return e.parentNode.insertBefore(t, e.nextSibling)
            }, t);
            return a
          }

          function dl(e) {
            e.off = Re, e.on = Ce, e.wheelEventPixels = an, e.Doc = _o, e.splitLines = He, e.countColumn = W, e.findColumn = q, e.isWordChar = oe, e.Pass = z, e.signal = Ae, e.Line = pi, e.changeEnd = pn, e.scrollbarModel = Ns, e.Pos = ht, e.cmpPos = ut, e.modes = Ye, e.mimeModes = Ke, e.resolveMode = $e, e.getMode = je, e.modeExtensions = Je, e.extendMode = qe, e.copyState = Qe, e.startState = et, e.innerMode = Ze, e.commands = ia, e.keyMap = Wo, e.keyName = jo, e.isModifierKey = zo, e.lookupKey = Xo, e.normalizeKeyMap = Ko, e.StringStream = tt, e.SharedTextMarker = Ao, e.TextMarker = So, e.LineWidget = fo, e.e_preventDefault = Le, e.e_stopPropagation = _e, e.e_stop = we, e.addClass = M, e.contains = P, e.rmClass = L, e.keyNames = Ho
          }
          hl.prototype.init = function(e) {
            var t = this,
              i = this,
              r = this.cm;
            this.createField(e);
            var s = this.textarea;

            function n(e) {
              if (!ve(r, e)) {
                if (r.somethingSelected()) za({
                  lineWise: !1,
                  text: r.getSelections()
                });
                else {
                  if (!r.options.lineWiseCopyCut) return;
                  var t = qa(r);
                  za({
                    lineWise: !0,
                    text: t.text
                  }), "cut" == e.type ? r.setSelections(t.ranges, null, $) : (i.prevInput = "", s.value = t.text.join("\n"), x(s))
                }
                "cut" == e.type && (r.state.cutIncoming = +new Date)
              }
            }
            e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), f && (s.style.width = "0px"), Ce(s, "input", function() {
              o && a >= 9 && t.hasSelection && (t.hasSelection = null), i.poll()
            }), Ce(s, "paste", function(e) {
              ve(r, e) || ja(e, r) || (r.state.pasteIncoming = +new Date, i.fastPoll())
            }), Ce(s, "cut", n), Ce(s, "copy", n), Ce(e.scroller, "paste", function(t) {
              if (!$i(e, t) && !ve(r, t)) {
                if (!s.dispatchEvent) return r.state.pasteIncoming = +new Date, void i.focus();
                var n = new Event("paste");
                n.clipboardData = t.clipboardData, s.dispatchEvent(n)
              }
            }), Ce(e.lineSpace, "selectstart", function(t) {
              $i(e, t) || Le(t)
            }), Ce(s, "compositionstart", function() {
              var e = r.getCursor("from");
              i.composing && i.composing.range.clear(), i.composing = {
                start: e,
                range: r.markText(e, r.getCursor("to"), {
                  className: "CodeMirror-composing"
                })
              }
            }), Ce(s, "compositionend", function() {
              i.composing && (i.poll(), i.composing.range.clear(), i.composing = null)
            })
          }, hl.prototype.createField = function(e) {
            this.wrapper = Za(), this.textarea = this.wrapper.firstChild;
            var t = this.cm.options;
            Qa(this.textarea, t.spellcheck, t.autocorrect, t.autocapitalize)
          }, hl.prototype.screenReaderLabelChanged = function(e) {
            e ? this.textarea.setAttribute("aria-label", e) : this.textarea.removeAttribute("aria-label")
          }, hl.prototype.prepareSelection = function() {
            var e = this.cm,
              t = e.display,
              i = e.doc,
              r = $r(e);
            if (e.options.moveInputWithCursor) {
              var s = vr(e, i.sel.primary().head, "div"),
                n = t.wrapper.getBoundingClientRect(),
                o = t.lineDiv.getBoundingClientRect();
              r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, s.top + o.top - n.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, s.left + o.left - n.left))
            }
            return r
          }, hl.prototype.showSelection = function(e) {
            var t = this.cm.display;
            y(t.cursorDiv, e.cursors), y(t.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px")
          }, hl.prototype.reset = function(e) {
            if (!(this.contextMenuPending || this.composing && e)) {
              var t = this.cm;
              if (this.resetting = !0, t.somethingSelected()) {
                this.prevInput = "";
                var i = t.getSelection();
                this.textarea.value = i, t.state.focused && x(this.textarea), o && a >= 9 && (this.hasSelection = i)
              } else e || (this.prevInput = this.textarea.value = "", o && a >= 9 && (this.hasSelection = null));
              this.resetting = !1
            }
          }, hl.prototype.getField = function() {
            return this.textarea
          }, hl.prototype.supportsTouch = function() {
            return !1
          }, hl.prototype.focus = function() {
            if ("nocursor" != this.cm.options.readOnly && (!m || b(H(this.textarea)) != this.textarea)) try {
              this.textarea.focus()
            } catch (e) {}
          }, hl.prototype.blur = function() {
            this.textarea.blur()
          }, hl.prototype.resetPosition = function() {
            this.wrapper.style.top = this.wrapper.style.left = 0
          }, hl.prototype.receivedFocus = function() {
            this.slowPoll()
          }, hl.prototype.slowPoll = function() {
            var e = this;
            this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
              e.poll(), e.cm.state.focused && e.slowPoll()
            })
          }, hl.prototype.fastPoll = function() {
            var e = !1,
              t = this;

            function i() {
              t.poll() || e ? (t.pollingFast = !1, t.slowPoll()) : (e = !0, t.polling.set(60, i))
            }
            t.pollingFast = !0, t.polling.set(20, i)
          }, hl.prototype.poll = function() {
            var e = this,
              t = this.cm,
              i = this.textarea,
              r = this.prevInput;
            if (this.contextMenuPending || this.resetting || !t.state.focused || ke(i) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) return !1;
            var s = i.value;
            if (s == r && !t.somethingSelected()) return !1;
            if (o && a >= 9 && this.hasSelection === s || C && /[\uf700-\uf7ff]/.test(s)) return t.display.input.reset(), !1;
            if (t.doc.sel == t.display.selForContextMenu) {
              var n = s.charCodeAt(0);
              if (8203 != n || r || (r = "​"), 8666 == n) return this.reset(), this.cm.execCommand("undo")
            }
            for (var l = 0, c = Math.min(r.length, s.length); l < c && r.charCodeAt(l) == s.charCodeAt(l);) ++l;
            return Fs(t, function() {
              $a(t, s.slice(l), r.length - l, null, e.composing ? "*compose" : null), s.length > 1e3 || s.indexOf("\n") > -1 ? i.value = e.prevInput = "" : e.prevInput = s, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor("to"), {
                className: "CodeMirror-composing"
              }))
            }), !0
          }, hl.prototype.ensurePolled = function() {
            this.pollingFast && this.poll() && (this.pollingFast = !1)
          }, hl.prototype.onKeyPress = function() {
            o && a >= 9 && (this.hasSelection = null), this.fastPoll()
          }, hl.prototype.onContextMenu = function(e) {
            var t = this,
              i = t.cm,
              r = i.display,
              s = t.textarea;
            t.contextMenuPending && t.contextMenuPending();
            var n = Hr(i, e),
              c = r.scroller.scrollTop;
            if (n && !d) {
              i.options.resetSelectionOnContextMenu && -1 == i.doc.sel.contains(n) && xs(i, Xn)(i.doc, dn(n), $);
              var h, u = s.style.cssText,
                p = t.wrapper.style.cssText,
                E = t.wrapper.offsetParent.getBoundingClientRect();
              if (t.wrapper.style.cssText = "position: static", s.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - E.top - 5) + "px; left: " + (e.clientX - E.left - 5) + "px;\n      z-index: 1000; background: " + (o ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", l && (h = s.ownerDocument.defaultView.scrollY), r.input.focus(), l && s.ownerDocument.defaultView.scrollTo(null, h), r.input.reset(), i.somethingSelected() || (s.value = t.prevInput = " "), t.contextMenuPending = T, r.selForContextMenu = i.doc.sel, clearTimeout(r.detectingSelectAll), o && a >= 9 && f(), N) {
                we(e);
                var g = function() {
                  Re(window, "mouseup", g), setTimeout(T, 20)
                };
                Ce(window, "mouseup", g)
              } else setTimeout(T, 50)
            }

            function f() {
              if (null != s.selectionStart) {
                var e = i.somethingSelected(),
                  n = "​" + (e ? s.value : "");
                s.value = "⇚", s.value = n, t.prevInput = e ? "" : "​", s.selectionStart = 1, s.selectionEnd = n.length, r.selForContextMenu = i.doc.sel
              }
            }

            function T() {
              if (t.contextMenuPending == T && (t.contextMenuPending = !1, t.wrapper.style.cssText = p, s.style.cssText = u, o && a < 9 && r.scrollbars.setScrollTop(r.scroller.scrollTop = c), null != s.selectionStart)) {
                (!o || o && a < 9) && f();
                var e = 0,
                  n = function() {
                    r.selForContextMenu == i.doc.sel && 0 == s.selectionStart && s.selectionEnd > 0 && "​" == t.prevInput ? xs(i, eo)(i) : e++ < 10 ? r.detectingSelectAll = setTimeout(n, 500) : (r.selForContextMenu = null, r.input.reset())
                  };
                r.detectingSelectAll = setTimeout(n, 200)
              }
            }
          }, hl.prototype.readOnlyChanged = function(e) {
            e || this.reset(), this.textarea.disabled = "nocursor" == e, this.textarea.readOnly = !!e
          }, hl.prototype.setUneditable = function() {}, hl.prototype.needsContentAttribute = !1, Ha(Va), el(Va);
          var pl = "iter insert remove copy getEditor constructor".split(" ");
          for (var El in _o.prototype) _o.prototype.hasOwnProperty(El) && K(pl, El) < 0 && (Va.prototype[El] = function(e) {
            return function() {
              return e.apply(this.doc, arguments)
            }
          }(_o.prototype[El]));
          return Oe(_o), Va.inputStyles = {
            textarea: hl,
            contenteditable: rl
          }, Va.defineMode = function(e) {
            Va.defaults.mode || "null" == e || (Va.defaults.mode = e), Xe.apply(this, arguments)
          }, Va.defineMIME = ze, Va.defineMode("null", function() {
            return {
              token: function(e) {
                return e.skipToEnd()
              }
            }
          }), Va.defineMIME("text/plain", "null"), Va.defineExtension = function(e, t) {
            Va.prototype[e] = t
          }, Va.defineDocExtension = function(e, t) {
            _o.prototype[e] = t
          }, Va.fromTextArea = ul, dl(Va), Va.version = "5.65.20", Va
        }()
      },
      515: function(e) {
        var t, i;
        t = this, i = function() {
          function e(t, i, r) {
            return this.id = ++e.highestId, this.name = t, this.symbols = i, this.postprocess = r, this
          }

          function t(e, t, i, r) {
            this.rule = e, this.dot = t, this.reference = i, this.data = [], this.wantedBy = r, this.isComplete = this.dot === e.symbols.length
          }

          function i(e, t) {
            this.grammar = e, this.index = t, this.states = [], this.wants = {}, this.scannable = [], this.completed = {}
          }

          function r(e, t) {
            this.rules = e, this.start = t || this.rules[0].name;
            var i = this.byName = {};
            this.rules.forEach(function(e) {
              i.hasOwnProperty(e.name) || (i[e.name] = []), i[e.name].push(e)
            })
          }

          function s() {
            this.reset("")
          }

          function n(e, t, n) {
            if (e instanceof r) {
              var o = e;
              n = t
            } else o = r.fromCompiled(e, t);
            for (var a in this.grammar = o, this.options = {
                keepHistory: !1,
                lexer: o.lexer || new s
              }, n || {}) this.options[a] = n[a];
            this.lexer = this.options.lexer, this.lexerState = void 0;
            var l = new i(o, 0);
            this.table = [l], l.wants[o.start] = [], l.predict(o.start), l.process(), this.current = 0
          }

          function o(e) {
            var t = typeof e;
            if ("string" === t) return e;
            if ("object" === t) {
              if (e.literal) return JSON.stringify(e.literal);
              if (e instanceof RegExp) return e.toString();
              if (e.type) return "%" + e.type;
              if (e.test) return "<" + String(e.test) + ">";
              throw new Error("Unknown symbol type: " + e)
            }
          }
          return e.highestId = 0, e.prototype.toString = function(e) {
            var t = void 0 === e ? this.symbols.map(o).join(" ") : this.symbols.slice(0, e).map(o).join(" ") + " ● " + this.symbols.slice(e).map(o).join(" ");
            return this.name + " → " + t
          }, t.prototype.toString = function() {
            return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0)
          }, t.prototype.nextState = function(e) {
            var i = new t(this.rule, this.dot + 1, this.reference, this.wantedBy);
            return i.left = this, i.right = e, i.isComplete && (i.data = i.build(), i.right = void 0), i
          }, t.prototype.build = function() {
            var e = [],
              t = this;
            do {
              e.push(t.right.data), t = t.left
            } while (t.left);
            return e.reverse(), e
          }, t.prototype.finish = function() {
            this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, n.fail))
          }, i.prototype.process = function(e) {
            for (var t = this.states, i = this.wants, r = this.completed, s = 0; s < t.length; s++) {
              var o = t[s];
              if (o.isComplete) {
                if (o.finish(), o.data !== n.fail) {
                  for (var a = o.wantedBy, l = a.length; l--;) {
                    var c = a[l];
                    this.complete(c, o)
                  }
                  if (o.reference === this.index) {
                    var h = o.rule.name;
                    (this.completed[h] = this.completed[h] || []).push(o)
                  }
                }
              } else {
                if ("string" != typeof(h = o.rule.symbols[o.dot])) {
                  this.scannable.push(o);
                  continue
                }
                if (i[h]) {
                  if (i[h].push(o), r.hasOwnProperty(h)) {
                    var u = r[h];
                    for (l = 0; l < u.length; l++) {
                      var d = u[l];
                      this.complete(o, d)
                    }
                  }
                } else i[h] = [o], this.predict(h)
              }
            }
          }, i.prototype.predict = function(e) {
            for (var i = this.grammar.byName[e] || [], r = 0; r < i.length; r++) {
              var s = i[r],
                n = this.wants[e],
                o = new t(s, 0, this.index, n);
              this.states.push(o)
            }
          }, i.prototype.complete = function(e, t) {
            var i = e.nextState(t);
            this.states.push(i)
          }, r.fromCompiled = function(t, i) {
            var s = t.Lexer;
            t.ParserStart && (i = t.ParserStart, t = t.ParserRules);
            var n = new r(t = t.map(function(t) {
              return new e(t.name, t.symbols, t.postprocess)
            }), i);
            return n.lexer = s, n
          }, s.prototype.reset = function(e, t) {
            this.buffer = e, this.index = 0, this.line = t ? t.line : 1, this.lastLineBreak = t ? -t.col : 0
          }, s.prototype.next = function() {
            if (this.index < this.buffer.length) {
              var e = this.buffer[this.index++];
              return "\n" === e && (this.line += 1, this.lastLineBreak = this.index), {
                value: e
              }
            }
          }, s.prototype.save = function() {
            return {
              line: this.line,
              col: this.index - this.lastLineBreak
            }
          }, s.prototype.formatError = function(e, t) {
            var i = this.buffer;
            if ("string" == typeof i) {
              var r = i.split("\n").slice(Math.max(0, this.line - 5), this.line),
                s = i.indexOf("\n", this.index); - 1 === s && (s = i.length);
              var n = this.index - this.lastLineBreak,
                o = String(this.line).length;
              return t += " at line " + this.line + " col " + n + ":\n\n", t += r.map(function(e, t) {
                return a(this.line - r.length + t + 1, o) + " " + e
              }, this).join("\n"), t += "\n" + a("", o + n) + "^\n"
            }
            return t + " at index " + (this.index - 1);

            function a(e, t) {
              var i = String(e);
              return Array(t - i.length + 1).join(" ") + i
            }
          }, n.fail = {}, n.prototype.feed = function(e) {
            var t, r = this.lexer;
            for (r.reset(e, this.lexerState);;) {
              try {
                if (!(t = r.next())) break
              } catch (e) {
                var n = new i(this.grammar, this.current + 1);
                throw this.table.push(n), (l = new Error(this.reportLexerError(e))).offset = this.current, l.token = e.token, l
              }
              var o = this.table[this.current];
              this.options.keepHistory || delete this.table[this.current - 1];
              var a = this.current + 1;
              n = new i(this.grammar, a), this.table.push(n);
              for (var l, c = void 0 !== t.text ? t.text : t.value, h = r.constructor === s ? t.value : t, u = o.scannable, d = u.length; d--;) {
                var p = u[d],
                  E = p.rule.symbols[p.dot];
                if (E.test ? E.test(h) : E.type ? E.type === t.type : E.literal === c) {
                  var g = p.nextState({
                    data: h,
                    token: t,
                    isToken: !0,
                    reference: a - 1
                  });
                  n.states.push(g)
                }
              }
              if (n.process(), 0 === n.states.length) throw (l = new Error(this.reportError(t))).offset = this.current, l.token = t, l;
              this.options.keepHistory && (o.lexerState = r.save()), this.current++
            }
            return o && (this.lexerState = r.save()), this.results = this.finish(), this
          }, n.prototype.reportLexerError = function(e) {
            var t, i, r = e.token;
            return r ? (t = "input " + JSON.stringify(r.text[0]) + " (lexer error)", i = this.lexer.formatError(r, "Syntax error")) : (t = "input (lexer error)", i = e.message), this.reportErrorCommon(i, t)
          }, n.prototype.reportError = function(e) {
            var t = (e.type ? e.type + " token: " : "") + JSON.stringify(void 0 !== e.value ? e.value : e),
              i = this.lexer.formatError(e, "Syntax error");
            return this.reportErrorCommon(i, t)
          }, n.prototype.reportErrorCommon = function(e, t) {
            var i = [];
            i.push(e);
            var r = this.table.length - 2,
              s = this.table[r],
              n = s.states.filter(function(e) {
                var t = e.rule.symbols[e.dot];
                return t && "string" != typeof t
              });
            return 0 === n.length ? (i.push("Unexpected " + t + ". I did not expect any more input. Here is the state of my parse table:\n"), this.displayStateStack(s.states, i)) : (i.push("Unexpected " + t + ". Instead, I was expecting to see one of the following:\n"), n.map(function(e) {
              return this.buildFirstStateStack(e, []) || [e]
            }, this).forEach(function(e) {
              var t = e[0],
                r = t.rule.symbols[t.dot],
                s = this.getSymbolDisplay(r);
              i.push("A " + s + " based on:"), this.displayStateStack(e, i)
            }, this)), i.push(""), i.join("\n")
          }, n.prototype.displayStateStack = function(e, t) {
            for (var i, r = 0, s = 0; s < e.length; s++) {
              var n = e[s],
                o = n.rule.toString(n.dot);
              o === i ? r++ : (r > 0 && t.push("    ^ " + r + " more lines identical to this"), r = 0, t.push("    " + o)), i = o
            }
          }, n.prototype.getSymbolDisplay = function(e) {
            return function(e) {
              var t = typeof e;
              if ("string" === t) return e;
              if ("object" === t) {
                if (e.literal) return JSON.stringify(e.literal);
                if (e instanceof RegExp) return "character matching " + e;
                if (e.type) return e.type + " token";
                if (e.test) return "token matching " + String(e.test);
                throw new Error("Unknown symbol type: " + e)
              }
            }(e)
          }, n.prototype.buildFirstStateStack = function(e, t) {
            if (-1 !== t.indexOf(e)) return null;
            if (0 === e.wantedBy.length) return [e];
            var i = e.wantedBy[0],
              r = [e].concat(t),
              s = this.buildFirstStateStack(i, r);
            return null === s ? null : [e].concat(s)
          }, n.prototype.save = function() {
            var e = this.table[this.current];
            return e.lexerState = this.lexerState, e
          }, n.prototype.restore = function(e) {
            var t = e.index;
            this.current = t, this.table[t] = e, this.table.splice(t + 1), this.lexerState = e.lexerState, this.results = this.finish()
          }, n.prototype.rewind = function(e) {
            if (!this.options.keepHistory) throw new Error("set option `keepHistory` to enable rewinding");
            this.restore(this.table[e])
          }, n.prototype.finish = function() {
            var e = [],
              t = this.grammar.start;
            return this.table[this.table.length - 1].states.forEach(function(i) {
              i.rule.name === t && i.dot === i.rule.symbols.length && 0 === i.reference && i.data !== n.fail && e.push(i)
            }), e.map(function(e) {
              return e.data
            })
          }, {
            Parser: n,
            Grammar: r,
            Rule: e
          }
        }, e.exports ? e.exports = i() : t.nearley = i()
      },
      532: (e, t, i) => {
        ! function(e) {
          "use strict";

          function t(e) {
            for (var t; null != (t = e.next());)
              if ("`" == t && !e.eat("`")) return "variable-2";
            return e.backUp(e.current().length - 1), e.eatWhile(/\w/) ? "variable-2" : null
          }

          function i(e) {
            for (var t; null != (t = e.next());)
              if ('"' == t && !e.eat('"')) return "variable-2";
            return e.backUp(e.current().length - 1), e.eatWhile(/\w/) ? "variable-2" : null
          }

          function r(e) {
            return e.eat("@") && (e.match("session."), e.match("local."), e.match("global.")), e.eat("'") ? (e.match(/^.*'/), "variable-2") : e.eat('"') ? (e.match(/^.*"/), "variable-2") : e.eat("`") ? (e.match(/^.*`/), "variable-2") : e.match(/^[0-9a-zA-Z$\.\_]+/) ? "variable-2" : null
          }

          function s(e) {
            return e.eat("N") ? "atom" : e.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null
          }
          e.defineMode("sql", function(t, i) {
            var r = i.client || {},
              s = i.atoms || {
                false: !0,
                true: !0,
                null: !0
              },
              l = i.builtin || o(a),
              c = i.keywords || o(n),
              h = i.operatorChars || /^[*+\-%<>!=&|~^\/]/,
              u = i.support || {},
              d = i.hooks || {},
              p = i.dateSQL || {
                date: !0,
                time: !0,
                timestamp: !0
              },
              E = !1 !== i.backslashStringEscapes,
              g = i.brackets || /^[\{}\(\)\[\]]/,
              f = i.punctuation || /^[;.,:]/;

            function T(e, t) {
              var i = e.next();
              if (d[i]) {
                var n = d[i](e, t);
                if (!1 !== n) return n
              }
              if (u.hexNumber && ("0" == i && e.match(/^[xX][0-9a-fA-F]+/) || ("x" == i || "X" == i) && e.match(/^'[0-9a-fA-F]*'/))) return "number";
              if (u.binaryNumber && (("b" == i || "B" == i) && e.match(/^'[01]*'/) || "0" == i && e.match(/^b[01]+/))) return "number";
              if (i.charCodeAt(0) > 47 && i.charCodeAt(0) < 58) return e.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/), u.decimallessFloat && e.match(/^\.(?!\.)/), "number";
              if ("?" == i && (e.eatSpace() || e.eol() || e.eat(";"))) return "variable-3";
              if ("'" == i || '"' == i && u.doubleQuote) return t.tokenize = m(i), t.tokenize(e, t);
              if ((u.nCharCast && ("n" == i || "N" == i) || u.charsetCast && "_" == i && e.match(/[a-z][a-z0-9]*/i)) && ("'" == e.peek() || '"' == e.peek())) return "keyword";
              if (u.escapeConstant && ("e" == i || "E" == i) && ("'" == e.peek() || '"' == e.peek() && u.doubleQuote)) return t.tokenize = function(e, t) {
                return (t.tokenize = m(e.next(), !0))(e, t)
              }, "keyword";
              if (u.commentSlashSlash && "/" == i && e.eat("/")) return e.skipToEnd(), "comment";
              if (u.commentHash && "#" == i || "-" == i && e.eat("-") && (!u.commentSpaceRequired || e.eat(" "))) return e.skipToEnd(), "comment";
              if ("/" == i && e.eat("*")) return t.tokenize = C(1), t.tokenize(e, t);
              if ("." != i) {
                if (h.test(i)) return e.eatWhile(h), "operator";
                if (g.test(i)) return "bracket";
                if (f.test(i)) return e.eatWhile(f), "punctuation";
                if ("{" == i && (e.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || e.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) return "number";
                e.eatWhile(/^[_\w\d]/);
                var o = e.current().toLowerCase();
                return p.hasOwnProperty(o) && (e.match(/^( )+'[^']*'/) || e.match(/^( )+"[^"]*"/)) ? "number" : s.hasOwnProperty(o) ? "atom" : l.hasOwnProperty(o) ? "type" : c.hasOwnProperty(o) ? "keyword" : r.hasOwnProperty(o) ? "builtin" : null
              }
              return u.zerolessFloat && e.match(/^(?:\d+(?:e[+-]?\d+)?)/i) ? "number" : e.match(/^\.+/) ? null : e.match(/^[\w\d_$#]+/) ? "variable-2" : void 0
            }

            function m(e, t) {
              return function(i, r) {
                for (var s, n = !1; null != (s = i.next());) {
                  if (s == e && !n) {
                    r.tokenize = T;
                    break
                  }
                  n = (E || t) && !n && "\\" == s
                }
                return "string"
              }
            }

            function C(e) {
              return function(t, i) {
                var r = t.match(/^.*?(\/\*|\*\/)/);
                return r ? "/*" == r[1] ? i.tokenize = C(e + 1) : i.tokenize = e > 1 ? C(e - 1) : T : t.skipToEnd(), "comment"
              }
            }

            function S(e, t, i) {
              t.context = {
                prev: t.context,
                indent: e.indentation(),
                col: e.column(),
                type: i
              }
            }

            function R(e) {
              e.indent = e.context.indent, e.context = e.context.prev
            }
            return {
              startState: function() {
                return {
                  tokenize: T,
                  context: null
                }
              },
              token: function(e, t) {
                if (e.sol() && t.context && null == t.context.align && (t.context.align = !1), t.tokenize == T && e.eatSpace()) return null;
                var i = t.tokenize(e, t);
                if ("comment" == i) return i;
                t.context && null == t.context.align && (t.context.align = !0);
                var r = e.current();
                return "(" == r ? S(e, t, ")") : "[" == r ? S(e, t, "]") : t.context && t.context.type == r && R(t), i
              },
              indent: function(i, r) {
                var s = i.context;
                if (!s) return e.Pass;
                var n = r.charAt(0) == s.type;
                return s.align ? s.col + (n ? 0 : 1) : s.indent + (n ? 0 : t.indentUnit)
              },
              blockCommentStart: "/*",
              blockCommentEnd: "*/",
              lineComment: u.commentSlashSlash ? "//" : u.commentHash ? "#" : "--",
              closeBrackets: "()[]{}''\"\"``",
              config: i
            }
          });
          var n = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";

          function o(e) {
            for (var t = {}, i = e.split(" "), r = 0; r < i.length; ++r) t[i[r]] = !0;
            return t
          }
          var a = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric";
          e.defineMIME("text/x-sql", {
            name: "sql",
            keywords: o(n + "begin"),
            builtin: o(a),
            atoms: o("false true null unknown"),
            dateSQL: o("date time timestamp"),
            support: o("doubleQuote binaryNumber hexNumber")
          }), e.defineMIME("text/x-mssql", {
            name: "sql",
            client: o("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
            keywords: o(n + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
            builtin: o("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
            atoms: o("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
            operatorChars: /^[*+\-%<>!=^\&|\/]/,
            brackets: /^[\{}\(\)]/,
            punctuation: /^[;.,:/]/,
            backslashStringEscapes: !1,
            dateSQL: o("date datetimeoffset datetime2 smalldatetime datetime time"),
            hooks: {
              "@": r
            }
          }), e.defineMIME("text/x-mysql", {
            name: "sql",
            client: o("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
            keywords: o(n + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
            builtin: o("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
            atoms: o("false true null unknown"),
            operatorChars: /^[*+\-%<>!=&|^]/,
            dateSQL: o("date time timestamp"),
            support: o("decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
            hooks: {
              "@": r,
              "`": t,
              "\\": s
            }
          }), e.defineMIME("text/x-mariadb", {
            name: "sql",
            client: o("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
            keywords: o(n + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group group_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
            builtin: o("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
            atoms: o("false true null unknown"),
            operatorChars: /^[*+\-%<>!=&|^]/,
            dateSQL: o("date time timestamp"),
            support: o("decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
            hooks: {
              "@": r,
              "`": t,
              "\\": s
            }
          }), e.defineMIME("text/x-sqlite", {
            name: "sql",
            client: o("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
            keywords: o(n + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
            builtin: o("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
            atoms: o("null current_date current_time current_timestamp"),
            operatorChars: /^[*+\-%<>!=&|/~]/,
            dateSQL: o("date time timestamp datetime"),
            support: o("decimallessFloat zerolessFloat"),
            identifierQuote: '"',
            hooks: {
              "@": r,
              ":": r,
              "?": r,
              $: r,
              '"': i,
              "`": t
            }
          }), e.defineMIME("text/x-cassandra", {
            name: "sql",
            client: {},
            keywords: o("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
            builtin: o("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
            atoms: o("false true infinity NaN"),
            operatorChars: /^[<>=]/,
            dateSQL: {},
            support: o("commentSlashSlash decimallessFloat"),
            hooks: {}
          }), e.defineMIME("text/x-plsql", {
            name: "sql",
            client: o("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
            keywords: o("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
            builtin: o("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
            operatorChars: /^[*\/+\-%<>!=~]/,
            dateSQL: o("date time timestamp"),
            support: o("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
          }), e.defineMIME("text/x-hive", {
            name: "sql",
            keywords: o("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
            builtin: o("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
            atoms: o("false true null unknown"),
            operatorChars: /^[*+\-%<>!=]/,
            dateSQL: o("date timestamp"),
            support: o("doubleQuote binaryNumber hexNumber")
          }), e.defineMIME("text/x-pgsql", {
            name: "sql",
            client: o("source"),
            keywords: o(n + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
            builtin: o("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time zone timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
            atoms: o("false true null unknown"),
            operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
            backslashStringEscapes: !1,
            identifierQuote: '"',
            hooks: {
              '"': i
            },
            dateSQL: o("date time timestamp"),
            support: o("decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast escapeConstant")
          }), e.defineMIME("text/x-gql", {
            name: "sql",
            keywords: o("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
            atoms: o("false true"),
            builtin: o("blob datetime first key __key__ string integer double boolean null"),
            operatorChars: /^[*+\-%<>!=]/
          }), e.defineMIME("text/x-gpsql", {
            name: "sql",
            client: o("source"),
            keywords: o("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
            builtin: o("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
            atoms: o("false true null unknown"),
            operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
            dateSQL: o("date time timestamp"),
            support: o("decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
          }), e.defineMIME("text/x-sparksql", {
            name: "sql",
            keywords: o("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases data dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
            builtin: o("abs acos acosh add_months aggregate and any approx_count_distinct approx_percentile array array_contains array_distinct array_except array_intersect array_join array_max array_min array_position array_remove array_repeat array_sort array_union arrays_overlap arrays_zip ascii asin asinh assert_true atan atan2 atanh avg base64 between bigint bin binary bit_and bit_count bit_get bit_length bit_or bit_xor bool_and bool_or boolean bround btrim cardinality case cast cbrt ceil ceiling char char_length character_length chr coalesce collect_list collect_set concat concat_ws conv corr cos cosh cot count count_if count_min_sketch covar_pop covar_samp crc32 cume_dist current_catalog current_database current_date current_timestamp current_timezone current_user date date_add date_format date_from_unix_date date_part date_sub date_trunc datediff day dayofmonth dayofweek dayofyear decimal decode degrees delimited dense_rank div double e element_at elt encode every exists exp explode explode_outer expm1 extract factorial filter find_in_set first first_value flatten float floor forall format_number format_string from_csv from_json from_unixtime from_utc_timestamp get_json_object getbit greatest grouping grouping_id hash hex hour hypot if ifnull in initcap inline inline_outer input_file_block_length input_file_block_start input_file_name inputformat instr int isnan isnotnull isnull java_method json_array_length json_object_keys json_tuple kurtosis lag last last_day last_value lcase lead least left length levenshtein like ln locate log log10 log1p log2 lower lpad ltrim make_date make_dt_interval make_interval make_timestamp make_ym_interval map map_concat map_entries map_filter map_from_arrays map_from_entries map_keys map_values map_zip_with max max_by md5 mean min min_by minute mod monotonically_increasing_id month months_between named_struct nanvl negative next_day not now nth_value ntile nullif nvl nvl2 octet_length or outputformat overlay parse_url percent_rank percentile percentile_approx pi pmod posexplode posexplode_outer position positive pow power printf quarter radians raise_error rand randn random rank rcfile reflect regexp regexp_extract regexp_extract_all regexp_like regexp_replace repeat replace reverse right rint rlike round row_number rpad rtrim schema_of_csv schema_of_json second sentences sequence sequencefile serde session_window sha sha1 sha2 shiftleft shiftright shiftrightunsigned shuffle sign signum sin sinh size skewness slice smallint some sort_array soundex space spark_partition_id split sqrt stack std stddev stddev_pop stddev_samp str_to_map string struct substr substring substring_index sum tan tanh textfile timestamp timestamp_micros timestamp_millis timestamp_seconds tinyint to_csv to_date to_json to_timestamp to_unix_timestamp to_utc_timestamp transform transform_keys transform_values translate trim trunc try_add try_divide typeof ucase unbase64 unhex uniontype unix_date unix_micros unix_millis unix_seconds unix_timestamp upper uuid var_pop var_samp variance version weekday weekofyear when width_bucket window xpath xpath_boolean xpath_double xpath_float xpath_int xpath_long xpath_number xpath_short xpath_string xxhash64 year zip_with"),
            atoms: o("false true null"),
            operatorChars: /^[*\/+\-%<>!=~&|^]/,
            dateSQL: o("date time timestamp"),
            support: o("doubleQuote zerolessFloat")
          }), e.defineMIME("text/x-esper", {
            name: "sql",
            client: o("source"),
            keywords: o("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
            builtin: {},
            atoms: o("false true null"),
            operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
            dateSQL: o("time"),
            support: o("decimallessFloat zerolessFloat binaryNumber hexNumber")
          }), e.defineMIME("text/x-trino", {
            name: "sql",
            keywords: o("abs absent acos add admin after all all_match alter analyze and any any_match approx_distinct approx_most_frequent approx_percentile approx_set arbitrary array_agg array_distinct array_except array_intersect array_join array_max array_min array_position array_remove array_sort array_union arrays_overlap as asc asin at at_timezone atan atan2 authorization avg bar bernoulli beta_cdf between bing_tile bing_tile_at bing_tile_coordinates bing_tile_polygon bing_tile_quadkey bing_tile_zoom_level bing_tiles_around bit_count bitwise_and bitwise_and_agg bitwise_left_shift bitwise_not bitwise_or bitwise_or_agg bitwise_right_shift bitwise_right_shift_arithmetic bitwise_xor bool_and bool_or both by call cardinality cascade case cast catalogs cbrt ceil ceiling char2hexint checksum chr classify coalesce codepoint column columns combinations comment commit committed concat concat_ws conditional constraint contains contains_sequence convex_hull_agg copartition corr cos cosh cosine_similarity count count_if covar_pop covar_samp crc32 create cross cube cume_dist current current_catalog current_date current_groups current_path current_role current_schema current_time current_timestamp current_timezone current_user data date_add date_diff date_format date_parse date_trunc day day_of_month day_of_week day_of_year deallocate default define definer degrees delete dense_rank deny desc describe descriptor distinct distributed dow doy drop e element_at else empty empty_approx_set encoding end error escape evaluate_classifier_predictions every except excluding execute exists exp explain extract false features fetch filter final first first_value flatten floor following for format format_datetime format_number from from_base from_base32 from_base64 from_base64url from_big_endian_32 from_big_endian_64 from_encoded_polyline from_geojson_geometry from_hex from_ieee754_32 from_ieee754_64 from_iso8601_date from_iso8601_timestamp from_iso8601_timestamp_nanos from_unixtime from_unixtime_nanos from_utf8 full functions geometric_mean geometry_from_hadoop_shape geometry_invalid_reason geometry_nearest_points geometry_to_bing_tiles geometry_union geometry_union_agg grant granted grants graphviz great_circle_distance greatest group grouping groups hamming_distance hash_counts having histogram hmac_md5 hmac_sha1 hmac_sha256 hmac_sha512 hour human_readable_seconds if ignore in including index infinity initial inner input insert intersect intersection_cardinality into inverse_beta_cdf inverse_normal_cdf invoker io is is_finite is_infinite is_json_scalar is_nan isolation jaccard_index join json_array json_array_contains json_array_get json_array_length json_exists json_extract json_extract_scalar json_format json_object json_parse json_query json_size json_value keep key keys kurtosis lag last last_day_of_month last_value lateral lead leading learn_classifier learn_libsvm_classifier learn_libsvm_regressor learn_regressor least left length level levenshtein_distance like limit line_interpolate_point line_interpolate_points line_locate_point listagg ln local localtime localtimestamp log log10 log2 logical lower lpad ltrim luhn_check make_set_digest map_agg map_concat map_entries map_filter map_from_entries map_keys map_union map_values map_zip_with match match_recognize matched matches materialized max max_by md5 measures merge merge_set_digest millisecond min min_by minute mod month multimap_agg multimap_from_entries murmur3 nan natural next nfc nfd nfkc nfkd ngrams no none none_match normal_cdf normalize not now nth_value ntile null nullif nulls numeric_histogram object objectid_timestamp of offset omit on one only option or order ordinality outer output over overflow parse_data_size parse_datetime parse_duration partition partitions passing past path pattern per percent_rank permute pi position pow power preceding prepare privileges properties prune qdigest_agg quarter quotes radians rand random range rank read recursive reduce reduce_agg refresh regexp_count regexp_extract regexp_extract_all regexp_like regexp_position regexp_replace regexp_split regr_intercept regr_slope regress rename render repeat repeatable replace reset respect restrict returning reverse revoke rgb right role roles rollback rollup round row_number rows rpad rtrim running scalar schema schemas second security seek select sequence serializable session set sets sha1 sha256 sha512 show shuffle sign simplify_geometry sin skewness skip slice some soundex spatial_partitioning spatial_partitions split split_part split_to_map split_to_multimap spooky_hash_v2_32 spooky_hash_v2_64 sqrt st_area st_asbinary st_astext st_boundary st_buffer st_centroid st_contains st_convexhull st_coorddim st_crosses st_difference st_dimension st_disjoint st_distance st_endpoint st_envelope st_envelopeaspts st_equals st_exteriorring st_geometries st_geometryfromtext st_geometryn st_geometrytype st_geomfrombinary st_interiorringn st_interiorrings st_intersection st_intersects st_isclosed st_isempty st_isring st_issimple st_isvalid st_length st_linefromtext st_linestring st_multipoint st_numgeometries st_numinteriorring st_numpoints st_overlaps st_point st_pointn st_points st_polygon st_relate st_startpoint st_symdifference st_touches st_union st_within st_x st_xmax st_xmin st_y st_ymax st_ymin start starts_with stats stddev stddev_pop stddev_samp string strpos subset substr substring sum system table tables tablesample tan tanh tdigest_agg text then ties timestamp_objectid timezone_hour timezone_minute to to_base to_base32 to_base64 to_base64url to_big_endian_32 to_big_endian_64 to_char to_date to_encoded_polyline to_geojson_geometry to_geometry to_hex to_ieee754_32 to_ieee754_64 to_iso8601 to_milliseconds to_spherical_geography to_timestamp to_unixtime to_utf8 trailing transaction transform transform_keys transform_values translate trim trim_array true truncate try try_cast type typeof uescape unbounded uncommitted unconditional union unique unknown unmatched unnest update upper url_decode url_encode url_extract_fragment url_extract_host url_extract_parameter url_extract_path url_extract_port url_extract_protocol url_extract_query use user using utf16 utf32 utf8 validate value value_at_quantile values values_at_quantiles var_pop var_samp variance verbose version view week week_of_year when where width_bucket wilson_interval_lower wilson_interval_upper window with with_timezone within without word_stem work wrapper write xxhash64 year year_of_week yow zip zip_with"),
            builtin: o("array bigint bingtile boolean char codepoints color date decimal double function geometry hyperloglog int integer interval ipaddress joniregexp json json2016 jsonpath kdbtree likepattern map model objectid p4hyperloglog precision qdigest re2jregexp real regressor row setdigest smallint sphericalgeography tdigest time timestamp tinyint uuid varbinary varchar zone"),
            atoms: o("false true null unknown"),
            operatorChars: /^[[\]|<>=!\-+*/%]/,
            dateSQL: o("date time timestamp zone"),
            support: o("decimallessFloat zerolessFloat hexNumber")
          })
        }(i(237))
      },
      692: function(e, t) {
        var i;
        ! function(t, i) {
          "use strict";
          "object" == typeof e.exports ? e.exports = t.document ? i(t, !0) : function(e) {
            if (!e.document) throw new Error("jQuery requires a window with a document");
            return i(e)
          } : i(t)
        }("undefined" != typeof window ? window : this, function(r, s) {
          "use strict";
          var n = [],
            o = Object.getPrototypeOf,
            a = n.slice,
            l = n.flat ? function(e) {
              return n.flat.call(e)
            } : function(e) {
              return n.concat.apply([], e)
            },
            c = n.push,
            h = n.indexOf,
            u = {},
            d = u.toString,
            p = u.hasOwnProperty,
            E = p.toString,
            g = E.call(Object),
            f = {},
            T = function(e) {
              return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
            },
            m = function(e) {
              return null != e && e === e.window
            },
            C = r.document,
            S = {
              type: !0,
              src: !0,
              nonce: !0,
              noModule: !0
            };

          function R(e, t, i) {
            var r, s, n = (i = i || C).createElement("script");
            if (n.text = e, t)
              for (r in S)(s = t[r] || t.getAttribute && t.getAttribute(r)) && n.setAttribute(r, s);
            i.head.appendChild(n).parentNode.removeChild(n)
          }

          function A(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? u[d.call(e)] || "object" : typeof e
          }
          var v = "3.7.1",
            N = /HTML$/i,
            I = function(e, t) {
              return new I.fn.init(e, t)
            };

          function O(e) {
            var t = !!e && "length" in e && e.length,
              i = A(e);
            return !T(e) && !m(e) && ("array" === i || 0 === t || "number" == typeof t && t > 0 && t - 1 in e)
          }

          function L(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
          }
          I.fn = I.prototype = {
            jquery: v,
            constructor: I,
            length: 0,
            toArray: function() {
              return a.call(this)
            },
            get: function(e) {
              return null == e ? a.call(this) : e < 0 ? this[e + this.length] : this[e]
            },
            pushStack: function(e) {
              var t = I.merge(this.constructor(), e);
              return t.prevObject = this, t
            },
            each: function(e) {
              return I.each(this, e)
            },
            map: function(e) {
              return this.pushStack(I.map(this, function(t, i) {
                return e.call(t, i, t)
              }))
            },
            slice: function() {
              return this.pushStack(a.apply(this, arguments))
            },
            first: function() {
              return this.eq(0)
            },
            last: function() {
              return this.eq(-1)
            },
            even: function() {
              return this.pushStack(I.grep(this, function(e, t) {
                return (t + 1) % 2
              }))
            },
            odd: function() {
              return this.pushStack(I.grep(this, function(e, t) {
                return t % 2
              }))
            },
            eq: function(e) {
              var t = this.length,
                i = +e + (e < 0 ? t : 0);
              return this.pushStack(i >= 0 && i < t ? [this[i]] : [])
            },
            end: function() {
              return this.prevObject || this.constructor()
            },
            push: c,
            sort: n.sort,
            splice: n.splice
          }, I.extend = I.fn.extend = function() {
            var e, t, i, r, s, n, o = arguments[0] || {},
              a = 1,
              l = arguments.length,
              c = !1;
            for ("boolean" == typeof o && (c = o, o = arguments[a] || {}, a++), "object" == typeof o || T(o) || (o = {}), a === l && (o = this, a--); a < l; a++)
              if (null != (e = arguments[a]))
                for (t in e) r = e[t], "__proto__" !== t && o !== r && (c && r && (I.isPlainObject(r) || (s = Array.isArray(r))) ? (i = o[t], n = s && !Array.isArray(i) ? [] : s || I.isPlainObject(i) ? i : {}, s = !1, o[t] = I.extend(c, n, r)) : void 0 !== r && (o[t] = r));
            return o
          }, I.extend({
            expando: "jQuery" + (v + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(e) {
              throw new Error(e)
            },
            noop: function() {},
            isPlainObject: function(e) {
              var t, i;
              return !(!e || "[object Object]" !== d.call(e)) && (!(t = o(e)) || "function" == typeof(i = p.call(t, "constructor") && t.constructor) && E.call(i) === g)
            },
            isEmptyObject: function(e) {
              var t;
              for (t in e) return !1;
              return !0
            },
            globalEval: function(e, t, i) {
              R(e, {
                nonce: t && t.nonce
              }, i)
            },
            each: function(e, t) {
              var i, r = 0;
              if (O(e))
                for (i = e.length; r < i && !1 !== t.call(e[r], r, e[r]); r++);
              else
                for (r in e)
                  if (!1 === t.call(e[r], r, e[r])) break;
              return e
            },
            text: function(e) {
              var t, i = "",
                r = 0,
                s = e.nodeType;
              if (!s)
                for (; t = e[r++];) i += I.text(t);
              return 1 === s || 11 === s ? e.textContent : 9 === s ? e.documentElement.textContent : 3 === s || 4 === s ? e.nodeValue : i
            },
            makeArray: function(e, t) {
              var i = t || [];
              return null != e && (O(Object(e)) ? I.merge(i, "string" == typeof e ? [e] : e) : c.call(i, e)), i
            },
            inArray: function(e, t, i) {
              return null == t ? -1 : h.call(t, e, i)
            },
            isXMLDoc: function(e) {
              var t = e && e.namespaceURI,
                i = e && (e.ownerDocument || e).documentElement;
              return !N.test(t || i && i.nodeName || "HTML")
            },
            merge: function(e, t) {
              for (var i = +t.length, r = 0, s = e.length; r < i; r++) e[s++] = t[r];
              return e.length = s, e
            },
            grep: function(e, t, i) {
              for (var r = [], s = 0, n = e.length, o = !i; s < n; s++) !t(e[s], s) !== o && r.push(e[s]);
              return r
            },
            map: function(e, t, i) {
              var r, s, n = 0,
                o = [];
              if (O(e))
                for (r = e.length; n < r; n++) null != (s = t(e[n], n, i)) && o.push(s);
              else
                for (n in e) null != (s = t(e[n], n, i)) && o.push(s);
              return l(o)
            },
            guid: 1,
            support: f
          }), "function" == typeof Symbol && (I.fn[Symbol.iterator] = n[Symbol.iterator]), I.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
            u["[object " + t + "]"] = t.toLowerCase()
          });
          var _ = n.pop,
            y = n.sort,
            w = n.splice,
            D = "[\\x20\\t\\r\\n\\f]",
            P = new RegExp("^" + D + "+|((?:^|[^\\\\])(?:\\\\.)*)" + D + "+$", "g");
          I.contains = function(e, t) {
            var i = t && t.parentNode;
            return e === i || !(!i || 1 !== i.nodeType || !(e.contains ? e.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
          };
          var b = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

          function M(e, t) {
            return t ? "\0" === e ? "�" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
          }
          I.escapeSelector = function(e) {
            return (e + "").replace(b, M)
          };
          var F = C,
            x = c;
          ! function() {
            var e, t, i, s, o, l, c, u, d, E, g = x,
              T = I.expando,
              m = 0,
              C = 0,
              S = ee(),
              R = ee(),
              A = ee(),
              v = ee(),
              N = function(e, t) {
                return e === t && (o = !0), 0
              },
              O = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
              b = "(?:\\\\[\\da-fA-F]{1,6}" + D + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
              M = "\\[" + D + "*(" + b + ")(?:" + D + "*([*^$|!~]?=)" + D + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + b + "))|)" + D + "*\\]",
              G = ":(" + b + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + M + ")*)|.*)\\)|)",
              U = new RegExp(D + "+", "g"),
              H = new RegExp("^" + D + "*," + D + "*"),
              k = new RegExp("^" + D + "*([>+~]|" + D + ")" + D + "*"),
              B = new RegExp(D + "|>"),
              V = new RegExp(G),
              W = new RegExp("^" + b + "$"),
              Y = {
                ID: new RegExp("^#(" + b + ")"),
                CLASS: new RegExp("^\\.(" + b + ")"),
                TAG: new RegExp("^(" + b + "|[*])"),
                ATTR: new RegExp("^" + M),
                PSEUDO: new RegExp("^" + G),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + D + "*(even|odd|(([+-]|)(\\d*)n|)" + D + "*(?:([+-]|)" + D + "*(\\d+)|))" + D + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + O + ")$", "i"),
                needsContext: new RegExp("^" + D + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + D + "*((?:-\\d)?\\d*)" + D + "*\\)|)(?=[^-]|$)", "i")
              },
              K = /^(?:input|select|textarea|button)$/i,
              X = /^h\d$/i,
              z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
              $ = /[+~]/,
              j = new RegExp("\\\\[\\da-fA-F]{1,6}" + D + "?|\\\\([^\\r\\n\\f])", "g"),
              J = function(e, t) {
                var i = "0x" + e.slice(1) - 65536;
                return t || (i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320))
              },
              q = function() {
                le()
              },
              Q = de(function(e) {
                return !0 === e.disabled && L(e, "fieldset")
              }, {
                dir: "parentNode",
                next: "legend"
              });
            try {
              g.apply(n = a.call(F.childNodes), F.childNodes), n[F.childNodes.length].nodeType
            } catch (e) {
              g = {
                apply: function(e, t) {
                  x.apply(e, a.call(t))
                },
                call: function(e) {
                  x.apply(e, a.call(arguments, 1))
                }
              }
            }

            function Z(e, t, i, r) {
              var s, n, o, a, c, h, p, E = t && t.ownerDocument,
                m = t ? t.nodeType : 9;
              if (i = i || [], "string" != typeof e || !e || 1 !== m && 9 !== m && 11 !== m) return i;
              if (!r && (le(t), t = t || l, u)) {
                if (11 !== m && (c = z.exec(e)))
                  if (s = c[1]) {
                    if (9 === m) {
                      if (!(o = t.getElementById(s))) return i;
                      if (o.id === s) return g.call(i, o), i
                    } else if (E && (o = E.getElementById(s)) && Z.contains(t, o) && o.id === s) return g.call(i, o), i
                  } else {
                    if (c[2]) return g.apply(i, t.getElementsByTagName(e)), i;
                    if ((s = c[3]) && t.getElementsByClassName) return g.apply(i, t.getElementsByClassName(s)), i
                  } if (!(v[e + " "] || d && d.test(e))) {
                  if (p = e, E = t, 1 === m && (B.test(e) || k.test(e))) {
                    for ((E = $.test(e) && ae(t.parentNode) || t) == t && f.scope || ((a = t.getAttribute("id")) ? a = I.escapeSelector(a) : t.setAttribute("id", a = T)), n = (h = he(e)).length; n--;) h[n] = (a ? "#" + a : ":scope") + " " + ue(h[n]);
                    p = h.join(",")
                  }
                  try {
                    return g.apply(i, E.querySelectorAll(p)), i
                  } catch (t) {
                    v(e, !0)
                  } finally {
                    a === T && t.removeAttribute("id")
                  }
                }
              }
              return me(e.replace(P, "$1"), t, i, r)
            }

            function ee() {
              var e = [];
              return function i(r, s) {
                return e.push(r + " ") > t.cacheLength && delete i[e.shift()], i[r + " "] = s
              }
            }

            function te(e) {
              return e[T] = !0, e
            }

            function ie(e) {
              var t = l.createElement("fieldset");
              try {
                return !!e(t)
              } catch (e) {
                return !1
              } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null
              }
            }

            function re(e) {
              return function(t) {
                return L(t, "input") && t.type === e
              }
            }

            function se(e) {
              return function(t) {
                return (L(t, "input") || L(t, "button")) && t.type === e
              }
            }

            function ne(e) {
              return function(t) {
                return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && Q(t) === e : t.disabled === e : "label" in t && t.disabled === e
              }
            }

            function oe(e) {
              return te(function(t) {
                return t = +t, te(function(i, r) {
                  for (var s, n = e([], i.length, t), o = n.length; o--;) i[s = n[o]] && (i[s] = !(r[s] = i[s]))
                })
              })
            }

            function ae(e) {
              return e && void 0 !== e.getElementsByTagName && e
            }

            function le(e) {
              var i, r = e ? e.ownerDocument || e : F;
              return r != l && 9 === r.nodeType && r.documentElement ? (c = (l = r).documentElement, u = !I.isXMLDoc(l), E = c.matches || c.webkitMatchesSelector || c.msMatchesSelector, c.msMatchesSelector && F != l && (i = l.defaultView) && i.top !== i && i.addEventListener("unload", q), f.getById = ie(function(e) {
                return c.appendChild(e).id = I.expando, !l.getElementsByName || !l.getElementsByName(I.expando).length
              }), f.disconnectedMatch = ie(function(e) {
                return E.call(e, "*")
              }), f.scope = ie(function() {
                return l.querySelectorAll(":scope")
              }), f.cssHas = ie(function() {
                try {
                  return l.querySelector(":has(*,:jqfake)"), !1
                } catch (e) {
                  return !0
                }
              }), f.getById ? (t.filter.ID = function(e) {
                var t = e.replace(j, J);
                return function(e) {
                  return e.getAttribute("id") === t
                }
              }, t.find.ID = function(e, t) {
                if (void 0 !== t.getElementById && u) {
                  var i = t.getElementById(e);
                  return i ? [i] : []
                }
              }) : (t.filter.ID = function(e) {
                var t = e.replace(j, J);
                return function(e) {
                  var i = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                  return i && i.value === t
                }
              }, t.find.ID = function(e, t) {
                if (void 0 !== t.getElementById && u) {
                  var i, r, s, n = t.getElementById(e);
                  if (n) {
                    if ((i = n.getAttributeNode("id")) && i.value === e) return [n];
                    for (s = t.getElementsByName(e), r = 0; n = s[r++];)
                      if ((i = n.getAttributeNode("id")) && i.value === e) return [n]
                  }
                  return []
                }
              }), t.find.TAG = function(e, t) {
                return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : t.querySelectorAll(e)
              }, t.find.CLASS = function(e, t) {
                if (void 0 !== t.getElementsByClassName && u) return t.getElementsByClassName(e)
              }, d = [], ie(function(e) {
                var t;
                c.appendChild(e).innerHTML = "<a id='" + T + "' href='' disabled='disabled'></a><select id='" + T + "-\r\\' disabled='disabled'><option selected=''></option></select>", e.querySelectorAll("[selected]").length || d.push("\\[" + D + "*(?:value|" + O + ")"), e.querySelectorAll("[id~=" + T + "-]").length || d.push("~="), e.querySelectorAll("a#" + T + "+*").length || d.push(".#.+[+~]"), e.querySelectorAll(":checked").length || d.push(":checked"), (t = l.createElement("input")).setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), c.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && d.push(":enabled", ":disabled"), (t = l.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || d.push("\\[" + D + "*name" + D + "*=" + D + "*(?:''|\"\")")
              }), f.cssHas || d.push(":has"), d = d.length && new RegExp(d.join("|")), N = function(e, t) {
                if (e === t) return o = !0, 0;
                var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return i || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !f.sortDetached && t.compareDocumentPosition(e) === i ? e === l || e.ownerDocument == F && Z.contains(F, e) ? -1 : t === l || t.ownerDocument == F && Z.contains(F, t) ? 1 : s ? h.call(s, e) - h.call(s, t) : 0 : 4 & i ? -1 : 1)
              }, l) : l
            }
            for (e in Z.matches = function(e, t) {
                return Z(e, null, null, t)
              }, Z.matchesSelector = function(e, t) {
                if (le(e), u && !v[t + " "] && (!d || !d.test(t))) try {
                  var i = E.call(e, t);
                  if (i || f.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                } catch (e) {
                  v(t, !0)
                }
                return Z(t, l, null, [e]).length > 0
              }, Z.contains = function(e, t) {
                return (e.ownerDocument || e) != l && le(e), I.contains(e, t)
              }, Z.attr = function(e, i) {
                (e.ownerDocument || e) != l && le(e);
                var r = t.attrHandle[i.toLowerCase()],
                  s = r && p.call(t.attrHandle, i.toLowerCase()) ? r(e, i, !u) : void 0;
                return void 0 !== s ? s : e.getAttribute(i)
              }, Z.error = function(e) {
                throw new Error("Syntax error, unrecognized expression: " + e)
              }, I.uniqueSort = function(e) {
                var t, i = [],
                  r = 0,
                  n = 0;
                if (o = !f.sortStable, s = !f.sortStable && a.call(e, 0), y.call(e, N), o) {
                  for (; t = e[n++];) t === e[n] && (r = i.push(n));
                  for (; r--;) w.call(e, i[r], 1)
                }
                return s = null, e
              }, I.fn.uniqueSort = function() {
                return this.pushStack(I.uniqueSort(a.apply(this)))
              }, t = I.expr = {
                cacheLength: 50,
                createPseudo: te,
                match: Y,
                attrHandle: {},
                find: {},
                relative: {
                  ">": {
                    dir: "parentNode",
                    first: !0
                  },
                  " ": {
                    dir: "parentNode"
                  },
                  "+": {
                    dir: "previousSibling",
                    first: !0
                  },
                  "~": {
                    dir: "previousSibling"
                  }
                },
                preFilter: {
                  ATTR: function(e) {
                    return e[1] = e[1].replace(j, J), e[3] = (e[3] || e[4] || e[5] || "").replace(j, J), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                  },
                  CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || Z.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && Z.error(e[0]), e
                  },
                  PSEUDO: function(e) {
                    var t, i = !e[6] && e[2];
                    return Y.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && V.test(i) && (t = he(i, !0)) && (t = i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3))
                  }
                },
                filter: {
                  TAG: function(e) {
                    var t = e.replace(j, J).toLowerCase();
                    return "*" === e ? function() {
                      return !0
                    } : function(e) {
                      return L(e, t)
                    }
                  },
                  CLASS: function(e) {
                    var t = S[e + " "];
                    return t || (t = new RegExp("(^|" + D + ")" + e + "(" + D + "|$)")) && S(e, function(e) {
                      return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                    })
                  },
                  ATTR: function(e, t, i) {
                    return function(r) {
                      var s = Z.attr(r, e);
                      return null == s ? "!=" === t : !t || (s += "", "=" === t ? s === i : "!=" === t ? s !== i : "^=" === t ? i && 0 === s.indexOf(i) : "*=" === t ? i && s.indexOf(i) > -1 : "$=" === t ? i && s.slice(-i.length) === i : "~=" === t ? (" " + s.replace(U, " ") + " ").indexOf(i) > -1 : "|=" === t && (s === i || s.slice(0, i.length + 1) === i + "-"))
                    }
                  },
                  CHILD: function(e, t, i, r, s) {
                    var n = "nth" !== e.slice(0, 3),
                      o = "last" !== e.slice(-4),
                      a = "of-type" === t;
                    return 1 === r && 0 === s ? function(e) {
                      return !!e.parentNode
                    } : function(t, i, l) {
                      var c, h, u, d, p, E = n !== o ? "nextSibling" : "previousSibling",
                        g = t.parentNode,
                        f = a && t.nodeName.toLowerCase(),
                        C = !l && !a,
                        S = !1;
                      if (g) {
                        if (n) {
                          for (; E;) {
                            for (u = t; u = u[E];)
                              if (a ? L(u, f) : 1 === u.nodeType) return !1;
                            p = E = "only" === e && !p && "nextSibling"
                          }
                          return !0
                        }
                        if (p = [o ? g.firstChild : g.lastChild], o && C) {
                          for (S = (d = (c = (h = g[T] || (g[T] = {}))[e] || [])[0] === m && c[1]) && c[2], u = d && g.childNodes[d]; u = ++d && u && u[E] || (S = d = 0) || p.pop();)
                            if (1 === u.nodeType && ++S && u === t) {
                              h[e] = [m, d, S];
                              break
                            }
                        } else if (C && (S = d = (c = (h = t[T] || (t[T] = {}))[e] || [])[0] === m && c[1]), !1 === S)
                          for (;
                            (u = ++d && u && u[E] || (S = d = 0) || p.pop()) && (!(a ? L(u, f) : 1 === u.nodeType) || !++S || (C && ((h = u[T] || (u[T] = {}))[e] = [m, S]), u !== t)););
                        return (S -= s) === r || S % r === 0 && S / r >= 0
                      }
                    }
                  },
                  PSEUDO: function(e, i) {
                    var r, s = t.pseudos[e] || t.setFilters[e.toLowerCase()] || Z.error("unsupported pseudo: " + e);
                    return s[T] ? s(i) : s.length > 1 ? (r = [e, e, "", i], t.setFilters.hasOwnProperty(e.toLowerCase()) ? te(function(e, t) {
                      for (var r, n = s(e, i), o = n.length; o--;) e[r = h.call(e, n[o])] = !(t[r] = n[o])
                    }) : function(e) {
                      return s(e, 0, r)
                    }) : s
                  }
                },
                pseudos: {
                  not: te(function(e) {
                    var t = [],
                      i = [],
                      r = Te(e.replace(P, "$1"));
                    return r[T] ? te(function(e, t, i, s) {
                      for (var n, o = r(e, null, s, []), a = e.length; a--;)(n = o[a]) && (e[a] = !(t[a] = n))
                    }) : function(e, s, n) {
                      return t[0] = e, r(t, null, n, i), t[0] = null, !i.pop()
                    }
                  }),
                  has: te(function(e) {
                    return function(t) {
                      return Z(e, t).length > 0
                    }
                  }),
                  contains: te(function(e) {
                    return e = e.replace(j, J),
                      function(t) {
                        return (t.textContent || I.text(t)).indexOf(e) > -1
                      }
                  }),
                  lang: te(function(e) {
                    return W.test(e || "") || Z.error("unsupported lang: " + e), e = e.replace(j, J).toLowerCase(),
                      function(t) {
                        var i;
                        do {
                          if (i = u ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (i = i.toLowerCase()) === e || 0 === i.indexOf(e + "-")
                        } while ((t = t.parentNode) && 1 === t.nodeType);
                        return !1
                      }
                  }),
                  target: function(e) {
                    var t = r.location && r.location.hash;
                    return t && t.slice(1) === e.id
                  },
                  root: function(e) {
                    return e === c
                  },
                  focus: function(e) {
                    return e === function() {
                      try {
                        return l.activeElement
                      } catch (e) {}
                    }() && l.hasFocus() && !!(e.type || e.href || ~e.tabIndex)
                  },
                  enabled: ne(!1),
                  disabled: ne(!0),
                  checked: function(e) {
                    return L(e, "input") && !!e.checked || L(e, "option") && !!e.selected
                  },
                  selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                  },
                  empty: function(e) {
                    for (e = e.firstChild; e; e = e.nextSibling)
                      if (e.nodeType < 6) return !1;
                    return !0
                  },
                  parent: function(e) {
                    return !t.pseudos.empty(e)
                  },
                  header: function(e) {
                    return X.test(e.nodeName)
                  },
                  input: function(e) {
                    return K.test(e.nodeName)
                  },
                  button: function(e) {
                    return L(e, "input") && "button" === e.type || L(e, "button")
                  },
                  text: function(e) {
                    var t;
                    return L(e, "input") && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                  },
                  first: oe(function() {
                    return [0]
                  }),
                  last: oe(function(e, t) {
                    return [t - 1]
                  }),
                  eq: oe(function(e, t, i) {
                    return [i < 0 ? i + t : i]
                  }),
                  even: oe(function(e, t) {
                    for (var i = 0; i < t; i += 2) e.push(i);
                    return e
                  }),
                  odd: oe(function(e, t) {
                    for (var i = 1; i < t; i += 2) e.push(i);
                    return e
                  }),
                  lt: oe(function(e, t, i) {
                    var r;
                    for (r = i < 0 ? i + t : i > t ? t : i; --r >= 0;) e.push(r);
                    return e
                  }),
                  gt: oe(function(e, t, i) {
                    for (var r = i < 0 ? i + t : i; ++r < t;) e.push(r);
                    return e
                  })
                }
              }, t.pseudos.nth = t.pseudos.eq, {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
              }) t.pseudos[e] = re(e);
            for (e in {
                submit: !0,
                reset: !0
              }) t.pseudos[e] = se(e);

            function ce() {}

            function he(e, i) {
              var r, s, n, o, a, l, c, h = R[e + " "];
              if (h) return i ? 0 : h.slice(0);
              for (a = e, l = [], c = t.preFilter; a;) {
                for (o in r && !(s = H.exec(a)) || (s && (a = a.slice(s[0].length) || a), l.push(n = [])), r = !1, (s = k.exec(a)) && (r = s.shift(), n.push({
                    value: r,
                    type: s[0].replace(P, " ")
                  }), a = a.slice(r.length)), t.filter) !(s = Y[o].exec(a)) || c[o] && !(s = c[o](s)) || (r = s.shift(), n.push({
                  value: r,
                  type: o,
                  matches: s
                }), a = a.slice(r.length));
                if (!r) break
              }
              return i ? a.length : a ? Z.error(e) : R(e, l).slice(0)
            }

            function ue(e) {
              for (var t = 0, i = e.length, r = ""; t < i; t++) r += e[t].value;
              return r
            }

            function de(e, t, i) {
              var r = t.dir,
                s = t.next,
                n = s || r,
                o = i && "parentNode" === n,
                a = C++;
              return t.first ? function(t, i, s) {
                for (; t = t[r];)
                  if (1 === t.nodeType || o) return e(t, i, s);
                return !1
              } : function(t, i, l) {
                var c, h, u = [m, a];
                if (l) {
                  for (; t = t[r];)
                    if ((1 === t.nodeType || o) && e(t, i, l)) return !0
                } else
                  for (; t = t[r];)
                    if (1 === t.nodeType || o)
                      if (h = t[T] || (t[T] = {}), s && L(t, s)) t = t[r] || t;
                      else {
                        if ((c = h[n]) && c[0] === m && c[1] === a) return u[2] = c[2];
                        if (h[n] = u, u[2] = e(t, i, l)) return !0
                      } return !1
              }
            }

            function pe(e) {
              return e.length > 1 ? function(t, i, r) {
                for (var s = e.length; s--;)
                  if (!e[s](t, i, r)) return !1;
                return !0
              } : e[0]
            }

            function Ee(e, t, i, r, s) {
              for (var n, o = [], a = 0, l = e.length, c = null != t; a < l; a++)(n = e[a]) && (i && !i(n, r, s) || (o.push(n), c && t.push(a)));
              return o
            }

            function ge(e, t, i, r, s, n) {
              return r && !r[T] && (r = ge(r)), s && !s[T] && (s = ge(s, n)), te(function(n, o, a, l) {
                var c, u, d, p, E = [],
                  f = [],
                  T = o.length,
                  m = n || function(e, t, i) {
                    for (var r = 0, s = t.length; r < s; r++) Z(e, t[r], i);
                    return i
                  }(t || "*", a.nodeType ? [a] : a, []),
                  C = !e || !n && t ? m : Ee(m, E, e, a, l);
                if (i ? i(C, p = s || (n ? e : T || r) ? [] : o, a, l) : p = C, r)
                  for (c = Ee(p, f), r(c, [], a, l), u = c.length; u--;)(d = c[u]) && (p[f[u]] = !(C[f[u]] = d));
                if (n) {
                  if (s || e) {
                    if (s) {
                      for (c = [], u = p.length; u--;)(d = p[u]) && c.push(C[u] = d);
                      s(null, p = [], c, l)
                    }
                    for (u = p.length; u--;)(d = p[u]) && (c = s ? h.call(n, d) : E[u]) > -1 && (n[c] = !(o[c] = d))
                  }
                } else p = Ee(p === o ? p.splice(T, p.length) : p), s ? s(null, o, p, l) : g.apply(o, p)
              })
            }

            function fe(e) {
              for (var r, s, n, o = e.length, a = t.relative[e[0].type], l = a || t.relative[" "], c = a ? 1 : 0, u = de(function(e) {
                  return e === r
                }, l, !0), d = de(function(e) {
                  return h.call(r, e) > -1
                }, l, !0), p = [function(e, t, s) {
                  var n = !a && (s || t != i) || ((r = t).nodeType ? u(e, t, s) : d(e, t, s));
                  return r = null, n
                }]; c < o; c++)
                if (s = t.relative[e[c].type]) p = [de(pe(p), s)];
                else {
                  if ((s = t.filter[e[c].type].apply(null, e[c].matches))[T]) {
                    for (n = ++c; n < o && !t.relative[e[n].type]; n++);
                    return ge(c > 1 && pe(p), c > 1 && ue(e.slice(0, c - 1).concat({
                      value: " " === e[c - 2].type ? "*" : ""
                    })).replace(P, "$1"), s, c < n && fe(e.slice(c, n)), n < o && fe(e = e.slice(n)), n < o && ue(e))
                  }
                  p.push(s)
                } return pe(p)
            }

            function Te(e, r) {
              var s, n = [],
                o = [],
                a = A[e + " "];
              if (!a) {
                for (r || (r = he(e)), s = r.length; s--;)(a = fe(r[s]))[T] ? n.push(a) : o.push(a);
                a = A(e, function(e, r) {
                  var s = r.length > 0,
                    n = e.length > 0,
                    o = function(o, a, c, h, d) {
                      var p, E, f, T = 0,
                        C = "0",
                        S = o && [],
                        R = [],
                        A = i,
                        v = o || n && t.find.TAG("*", d),
                        N = m += null == A ? 1 : Math.random() || .1,
                        O = v.length;
                      for (d && (i = a == l || a || d); C !== O && null != (p = v[C]); C++) {
                        if (n && p) {
                          for (E = 0, a || p.ownerDocument == l || (le(p), c = !u); f = e[E++];)
                            if (f(p, a || l, c)) {
                              g.call(h, p);
                              break
                            } d && (m = N)
                        }
                        s && ((p = !f && p) && T--, o && S.push(p))
                      }
                      if (T += C, s && C !== T) {
                        for (E = 0; f = r[E++];) f(S, R, a, c);
                        if (o) {
                          if (T > 0)
                            for (; C--;) S[C] || R[C] || (R[C] = _.call(h));
                          R = Ee(R)
                        }
                        g.apply(h, R), d && !o && R.length > 0 && T + r.length > 1 && I.uniqueSort(h)
                      }
                      return d && (m = N, i = A), S
                    };
                  return s ? te(o) : o
                }(o, n)), a.selector = e
              }
              return a
            }

            function me(e, i, r, s) {
              var n, o, a, l, c, h = "function" == typeof e && e,
                d = !s && he(e = h.selector || e);
              if (r = r || [], 1 === d.length) {
                if ((o = d[0] = d[0].slice(0)).length > 2 && "ID" === (a = o[0]).type && 9 === i.nodeType && u && t.relative[o[1].type]) {
                  if (!(i = (t.find.ID(a.matches[0].replace(j, J), i) || [])[0])) return r;
                  h && (i = i.parentNode), e = e.slice(o.shift().value.length)
                }
                for (n = Y.needsContext.test(e) ? 0 : o.length; n-- && (a = o[n], !t.relative[l = a.type]);)
                  if ((c = t.find[l]) && (s = c(a.matches[0].replace(j, J), $.test(o[0].type) && ae(i.parentNode) || i))) {
                    if (o.splice(n, 1), !(e = s.length && ue(o))) return g.apply(r, s), r;
                    break
                  }
              }
              return (h || Te(e, d))(s, i, !u, r, !i || $.test(e) && ae(i.parentNode) || i), r
            }
            ce.prototype = t.filters = t.pseudos, t.setFilters = new ce, f.sortStable = T.split("").sort(N).join("") === T, le(), f.sortDetached = ie(function(e) {
              return 1 & e.compareDocumentPosition(l.createElement("fieldset"))
            }), I.find = Z, I.expr[":"] = I.expr.pseudos, I.unique = I.uniqueSort, Z.compile = Te, Z.select = me, Z.setDocument = le, Z.tokenize = he, Z.escape = I.escapeSelector, Z.getText = I.text, Z.isXML = I.isXMLDoc, Z.selectors = I.expr, Z.support = I.support, Z.uniqueSort = I.uniqueSort
          }();
          var G = function(e, t, i) {
              for (var r = [], s = void 0 !== i;
                (e = e[t]) && 9 !== e.nodeType;)
                if (1 === e.nodeType) {
                  if (s && I(e).is(i)) break;
                  r.push(e)
                } return r
            },
            U = function(e, t) {
              for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
              return i
            },
            H = I.expr.match.needsContext,
            k = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

          function B(e, t, i) {
            return T(t) ? I.grep(e, function(e, r) {
              return !!t.call(e, r, e) !== i
            }) : t.nodeType ? I.grep(e, function(e) {
              return e === t !== i
            }) : "string" != typeof t ? I.grep(e, function(e) {
              return h.call(t, e) > -1 !== i
            }) : I.filter(t, e, i)
          }
          I.filter = function(e, t, i) {
            var r = t[0];
            return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? I.find.matchesSelector(r, e) ? [r] : [] : I.find.matches(e, I.grep(t, function(e) {
              return 1 === e.nodeType
            }))
          }, I.fn.extend({
            find: function(e) {
              var t, i, r = this.length,
                s = this;
              if ("string" != typeof e) return this.pushStack(I(e).filter(function() {
                for (t = 0; t < r; t++)
                  if (I.contains(s[t], this)) return !0
              }));
              for (i = this.pushStack([]), t = 0; t < r; t++) I.find(e, s[t], i);
              return r > 1 ? I.uniqueSort(i) : i
            },
            filter: function(e) {
              return this.pushStack(B(this, e || [], !1))
            },
            not: function(e) {
              return this.pushStack(B(this, e || [], !0))
            },
            is: function(e) {
              return !!B(this, "string" == typeof e && H.test(e) ? I(e) : e || [], !1).length
            }
          });
          var V, W = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
          (I.fn.init = function(e, t, i) {
            var r, s;
            if (!e) return this;
            if (i = i || V, "string" == typeof e) {
              if (!(r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : W.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || i).find(e) : this.constructor(t).find(e);
              if (r[1]) {
                if (t = t instanceof I ? t[0] : t, I.merge(this, I.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : C, !0)), k.test(r[1]) && I.isPlainObject(t))
                  for (r in t) T(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this
              }
              return (s = C.getElementById(r[2])) && (this[0] = s, this.length = 1), this
            }
            return e.nodeType ? (this[0] = e, this.length = 1, this) : T(e) ? void 0 !== i.ready ? i.ready(e) : e(I) : I.makeArray(e, this)
          }).prototype = I.fn, V = I(C);
          var Y = /^(?:parents|prev(?:Until|All))/,
            K = {
              children: !0,
              contents: !0,
              next: !0,
              prev: !0
            };

          function X(e, t) {
            for (;
              (e = e[t]) && 1 !== e.nodeType;);
            return e
          }
          I.fn.extend({
            has: function(e) {
              var t = I(e, this),
                i = t.length;
              return this.filter(function() {
                for (var e = 0; e < i; e++)
                  if (I.contains(this, t[e])) return !0
              })
            },
            closest: function(e, t) {
              var i, r = 0,
                s = this.length,
                n = [],
                o = "string" != typeof e && I(e);
              if (!H.test(e))
                for (; r < s; r++)
                  for (i = this[r]; i && i !== t; i = i.parentNode)
                    if (i.nodeType < 11 && (o ? o.index(i) > -1 : 1 === i.nodeType && I.find.matchesSelector(i, e))) {
                      n.push(i);
                      break
                    } return this.pushStack(n.length > 1 ? I.uniqueSort(n) : n)
            },
            index: function(e) {
              return e ? "string" == typeof e ? h.call(I(e), this[0]) : h.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(e, t) {
              return this.pushStack(I.uniqueSort(I.merge(this.get(), I(e, t))))
            },
            addBack: function(e) {
              return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
            }
          }), I.each({
            parent: function(e) {
              var t = e.parentNode;
              return t && 11 !== t.nodeType ? t : null
            },
            parents: function(e) {
              return G(e, "parentNode")
            },
            parentsUntil: function(e, t, i) {
              return G(e, "parentNode", i)
            },
            next: function(e) {
              return X(e, "nextSibling")
            },
            prev: function(e) {
              return X(e, "previousSibling")
            },
            nextAll: function(e) {
              return G(e, "nextSibling")
            },
            prevAll: function(e) {
              return G(e, "previousSibling")
            },
            nextUntil: function(e, t, i) {
              return G(e, "nextSibling", i)
            },
            prevUntil: function(e, t, i) {
              return G(e, "previousSibling", i)
            },
            siblings: function(e) {
              return U((e.parentNode || {}).firstChild, e)
            },
            children: function(e) {
              return U(e.firstChild)
            },
            contents: function(e) {
              return null != e.contentDocument && o(e.contentDocument) ? e.contentDocument : (L(e, "template") && (e = e.content || e), I.merge([], e.childNodes))
            }
          }, function(e, t) {
            I.fn[e] = function(i, r) {
              var s = I.map(this, t, i);
              return "Until" !== e.slice(-5) && (r = i), r && "string" == typeof r && (s = I.filter(r, s)), this.length > 1 && (K[e] || I.uniqueSort(s), Y.test(e) && s.reverse()), this.pushStack(s)
            }
          });
          var z = /[^\x20\t\r\n\f]+/g;

          function $(e) {
            return e
          }

          function j(e) {
            throw e
          }

          function J(e, t, i, r) {
            var s;
            try {
              e && T(s = e.promise) ? s.call(e).done(t).fail(i) : e && T(s = e.then) ? s.call(e, t, i) : t.apply(void 0, [e].slice(r))
            } catch (e) {
              i.apply(void 0, [e])
            }
          }
          I.Callbacks = function(e) {
            e = "string" == typeof e ? function(e) {
              var t = {};
              return I.each(e.match(z) || [], function(e, i) {
                t[i] = !0
              }), t
            }(e) : I.extend({}, e);
            var t, i, r, s, n = [],
              o = [],
              a = -1,
              l = function() {
                for (s = s || e.once, r = t = !0; o.length; a = -1)
                  for (i = o.shift(); ++a < n.length;) !1 === n[a].apply(i[0], i[1]) && e.stopOnFalse && (a = n.length, i = !1);
                e.memory || (i = !1), t = !1, s && (n = i ? [] : "")
              },
              c = {
                add: function() {
                  return n && (i && !t && (a = n.length - 1, o.push(i)), function t(i) {
                    I.each(i, function(i, r) {
                      T(r) ? e.unique && c.has(r) || n.push(r) : r && r.length && "string" !== A(r) && t(r)
                    })
                  }(arguments), i && !t && l()), this
                },
                remove: function() {
                  return I.each(arguments, function(e, t) {
                    for (var i;
                      (i = I.inArray(t, n, i)) > -1;) n.splice(i, 1), i <= a && a--
                  }), this
                },
                has: function(e) {
                  return e ? I.inArray(e, n) > -1 : n.length > 0
                },
                empty: function() {
                  return n && (n = []), this
                },
                disable: function() {
                  return s = o = [], n = i = "", this
                },
                disabled: function() {
                  return !n
                },
                lock: function() {
                  return s = o = [], i || t || (n = i = ""), this
                },
                locked: function() {
                  return !!s
                },
                fireWith: function(e, i) {
                  return s || (i = [e, (i = i || []).slice ? i.slice() : i], o.push(i), t || l()), this
                },
                fire: function() {
                  return c.fireWith(this, arguments), this
                },
                fired: function() {
                  return !!r
                }
              };
            return c
          }, I.extend({
            Deferred: function(e) {
              var t = [
                  ["notify", "progress", I.Callbacks("memory"), I.Callbacks("memory"), 2],
                  ["resolve", "done", I.Callbacks("once memory"), I.Callbacks("once memory"), 0, "resolved"],
                  ["reject", "fail", I.Callbacks("once memory"), I.Callbacks("once memory"), 1, "rejected"]
                ],
                i = "pending",
                s = {
                  state: function() {
                    return i
                  },
                  always: function() {
                    return n.done(arguments).fail(arguments), this
                  },
                  catch: function(e) {
                    return s.then(null, e)
                  },
                  pipe: function() {
                    var e = arguments;
                    return I.Deferred(function(i) {
                      I.each(t, function(t, r) {
                        var s = T(e[r[4]]) && e[r[4]];
                        n[r[1]](function() {
                          var e = s && s.apply(this, arguments);
                          e && T(e.promise) ? e.promise().progress(i.notify).done(i.resolve).fail(i.reject) : i[r[0] + "With"](this, s ? [e] : arguments)
                        })
                      }), e = null
                    }).promise()
                  },
                  then: function(e, i, s) {
                    var n = 0;

                    function o(e, t, i, s) {
                      return function() {
                        var a = this,
                          l = arguments,
                          c = function() {
                            var r, c;
                            if (!(e < n)) {
                              if ((r = i.apply(a, l)) === t.promise()) throw new TypeError("Thenable self-resolution");
                              c = r && ("object" == typeof r || "function" == typeof r) && r.then, T(c) ? s ? c.call(r, o(n, t, $, s), o(n, t, j, s)) : (n++, c.call(r, o(n, t, $, s), o(n, t, j, s), o(n, t, $, t.notifyWith))) : (i !== $ && (a = void 0, l = [r]), (s || t.resolveWith)(a, l))
                            }
                          },
                          h = s ? c : function() {
                            try {
                              c()
                            } catch (r) {
                              I.Deferred.exceptionHook && I.Deferred.exceptionHook(r, h.error), e + 1 >= n && (i !== j && (a = void 0, l = [r]), t.rejectWith(a, l))
                            }
                          };
                        e ? h() : (I.Deferred.getErrorHook ? h.error = I.Deferred.getErrorHook() : I.Deferred.getStackHook && (h.error = I.Deferred.getStackHook()), r.setTimeout(h))
                      }
                    }
                    return I.Deferred(function(r) {
                      t[0][3].add(o(0, r, T(s) ? s : $, r.notifyWith)), t[1][3].add(o(0, r, T(e) ? e : $)), t[2][3].add(o(0, r, T(i) ? i : j))
                    }).promise()
                  },
                  promise: function(e) {
                    return null != e ? I.extend(e, s) : s
                  }
                },
                n = {};
              return I.each(t, function(e, r) {
                var o = r[2],
                  a = r[5];
                s[r[1]] = o.add, a && o.add(function() {
                  i = a
                }, t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), o.add(r[3].fire), n[r[0]] = function() {
                  return n[r[0] + "With"](this === n ? void 0 : this, arguments), this
                }, n[r[0] + "With"] = o.fireWith
              }), s.promise(n), e && e.call(n, n), n
            },
            when: function(e) {
              var t = arguments.length,
                i = t,
                r = Array(i),
                s = a.call(arguments),
                n = I.Deferred(),
                o = function(e) {
                  return function(i) {
                    r[e] = this, s[e] = arguments.length > 1 ? a.call(arguments) : i, --t || n.resolveWith(r, s)
                  }
                };
              if (t <= 1 && (J(e, n.done(o(i)).resolve, n.reject, !t), "pending" === n.state() || T(s[i] && s[i].then))) return n.then();
              for (; i--;) J(s[i], o(i), n.reject);
              return n.promise()
            }
          });
          var q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
          I.Deferred.exceptionHook = function(e, t) {
            r.console && r.console.warn && e && q.test(e.name) && r.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
          }, I.readyException = function(e) {
            r.setTimeout(function() {
              throw e
            })
          };
          var Q = I.Deferred();

          function Z() {
            C.removeEventListener("DOMContentLoaded", Z), r.removeEventListener("load", Z), I.ready()
          }
          I.fn.ready = function(e) {
            return Q.then(e).catch(function(e) {
              I.readyException(e)
            }), this
          }, I.extend({
            isReady: !1,
            readyWait: 1,
            ready: function(e) {
              (!0 === e ? --I.readyWait : I.isReady) || (I.isReady = !0, !0 !== e && --I.readyWait > 0 || Q.resolveWith(C, [I]))
            }
          }), I.ready.then = Q.then, "complete" === C.readyState || "loading" !== C.readyState && !C.documentElement.doScroll ? r.setTimeout(I.ready) : (C.addEventListener("DOMContentLoaded", Z), r.addEventListener("load", Z));
          var ee = function(e, t, i, r, s, n, o) {
              var a = 0,
                l = e.length,
                c = null == i;
              if ("object" === A(i))
                for (a in s = !0, i) ee(e, t, a, i[a], !0, n, o);
              else if (void 0 !== r && (s = !0, T(r) || (o = !0), c && (o ? (t.call(e, r), t = null) : (c = t, t = function(e, t, i) {
                  return c.call(I(e), i)
                })), t))
                for (; a < l; a++) t(e[a], i, o ? r : r.call(e[a], a, t(e[a], i)));
              return s ? e : c ? t.call(e) : l ? t(e[0], i) : n
            },
            te = /^-ms-/,
            ie = /-([a-z])/g;

          function re(e, t) {
            return t.toUpperCase()
          }

          function se(e) {
            return e.replace(te, "ms-").replace(ie, re)
          }
          var ne = function(e) {
            return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
          };

          function oe() {
            this.expando = I.expando + oe.uid++
          }
          oe.uid = 1, oe.prototype = {
            cache: function(e) {
              var t = e[this.expando];
              return t || (t = {}, ne(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
              }))), t
            },
            set: function(e, t, i) {
              var r, s = this.cache(e);
              if ("string" == typeof t) s[se(t)] = i;
              else
                for (r in t) s[se(r)] = t[r];
              return s
            },
            get: function(e, t) {
              return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][se(t)]
            },
            access: function(e, t, i) {
              return void 0 === t || t && "string" == typeof t && void 0 === i ? this.get(e, t) : (this.set(e, t, i), void 0 !== i ? i : t)
            },
            remove: function(e, t) {
              var i, r = e[this.expando];
              if (void 0 !== r) {
                if (void 0 !== t) {
                  i = (t = Array.isArray(t) ? t.map(se) : (t = se(t)) in r ? [t] : t.match(z) || []).length;
                  for (; i--;) delete r[t[i]]
                }(void 0 === t || I.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
              }
            },
            hasData: function(e) {
              var t = e[this.expando];
              return void 0 !== t && !I.isEmptyObject(t)
            }
          };
          var ae = new oe,
            le = new oe,
            ce = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            he = /[A-Z]/g;

          function ue(e, t, i) {
            var r;
            if (void 0 === i && 1 === e.nodeType)
              if (r = "data-" + t.replace(he, "-$&").toLowerCase(), "string" == typeof(i = e.getAttribute(r))) {
                try {
                  i = function(e) {
                    return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : ce.test(e) ? JSON.parse(e) : e)
                  }(i)
                } catch (e) {}
                le.set(e, t, i)
              } else i = void 0;
            return i
          }
          I.extend({
            hasData: function(e) {
              return le.hasData(e) || ae.hasData(e)
            },
            data: function(e, t, i) {
              return le.access(e, t, i)
            },
            removeData: function(e, t) {
              le.remove(e, t)
            },
            _data: function(e, t, i) {
              return ae.access(e, t, i)
            },
            _removeData: function(e, t) {
              ae.remove(e, t)
            }
          }), I.fn.extend({
            data: function(e, t) {
              var i, r, s, n = this[0],
                o = n && n.attributes;
              if (void 0 === e) {
                if (this.length && (s = le.get(n), 1 === n.nodeType && !ae.get(n, "hasDataAttrs"))) {
                  for (i = o.length; i--;) o[i] && 0 === (r = o[i].name).indexOf("data-") && (r = se(r.slice(5)), ue(n, r, s[r]));
                  ae.set(n, "hasDataAttrs", !0)
                }
                return s
              }
              return "object" == typeof e ? this.each(function() {
                le.set(this, e)
              }) : ee(this, function(t) {
                var i;
                if (n && void 0 === t) return void 0 !== (i = le.get(n, e)) || void 0 !== (i = ue(n, e)) ? i : void 0;
                this.each(function() {
                  le.set(this, e, t)
                })
              }, null, t, arguments.length > 1, null, !0)
            },
            removeData: function(e) {
              return this.each(function() {
                le.remove(this, e)
              })
            }
          }), I.extend({
            queue: function(e, t, i) {
              var r;
              if (e) return t = (t || "fx") + "queue", r = ae.get(e, t), i && (!r || Array.isArray(i) ? r = ae.access(e, t, I.makeArray(i)) : r.push(i)), r || []
            },
            dequeue: function(e, t) {
              t = t || "fx";
              var i = I.queue(e, t),
                r = i.length,
                s = i.shift(),
                n = I._queueHooks(e, t);
              "inprogress" === s && (s = i.shift(), r--), s && ("fx" === t && i.unshift("inprogress"), delete n.stop, s.call(e, function() {
                I.dequeue(e, t)
              }, n)), !r && n && n.empty.fire()
            },
            _queueHooks: function(e, t) {
              var i = t + "queueHooks";
              return ae.get(e, i) || ae.access(e, i, {
                empty: I.Callbacks("once memory").add(function() {
                  ae.remove(e, [t + "queue", i])
                })
              })
            }
          }), I.fn.extend({
            queue: function(e, t) {
              var i = 2;
              return "string" != typeof e && (t = e, e = "fx", i--), arguments.length < i ? I.queue(this[0], e) : void 0 === t ? this : this.each(function() {
                var i = I.queue(this, e, t);
                I._queueHooks(this, e), "fx" === e && "inprogress" !== i[0] && I.dequeue(this, e)
              })
            },
            dequeue: function(e) {
              return this.each(function() {
                I.dequeue(this, e)
              })
            },
            clearQueue: function(e) {
              return this.queue(e || "fx", [])
            },
            promise: function(e, t) {
              var i, r = 1,
                s = I.Deferred(),
                n = this,
                o = this.length,
                a = function() {
                  --r || s.resolveWith(n, [n])
                };
              for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; o--;)(i = ae.get(n[o], e + "queueHooks")) && i.empty && (r++, i.empty.add(a));
              return a(), s.promise(t)
            }
          });
          var de = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            pe = new RegExp("^(?:([+-])=|)(" + de + ")([a-z%]*)$", "i"),
            Ee = ["Top", "Right", "Bottom", "Left"],
            ge = C.documentElement,
            fe = function(e) {
              return I.contains(e.ownerDocument, e)
            },
            Te = {
              composed: !0
            };
          ge.getRootNode && (fe = function(e) {
            return I.contains(e.ownerDocument, e) || e.getRootNode(Te) === e.ownerDocument
          });
          var me = function(e, t) {
            return "none" === (e = t || e).style.display || "" === e.style.display && fe(e) && "none" === I.css(e, "display")
          };

          function Ce(e, t, i, r) {
            var s, n, o = 20,
              a = r ? function() {
                return r.cur()
              } : function() {
                return I.css(e, t, "")
              },
              l = a(),
              c = i && i[3] || (I.cssNumber[t] ? "" : "px"),
              h = e.nodeType && (I.cssNumber[t] || "px" !== c && +l) && pe.exec(I.css(e, t));
            if (h && h[3] !== c) {
              for (l /= 2, c = c || h[3], h = +l || 1; o--;) I.style(e, t, h + c), (1 - n) * (1 - (n = a() / l || .5)) <= 0 && (o = 0), h /= n;
              h *= 2, I.style(e, t, h + c), i = i || []
            }
            return i && (h = +h || +l || 0, s = i[1] ? h + (i[1] + 1) * i[2] : +i[2], r && (r.unit = c, r.start = h, r.end = s)), s
          }
          var Se = {};

          function Re(e) {
            var t, i = e.ownerDocument,
              r = e.nodeName,
              s = Se[r];
            return s || (t = i.body.appendChild(i.createElement(r)), s = I.css(t, "display"), t.parentNode.removeChild(t), "none" === s && (s = "block"), Se[r] = s, s)
          }

          function Ae(e, t) {
            for (var i, r, s = [], n = 0, o = e.length; n < o; n++)(r = e[n]).style && (i = r.style.display, t ? ("none" === i && (s[n] = ae.get(r, "display") || null, s[n] || (r.style.display = "")), "" === r.style.display && me(r) && (s[n] = Re(r))) : "none" !== i && (s[n] = "none", ae.set(r, "display", i)));
            for (n = 0; n < o; n++) null != s[n] && (e[n].style.display = s[n]);
            return e
          }
          I.fn.extend({
            show: function() {
              return Ae(this, !0)
            },
            hide: function() {
              return Ae(this)
            },
            toggle: function(e) {
              return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                me(this) ? I(this).show() : I(this).hide()
              })
            }
          });
          var ve, Ne, Ie = /^(?:checkbox|radio)$/i,
            Oe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            Le = /^$|^module$|\/(?:java|ecma)script/i;
          ve = C.createDocumentFragment().appendChild(C.createElement("div")), (Ne = C.createElement("input")).setAttribute("type", "radio"), Ne.setAttribute("checked", "checked"), Ne.setAttribute("name", "t"), ve.appendChild(Ne), f.checkClone = ve.cloneNode(!0).cloneNode(!0).lastChild.checked, ve.innerHTML = "<textarea>x</textarea>", f.noCloneChecked = !!ve.cloneNode(!0).lastChild.defaultValue, ve.innerHTML = "<option></option>", f.option = !!ve.lastChild;
          var _e = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
          };

          function ye(e, t) {
            var i;
            return i = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && L(e, t) ? I.merge([e], i) : i
          }

          function we(e, t) {
            for (var i = 0, r = e.length; i < r; i++) ae.set(e[i], "globalEval", !t || ae.get(t[i], "globalEval"))
          }
          _e.tbody = _e.tfoot = _e.colgroup = _e.caption = _e.thead, _e.th = _e.td, f.option || (_e.optgroup = _e.option = [1, "<select multiple='multiple'>", "</select>"]);
          var De = /<|&#?\w+;/;

          function Pe(e, t, i, r, s) {
            for (var n, o, a, l, c, h, u = t.createDocumentFragment(), d = [], p = 0, E = e.length; p < E; p++)
              if ((n = e[p]) || 0 === n)
                if ("object" === A(n)) I.merge(d, n.nodeType ? [n] : n);
                else if (De.test(n)) {
              for (o = o || u.appendChild(t.createElement("div")), a = (Oe.exec(n) || ["", ""])[1].toLowerCase(), l = _e[a] || _e._default, o.innerHTML = l[1] + I.htmlPrefilter(n) + l[2], h = l[0]; h--;) o = o.lastChild;
              I.merge(d, o.childNodes), (o = u.firstChild).textContent = ""
            } else d.push(t.createTextNode(n));
            for (u.textContent = "", p = 0; n = d[p++];)
              if (r && I.inArray(n, r) > -1) s && s.push(n);
              else if (c = fe(n), o = ye(u.appendChild(n), "script"), c && we(o), i)
              for (h = 0; n = o[h++];) Le.test(n.type || "") && i.push(n);
            return u
          }
          var be = /^([^.]*)(?:\.(.+)|)/;

          function Me() {
            return !0
          }

          function Fe() {
            return !1
          }

          function xe(e, t, i, r, s, n) {
            var o, a;
            if ("object" == typeof t) {
              for (a in "string" != typeof i && (r = r || i, i = void 0), t) xe(e, a, i, r, t[a], n);
              return e
            }
            if (null == r && null == s ? (s = i, r = i = void 0) : null == s && ("string" == typeof i ? (s = r, r = void 0) : (s = r, r = i, i = void 0)), !1 === s) s = Fe;
            else if (!s) return e;
            return 1 === n && (o = s, s = function(e) {
              return I().off(e), o.apply(this, arguments)
            }, s.guid = o.guid || (o.guid = I.guid++)), e.each(function() {
              I.event.add(this, t, s, r, i)
            })
          }

          function Ge(e, t, i) {
            i ? (ae.set(e, t, !1), I.event.add(e, t, {
              namespace: !1,
              handler: function(e) {
                var i, r = ae.get(this, t);
                if (1 & e.isTrigger && this[t]) {
                  if (r)(I.event.special[t] || {}).delegateType && e.stopPropagation();
                  else if (r = a.call(arguments), ae.set(this, t, r), this[t](), i = ae.get(this, t), ae.set(this, t, !1), r !== i) return e.stopImmediatePropagation(), e.preventDefault(), i
                } else r && (ae.set(this, t, I.event.trigger(r[0], r.slice(1), this)), e.stopPropagation(), e.isImmediatePropagationStopped = Me)
              }
            })) : void 0 === ae.get(e, t) && I.event.add(e, t, Me)
          }
          I.event = {
            global: {},
            add: function(e, t, i, r, s) {
              var n, o, a, l, c, h, u, d, p, E, g, f = ae.get(e);
              if (ne(e))
                for (i.handler && (i = (n = i).handler, s = n.selector), s && I.find.matchesSelector(ge, s), i.guid || (i.guid = I.guid++), (l = f.events) || (l = f.events = Object.create(null)), (o = f.handle) || (o = f.handle = function(t) {
                    return void 0 !== I && I.event.triggered !== t.type ? I.event.dispatch.apply(e, arguments) : void 0
                  }), c = (t = (t || "").match(z) || [""]).length; c--;) p = g = (a = be.exec(t[c]) || [])[1], E = (a[2] || "").split(".").sort(), p && (u = I.event.special[p] || {}, p = (s ? u.delegateType : u.bindType) || p, u = I.event.special[p] || {}, h = I.extend({
                  type: p,
                  origType: g,
                  data: r,
                  handler: i,
                  guid: i.guid,
                  selector: s,
                  needsContext: s && I.expr.match.needsContext.test(s),
                  namespace: E.join(".")
                }, n), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(e, r, E, o) || e.addEventListener && e.addEventListener(p, o)), u.add && (u.add.call(e, h), h.handler.guid || (h.handler.guid = i.guid)), s ? d.splice(d.delegateCount++, 0, h) : d.push(h), I.event.global[p] = !0)
            },
            remove: function(e, t, i, r, s) {
              var n, o, a, l, c, h, u, d, p, E, g, f = ae.hasData(e) && ae.get(e);
              if (f && (l = f.events)) {
                for (c = (t = (t || "").match(z) || [""]).length; c--;)
                  if (p = g = (a = be.exec(t[c]) || [])[1], E = (a[2] || "").split(".").sort(), p) {
                    for (u = I.event.special[p] || {}, d = l[p = (r ? u.delegateType : u.bindType) || p] || [], a = a[2] && new RegExp("(^|\\.)" + E.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = n = d.length; n--;) h = d[n], !s && g !== h.origType || i && i.guid !== h.guid || a && !a.test(h.namespace) || r && r !== h.selector && ("**" !== r || !h.selector) || (d.splice(n, 1), h.selector && d.delegateCount--, u.remove && u.remove.call(e, h));
                    o && !d.length && (u.teardown && !1 !== u.teardown.call(e, E, f.handle) || I.removeEvent(e, p, f.handle), delete l[p])
                  } else
                    for (p in l) I.event.remove(e, p + t[c], i, r, !0);
                I.isEmptyObject(l) && ae.remove(e, "handle events")
              }
            },
            dispatch: function(e) {
              var t, i, r, s, n, o, a = new Array(arguments.length),
                l = I.event.fix(e),
                c = (ae.get(this, "events") || Object.create(null))[l.type] || [],
                h = I.event.special[l.type] || {};
              for (a[0] = l, t = 1; t < arguments.length; t++) a[t] = arguments[t];
              if (l.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, l)) {
                for (o = I.event.handlers.call(this, l, c), t = 0;
                  (s = o[t++]) && !l.isPropagationStopped();)
                  for (l.currentTarget = s.elem, i = 0;
                    (n = s.handlers[i++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== n.namespace && !l.rnamespace.test(n.namespace) || (l.handleObj = n, l.data = n.data, void 0 !== (r = ((I.event.special[n.origType] || {}).handle || n.handler).apply(s.elem, a)) && !1 === (l.result = r) && (l.preventDefault(), l.stopPropagation()));
                return h.postDispatch && h.postDispatch.call(this, l), l.result
              }
            },
            handlers: function(e, t) {
              var i, r, s, n, o, a = [],
                l = t.delegateCount,
                c = e.target;
              if (l && c.nodeType && !("click" === e.type && e.button >= 1))
                for (; c !== this; c = c.parentNode || this)
                  if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                    for (n = [], o = {}, i = 0; i < l; i++) void 0 === o[s = (r = t[i]).selector + " "] && (o[s] = r.needsContext ? I(s, this).index(c) > -1 : I.find(s, this, null, [c]).length), o[s] && n.push(r);
                    n.length && a.push({
                      elem: c,
                      handlers: n
                    })
                  } return c = this, l < t.length && a.push({
                elem: c,
                handlers: t.slice(l)
              }), a
            },
            addProp: function(e, t) {
              Object.defineProperty(I.Event.prototype, e, {
                enumerable: !0,
                configurable: !0,
                get: T(t) ? function() {
                  if (this.originalEvent) return t(this.originalEvent)
                } : function() {
                  if (this.originalEvent) return this.originalEvent[e]
                },
                set: function(t) {
                  Object.defineProperty(this, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                  })
                }
              })
            },
            fix: function(e) {
              return e[I.expando] ? e : new I.Event(e)
            },
            special: {
              load: {
                noBubble: !0
              },
              click: {
                setup: function(e) {
                  var t = this || e;
                  return Ie.test(t.type) && t.click && L(t, "input") && Ge(t, "click", !0), !1
                },
                trigger: function(e) {
                  var t = this || e;
                  return Ie.test(t.type) && t.click && L(t, "input") && Ge(t, "click"), !0
                },
                _default: function(e) {
                  var t = e.target;
                  return Ie.test(t.type) && t.click && L(t, "input") && ae.get(t, "click") || L(t, "a")
                }
              },
              beforeunload: {
                postDispatch: function(e) {
                  void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
              }
            }
          }, I.removeEvent = function(e, t, i) {
            e.removeEventListener && e.removeEventListener(t, i)
          }, I.Event = function(e, t) {
            if (!(this instanceof I.Event)) return new I.Event(e, t);
            e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Me : Fe, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && I.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[I.expando] = !0
          }, I.Event.prototype = {
            constructor: I.Event,
            isDefaultPrevented: Fe,
            isPropagationStopped: Fe,
            isImmediatePropagationStopped: Fe,
            isSimulated: !1,
            preventDefault: function() {
              var e = this.originalEvent;
              this.isDefaultPrevented = Me, e && !this.isSimulated && e.preventDefault()
            },
            stopPropagation: function() {
              var e = this.originalEvent;
              this.isPropagationStopped = Me, e && !this.isSimulated && e.stopPropagation()
            },
            stopImmediatePropagation: function() {
              var e = this.originalEvent;
              this.isImmediatePropagationStopped = Me, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
            }
          }, I.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: !0
          }, I.event.addProp), I.each({
            focus: "focusin",
            blur: "focusout"
          }, function(e, t) {
            function i(e) {
              if (C.documentMode) {
                var i = ae.get(this, "handle"),
                  r = I.event.fix(e);
                r.type = "focusin" === e.type ? "focus" : "blur", r.isSimulated = !0, i(e), r.target === r.currentTarget && i(r)
              } else I.event.simulate(t, e.target, I.event.fix(e))
            }
            I.event.special[e] = {
              setup: function() {
                var r;
                if (Ge(this, e, !0), !C.documentMode) return !1;
                (r = ae.get(this, t)) || this.addEventListener(t, i), ae.set(this, t, (r || 0) + 1)
              },
              trigger: function() {
                return Ge(this, e), !0
              },
              teardown: function() {
                var e;
                if (!C.documentMode) return !1;
                (e = ae.get(this, t) - 1) ? ae.set(this, t, e): (this.removeEventListener(t, i), ae.remove(this, t))
              },
              _default: function(t) {
                return ae.get(t.target, e)
              },
              delegateType: t
            }, I.event.special[t] = {
              setup: function() {
                var r = this.ownerDocument || this.document || this,
                  s = C.documentMode ? this : r,
                  n = ae.get(s, t);
                n || (C.documentMode ? this.addEventListener(t, i) : r.addEventListener(e, i, !0)), ae.set(s, t, (n || 0) + 1)
              },
              teardown: function() {
                var r = this.ownerDocument || this.document || this,
                  s = C.documentMode ? this : r,
                  n = ae.get(s, t) - 1;
                n ? ae.set(s, t, n) : (C.documentMode ? this.removeEventListener(t, i) : r.removeEventListener(e, i, !0), ae.remove(s, t))
              }
            }
          }), I.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
          }, function(e, t) {
            I.event.special[e] = {
              delegateType: t,
              bindType: t,
              handle: function(e) {
                var i, r = e.relatedTarget,
                  s = e.handleObj;
                return r && (r === this || I.contains(this, r)) || (e.type = s.origType, i = s.handler.apply(this, arguments), e.type = t), i
              }
            }
          }), I.fn.extend({
            on: function(e, t, i, r) {
              return xe(this, e, t, i, r)
            },
            one: function(e, t, i, r) {
              return xe(this, e, t, i, r, 1)
            },
            off: function(e, t, i) {
              var r, s;
              if (e && e.preventDefault && e.handleObj) return r = e.handleObj, I(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
              if ("object" == typeof e) {
                for (s in e) this.off(s, t, e[s]);
                return this
              }
              return !1 !== t && "function" != typeof t || (i = t, t = void 0), !1 === i && (i = Fe), this.each(function() {
                I.event.remove(this, e, i, t)
              })
            }
          });
          var Ue = /<script|<style|<link/i,
            He = /checked\s*(?:[^=]|=\s*.checked.)/i,
            ke = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

          function Be(e, t) {
            return L(e, "table") && L(11 !== t.nodeType ? t : t.firstChild, "tr") && I(e).children("tbody")[0] || e
          }

          function Ve(e) {
            return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
          }

          function We(e) {
            return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
          }

          function Ye(e, t) {
            var i, r, s, n, o, a;
            if (1 === t.nodeType) {
              if (ae.hasData(e) && (a = ae.get(e).events))
                for (s in ae.remove(t, "handle events"), a)
                  for (i = 0, r = a[s].length; i < r; i++) I.event.add(t, s, a[s][i]);
              le.hasData(e) && (n = le.access(e), o = I.extend({}, n), le.set(t, o))
            }
          }

          function Ke(e, t) {
            var i = t.nodeName.toLowerCase();
            "input" === i && Ie.test(e.type) ? t.checked = e.checked : "input" !== i && "textarea" !== i || (t.defaultValue = e.defaultValue)
          }

          function Xe(e, t, i, r) {
            t = l(t);
            var s, n, o, a, c, h, u = 0,
              d = e.length,
              p = d - 1,
              E = t[0],
              g = T(E);
            if (g || d > 1 && "string" == typeof E && !f.checkClone && He.test(E)) return e.each(function(s) {
              var n = e.eq(s);
              g && (t[0] = E.call(this, s, n.html())), Xe(n, t, i, r)
            });
            if (d && (n = (s = Pe(t, e[0].ownerDocument, !1, e, r)).firstChild, 1 === s.childNodes.length && (s = n), n || r)) {
              for (a = (o = I.map(ye(s, "script"), Ve)).length; u < d; u++) c = s, u !== p && (c = I.clone(c, !0, !0), a && I.merge(o, ye(c, "script"))), i.call(e[u], c, u);
              if (a)
                for (h = o[o.length - 1].ownerDocument, I.map(o, We), u = 0; u < a; u++) c = o[u], Le.test(c.type || "") && !ae.access(c, "globalEval") && I.contains(h, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? I._evalUrl && !c.noModule && I._evalUrl(c.src, {
                  nonce: c.nonce || c.getAttribute("nonce")
                }, h) : R(c.textContent.replace(ke, ""), c, h))
            }
            return e
          }

          function ze(e, t, i) {
            for (var r, s = t ? I.filter(t, e) : e, n = 0; null != (r = s[n]); n++) i || 1 !== r.nodeType || I.cleanData(ye(r)), r.parentNode && (i && fe(r) && we(ye(r, "script")), r.parentNode.removeChild(r));
            return e
          }
          I.extend({
            htmlPrefilter: function(e) {
              return e
            },
            clone: function(e, t, i) {
              var r, s, n, o, a = e.cloneNode(!0),
                l = fe(e);
              if (!(f.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || I.isXMLDoc(e)))
                for (o = ye(a), r = 0, s = (n = ye(e)).length; r < s; r++) Ke(n[r], o[r]);
              if (t)
                if (i)
                  for (n = n || ye(e), o = o || ye(a), r = 0, s = n.length; r < s; r++) Ye(n[r], o[r]);
                else Ye(e, a);
              return (o = ye(a, "script")).length > 0 && we(o, !l && ye(e, "script")), a
            },
            cleanData: function(e) {
              for (var t, i, r, s = I.event.special, n = 0; void 0 !== (i = e[n]); n++)
                if (ne(i)) {
                  if (t = i[ae.expando]) {
                    if (t.events)
                      for (r in t.events) s[r] ? I.event.remove(i, r) : I.removeEvent(i, r, t.handle);
                    i[ae.expando] = void 0
                  }
                  i[le.expando] && (i[le.expando] = void 0)
                }
            }
          }), I.fn.extend({
            detach: function(e) {
              return ze(this, e, !0)
            },
            remove: function(e) {
              return ze(this, e)
            },
            text: function(e) {
              return ee(this, function(e) {
                return void 0 === e ? I.text(this) : this.empty().each(function() {
                  1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                })
              }, null, e, arguments.length)
            },
            append: function() {
              return Xe(this, arguments, function(e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Be(this, e).appendChild(e)
              })
            },
            prepend: function() {
              return Xe(this, arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                  var t = Be(this, e);
                  t.insertBefore(e, t.firstChild)
                }
              })
            },
            before: function() {
              return Xe(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
              })
            },
            after: function() {
              return Xe(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
              })
            },
            empty: function() {
              for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (I.cleanData(ye(e, !1)), e.textContent = "");
              return this
            },
            clone: function(e, t) {
              return e = null != e && e, t = null == t ? e : t, this.map(function() {
                return I.clone(this, e, t)
              })
            },
            html: function(e) {
              return ee(this, function(e) {
                var t = this[0] || {},
                  i = 0,
                  r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Ue.test(e) && !_e[(Oe.exec(e) || ["", ""])[1].toLowerCase()]) {
                  e = I.htmlPrefilter(e);
                  try {
                    for (; i < r; i++) 1 === (t = this[i] || {}).nodeType && (I.cleanData(ye(t, !1)), t.innerHTML = e);
                    t = 0
                  } catch (e) {}
                }
                t && this.empty().append(e)
              }, null, e, arguments.length)
            },
            replaceWith: function() {
              var e = [];
              return Xe(this, arguments, function(t) {
                var i = this.parentNode;
                I.inArray(this, e) < 0 && (I.cleanData(ye(this)), i && i.replaceChild(t, this))
              }, e)
            }
          }), I.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
          }, function(e, t) {
            I.fn[e] = function(e) {
              for (var i, r = [], s = I(e), n = s.length - 1, o = 0; o <= n; o++) i = o === n ? this : this.clone(!0), I(s[o])[t](i), c.apply(r, i.get());
              return this.pushStack(r)
            }
          });
          var $e = new RegExp("^(" + de + ")(?!px)[a-z%]+$", "i"),
            je = /^--/,
            Je = function(e) {
              var t = e.ownerDocument.defaultView;
              return t && t.opener || (t = r), t.getComputedStyle(e)
            },
            qe = function(e, t, i) {
              var r, s, n = {};
              for (s in t) n[s] = e.style[s], e.style[s] = t[s];
              for (s in r = i.call(e), t) e.style[s] = n[s];
              return r
            },
            Qe = new RegExp(Ee.join("|"), "i");

          function Ze(e, t, i) {
            var r, s, n, o, a = je.test(t),
              l = e.style;
            return (i = i || Je(e)) && (o = i.getPropertyValue(t) || i[t], a && o && (o = o.replace(P, "$1") || void 0), "" !== o || fe(e) || (o = I.style(e, t)), !f.pixelBoxStyles() && $e.test(o) && Qe.test(t) && (r = l.width, s = l.minWidth, n = l.maxWidth, l.minWidth = l.maxWidth = l.width = o, o = i.width, l.width = r, l.minWidth = s, l.maxWidth = n)), void 0 !== o ? o + "" : o
          }

          function et(e, t) {
            return {
              get: function() {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get
              }
            }
          }! function() {
            function e() {
              if (h) {
                c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", h.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ge.appendChild(c).appendChild(h);
                var e = r.getComputedStyle(h);
                i = "1%" !== e.top, l = 12 === t(e.marginLeft), h.style.right = "60%", o = 36 === t(e.right), s = 36 === t(e.width), h.style.position = "absolute", n = 12 === t(h.offsetWidth / 3), ge.removeChild(c), h = null
              }
            }

            function t(e) {
              return Math.round(parseFloat(e))
            }
            var i, s, n, o, a, l, c = C.createElement("div"),
              h = C.createElement("div");
            h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", f.clearCloneStyle = "content-box" === h.style.backgroundClip, I.extend(f, {
              boxSizingReliable: function() {
                return e(), s
              },
              pixelBoxStyles: function() {
                return e(), o
              },
              pixelPosition: function() {
                return e(), i
              },
              reliableMarginLeft: function() {
                return e(), l
              },
              scrollboxSize: function() {
                return e(), n
              },
              reliableTrDimensions: function() {
                var e, t, i, s;
                return null == a && (e = C.createElement("table"), t = C.createElement("tr"), i = C.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "box-sizing:content-box;border:1px solid", t.style.height = "1px", i.style.height = "9px", i.style.display = "block", ge.appendChild(e).appendChild(t).appendChild(i), s = r.getComputedStyle(t), a = parseInt(s.height, 10) + parseInt(s.borderTopWidth, 10) + parseInt(s.borderBottomWidth, 10) === t.offsetHeight, ge.removeChild(e)), a
              }
            }))
          }();
          var tt = ["Webkit", "Moz", "ms"],
            it = C.createElement("div").style,
            rt = {};

          function st(e) {
            var t = I.cssProps[e] || rt[e];
            return t || (e in it ? e : rt[e] = function(e) {
              for (var t = e[0].toUpperCase() + e.slice(1), i = tt.length; i--;)
                if ((e = tt[i] + t) in it) return e
            }(e) || e)
          }
          var nt = /^(none|table(?!-c[ea]).+)/,
            ot = {
              position: "absolute",
              visibility: "hidden",
              display: "block"
            },
            at = {
              letterSpacing: "0",
              fontWeight: "400"
            };

          function lt(e, t, i) {
            var r = pe.exec(t);
            return r ? Math.max(0, r[2] - (i || 0)) + (r[3] || "px") : t
          }

          function ct(e, t, i, r, s, n) {
            var o = "width" === t ? 1 : 0,
              a = 0,
              l = 0,
              c = 0;
            if (i === (r ? "border" : "content")) return 0;
            for (; o < 4; o += 2) "margin" === i && (c += I.css(e, i + Ee[o], !0, s)), r ? ("content" === i && (l -= I.css(e, "padding" + Ee[o], !0, s)), "margin" !== i && (l -= I.css(e, "border" + Ee[o] + "Width", !0, s))) : (l += I.css(e, "padding" + Ee[o], !0, s), "padding" !== i ? l += I.css(e, "border" + Ee[o] + "Width", !0, s) : a += I.css(e, "border" + Ee[o] + "Width", !0, s));
            return !r && n >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - n - l - a - .5)) || 0), l + c
          }

          function ht(e, t, i) {
            var r = Je(e),
              s = (!f.boxSizingReliable() || i) && "border-box" === I.css(e, "boxSizing", !1, r),
              n = s,
              o = Ze(e, t, r),
              a = "offset" + t[0].toUpperCase() + t.slice(1);
            if ($e.test(o)) {
              if (!i) return o;
              o = "auto"
            }
            return (!f.boxSizingReliable() && s || !f.reliableTrDimensions() && L(e, "tr") || "auto" === o || !parseFloat(o) && "inline" === I.css(e, "display", !1, r)) && e.getClientRects().length && (s = "border-box" === I.css(e, "boxSizing", !1, r), (n = a in e) && (o = e[a])), (o = parseFloat(o) || 0) + ct(e, t, i || (s ? "border" : "content"), n, r, o) + "px"
          }

          function ut(e, t, i, r, s) {
            return new ut.prototype.init(e, t, i, r, s)
          }
          I.extend({
            cssHooks: {
              opacity: {
                get: function(e, t) {
                  if (t) {
                    var i = Ze(e, "opacity");
                    return "" === i ? "1" : i
                  }
                }
              }
            },
            cssNumber: {
              animationIterationCount: !0,
              aspectRatio: !0,
              borderImageSlice: !0,
              columnCount: !0,
              flexGrow: !0,
              flexShrink: !0,
              fontWeight: !0,
              gridArea: !0,
              gridColumn: !0,
              gridColumnEnd: !0,
              gridColumnStart: !0,
              gridRow: !0,
              gridRowEnd: !0,
              gridRowStart: !0,
              lineHeight: !0,
              opacity: !0,
              order: !0,
              orphans: !0,
              scale: !0,
              widows: !0,
              zIndex: !0,
              zoom: !0,
              fillOpacity: !0,
              floodOpacity: !0,
              stopOpacity: !0,
              strokeMiterlimit: !0,
              strokeOpacity: !0
            },
            cssProps: {},
            style: function(e, t, i, r) {
              if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var s, n, o, a = se(t),
                  l = je.test(t),
                  c = e.style;
                if (l || (t = st(a)), o = I.cssHooks[t] || I.cssHooks[a], void 0 === i) return o && "get" in o && void 0 !== (s = o.get(e, !1, r)) ? s : c[t];
                "string" === (n = typeof i) && (s = pe.exec(i)) && s[1] && (i = Ce(e, t, s), n = "number"), null != i && i == i && ("number" !== n || l || (i += s && s[3] || (I.cssNumber[a] ? "" : "px")), f.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (c[t] = "inherit"), o && "set" in o && void 0 === (i = o.set(e, i, r)) || (l ? c.setProperty(t, i) : c[t] = i))
              }
            },
            css: function(e, t, i, r) {
              var s, n, o, a = se(t);
              return je.test(t) || (t = st(a)), (o = I.cssHooks[t] || I.cssHooks[a]) && "get" in o && (s = o.get(e, !0, i)), void 0 === s && (s = Ze(e, t, r)), "normal" === s && t in at && (s = at[t]), "" === i || i ? (n = parseFloat(s), !0 === i || isFinite(n) ? n || 0 : s) : s
            }
          }), I.each(["height", "width"], function(e, t) {
            I.cssHooks[t] = {
              get: function(e, i, r) {
                if (i) return !nt.test(I.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? ht(e, t, r) : qe(e, ot, function() {
                  return ht(e, t, r)
                })
              },
              set: function(e, i, r) {
                var s, n = Je(e),
                  o = !f.scrollboxSize() && "absolute" === n.position,
                  a = (o || r) && "border-box" === I.css(e, "boxSizing", !1, n),
                  l = r ? ct(e, t, r, a, n) : 0;
                return a && o && (l -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(n[t]) - ct(e, t, "border", !1, n) - .5)), l && (s = pe.exec(i)) && "px" !== (s[3] || "px") && (e.style[t] = i, i = I.css(e, t)), lt(0, i, l)
              }
            }
          }), I.cssHooks.marginLeft = et(f.reliableMarginLeft, function(e, t) {
            if (t) return (parseFloat(Ze(e, "marginLeft")) || e.getBoundingClientRect().left - qe(e, {
              marginLeft: 0
            }, function() {
              return e.getBoundingClientRect().left
            })) + "px"
          }), I.each({
            margin: "",
            padding: "",
            border: "Width"
          }, function(e, t) {
            I.cssHooks[e + t] = {
              expand: function(i) {
                for (var r = 0, s = {}, n = "string" == typeof i ? i.split(" ") : [i]; r < 4; r++) s[e + Ee[r] + t] = n[r] || n[r - 2] || n[0];
                return s
              }
            }, "margin" !== e && (I.cssHooks[e + t].set = lt)
          }), I.fn.extend({
            css: function(e, t) {
              return ee(this, function(e, t, i) {
                var r, s, n = {},
                  o = 0;
                if (Array.isArray(t)) {
                  for (r = Je(e), s = t.length; o < s; o++) n[t[o]] = I.css(e, t[o], !1, r);
                  return n
                }
                return void 0 !== i ? I.style(e, t, i) : I.css(e, t)
              }, e, t, arguments.length > 1)
            }
          }), I.Tween = ut, ut.prototype = {
            constructor: ut,
            init: function(e, t, i, r, s, n) {
              this.elem = e, this.prop = i, this.easing = s || I.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = n || (I.cssNumber[i] ? "" : "px")
            },
            cur: function() {
              var e = ut.propHooks[this.prop];
              return e && e.get ? e.get(this) : ut.propHooks._default.get(this)
            },
            run: function(e) {
              var t, i = ut.propHooks[this.prop];
              return this.options.duration ? this.pos = t = I.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : ut.propHooks._default.set(this), this
            }
          }, ut.prototype.init.prototype = ut.prototype, ut.propHooks = {
            _default: {
              get: function(e) {
                var t;
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = I.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
              },
              set: function(e) {
                I.fx.step[e.prop] ? I.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !I.cssHooks[e.prop] && null == e.elem.style[st(e.prop)] ? e.elem[e.prop] = e.now : I.style(e.elem, e.prop, e.now + e.unit)
              }
            }
          }, ut.propHooks.scrollTop = ut.propHooks.scrollLeft = {
            set: function(e) {
              e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
            }
          }, I.easing = {
            linear: function(e) {
              return e
            },
            swing: function(e) {
              return .5 - Math.cos(e * Math.PI) / 2
            },
            _default: "swing"
          }, I.fx = ut.prototype.init, I.fx.step = {};
          var dt, pt, Et = /^(?:toggle|show|hide)$/,
            gt = /queueHooks$/;

          function ft() {
            pt && (!1 === C.hidden && r.requestAnimationFrame ? r.requestAnimationFrame(ft) : r.setTimeout(ft, I.fx.interval), I.fx.tick())
          }

          function Tt() {
            return r.setTimeout(function() {
              dt = void 0
            }), dt = Date.now()
          }

          function mt(e, t) {
            var i, r = 0,
              s = {
                height: e
              };
            for (t = t ? 1 : 0; r < 4; r += 2 - t) s["margin" + (i = Ee[r])] = s["padding" + i] = e;
            return t && (s.opacity = s.width = e), s
          }

          function Ct(e, t, i) {
            for (var r, s = (St.tweeners[t] || []).concat(St.tweeners["*"]), n = 0, o = s.length; n < o; n++)
              if (r = s[n].call(i, t, e)) return r
          }

          function St(e, t, i) {
            var r, s, n = 0,
              o = St.prefilters.length,
              a = I.Deferred().always(function() {
                delete l.elem
              }),
              l = function() {
                if (s) return !1;
                for (var t = dt || Tt(), i = Math.max(0, c.startTime + c.duration - t), r = 1 - (i / c.duration || 0), n = 0, o = c.tweens.length; n < o; n++) c.tweens[n].run(r);
                return a.notifyWith(e, [c, r, i]), r < 1 && o ? i : (o || a.notifyWith(e, [c, 1, 0]), a.resolveWith(e, [c]), !1)
              },
              c = a.promise({
                elem: e,
                props: I.extend({}, t),
                opts: I.extend(!0, {
                  specialEasing: {},
                  easing: I.easing._default
                }, i),
                originalProperties: t,
                originalOptions: i,
                startTime: dt || Tt(),
                duration: i.duration,
                tweens: [],
                createTween: function(t, i) {
                  var r = I.Tween(e, c.opts, t, i, c.opts.specialEasing[t] || c.opts.easing);
                  return c.tweens.push(r), r
                },
                stop: function(t) {
                  var i = 0,
                    r = t ? c.tweens.length : 0;
                  if (s) return this;
                  for (s = !0; i < r; i++) c.tweens[i].run(1);
                  return t ? (a.notifyWith(e, [c, 1, 0]), a.resolveWith(e, [c, t])) : a.rejectWith(e, [c, t]), this
                }
              }),
              h = c.props;
            for (! function(e, t) {
                var i, r, s, n, o;
                for (i in e)
                  if (s = t[r = se(i)], n = e[i], Array.isArray(n) && (s = n[1], n = e[i] = n[0]), i !== r && (e[r] = n, delete e[i]), (o = I.cssHooks[r]) && "expand" in o)
                    for (i in n = o.expand(n), delete e[r], n) i in e || (e[i] = n[i], t[i] = s);
                  else t[r] = s
              }(h, c.opts.specialEasing); n < o; n++)
              if (r = St.prefilters[n].call(c, e, h, c.opts)) return T(r.stop) && (I._queueHooks(c.elem, c.opts.queue).stop = r.stop.bind(r)), r;
            return I.map(h, Ct, c), T(c.opts.start) && c.opts.start.call(e, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), I.fx.timer(I.extend(l, {
              elem: e,
              anim: c,
              queue: c.opts.queue
            })), c
          }
          I.Animation = I.extend(St, {
              tweeners: {
                "*": [function(e, t) {
                  var i = this.createTween(e, t);
                  return Ce(i.elem, e, pe.exec(t), i), i
                }]
              },
              tweener: function(e, t) {
                T(e) ? (t = e, e = ["*"]) : e = e.match(z);
                for (var i, r = 0, s = e.length; r < s; r++) i = e[r], St.tweeners[i] = St.tweeners[i] || [], St.tweeners[i].unshift(t)
              },
              prefilters: [function(e, t, i) {
                var r, s, n, o, a, l, c, h, u = "width" in t || "height" in t,
                  d = this,
                  p = {},
                  E = e.style,
                  g = e.nodeType && me(e),
                  f = ae.get(e, "fxshow");
                for (r in i.queue || (null == (o = I._queueHooks(e, "fx")).unqueued && (o.unqueued = 0, a = o.empty.fire, o.empty.fire = function() {
                    o.unqueued || a()
                  }), o.unqueued++, d.always(function() {
                    d.always(function() {
                      o.unqueued--, I.queue(e, "fx").length || o.empty.fire()
                    })
                  })), t)
                  if (s = t[r], Et.test(s)) {
                    if (delete t[r], n = n || "toggle" === s, s === (g ? "hide" : "show")) {
                      if ("show" !== s || !f || void 0 === f[r]) continue;
                      g = !0
                    }
                    p[r] = f && f[r] || I.style(e, r)
                  } if ((l = !I.isEmptyObject(t)) || !I.isEmptyObject(p))
                  for (r in u && 1 === e.nodeType && (i.overflow = [E.overflow, E.overflowX, E.overflowY], null == (c = f && f.display) && (c = ae.get(e, "display")), "none" === (h = I.css(e, "display")) && (c ? h = c : (Ae([e], !0), c = e.style.display || c, h = I.css(e, "display"), Ae([e]))), ("inline" === h || "inline-block" === h && null != c) && "none" === I.css(e, "float") && (l || (d.done(function() {
                      E.display = c
                    }), null == c && (h = E.display, c = "none" === h ? "" : h)), E.display = "inline-block")), i.overflow && (E.overflow = "hidden", d.always(function() {
                      E.overflow = i.overflow[0], E.overflowX = i.overflow[1], E.overflowY = i.overflow[2]
                    })), l = !1, p) l || (f ? "hidden" in f && (g = f.hidden) : f = ae.access(e, "fxshow", {
                    display: c
                  }), n && (f.hidden = !g), g && Ae([e], !0), d.done(function() {
                    for (r in g || Ae([e]), ae.remove(e, "fxshow"), p) I.style(e, r, p[r])
                  })), l = Ct(g ? f[r] : 0, r, d), r in f || (f[r] = l.start, g && (l.end = l.start, l.start = 0))
              }],
              prefilter: function(e, t) {
                t ? St.prefilters.unshift(e) : St.prefilters.push(e)
              }
            }), I.speed = function(e, t, i) {
              var r = e && "object" == typeof e ? I.extend({}, e) : {
                complete: i || !i && t || T(e) && e,
                duration: e,
                easing: i && t || t && !T(t) && t
              };
              return I.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in I.fx.speeds ? r.duration = I.fx.speeds[r.duration] : r.duration = I.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
                T(r.old) && r.old.call(this), r.queue && I.dequeue(this, r.queue)
              }, r
            }, I.fn.extend({
              fadeTo: function(e, t, i, r) {
                return this.filter(me).css("opacity", 0).show().end().animate({
                  opacity: t
                }, e, i, r)
              },
              animate: function(e, t, i, r) {
                var s = I.isEmptyObject(e),
                  n = I.speed(t, i, r),
                  o = function() {
                    var t = St(this, I.extend({}, e), n);
                    (s || ae.get(this, "finish")) && t.stop(!0)
                  };
                return o.finish = o, s || !1 === n.queue ? this.each(o) : this.queue(n.queue, o)
              },
              stop: function(e, t, i) {
                var r = function(e) {
                  var t = e.stop;
                  delete e.stop, t(i)
                };
                return "string" != typeof e && (i = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each(function() {
                  var t = !0,
                    s = null != e && e + "queueHooks",
                    n = I.timers,
                    o = ae.get(this);
                  if (s) o[s] && o[s].stop && r(o[s]);
                  else
                    for (s in o) o[s] && o[s].stop && gt.test(s) && r(o[s]);
                  for (s = n.length; s--;) n[s].elem !== this || null != e && n[s].queue !== e || (n[s].anim.stop(i), t = !1, n.splice(s, 1));
                  !t && i || I.dequeue(this, e)
                })
              },
              finish: function(e) {
                return !1 !== e && (e = e || "fx"), this.each(function() {
                  var t, i = ae.get(this),
                    r = i[e + "queue"],
                    s = i[e + "queueHooks"],
                    n = I.timers,
                    o = r ? r.length : 0;
                  for (i.finish = !0, I.queue(this, e, []), s && s.stop && s.stop.call(this, !0), t = n.length; t--;) n[t].elem === this && n[t].queue === e && (n[t].anim.stop(!0), n.splice(t, 1));
                  for (t = 0; t < o; t++) r[t] && r[t].finish && r[t].finish.call(this);
                  delete i.finish
                })
              }
            }), I.each(["toggle", "show", "hide"], function(e, t) {
              var i = I.fn[t];
              I.fn[t] = function(e, r, s) {
                return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(mt(t, !0), e, r, s)
              }
            }), I.each({
              slideDown: mt("show"),
              slideUp: mt("hide"),
              slideToggle: mt("toggle"),
              fadeIn: {
                opacity: "show"
              },
              fadeOut: {
                opacity: "hide"
              },
              fadeToggle: {
                opacity: "toggle"
              }
            }, function(e, t) {
              I.fn[e] = function(e, i, r) {
                return this.animate(t, e, i, r)
              }
            }), I.timers = [], I.fx.tick = function() {
              var e, t = 0,
                i = I.timers;
              for (dt = Date.now(); t < i.length; t++)(e = i[t])() || i[t] !== e || i.splice(t--, 1);
              i.length || I.fx.stop(), dt = void 0
            }, I.fx.timer = function(e) {
              I.timers.push(e), I.fx.start()
            }, I.fx.interval = 13, I.fx.start = function() {
              pt || (pt = !0, ft())
            }, I.fx.stop = function() {
              pt = null
            }, I.fx.speeds = {
              slow: 600,
              fast: 200,
              _default: 400
            }, I.fn.delay = function(e, t) {
              return e = I.fx && I.fx.speeds[e] || e, t = t || "fx", this.queue(t, function(t, i) {
                var s = r.setTimeout(t, e);
                i.stop = function() {
                  r.clearTimeout(s)
                }
              })
            },
            function() {
              var e = C.createElement("input"),
                t = C.createElement("select").appendChild(C.createElement("option"));
              e.type = "checkbox", f.checkOn = "" !== e.value, f.optSelected = t.selected, (e = C.createElement("input")).value = "t", e.type = "radio", f.radioValue = "t" === e.value
            }();
          var Rt, At = I.expr.attrHandle;
          I.fn.extend({
            attr: function(e, t) {
              return ee(this, I.attr, e, t, arguments.length > 1)
            },
            removeAttr: function(e) {
              return this.each(function() {
                I.removeAttr(this, e)
              })
            }
          }), I.extend({
            attr: function(e, t, i) {
              var r, s, n = e.nodeType;
              if (3 !== n && 8 !== n && 2 !== n) return void 0 === e.getAttribute ? I.prop(e, t, i) : (1 === n && I.isXMLDoc(e) || (s = I.attrHooks[t.toLowerCase()] || (I.expr.match.bool.test(t) ? Rt : void 0)), void 0 !== i ? null === i ? void I.removeAttr(e, t) : s && "set" in s && void 0 !== (r = s.set(e, i, t)) ? r : (e.setAttribute(t, i + ""), i) : s && "get" in s && null !== (r = s.get(e, t)) ? r : null == (r = I.find.attr(e, t)) ? void 0 : r)
            },
            attrHooks: {
              type: {
                set: function(e, t) {
                  if (!f.radioValue && "radio" === t && L(e, "input")) {
                    var i = e.value;
                    return e.setAttribute("type", t), i && (e.value = i), t
                  }
                }
              }
            },
            removeAttr: function(e, t) {
              var i, r = 0,
                s = t && t.match(z);
              if (s && 1 === e.nodeType)
                for (; i = s[r++];) e.removeAttribute(i)
            }
          }), Rt = {
            set: function(e, t, i) {
              return !1 === t ? I.removeAttr(e, i) : e.setAttribute(i, i), i
            }
          }, I.each(I.expr.match.bool.source.match(/\w+/g), function(e, t) {
            var i = At[t] || I.find.attr;
            At[t] = function(e, t, r) {
              var s, n, o = t.toLowerCase();
              return r || (n = At[o], At[o] = s, s = null != i(e, t, r) ? o : null, At[o] = n), s
            }
          });
          var vt = /^(?:input|select|textarea|button)$/i,
            Nt = /^(?:a|area)$/i;

          function It(e) {
            return (e.match(z) || []).join(" ")
          }

          function Ot(e) {
            return e.getAttribute && e.getAttribute("class") || ""
          }

          function Lt(e) {
            return Array.isArray(e) ? e : "string" == typeof e && e.match(z) || []
          }
          I.fn.extend({
            prop: function(e, t) {
              return ee(this, I.prop, e, t, arguments.length > 1)
            },
            removeProp: function(e) {
              return this.each(function() {
                delete this[I.propFix[e] || e]
              })
            }
          }), I.extend({
            prop: function(e, t, i) {
              var r, s, n = e.nodeType;
              if (3 !== n && 8 !== n && 2 !== n) return 1 === n && I.isXMLDoc(e) || (t = I.propFix[t] || t, s = I.propHooks[t]), void 0 !== i ? s && "set" in s && void 0 !== (r = s.set(e, i, t)) ? r : e[t] = i : s && "get" in s && null !== (r = s.get(e, t)) ? r : e[t]
            },
            propHooks: {
              tabIndex: {
                get: function(e) {
                  var t = I.find.attr(e, "tabindex");
                  return t ? parseInt(t, 10) : vt.test(e.nodeName) || Nt.test(e.nodeName) && e.href ? 0 : -1
                }
              }
            },
            propFix: {
              for: "htmlFor",
              class: "className"
            }
          }), f.optSelected || (I.propHooks.selected = {
            get: function(e) {
              var t = e.parentNode;
              return t && t.parentNode && t.parentNode.selectedIndex, null
            },
            set: function(e) {
              var t = e.parentNode;
              t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
            }
          }), I.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            I.propFix[this.toLowerCase()] = this
          }), I.fn.extend({
            addClass: function(e) {
              var t, i, r, s, n, o;
              return T(e) ? this.each(function(t) {
                I(this).addClass(e.call(this, t, Ot(this)))
              }) : (t = Lt(e)).length ? this.each(function() {
                if (r = Ot(this), i = 1 === this.nodeType && " " + It(r) + " ") {
                  for (n = 0; n < t.length; n++) s = t[n], i.indexOf(" " + s + " ") < 0 && (i += s + " ");
                  o = It(i), r !== o && this.setAttribute("class", o)
                }
              }) : this
            },
            removeClass: function(e) {
              var t, i, r, s, n, o;
              return T(e) ? this.each(function(t) {
                I(this).removeClass(e.call(this, t, Ot(this)))
              }) : arguments.length ? (t = Lt(e)).length ? this.each(function() {
                if (r = Ot(this), i = 1 === this.nodeType && " " + It(r) + " ") {
                  for (n = 0; n < t.length; n++)
                    for (s = t[n]; i.indexOf(" " + s + " ") > -1;) i = i.replace(" " + s + " ", " ");
                  o = It(i), r !== o && this.setAttribute("class", o)
                }
              }) : this : this.attr("class", "")
            },
            toggleClass: function(e, t) {
              var i, r, s, n, o = typeof e,
                a = "string" === o || Array.isArray(e);
              return T(e) ? this.each(function(i) {
                I(this).toggleClass(e.call(this, i, Ot(this), t), t)
              }) : "boolean" == typeof t && a ? t ? this.addClass(e) : this.removeClass(e) : (i = Lt(e), this.each(function() {
                if (a)
                  for (n = I(this), s = 0; s < i.length; s++) r = i[s], n.hasClass(r) ? n.removeClass(r) : n.addClass(r);
                else void 0 !== e && "boolean" !== o || ((r = Ot(this)) && ae.set(this, "__className__", r), this.setAttribute && this.setAttribute("class", r || !1 === e ? "" : ae.get(this, "__className__") || ""))
              }))
            },
            hasClass: function(e) {
              var t, i, r = 0;
              for (t = " " + e + " "; i = this[r++];)
                if (1 === i.nodeType && (" " + It(Ot(i)) + " ").indexOf(t) > -1) return !0;
              return !1
            }
          });
          var _t = /\r/g;
          I.fn.extend({
            val: function(e) {
              var t, i, r, s = this[0];
              return arguments.length ? (r = T(e), this.each(function(i) {
                var s;
                1 === this.nodeType && (null == (s = r ? e.call(this, i, I(this).val()) : e) ? s = "" : "number" == typeof s ? s += "" : Array.isArray(s) && (s = I.map(s, function(e) {
                  return null == e ? "" : e + ""
                })), (t = I.valHooks[this.type] || I.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, s, "value") || (this.value = s))
              })) : s ? (t = I.valHooks[s.type] || I.valHooks[s.nodeName.toLowerCase()]) && "get" in t && void 0 !== (i = t.get(s, "value")) ? i : "string" == typeof(i = s.value) ? i.replace(_t, "") : null == i ? "" : i : void 0
            }
          }), I.extend({
            valHooks: {
              option: {
                get: function(e) {
                  var t = I.find.attr(e, "value");
                  return null != t ? t : It(I.text(e))
                }
              },
              select: {
                get: function(e) {
                  var t, i, r, s = e.options,
                    n = e.selectedIndex,
                    o = "select-one" === e.type,
                    a = o ? null : [],
                    l = o ? n + 1 : s.length;
                  for (r = n < 0 ? l : o ? n : 0; r < l; r++)
                    if (((i = s[r]).selected || r === n) && !i.disabled && (!i.parentNode.disabled || !L(i.parentNode, "optgroup"))) {
                      if (t = I(i).val(), o) return t;
                      a.push(t)
                    } return a
                },
                set: function(e, t) {
                  for (var i, r, s = e.options, n = I.makeArray(t), o = s.length; o--;)((r = s[o]).selected = I.inArray(I.valHooks.option.get(r), n) > -1) && (i = !0);
                  return i || (e.selectedIndex = -1), n
                }
              }
            }
          }), I.each(["radio", "checkbox"], function() {
            I.valHooks[this] = {
              set: function(e, t) {
                if (Array.isArray(t)) return e.checked = I.inArray(I(e).val(), t) > -1
              }
            }, f.checkOn || (I.valHooks[this].get = function(e) {
              return null === e.getAttribute("value") ? "on" : e.value
            })
          });
          var yt = r.location,
            wt = {
              guid: Date.now()
            },
            Dt = /\?/;
          I.parseXML = function(e) {
            var t, i;
            if (!e || "string" != typeof e) return null;
            try {
              t = (new r.DOMParser).parseFromString(e, "text/xml")
            } catch (e) {}
            return i = t && t.getElementsByTagName("parsererror")[0], t && !i || I.error("Invalid XML: " + (i ? I.map(i.childNodes, function(e) {
              return e.textContent
            }).join("\n") : e)), t
          };
          var Pt = /^(?:focusinfocus|focusoutblur)$/,
            bt = function(e) {
              e.stopPropagation()
            };
          I.extend(I.event, {
            trigger: function(e, t, i, s) {
              var n, o, a, l, c, h, u, d, E = [i || C],
                g = p.call(e, "type") ? e.type : e,
                f = p.call(e, "namespace") ? e.namespace.split(".") : [];
              if (o = d = a = i = i || C, 3 !== i.nodeType && 8 !== i.nodeType && !Pt.test(g + I.event.triggered) && (g.indexOf(".") > -1 && (f = g.split("."), g = f.shift(), f.sort()), c = g.indexOf(":") < 0 && "on" + g, (e = e[I.expando] ? e : new I.Event(g, "object" == typeof e && e)).isTrigger = s ? 2 : 3, e.namespace = f.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : I.makeArray(t, [e]), u = I.event.special[g] || {}, s || !u.trigger || !1 !== u.trigger.apply(i, t))) {
                if (!s && !u.noBubble && !m(i)) {
                  for (l = u.delegateType || g, Pt.test(l + g) || (o = o.parentNode); o; o = o.parentNode) E.push(o), a = o;
                  a === (i.ownerDocument || C) && E.push(a.defaultView || a.parentWindow || r)
                }
                for (n = 0;
                  (o = E[n++]) && !e.isPropagationStopped();) d = o, e.type = n > 1 ? l : u.bindType || g, (h = (ae.get(o, "events") || Object.create(null))[e.type] && ae.get(o, "handle")) && h.apply(o, t), (h = c && o[c]) && h.apply && ne(o) && (e.result = h.apply(o, t), !1 === e.result && e.preventDefault());
                return e.type = g, s || e.isDefaultPrevented() || u._default && !1 !== u._default.apply(E.pop(), t) || !ne(i) || c && T(i[g]) && !m(i) && ((a = i[c]) && (i[c] = null), I.event.triggered = g, e.isPropagationStopped() && d.addEventListener(g, bt), i[g](), e.isPropagationStopped() && d.removeEventListener(g, bt), I.event.triggered = void 0, a && (i[c] = a)), e.result
              }
            },
            simulate: function(e, t, i) {
              var r = I.extend(new I.Event, i, {
                type: e,
                isSimulated: !0
              });
              I.event.trigger(r, null, t)
            }
          }), I.fn.extend({
            trigger: function(e, t) {
              return this.each(function() {
                I.event.trigger(e, t, this)
              })
            },
            triggerHandler: function(e, t) {
              var i = this[0];
              if (i) return I.event.trigger(e, t, i, !0)
            }
          });
          var Mt = /\[\]$/,
            Ft = /\r?\n/g,
            xt = /^(?:submit|button|image|reset|file)$/i,
            Gt = /^(?:input|select|textarea|keygen)/i;

          function Ut(e, t, i, r) {
            var s;
            if (Array.isArray(t)) I.each(t, function(t, s) {
              i || Mt.test(e) ? r(e, s) : Ut(e + "[" + ("object" == typeof s && null != s ? t : "") + "]", s, i, r)
            });
            else if (i || "object" !== A(t)) r(e, t);
            else
              for (s in t) Ut(e + "[" + s + "]", t[s], i, r)
          }
          I.param = function(e, t) {
            var i, r = [],
              s = function(e, t) {
                var i = T(t) ? t() : t;
                r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == i ? "" : i)
              };
            if (null == e) return "";
            if (Array.isArray(e) || e.jquery && !I.isPlainObject(e)) I.each(e, function() {
              s(this.name, this.value)
            });
            else
              for (i in e) Ut(i, e[i], t, s);
            return r.join("&")
          }, I.fn.extend({
            serialize: function() {
              return I.param(this.serializeArray())
            },
            serializeArray: function() {
              return this.map(function() {
                var e = I.prop(this, "elements");
                return e ? I.makeArray(e) : this
              }).filter(function() {
                var e = this.type;
                return this.name && !I(this).is(":disabled") && Gt.test(this.nodeName) && !xt.test(e) && (this.checked || !Ie.test(e))
              }).map(function(e, t) {
                var i = I(this).val();
                return null == i ? null : Array.isArray(i) ? I.map(i, function(e) {
                  return {
                    name: t.name,
                    value: e.replace(Ft, "\r\n")
                  }
                }) : {
                  name: t.name,
                  value: i.replace(Ft, "\r\n")
                }
              }).get()
            }
          });
          var Ht = /%20/g,
            kt = /#.*$/,
            Bt = /([?&])_=[^&]*/,
            Vt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            Wt = /^(?:GET|HEAD)$/,
            Yt = /^\/\//,
            Kt = {},
            Xt = {},
            zt = "*/".concat("*"),
            $t = C.createElement("a");

          function jt(e) {
            return function(t, i) {
              "string" != typeof t && (i = t, t = "*");
              var r, s = 0,
                n = t.toLowerCase().match(z) || [];
              if (T(i))
                for (; r = n[s++];) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(i)) : (e[r] = e[r] || []).push(i)
            }
          }

          function Jt(e, t, i, r) {
            var s = {},
              n = e === Xt;

            function o(a) {
              var l;
              return s[a] = !0, I.each(e[a] || [], function(e, a) {
                var c = a(t, i, r);
                return "string" != typeof c || n || s[c] ? n ? !(l = c) : void 0 : (t.dataTypes.unshift(c), o(c), !1)
              }), l
            }
            return o(t.dataTypes[0]) || !s["*"] && o("*")
          }

          function qt(e, t) {
            var i, r, s = I.ajaxSettings.flatOptions || {};
            for (i in t) void 0 !== t[i] && ((s[i] ? e : r || (r = {}))[i] = t[i]);
            return r && I.extend(!0, e, r), e
          }
          $t.href = yt.href, I.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
              url: yt.href,
              type: "GET",
              isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(yt.protocol),
              global: !0,
              processData: !0,
              async: !0,
              contentType: "application/x-www-form-urlencoded; charset=UTF-8",
              accepts: {
                "*": zt,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
              },
              contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
              },
              responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
              },
              converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": I.parseXML
              },
              flatOptions: {
                url: !0,
                context: !0
              }
            },
            ajaxSetup: function(e, t) {
              return t ? qt(qt(e, I.ajaxSettings), t) : qt(I.ajaxSettings, e)
            },
            ajaxPrefilter: jt(Kt),
            ajaxTransport: jt(Xt),
            ajax: function(e, t) {
              "object" == typeof e && (t = e, e = void 0), t = t || {};
              var i, s, n, o, a, l, c, h, u, d, p = I.ajaxSetup({}, t),
                E = p.context || p,
                g = p.context && (E.nodeType || E.jquery) ? I(E) : I.event,
                f = I.Deferred(),
                T = I.Callbacks("once memory"),
                m = p.statusCode || {},
                S = {},
                R = {},
                A = "canceled",
                v = {
                  readyState: 0,
                  getResponseHeader: function(e) {
                    var t;
                    if (c) {
                      if (!o)
                        for (o = {}; t = Vt.exec(n);) o[t[1].toLowerCase() + " "] = (o[t[1].toLowerCase() + " "] || []).concat(t[2]);
                      t = o[e.toLowerCase() + " "]
                    }
                    return null == t ? null : t.join(", ")
                  },
                  getAllResponseHeaders: function() {
                    return c ? n : null
                  },
                  setRequestHeader: function(e, t) {
                    return null == c && (e = R[e.toLowerCase()] = R[e.toLowerCase()] || e, S[e] = t), this
                  },
                  overrideMimeType: function(e) {
                    return null == c && (p.mimeType = e), this
                  },
                  statusCode: function(e) {
                    var t;
                    if (e)
                      if (c) v.always(e[v.status]);
                      else
                        for (t in e) m[t] = [m[t], e[t]];
                    return this
                  },
                  abort: function(e) {
                    var t = e || A;
                    return i && i.abort(t), N(0, t), this
                  }
                };
              if (f.promise(v), p.url = ((e || p.url || yt.href) + "").replace(Yt, yt.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(z) || [""], null == p.crossDomain) {
                l = C.createElement("a");
                try {
                  l.href = p.url, l.href = l.href, p.crossDomain = $t.protocol + "//" + $t.host != l.protocol + "//" + l.host
                } catch (e) {
                  p.crossDomain = !0
                }
              }
              if (p.data && p.processData && "string" != typeof p.data && (p.data = I.param(p.data, p.traditional)), Jt(Kt, p, t, v), c) return v;
              for (u in (h = I.event && p.global) && 0 === I.active++ && I.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Wt.test(p.type), s = p.url.replace(kt, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Ht, "+")) : (d = p.url.slice(s.length), p.data && (p.processData || "string" == typeof p.data) && (s += (Dt.test(s) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (s = s.replace(Bt, "$1"), d = (Dt.test(s) ? "&" : "?") + "_=" + wt.guid++ + d), p.url = s + d), p.ifModified && (I.lastModified[s] && v.setRequestHeader("If-Modified-Since", I.lastModified[s]), I.etag[s] && v.setRequestHeader("If-None-Match", I.etag[s])), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && v.setRequestHeader("Content-Type", p.contentType), v.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + zt + "; q=0.01" : "") : p.accepts["*"]), p.headers) v.setRequestHeader(u, p.headers[u]);
              if (p.beforeSend && (!1 === p.beforeSend.call(E, v, p) || c)) return v.abort();
              if (A = "abort", T.add(p.complete), v.done(p.success), v.fail(p.error), i = Jt(Xt, p, t, v)) {
                if (v.readyState = 1, h && g.trigger("ajaxSend", [v, p]), c) return v;
                p.async && p.timeout > 0 && (a = r.setTimeout(function() {
                  v.abort("timeout")
                }, p.timeout));
                try {
                  c = !1, i.send(S, N)
                } catch (e) {
                  if (c) throw e;
                  N(-1, e)
                }
              } else N(-1, "No Transport");

              function N(e, t, o, l) {
                var u, d, C, S, R, A = t;
                c || (c = !0, a && r.clearTimeout(a), i = void 0, n = l || "", v.readyState = e > 0 ? 4 : 0, u = e >= 200 && e < 300 || 304 === e, o && (S = function(e, t, i) {
                  for (var r, s, n, o, a = e.contents, l = e.dataTypes;
                    "*" === l[0];) l.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                  if (r)
                    for (s in a)
                      if (a[s] && a[s].test(r)) {
                        l.unshift(s);
                        break
                      } if (l[0] in i) n = l[0];
                  else {
                    for (s in i) {
                      if (!l[0] || e.converters[s + " " + l[0]]) {
                        n = s;
                        break
                      }
                      o || (o = s)
                    }
                    n = n || o
                  }
                  if (n) return n !== l[0] && l.unshift(n), i[n]
                }(p, v, o)), !u && I.inArray("script", p.dataTypes) > -1 && I.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function() {}), S = function(e, t, i, r) {
                  var s, n, o, a, l, c = {},
                    h = e.dataTypes.slice();
                  if (h[1])
                    for (o in e.converters) c[o.toLowerCase()] = e.converters[o];
                  for (n = h.shift(); n;)
                    if (e.responseFields[n] && (i[e.responseFields[n]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = n, n = h.shift())
                      if ("*" === n) n = l;
                      else if ("*" !== l && l !== n) {
                    if (!(o = c[l + " " + n] || c["* " + n]))
                      for (s in c)
                        if ((a = s.split(" "))[1] === n && (o = c[l + " " + a[0]] || c["* " + a[0]])) {
                          !0 === o ? o = c[s] : !0 !== c[s] && (n = a[0], h.unshift(a[1]));
                          break
                        } if (!0 !== o)
                      if (o && e.throws) t = o(t);
                      else try {
                        t = o(t)
                      } catch (e) {
                        return {
                          state: "parsererror",
                          error: o ? e : "No conversion from " + l + " to " + n
                        }
                      }
                  }
                  return {
                    state: "success",
                    data: t
                  }
                }(p, S, v, u), u ? (p.ifModified && ((R = v.getResponseHeader("Last-Modified")) && (I.lastModified[s] = R), (R = v.getResponseHeader("etag")) && (I.etag[s] = R)), 204 === e || "HEAD" === p.type ? A = "nocontent" : 304 === e ? A = "notmodified" : (A = S.state, d = S.data, u = !(C = S.error))) : (C = A, !e && A || (A = "error", e < 0 && (e = 0))), v.status = e, v.statusText = (t || A) + "", u ? f.resolveWith(E, [d, A, v]) : f.rejectWith(E, [v, A, C]), v.statusCode(m), m = void 0, h && g.trigger(u ? "ajaxSuccess" : "ajaxError", [v, p, u ? d : C]), T.fireWith(E, [v, A]), h && (g.trigger("ajaxComplete", [v, p]), --I.active || I.event.trigger("ajaxStop")))
              }
              return v
            },
            getJSON: function(e, t, i) {
              return I.get(e, t, i, "json")
            },
            getScript: function(e, t) {
              return I.get(e, void 0, t, "script")
            }
          }), I.each(["get", "post"], function(e, t) {
            I[t] = function(e, i, r, s) {
              return T(i) && (s = s || r, r = i, i = void 0), I.ajax(I.extend({
                url: e,
                type: t,
                dataType: s,
                data: i,
                success: r
              }, I.isPlainObject(e) && e))
            }
          }), I.ajaxPrefilter(function(e) {
            var t;
            for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
          }), I._evalUrl = function(e, t, i) {
            return I.ajax({
              url: e,
              type: "GET",
              dataType: "script",
              cache: !0,
              async: !1,
              global: !1,
              converters: {
                "text script": function() {}
              },
              dataFilter: function(e) {
                I.globalEval(e, t, i)
              }
            })
          }, I.fn.extend({
            wrapAll: function(e) {
              var t;
              return this[0] && (T(e) && (e = e.call(this[0])), t = I(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                return e
              }).append(this)), this
            },
            wrapInner: function(e) {
              return T(e) ? this.each(function(t) {
                I(this).wrapInner(e.call(this, t))
              }) : this.each(function() {
                var t = I(this),
                  i = t.contents();
                i.length ? i.wrapAll(e) : t.append(e)
              })
            },
            wrap: function(e) {
              var t = T(e);
              return this.each(function(i) {
                I(this).wrapAll(t ? e.call(this, i) : e)
              })
            },
            unwrap: function(e) {
              return this.parent(e).not("body").each(function() {
                I(this).replaceWith(this.childNodes)
              }), this
            }
          }), I.expr.pseudos.hidden = function(e) {
            return !I.expr.pseudos.visible(e)
          }, I.expr.pseudos.visible = function(e) {
            return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
          }, I.ajaxSettings.xhr = function() {
            try {
              return new r.XMLHttpRequest
            } catch (e) {}
          };
          var Qt = {
              0: 200,
              1223: 204
            },
            Zt = I.ajaxSettings.xhr();
          f.cors = !!Zt && "withCredentials" in Zt, f.ajax = Zt = !!Zt, I.ajaxTransport(function(e) {
            var t, i;
            if (f.cors || Zt && !e.crossDomain) return {
              send: function(s, n) {
                var o, a = e.xhr();
                if (a.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                  for (o in e.xhrFields) a[o] = e.xhrFields[o];
                for (o in e.mimeType && a.overrideMimeType && a.overrideMimeType(e.mimeType), e.crossDomain || s["X-Requested-With"] || (s["X-Requested-With"] = "XMLHttpRequest"), s) a.setRequestHeader(o, s[o]);
                t = function(e) {
                  return function() {
                    t && (t = i = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null, "abort" === e ? a.abort() : "error" === e ? "number" != typeof a.status ? n(0, "error") : n(a.status, a.statusText) : n(Qt[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {
                      binary: a.response
                    } : {
                      text: a.responseText
                    }, a.getAllResponseHeaders()))
                  }
                }, a.onload = t(), i = a.onerror = a.ontimeout = t("error"), void 0 !== a.onabort ? a.onabort = i : a.onreadystatechange = function() {
                  4 === a.readyState && r.setTimeout(function() {
                    t && i()
                  })
                }, t = t("abort");
                try {
                  a.send(e.hasContent && e.data || null)
                } catch (e) {
                  if (t) throw e
                }
              },
              abort: function() {
                t && t()
              }
            }
          }), I.ajaxPrefilter(function(e) {
            e.crossDomain && (e.contents.script = !1)
          }), I.ajaxSetup({
            accepts: {
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
              script: /\b(?:java|ecma)script\b/
            },
            converters: {
              "text script": function(e) {
                return I.globalEval(e), e
              }
            }
          }), I.ajaxPrefilter("script", function(e) {
            void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
          }), I.ajaxTransport("script", function(e) {
            var t, i;
            if (e.crossDomain || e.scriptAttrs) return {
              send: function(r, s) {
                t = I("<script>").attr(e.scriptAttrs || {}).prop({
                  charset: e.scriptCharset,
                  src: e.url
                }).on("load error", i = function(e) {
                  t.remove(), i = null, e && s("error" === e.type ? 404 : 200, e.type)
                }), C.head.appendChild(t[0])
              },
              abort: function() {
                i && i()
              }
            }
          });
          var ei, ti = [],
            ii = /(=)\?(?=&|$)|\?\?/;
          I.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
              var e = ti.pop() || I.expando + "_" + wt.guid++;
              return this[e] = !0, e
            }
          }), I.ajaxPrefilter("json jsonp", function(e, t, i) {
            var s, n, o, a = !1 !== e.jsonp && (ii.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && ii.test(e.data) && "data");
            if (a || "jsonp" === e.dataTypes[0]) return s = e.jsonpCallback = T(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(ii, "$1" + s) : !1 !== e.jsonp && (e.url += (Dt.test(e.url) ? "&" : "?") + e.jsonp + "=" + s), e.converters["script json"] = function() {
              return o || I.error(s + " was not called"), o[0]
            }, e.dataTypes[0] = "json", n = r[s], r[s] = function() {
              o = arguments
            }, i.always(function() {
              void 0 === n ? I(r).removeProp(s) : r[s] = n, e[s] && (e.jsonpCallback = t.jsonpCallback, ti.push(s)), o && T(n) && n(o[0]), o = n = void 0
            }), "script"
          }), f.createHTMLDocument = ((ei = C.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === ei.childNodes.length), I.parseHTML = function(e, t, i) {
            return "string" != typeof e ? [] : ("boolean" == typeof t && (i = t, t = !1), t || (f.createHTMLDocument ? ((r = (t = C.implementation.createHTMLDocument("")).createElement("base")).href = C.location.href, t.head.appendChild(r)) : t = C), n = !i && [], (s = k.exec(e)) ? [t.createElement(s[1])] : (s = Pe([e], t, n), n && n.length && I(n).remove(), I.merge([], s.childNodes)));
            var r, s, n
          }, I.fn.load = function(e, t, i) {
            var r, s, n, o = this,
              a = e.indexOf(" ");
            return a > -1 && (r = It(e.slice(a)), e = e.slice(0, a)), T(t) ? (i = t, t = void 0) : t && "object" == typeof t && (s = "POST"), o.length > 0 && I.ajax({
              url: e,
              type: s || "GET",
              dataType: "html",
              data: t
            }).done(function(e) {
              n = arguments, o.html(r ? I("<div>").append(I.parseHTML(e)).find(r) : e)
            }).always(i && function(e, t) {
              o.each(function() {
                i.apply(this, n || [e.responseText, t, e])
              })
            }), this
          }, I.expr.pseudos.animated = function(e) {
            return I.grep(I.timers, function(t) {
              return e === t.elem
            }).length
          }, I.offset = {
            setOffset: function(e, t, i) {
              var r, s, n, o, a, l, c = I.css(e, "position"),
                h = I(e),
                u = {};
              "static" === c && (e.style.position = "relative"), a = h.offset(), n = I.css(e, "top"), l = I.css(e, "left"), ("absolute" === c || "fixed" === c) && (n + l).indexOf("auto") > -1 ? (o = (r = h.position()).top, s = r.left) : (o = parseFloat(n) || 0, s = parseFloat(l) || 0), T(t) && (t = t.call(e, i, I.extend({}, a))), null != t.top && (u.top = t.top - a.top + o), null != t.left && (u.left = t.left - a.left + s), "using" in t ? t.using.call(e, u) : h.css(u)
            }
          }, I.fn.extend({
            offset: function(e) {
              if (arguments.length) return void 0 === e ? this : this.each(function(t) {
                I.offset.setOffset(this, e, t)
              });
              var t, i, r = this[0];
              return r ? r.getClientRects().length ? (t = r.getBoundingClientRect(), i = r.ownerDocument.defaultView, {
                top: t.top + i.pageYOffset,
                left: t.left + i.pageXOffset
              }) : {
                top: 0,
                left: 0
              } : void 0
            },
            position: function() {
              if (this[0]) {
                var e, t, i, r = this[0],
                  s = {
                    top: 0,
                    left: 0
                  };
                if ("fixed" === I.css(r, "position")) t = r.getBoundingClientRect();
                else {
                  for (t = this.offset(), i = r.ownerDocument, e = r.offsetParent || i.documentElement; e && (e === i.body || e === i.documentElement) && "static" === I.css(e, "position");) e = e.parentNode;
                  e && e !== r && 1 === e.nodeType && ((s = I(e).offset()).top += I.css(e, "borderTopWidth", !0), s.left += I.css(e, "borderLeftWidth", !0))
                }
                return {
                  top: t.top - s.top - I.css(r, "marginTop", !0),
                  left: t.left - s.left - I.css(r, "marginLeft", !0)
                }
              }
            },
            offsetParent: function() {
              return this.map(function() {
                for (var e = this.offsetParent; e && "static" === I.css(e, "position");) e = e.offsetParent;
                return e || ge
              })
            }
          }), I.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
          }, function(e, t) {
            var i = "pageYOffset" === t;
            I.fn[e] = function(r) {
              return ee(this, function(e, r, s) {
                var n;
                if (m(e) ? n = e : 9 === e.nodeType && (n = e.defaultView), void 0 === s) return n ? n[t] : e[r];
                n ? n.scrollTo(i ? n.pageXOffset : s, i ? s : n.pageYOffset) : e[r] = s
              }, e, r, arguments.length)
            }
          }), I.each(["top", "left"], function(e, t) {
            I.cssHooks[t] = et(f.pixelPosition, function(e, i) {
              if (i) return i = Ze(e, t), $e.test(i) ? I(e).position()[t] + "px" : i
            })
          }), I.each({
            Height: "height",
            Width: "width"
          }, function(e, t) {
            I.each({
              padding: "inner" + e,
              content: t,
              "": "outer" + e
            }, function(i, r) {
              I.fn[r] = function(s, n) {
                var o = arguments.length && (i || "boolean" != typeof s),
                  a = i || (!0 === s || !0 === n ? "margin" : "border");
                return ee(this, function(t, i, s) {
                  var n;
                  return m(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (n = t.documentElement, Math.max(t.body["scroll" + e], n["scroll" + e], t.body["offset" + e], n["offset" + e], n["client" + e])) : void 0 === s ? I.css(t, i, a) : I.style(t, i, s, a)
                }, t, o ? s : void 0, o)
              }
            })
          }), I.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
            I.fn[t] = function(e) {
              return this.on(t, e)
            }
          }), I.fn.extend({
            bind: function(e, t, i) {
              return this.on(e, null, t, i)
            },
            unbind: function(e, t) {
              return this.off(e, null, t)
            },
            delegate: function(e, t, i, r) {
              return this.on(t, e, i, r)
            },
            undelegate: function(e, t, i) {
              return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
            },
            hover: function(e, t) {
              return this.on("mouseenter", e).on("mouseleave", t || e)
            }
          }), I.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, t) {
            I.fn[t] = function(e, i) {
              return arguments.length > 0 ? this.on(t, null, e, i) : this.trigger(t)
            }
          });
          var ri = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
          I.proxy = function(e, t) {
            var i, r, s;
            if ("string" == typeof t && (i = e[t], t = e, e = i), T(e)) return r = a.call(arguments, 2), s = function() {
              return e.apply(t || this, r.concat(a.call(arguments)))
            }, s.guid = e.guid = e.guid || I.guid++, s
          }, I.holdReady = function(e) {
            e ? I.readyWait++ : I.ready(!0)
          }, I.isArray = Array.isArray, I.parseJSON = JSON.parse, I.nodeName = L, I.isFunction = T, I.isWindow = m, I.camelCase = se, I.type = A, I.now = Date.now, I.isNumeric = function(e) {
            var t = I.type(e);
            return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
          }, I.trim = function(e) {
            return null == e ? "" : (e + "").replace(ri, "$1")
          }, void 0 === (i = function() {
            return I
          }.apply(t, [])) || (e.exports = i);
          var si = r.jQuery,
            ni = r.$;
          return I.noConflict = function(e) {
            return r.$ === I && (r.$ = ni), e && r.jQuery === I && (r.jQuery = si), I
          }, void 0 === s && (r.jQuery = r.$ = I), I
        })
      }
    },
    t = {};

  function i(r) {
    var s = t[r];
    if (void 0 !== s) return s.exports;
    var n = t[r] = {
      exports: {}
    };
    return e[r].call(n.exports, n, n.exports, i), n.exports
  }
  i.n = e => {
    var t = e && e.__esModule ? () => e.default : () => e;
    return i.d(t, {
      a: t
    }), t
  }, i.d = (e, t) => {
    for (var r in t) i.o(t, r) && !i.o(e, r) && Object.defineProperty(e, r, {
      enumerable: !0,
      get: t[r]
    })
  }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    })
  }, (() => {
    "use strict";
    var e = {};
    i.r(e), i.d(e, {
      CFB: () => qd,
      SSF: () => zd,
      parse_xlscfb: () => RA,
      parse_zip: () => wv,
      read: () => Gv,
      readFile: () => Uv,
      readFileSync: () => Uv,
      set_cptable: () => ku,
      set_fs: () => Zd,
      stream: () => lN,
      utils: () => aN,
      version: () => cN,
      write: () => Yv,
      writeFile: () => Xv,
      writeFileAsync: () => $v,
      writeFileSync: () => Xv,
      writeFileXLSX: () => zv,
      writeXLSX: () => Wv
    });
    var t = {};
    i.r(t), i.d(t, {
      bigquery: () => FN,
      db2: () => XN,
      db2i: () => tI,
      duckdb: () => hI,
      hive: () => CI,
      mariadb: () => yI,
      mysql: () => UI,
      n1ql: () => tO,
      plsql: () => hO,
      postgresql: () => CO,
      redshift: () => _O,
      singlestoredb: () => _L,
      snowflake: () => GL,
      spark: () => GO,
      sql: () => tL,
      sqlite: () => XO,
      tidb: () => zI,
      transactsql: () => CL,
      trino: () => hL
    });
    var r = i(692),
      s = i.n(r);
    const n = bootstrap;
    var o = i(237),
      a = i.n(o),
      l = (i(532), Object.defineProperty),
      c = Object.defineProperties,
      h = Object.getOwnPropertyDescriptor,
      u = Object.getOwnPropertyDescriptors,
      d = Object.getOwnPropertySymbols,
      p = Object.prototype.hasOwnProperty,
      E = Object.prototype.propertyIsEnumerable,
      g = (e, t, i) => t in e ? l(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: i
      }) : e[t] = i,
      f = (e, t) => {
        for (var i in t || (t = {})) p.call(t, i) && g(e, i, t[i]);
        if (d)
          for (var i of d(t)) E.call(t, i) && g(e, i, t[i]);
        return e
      },
      T = (e, t) => c(e, u(t)),
      m = (e, t) => {
        for (var i in t) l(e, i, {
          get: t[i],
          enumerable: !0
        })
      },
      C = (e, t, i, r) => {
        for (var s, n = r > 1 ? void 0 : r ? h(t, i) : t, o = e.length - 1; o >= 0; o--)(s = e[o]) && (n = (r ? s(t, i, n) : s(n)) || n);
        return r && n && l(t, i, n), n
      },
      S = (e, t) => (i, r) => t(i, r, e),
      R = {};

    function A(e) {
      return null == e || "" === e ? null : e
    }

    function v(e, t = !1) {
      return null != e && ("" !== e || t)
    }

    function N(e) {
      return !v(e)
    }

    function I(e) {
      return null == e || 0 === e.length
    }

    function O(e) {
      return null != e && "function" == typeof e.toString ? e.toString() : null
    }

    function L(e) {
      if (void 0 === e) return;
      if (null === e || "" === e) return null;
      if ("number" == typeof e) return isNaN(e) ? void 0 : e;
      const t = parseInt(e, 10);
      return isNaN(t) ? void 0 : t
    }

    function _(e) {
      if (void 0 !== e) return null !== e && "" !== e && ("boolean" == typeof e ? e : /true/i.test(e))
    }

    function y(e) {
      if (null != e && "" !== e) return e
    }

    function w(e, t) {
      return (e ? JSON.stringify(e) : null) === (t ? JSON.stringify(t) : null)
    }

    function D(e, t, i = !1) {
      const r = null == e,
        s = null == t;
      if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), r && s) return 0;
      if (r) return -1;
      if (s) return 1;

      function n(e, t) {
        return e > t ? 1 : e < t ? -1 : 0
      }
      if ("string" != typeof e) return n(e, t);
      if (!i) return n(e, t);
      try {
        return e.localeCompare(t)
      } catch (i) {
        return n(e, t)
      }
    }

    function P(e) {
      if (e instanceof Set || e instanceof Map) {
        const t = [];
        return e.forEach(e => t.push(e)), t
      }
      return Object.values(e)
    }
    m(R, {
      attrToBoolean: () => _,
      attrToNumber: () => L,
      attrToString: () => y,
      defaultComparator: () => D,
      exists: () => v,
      jsonEquals: () => w,
      makeNull: () => A,
      missing: () => N,
      missingOrEmpty: () => I,
      toStringOrNull: () => O,
      values: () => P
    });
    var b = class {
        constructor() {
          this.existingKeys = {}
        }
        addExistingKeys(e) {
          for (let t = 0; t < e.length; t++) this.existingKeys[e[t]] = !0
        }
        getUniqueKey(e, t) {
          e = O(e);
          let i = 0;
          for (;;) {
            let r;
            if (e ? (r = e, 0 !== i && (r += "_" + i)) : t ? (r = t, 0 !== i && (r += "_" + i)) : r = i, !this.existingKeys[r]) return this.existingKeys[r] = !0, String(r);
            i++
          }
        }
      },
      M = {};
    m(M, {
      SKIP_JS_BUILTINS: () => F,
      cloneObject: () => G,
      deepCloneDefinition: () => U,
      getAllValuesInObject: () => H,
      getValueUsingField: () => B,
      isNonNullObject: () => W,
      iterateObject: () => x,
      mergeDeep: () => k,
      removeAllReferences: () => V
    });
    var F = new Set(["__proto__", "constructor", "prototype"]);

    function x(e, t) {
      if (null != e)
        if (Array.isArray(e))
          for (let i = 0; i < e.length; i++) t(i.toString(), e[i]);
        else
          for (const [i, r] of Object.entries(e)) t(i, r)
    }

    function G(e) {
      const t = {},
        i = Object.keys(e);
      for (let r = 0; r < i.length; r++) {
        if (F.has(i[r])) continue;
        const s = i[r],
          n = e[s];
        t[s] = n
      }
      return t
    }

    function U(e, t) {
      if (!e) return;
      const i = e,
        r = {};
      return Object.keys(i).forEach(e => {
        if (t && t.indexOf(e) >= 0 || F.has(e)) return;
        const s = i[e],
          n = W(s) && s.constructor === Object;
        r[e] = n ? U(s) : s
      }), r
    }

    function H(e) {
      if (!e) return [];
      const t = Object;
      if ("function" == typeof t.values) return t.values(e);
      const i = [];
      for (const t in e) e.hasOwnProperty(t) && e.propertyIsEnumerable(t) && i.push(e[t]);
      return i
    }

    function k(e, t, i = !0, r = !1) {
      v(t) && x(t, (t, s) => {
        if (F.has(t)) return;
        let n = e[t];
        if (n !== s) {
          if (r) {
            if (null == n && null != s) {
              "object" == typeof s && s.constructor === Object && (n = {}, e[t] = n)
            }
          }
          W(s) && W(n) && !Array.isArray(n) ? k(n, s, i, r) : (i || void 0 !== s) && (e[t] = s)
        }
      })
    }

    function B(e, t, i) {
      if (!t || !e) return;
      if (!i) return e[t];
      const r = t.split(".");
      let s = e;
      for (let e = 0; e < r.length; e++) {
        if (null == s) return;
        s = s[r[e]]
      }
      return s
    }

    function V(e, t = [], i) {
      Object.keys(e).forEach(i => {
        "object" != typeof e[i] || t.includes(i) || (e[i] = void 0)
      });
      const r = Object.getPrototypeOf(e),
        s = {};
      Object.getOwnPropertyNames(r).forEach(e => {
        if ("function" == typeof r[e] && !t.includes(e)) {
          const t = () => {
            console.warn((e => `AG Grid: Grid API function ${e}() cannot be called as the grid has been destroyed.\n    It is recommended to remove local references to the grid api. Alternatively, check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.\n    To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${i}`)(e))
          };
          s[e] = {
            value: t,
            writable: !0
          }
        }
      }), Object.defineProperties(e, s)
    }

    function W(e) {
      return "object" == typeof e && null !== e
    }
    var Y = {};
    m(Y, {
      compose: () => oe,
      debounce: () => re,
      doOnce: () => X,
      errorOnce: () => j,
      executeAfter: () => ie,
      executeInAWhile: () => Q,
      executeNextVMTurn: () => te,
      getFunctionName: () => J,
      isFunction: () => q,
      noop: () => ae,
      throttle: () => se,
      waitUntil: () => ne,
      warnOnce: () => z
    });
    var K = {};

    function X(e, t) {
      K[t] || (e(), K[t] = !0)
    }

    function z(e) {
      X(() => console.warn("AG Grid: " + e), e)
    }

    function j(e) {
      X(() => console.error("AG Grid: " + e), e)
    }

    function J(e) {
      if (e.name) return e.name;
      const t = /function\s+([^\(]+)/.exec(e.toString());
      return t && 2 === t.length ? t[1].trim() : null
    }

    function q(e) {
      return !!(e && e.constructor && e.call && e.apply)
    }

    function Q(e) {
      ie(e, 400)
    }
    var Z = [],
      ee = !1;

    function te(e) {
      Z.push(e), ee || (ee = !0, window.setTimeout(() => {
        const e = Z.slice();
        Z.length = 0, ee = !1, e.forEach(e => e())
      }, 0))
    }

    function ie(e, t = 0) {
      e.length > 0 && window.setTimeout(() => e.forEach(e => e()), t)
    }

    function re(e, t) {
      let i;
      return function(...r) {
        const s = this;
        window.clearTimeout(i), i = window.setTimeout(function() {
          e.apply(s, r)
        }, t)
      }
    }

    function se(e, t) {
      let i = 0;
      return function(...r) {
        const s = (new Date).getTime();
        s - i < t || (i = s, e.apply(this, r))
      }
    }

    function ne(e, t, i = 100, r) {
      const s = (new Date).getTime();
      let n = null,
        o = !1;
      const a = () => {
        const a = (new Date).getTime() - s > i;
        (e() || a) && (t(), o = !0, null != n && (window.clearInterval(n), n = null), a && r && console.warn(r))
      };
      a(), o || (n = window.setInterval(a, 10))
    }

    function oe(...e) {
      return t => e.reduce((e, t) => t(e), t)
    }
    var ae = () => {},
      le = (e => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(le || {}),
      ce = class e {
        static register(t) {
          e.__register(t, !0, void 0)
        }
        static registerModules(t) {
          e.__registerModules(t, !0, void 0)
        }
        static __register(t, i, r) {
          e.runVersionChecks(t), void 0 !== r ? (e.areGridScopedModules = !0, void 0 === e.gridModulesMap[r] && (e.gridModulesMap[r] = {}), e.gridModulesMap[r][t.moduleName] = t) : e.globalModulesMap[t.moduleName] = t, e.setModuleBased(i)
        }
        static __unRegisterGridModules(t) {
          delete e.gridModulesMap[t]
        }
        static __registerModules(t, i, r) {
          e.setModuleBased(i), t && t.forEach(t => e.__register(t, i, r))
        }
        static isValidModuleVersion(t) {
          const [i, r] = t.version.split(".") || [], [s, n] = e.currentModuleVersion.split(".") || [];
          return i === s && r === n
        }
        static runVersionChecks(t) {
          if (e.currentModuleVersion || (e.currentModuleVersion = t.version), t.version ? e.isValidModuleVersion(t) || console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${t.moduleName}' is version ${t.version} but the other modules are version ${this.currentModuleVersion}. Please update all modules to the same version.`) : console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${t.moduleName}' is incompatible. Please update all modules to the same version.`), t.validate) {
            const e = t.validate();
            if (!e.isValid) {
              const t = e;
              console.error(`AG Grid: ${t.message}`)
            }
          }
        }
        static setModuleBased(t) {
          void 0 === e.moduleBased ? e.moduleBased = t : e.moduleBased !== t && X(() => {
            console.warn("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), console.warn("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information.")
          }, "ModulePackageCheck")
        }
        static __setIsBundled() {
          e.isBundled = !0
        }
        static __assertRegistered(t, i, r) {
          var s;
          if (this.__isRegistered(t, r)) return !0;
          const n = i + t;
          let o;
          if (e.isBundled) o = `AG Grid: unable to use ${i} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:\n        \n        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>\n        \nFor more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
          else if (e.moduleBased || void 0 === e.moduleBased) {
            let n = null == (s = Object.entries(le).find(([e, i]) => i === t)) ? void 0 : s[0];
            o = `AG Grid: unable to use ${i} as the ${n} is not registered${e.areGridScopedModules?` for gridId: ${r}`:""}. Check if you have registered the module:\n           \n    import { ModuleRegistry } from '@ag-grid-community/core';\n    import { ${n} } from '${t}';\n    \n    ModuleRegistry.registerModules([ ${n} ]);\n\nFor more info see: https://www.ag-grid.com/javascript-grid/modules/`
          } else o = `AG Grid: unable to use ${i} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:\n            \n    import 'ag-grid-enterprise';`;
          return X(() => {
            console.warn(o)
          }, n), !1
        }
        static __isRegistered(t, i) {
          var r;
          return !!e.globalModulesMap[t] || !!(null == (r = e.gridModulesMap[i]) ? void 0 : r[t])
        }
        static __getRegisteredModules(t) {
          return [...P(e.globalModulesMap), ...P(e.gridModulesMap[t] || {})]
        }
        static __getGridRegisteredModules(t) {
          var i;
          return P(null != (i = e.gridModulesMap[t]) ? i : {}) || []
        }
        static __isPackageBased() {
          return !e.moduleBased
        }
      };
    ce.globalModulesMap = {}, ce.gridModulesMap = {}, ce.areGridScopedModules = !1;
    var he = ce,
      ue = class {
        constructor(e, t) {
          if (this.beanWrappers = {}, this.destroyed = !1, !e || !e.beanClasses) return;
          this.contextParams = e, this.logger = t, this.logger.log(">> creating ag-Application Context"), this.createBeans();
          const i = this.getBeanInstances();
          this.wireBeans(i), this.logger.log(">> ag-Application Context ready - component is alive")
        }
        getBeanInstances() {
          return P(this.beanWrappers).map(e => e.beanInstance)
        }
        createBean(e, t) {
          if (!e) throw Error("Can't wire to bean since it is null");
          return this.wireBeans([e], t), e
        }
        wireBeans(e, t) {
          this.autoWireBeans(e), this.methodWireBeans(e), this.callLifeCycleMethods(e, "preConstructMethods"), v(t) && e.forEach(t), this.callLifeCycleMethods(e, "postConstructMethods")
        }
        createBeans() {
          this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this)), x(this.beanWrappers, (e, t) => {
            let i;
            t.bean.__agBeanMetaData && t.bean.__agBeanMetaData.autowireMethods && t.bean.__agBeanMetaData.autowireMethods.agConstructor && (i = t.bean.__agBeanMetaData.autowireMethods.agConstructor);
            const r = this.getBeansForParameters(i, t.bean.name),
              s = new(t.bean.bind.apply(t.bean, [null, ...r]));
            t.beanInstance = s
          });
          const e = Object.keys(this.beanWrappers).join(", ");
          this.logger.log(`created beans: ${e}`)
        }
        createBeanWrapper(e) {
          const t = e.__agBeanMetaData;
          if (!t) {
            let t;
            return t = e.prototype.constructor ? J(e.prototype.constructor) : "" + e, void console.error(`Context item ${t} is not a bean`)
          }
          const i = {
            bean: e,
            beanInstance: null,
            beanName: t.beanName
          };
          this.beanWrappers[t.beanName] = i
        }
        autoWireBeans(e) {
          e.forEach(e => {
            this.forEachMetaDataInHierarchy(e, (t, i) => {
              const r = t.agClassAttributes;
              r && r.forEach(t => {
                const r = this.lookupBeanInstance(i, t.beanName, t.optional);
                e[t.attributeName] = r
              })
            })
          })
        }
        methodWireBeans(e) {
          e.forEach(e => {
            this.forEachMetaDataInHierarchy(e, (t, i) => {
              x(t.autowireMethods, (t, r) => {
                if ("agConstructor" === t) return;
                const s = this.getBeansForParameters(r, i);
                e[t].apply(e, s)
              })
            })
          })
        }
        forEachMetaDataInHierarchy(e, t) {
          let i = Object.getPrototypeOf(e);
          for (; null != i;) {
            const e = i.constructor;
            if (e.hasOwnProperty("__agBeanMetaData")) {
              t(e.__agBeanMetaData, this.getBeanName(e))
            }
            i = Object.getPrototypeOf(i)
          }
        }
        getBeanName(e) {
          if (e.__agBeanMetaData && e.__agBeanMetaData.beanName) return e.__agBeanMetaData.beanName;
          const t = e.toString();
          return t.substring(9, t.indexOf("("))
        }
        getBeansForParameters(e, t) {
          const i = [];
          return e && x(e, (e, r) => {
            const s = this.lookupBeanInstance(t, r);
            i[Number(e)] = s
          }), i
        }
        lookupBeanInstance(e, t, i = !1) {
          if (this.destroyed) return this.logger.log(`AG Grid: bean reference ${t} is used after the grid is destroyed!`), null;
          if ("context" === t) return this;
          if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(t)) return this.contextParams.providedBeanInstances[t];
          const r = this.beanWrappers[t];
          return r ? r.beanInstance : (i || console.error(`AG Grid: unable to find bean reference ${t} while initialising ${e}`), null)
        }
        callLifeCycleMethods(e, t) {
          e.forEach(e => this.callLifeCycleMethodsOnBean(e, t))
        }
        callLifeCycleMethodsOnBean(e, t, i) {
          const r = {};
          this.forEachMetaDataInHierarchy(e, e => {
            const s = e[t];
            s && s.forEach(e => {
              e != i && (r[e] = !0)
            })
          });
          Object.keys(r).forEach(t => e[t]())
        }
        getBean(e) {
          return this.lookupBeanInstance("getBean", e, !0)
        }
        destroy() {
          if (this.destroyed) return;
          this.destroyed = !0, this.logger.log(">> Shutting down ag-Application Context");
          const e = this.getBeanInstances();
          this.destroyBeans(e), this.contextParams.providedBeanInstances = null, he.__unRegisterGridModules(this.contextParams.gridId), this.logger.log(">> ag-Application Context shut down - component is dead")
        }
        destroyBean(e) {
          e && this.destroyBeans([e])
        }
        destroyBeans(e) {
          return e ? (e.forEach(e => {
            this.callLifeCycleMethodsOnBean(e, "preDestroyMethods", "destroy");
            const t = e;
            "function" == typeof t.destroy && t.destroy()
          }), []) : []
        }
        isDestroyed() {
          return this.destroyed
        }
        getGridId() {
          return this.contextParams.gridId
        }
      };

    function de(e, t, i) {
      const r = Se(e.constructor);
      r.preConstructMethods || (r.preConstructMethods = []), r.preConstructMethods.push(t)
    }

    function pe(e, t, i) {
      const r = Se(e.constructor);
      r.postConstructMethods || (r.postConstructMethods = []), r.postConstructMethods.push(t)
    }

    function Ee(e, t, i) {
      const r = Se(e.constructor);
      r.preDestroyMethods || (r.preDestroyMethods = []), r.preDestroyMethods.push(t)
    }

    function ge(e) {
      return t => {
        Se(t).beanName = e
      }
    }

    function fe(e) {
      return (t, i, r) => {
        me(t, e, !1, t, i, null)
      }
    }

    function Te(e) {
      return (t, i, r) => {
        me(t, e, !0, t, i, null)
      }
    }

    function me(e, t, i, r, s, n) {
      if (null === t) return void console.error("AG Grid: Autowired name should not be null");
      if ("number" == typeof n) return void console.error("AG Grid: Autowired should be on an attribute");
      const o = Se(e.constructor);
      o.agClassAttributes || (o.agClassAttributes = []), o.agClassAttributes.push({
        attributeName: s,
        beanName: t,
        optional: i
      })
    }

    function Ce(e) {
      return (t, i, r) => {
        const s = "function" == typeof t ? t : t.constructor;
        let n;
        if ("number" == typeof r) {
          let t;
          i ? (n = Se(s), t = i) : (n = Se(s), t = "agConstructor"), n.autowireMethods || (n.autowireMethods = {}), n.autowireMethods[t] || (n.autowireMethods[t] = {}), n.autowireMethods[t][r] = e
        }
      }
    }

    function Se(e) {
      return e.hasOwnProperty("__agBeanMetaData") || (e.__agBeanMetaData = {}), e.__agBeanMetaData
    }
    var Re = class {
      constructor() {
        this.allSyncListeners = new Map, this.allAsyncListeners = new Map, this.globalSyncListeners = new Set, this.globalAsyncListeners = new Set, this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {}
      }
      setBeans(e, t, i = null, r = null) {
        if (this.frameworkOverrides = t, this.gos = e, i) {
          const t = e.useAsyncEvents();
          this.addGlobalListener(i, t)
        }
        r && this.addGlobalListener(r, !1)
      }
      setFrameworkOverrides(e) {
        this.frameworkOverrides = e
      }
      getListeners(e, t, i) {
        const r = t ? this.allAsyncListeners : this.allSyncListeners;
        let s = r.get(e);
        return !s && i && (s = new Set, r.set(e, s)), s
      }
      noRegisteredListenersExist() {
        return 0 === this.allSyncListeners.size && 0 === this.allAsyncListeners.size && 0 === this.globalSyncListeners.size && 0 === this.globalAsyncListeners.size
      }
      addEventListener(e, t, i = !1) {
        this.getListeners(e, i, !0).add(t)
      }
      removeEventListener(e, t, i = !1) {
        const r = this.getListeners(e, i, !1);
        if (r && (r.delete(t), 0 === r.size)) {
          (i ? this.allAsyncListeners : this.allSyncListeners).delete(e)
        }
      }
      addGlobalListener(e, t = !1) {
        (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e)
      }
      removeGlobalListener(e, t = !1) {
        (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e)
      }
      dispatchEvent(e) {
        let t = e;
        this.gos && this.gos.addGridCommonParams(t), this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0
      }
      dispatchEventOnce(e) {
        this.firedEvents[e.type] || this.dispatchEvent(e)
      }
      dispatchToListeners(e, t) {
        var i;
        const r = e.type;
        if (t && "event" in e) {
          const t = e.event;
          t instanceof Event && (e.eventPath = t.composedPath())
        }
        const s = (i, r) => i.forEach(i => {
            if (!r.has(i)) return;
            const s = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => i(e)) : () => i(e);
            t ? this.dispatchAsync(s) : s()
          }),
          n = null != (i = this.getListeners(r, t, !1)) ? i : new Set,
          o = new Set(n);
        o.size > 0 && s(o, n);
        new Set(t ? this.globalAsyncListeners : this.globalSyncListeners).forEach(i => {
          const s = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => i(r, e)) : () => i(r, e);
          t ? this.dispatchAsync(s) : s()
        })
      }
      dispatchAsync(e) {
        this.asyncFunctionsQueue.push(e), this.scheduled || (this.frameworkOverrides.wrapIncoming(() => {
          window.setTimeout(this.flushAsyncQueue.bind(this), 0)
        }), this.scheduled = !0)
      }
      flushAsyncQueue() {
        this.scheduled = !1;
        const e = this.asyncFunctionsQueue.slice();
        this.asyncFunctionsQueue = [], e.forEach(e => e())
      }
    };
    C([S(0, Ce("gridOptionsService")), S(1, Ce("frameworkOverrides")), S(2, Ce("globalEventListener")), S(3, Ce("globalSyncEventListener"))], Re.prototype, "setBeans", 1), Re = C([ge("eventService")], Re);
    var Ae = class {
        constructor(e) {
          this.frameworkOverrides = e, this.wrappedListeners = new Map, this.wrappedGlobalListeners = new Map
        }
        wrap(e) {
          let t = e;
          return this.frameworkOverrides.shouldWrapOutgoing && (t = t => {
            this.frameworkOverrides.wrapOutgoing(() => e(t))
          }, this.wrappedListeners.set(e, t)), t
        }
        wrapGlobal(e) {
          let t = e;
          return this.frameworkOverrides.shouldWrapOutgoing && (t = (t, i) => {
            this.frameworkOverrides.wrapOutgoing(() => e(t, i))
          }, this.wrappedGlobalListeners.set(e, t)), t
        }
        unwrap(e) {
          var t;
          return null != (t = this.wrappedListeners.get(e)) ? t : e
        }
        unwrapGlobal(e) {
          var t;
          return null != (t = this.wrappedGlobalListeners.get(e)) ? t : e
        }
      },
      ve = {
        resizable: !0,
        sortable: !0
      },
      Ne = 0;

    function Ie() {
      return Ne++
    }
    var Oe = class e {
      constructor(e, t, i, r) {
        this.instanceId = Ie(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.eventService = new Re, this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = r, this.setState(e)
      }
      getInstanceId() {
        return this.instanceId
      }
      setState(e) {
        void 0 !== e.sort ? "asc" !== e.sort && "desc" !== e.sort || (this.sort = e.sort) : "asc" !== e.initialSort && "desc" !== e.initialSort || (this.sort = e.initialSort);
        const t = e.sortIndex,
          i = e.initialSortIndex;
        void 0 !== t ? null !== t && (this.sortIndex = t) : null !== i && (this.sortIndex = i);
        const r = e.hide,
          s = e.initialHide;
        this.visible = void 0 !== r ? !r : !s, void 0 !== e.pinned ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
        const n = e.flex,
          o = e.initialFlex;
        void 0 !== n ? this.flex = n : void 0 !== o && (this.flex = o)
      }
      setColDef(e, t, i) {
        this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.eventService.dispatchEvent(this.createColumnEvent("colDefChanged", i))
      }
      getUserProvidedColDef() {
        return this.userProvidedColDef
      }
      setParent(e) {
        this.parent = e
      }
      getParent() {
        return this.parent
      }
      setOriginalParent(e) {
        this.originalParent = e
      }
      getOriginalParent() {
        return this.originalParent
      }
      initialise() {
        this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip()
      }
      initDotNotation() {
        const e = this.gos.get("suppressFieldDotNotation");
        this.fieldContainsDots = v(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = v(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e
      }
      initMinAndMaxWidths() {
        var e, t;
        const i = this.colDef;
        this.minWidth = null != (e = i.minWidth) ? e : this.environment.getMinColWidth(), this.maxWidth = null != (t = i.maxWidth) ? t : Number.MAX_SAFE_INTEGER
      }
      initTooltip() {
        this.tooltipEnabled = v(this.colDef.tooltipField) || v(this.colDef.tooltipValueGetter) || v(this.colDef.tooltipComponent)
      }
      resetActualWidth(e) {
        const t = this.calculateColInitialWidth(this.colDef);
        this.setActualWidth(t, e, !0)
      }
      calculateColInitialWidth(e) {
        var t, i;
        const r = null != (t = e.minWidth) ? t : this.environment.getMinColWidth(),
          s = null != (i = e.maxWidth) ? i : Number.MAX_SAFE_INTEGER;
        let n;
        const o = L(e.width),
          a = L(e.initialWidth);
        return n = null != o ? o : null != a ? a : 200, Math.max(Math.min(n, s), r)
      }
      isEmptyGroup() {
        return !1
      }
      isRowGroupDisplayed(e) {
        if (N(this.colDef) || N(this.colDef.showRowGroup)) return !1;
        const t = !0 === this.colDef.showRowGroup,
          i = this.colDef.showRowGroup === e;
        return t || i
      }
      isPrimary() {
        return this.primary
      }
      isFilterAllowed() {
        return !!this.colDef.filter
      }
      isFieldContainsDots() {
        return this.fieldContainsDots
      }
      isTooltipEnabled() {
        return this.tooltipEnabled
      }
      isTooltipFieldContainsDots() {
        return this.tooltipFieldContainsDots
      }
      addEventListener(e, t) {
        var i, r;
        this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.eventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new Ae(this.frameworkOverrides));
        const s = null != (r = null == (i = this.frameworkEventListenerService) ? void 0 : i.wrap(t)) ? r : t;
        this.eventService.addEventListener(e, s)
      }
      removeEventListener(e, t) {
        var i, r;
        const s = null != (r = null == (i = this.frameworkEventListenerService) ? void 0 : i.unwrap(t)) ? r : t;
        this.eventService.removeEventListener(e, s)
      }
      createColumnFunctionCallbackParams(e) {
        return this.gos.addGridCommonParams({
          node: e,
          data: e.data,
          column: this,
          colDef: this.colDef
        })
      }
      isSuppressNavigable(e) {
        if ("boolean" == typeof this.colDef.suppressNavigable) return this.colDef.suppressNavigable;
        if ("function" == typeof this.colDef.suppressNavigable) {
          const t = this.createColumnFunctionCallbackParams(e);
          return (0, this.colDef.suppressNavigable)(t)
        }
        return !1
      }
      isCellEditable(e) {
        return !(e.group && !this.gos.get("enableGroupEdit")) && this.isColumnFunc(e, this.colDef.editable)
      }
      isSuppressFillHandle() {
        return !!this.colDef.suppressFillHandle
      }
      isAutoHeight() {
        return !!this.colDef.autoHeight
      }
      isAutoHeaderHeight() {
        return !!this.colDef.autoHeaderHeight
      }
      isRowDrag(e) {
        return this.isColumnFunc(e, this.colDef.rowDrag)
      }
      isDndSource(e) {
        return this.isColumnFunc(e, this.colDef.dndSource)
      }
      isCellCheckboxSelection(e) {
        return this.isColumnFunc(e, this.colDef.checkboxSelection)
      }
      isSuppressPaste(e) {
        return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null)
      }
      isResizable() {
        return !!this.getColDefValue("resizable")
      }
      getColDefValue(e) {
        var t;
        return null != (t = this.colDef[e]) ? t : ve[e]
      }
      isColumnFunc(e, t) {
        if ("boolean" == typeof t) return t;
        if ("function" == typeof t) {
          return t(this.createColumnFunctionCallbackParams(e))
        }
        return !1
      }
      setMoving(e, t) {
        this.moving = e, this.eventService.dispatchEvent(this.createColumnEvent("movingChanged", t))
      }
      createColumnEvent(e, t) {
        return this.gos.addGridCommonParams({
          type: e,
          column: this,
          columns: [this],
          source: t
        })
      }
      isMoving() {
        return this.moving
      }
      getSort() {
        return this.sort
      }
      setSort(e, t) {
        this.sort !== e && (this.sort = e, this.eventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort")
      }
      setMenuVisible(e, t) {
        this.menuVisible !== e && (this.menuVisible = e, this.eventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)))
      }
      isMenuVisible() {
        return this.menuVisible
      }
      isSortable() {
        return !!this.getColDefValue("sortable")
      }
      isSortAscending() {
        return "asc" === this.sort
      }
      isSortDescending() {
        return "desc" === this.sort
      }
      isSortNone() {
        return N(this.sort)
      }
      isSorting() {
        return v(this.sort)
      }
      getSortIndex() {
        return this.sortIndex
      }
      setSortIndex(e) {
        this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex")
      }
      setAggFunc(e) {
        this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc")
      }
      getAggFunc() {
        return this.aggFunc
      }
      getLeft() {
        return this.left
      }
      getOldLeft() {
        return this.oldLeft
      }
      getRight() {
        return this.left + this.actualWidth
      }
      setLeft(e, t) {
        this.oldLeft = this.left, this.left !== e && (this.left = e, this.eventService.dispatchEvent(this.createColumnEvent("leftChanged", t)))
      }
      isFilterActive() {
        return this.filterActive
      }
      setFilterActive(e, t, i) {
        this.filterActive !== e && (this.filterActive = e, this.eventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
        const r = this.createColumnEvent("filterChanged", t);
        i && k(r, i), this.eventService.dispatchEvent(r)
      }
      isHovered() {
        return this.columnHoverService.isHovered(this)
      }
      setPinned(e) {
        this.pinned = !0 === e || "left" === e ? "left" : "right" === e ? "right" : null, this.dispatchStateUpdatedEvent("pinned")
      }
      setFirstRightPinned(e, t) {
        this.firstRightPinned !== e && (this.firstRightPinned = e, this.eventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)))
      }
      setLastLeftPinned(e, t) {
        this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.eventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)))
      }
      isFirstRightPinned() {
        return this.firstRightPinned
      }
      isLastLeftPinned() {
        return this.lastLeftPinned
      }
      isPinned() {
        return "left" === this.pinned || "right" === this.pinned
      }
      isPinnedLeft() {
        return "left" === this.pinned
      }
      isPinnedRight() {
        return "right" === this.pinned
      }
      getPinned() {
        return this.pinned
      }
      setVisible(e, t) {
        const i = !0 === e;
        this.visible !== i && (this.visible = i, this.eventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide")
      }
      isVisible() {
        return this.visible
      }
      isSpanHeaderHeight() {
        const e = this.getColDef();
        return !e.suppressSpanHeaderHeight && !e.autoHeaderHeight
      }
      getColumnGroupPaddingInfo() {
        let e = this.getParent();
        if (!e || !e.isPadding()) return {
          numberOfParents: 0,
          isSpanningTotal: !1
        };
        const t = e.getPaddingLevel() + 1;
        let i = !0;
        for (; e;) {
          if (!e.isPadding()) {
            i = !1;
            break
          }
          e = e.getParent()
        }
        return {
          numberOfParents: t,
          isSpanningTotal: i
        }
      }
      getColDef() {
        return this.colDef
      }
      getColumnGroupShow() {
        return this.colDef.columnGroupShow
      }
      getColId() {
        return this.colId
      }
      getId() {
        return this.colId
      }
      getUniqueId() {
        return this.colId
      }
      getDefinition() {
        return this.colDef
      }
      getActualWidth() {
        return this.actualWidth
      }
      getAutoHeaderHeight() {
        return this.autoHeaderHeight
      }
      setAutoHeaderHeight(e) {
        const t = e !== this.autoHeaderHeight;
        return this.autoHeaderHeight = e, t
      }
      createBaseColDefParams(e) {
        return this.gos.addGridCommonParams({
          node: e,
          data: e.data,
          colDef: this.colDef,
          column: this
        })
      }
      getColSpan(e) {
        if (N(this.colDef.colSpan)) return 1;
        const t = this.createBaseColDefParams(e),
          i = this.colDef.colSpan(t);
        return Math.max(i, 1)
      }
      getRowSpan(e) {
        if (N(this.colDef.rowSpan)) return 1;
        const t = this.createBaseColDefParams(e),
          i = this.colDef.rowSpan(t);
        return Math.max(i, 1)
      }
      setActualWidth(e, t, i = !1) {
        null != this.minWidth && (e = Math.max(e, this.minWidth)), null != this.maxWidth && (e = Math.min(e, this.maxWidth)), this.actualWidth !== e && (this.actualWidth = e, this.flex && "flex" !== t && "gridInitializing" !== t && (this.flex = null), i || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width")
      }
      fireColumnWidthChangedEvent(e) {
        this.eventService.dispatchEvent(this.createColumnEvent("widthChanged", e))
      }
      isGreaterThanMax(e) {
        return null != this.maxWidth && e > this.maxWidth
      }
      getMinWidth() {
        return this.minWidth
      }
      getMaxWidth() {
        return this.maxWidth
      }
      getFlex() {
        return this.flex || 0
      }
      setFlex(e) {
        this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex")
      }
      setMinimum(e) {
        v(this.minWidth) && this.setActualWidth(this.minWidth, e)
      }
      setRowGroupActive(e, t) {
        this.rowGroupActive !== e && (this.rowGroupActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup")
      }
      isRowGroupActive() {
        return this.rowGroupActive
      }
      setPivotActive(e, t) {
        this.pivotActive !== e && (this.pivotActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot")
      }
      isPivotActive() {
        return this.pivotActive
      }
      isAnyFunctionActive() {
        return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive()
      }
      isAnyFunctionAllowed() {
        return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue()
      }
      setValueActive(e, t) {
        this.aggregationActive !== e && (this.aggregationActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)))
      }
      isValueActive() {
        return this.aggregationActive
      }
      isAllowPivot() {
        return !0 === this.colDef.enablePivot
      }
      isAllowValue() {
        return !0 === this.colDef.enableValue
      }
      isAllowRowGroup() {
        return !0 === this.colDef.enableRowGroup
      }
      getMenuTabs(e) {
        z("As of v31.1, 'getMenuTabs' is deprecated. Use 'getColDef().menuTabs ?? defaultValues' instead.");
        let t = this.getColDef().menuTabs;
        return null == t && (t = e), t
      }
      dispatchStateUpdatedEvent(t) {
        this.eventService.dispatchEvent({
          type: e.EVENT_STATE_UPDATED,
          key: t
        })
      }
    };
    Oe.EVENT_MOVING_CHANGED = "movingChanged", Oe.EVENT_LEFT_CHANGED = "leftChanged", Oe.EVENT_WIDTH_CHANGED = "widthChanged", Oe.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged", Oe.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged", Oe.EVENT_VISIBLE_CHANGED = "visibleChanged", Oe.EVENT_FILTER_CHANGED = "filterChanged", Oe.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged", Oe.EVENT_SORT_CHANGED = "sortChanged", Oe.EVENT_COL_DEF_CHANGED = "colDefChanged", Oe.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged", Oe.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged", Oe.EVENT_PIVOT_CHANGED = "columnPivotChanged", Oe.EVENT_VALUE_CHANGED = "columnValueChanged", Oe.EVENT_STATE_UPDATED = "columnStateUpdated", C([fe("gridOptionsService")], Oe.prototype, "gos", 2), C([fe("environment")], Oe.prototype, "environment", 2), C([fe("columnHoverService")], Oe.prototype, "columnHoverService", 2), C([fe("frameworkOverrides")], Oe.prototype, "frameworkOverrides", 2), C([pe], Oe.prototype, "initialise", 1);
    var Le = Oe,
      _e = class e {
        constructor(e, t, i, r) {
          this.localEventService = new Re, this.expandable = !1, this.instanceId = Ie(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = i, this.level = r
        }
        destroy() {
          this.expandableListenerRemoveCallback && this.reset(null, void 0)
        }
        reset(e, t) {
          this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0
        }
        getInstanceId() {
          return this.instanceId
        }
        setOriginalParent(e) {
          this.originalParent = e
        }
        getOriginalParent() {
          return this.originalParent
        }
        getLevel() {
          return this.level
        }
        isVisible() {
          return !!this.children && this.children.some(e => e.isVisible())
        }
        isPadding() {
          return this.padding
        }
        setExpanded(t) {
          this.expanded = void 0 !== t && t;
          const i = {
            type: e.EVENT_EXPANDED_CHANGED
          };
          this.localEventService.dispatchEvent(i)
        }
        isExpandable() {
          return this.expandable
        }
        isExpanded() {
          return this.expanded
        }
        getGroupId() {
          return this.groupId
        }
        getId() {
          return this.getGroupId()
        }
        setChildren(e) {
          this.children = e
        }
        getChildren() {
          return this.children
        }
        getColGroupDef() {
          return this.colGroupDef
        }
        getLeafColumns() {
          const e = [];
          return this.addLeafColumns(e), e
        }
        addLeafColumns(t) {
          this.children && this.children.forEach(i => {
            i instanceof Le ? t.push(i) : i instanceof e && i.addLeafColumns(t)
          })
        }
        getColumnGroupShow() {
          const e = this.colGroupDef;
          if (e) return e.columnGroupShow
        }
        setupExpandable() {
          this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
          const e = this.onColumnVisibilityChanged.bind(this);
          this.getLeafColumns().forEach(t => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
            this.getLeafColumns().forEach(t => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null
          }
        }
        setExpandable() {
          if (this.isPadding()) return;
          let t = !1,
            i = !1,
            r = !1;
          const s = this.findChildrenRemovingPadding();
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e];
            if (!n.isVisible()) continue;
            const o = n.getColumnGroupShow();
            "open" === o ? (t = !0, r = !0) : "closed" === o ? (i = !0, r = !0) : (t = !0, i = !0)
          }
          const n = t && i && r;
          if (this.expandable !== n) {
            this.expandable = n;
            const t = {
              type: e.EVENT_EXPANDABLE_CHANGED
            };
            this.localEventService.dispatchEvent(t)
          }
        }
        findChildrenRemovingPadding() {
          const t = [],
            i = r => {
              r.forEach(r => {
                r instanceof e && r.isPadding() ? i(r.children) : t.push(r)
              })
            };
          return i(this.children), t
        }
        onColumnVisibilityChanged() {
          this.setExpandable()
        }
        addEventListener(e, t) {
          this.localEventService.addEventListener(e, t)
        }
        removeEventListener(e, t) {
          this.localEventService.removeEventListener(e, t)
        }
      };
    _e.EVENT_EXPANDED_CHANGED = "expandedChanged", _e.EVENT_EXPANDABLE_CHANGED = "expandableChanged", C([Ee], _e.prototype, "destroy", 1);
    var ye = _e,
      we = {
        numericColumn: {
          headerClass: "ag-right-aligned-header",
          cellClass: "ag-right-aligned-cell"
        },
        rightAligned: {
          headerClass: "ag-right-aligned-header",
          cellClass: "ag-right-aligned-cell"
        }
      },
      De = {};
    m(De, {
      addSafePassiveEventListener: () => at,
      createEventPath: () => nt,
      getCtrlForEventTarget: () => rt,
      getEventPath: () => ot,
      isElementInEventPath: () => st,
      isEventSupported: () => it,
      isStopPropagationForAgGrid: () => tt,
      stopPropagationForAgGrid: () => et
    });
    var Pe = {};

    function be(e) {
      return null != e && e.length > 0
    }

    function Me(e) {
      if (e && e.length) return e[e.length - 1]
    }

    function Fe(e, t, i) {
      return null == e && null == t || null != e && null != t && e.length === t.length && e.every((e, r) => i ? i(e, t[r]) : t[r] === e)
    }

    function xe(e, t) {
      return Fe(e, t)
    }

    function Ge(e) {
      return e.sort((e, t) => e - t)
    }

    function Ue(e, t) {
      if (e)
        for (let i = e.length - 2; i >= 0; i--) {
          const r = e[i] === t,
            s = e[i + 1] === t;
          r && s && e.splice(i + 1, 1)
        }
    }

    function He(e, t) {
      const i = e.indexOf(t);
      i >= 0 && (e[i] = e[e.length - 1], e.pop())
    }

    function ke(e, t) {
      const i = e.indexOf(t);
      i >= 0 && e.splice(i, 1)
    }

    function Be(e, t) {
      for (let i = 0; i < t.length; i++) He(e, t[i])
    }

    function Ve(e, t) {
      for (let i = 0; i < t.length; i++) ke(e, t[i])
    }

    function We(e, t, i) {
      e.splice(i, 0, t)
    }

    function Ye(e, t, i) {
      if (null != e && null != t)
        for (let r = t.length - 1; r >= 0; r--) {
          We(e, t[r], i)
        }
    }

    function Ke(e, t, i) {
      Ve(e, t), t.slice().reverse().forEach(t => We(e, t, i))
    }

    function Xe(e, t) {
      return e.indexOf(t) > -1
    }

    function ze(e) {
      return [].concat.apply([], e)
    }

    function $e(e, t) {
      null != t && null != e && t.forEach(t => e.push(t))
    }

    function je(e) {
      return e.map(O)
    }

    function Je(e, t) {
      if (null != e)
        for (let i = e.length - 1; i >= 0; i--) t(e[i], i)
    }
    m(Pe, {
      areEqual: () => Fe,
      existsAndNotEmpty: () => be,
      flatten: () => ze,
      forEachReverse: () => Je,
      includes: () => Xe,
      insertArrayIntoArray: () => Ye,
      insertIntoArray: () => We,
      last: () => Me,
      moveInArray: () => Ke,
      pushAll: () => $e,
      removeAllFromArray: () => Ve,
      removeAllFromUnorderedArray: () => Be,
      removeFromArray: () => ke,
      removeFromUnorderedArray: () => He,
      removeRepeatsFromArray: () => Ue,
      shallowCompare: () => xe,
      sortNumerically: () => Ge,
      toStrings: () => je
    });
    var qe = "__ag_Grid_Stop_Propagation",
      Qe = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"],
      Ze = {};

    function et(e) {
      e[qe] = !0
    }

    function tt(e) {
      return !0 === e[qe]
    }
    var it = (() => {
      const e = {
        select: "input",
        change: "input",
        submit: "form",
        reset: "form",
        error: "img",
        load: "img",
        abort: "img"
      };
      return t => {
        if ("boolean" == typeof Ze[t]) return Ze[t];
        const i = document.createElement(e[t] || "div");
        return Ze[t = "on" + t] = t in i
      }
    })();

    function rt(e, t, i) {
      let r = t;
      for (; r;) {
        const t = e.getDomData(r, i);
        if (t) return t;
        r = r.parentElement
      }
      return null
    }

    function st(e, t) {
      return !(!t || !e) && ot(t).indexOf(e) >= 0
    }

    function nt(e) {
      const t = [];
      let i = e.target;
      for (; i;) t.push(i), i = i.parentElement;
      return t
    }

    function ot(e) {
      const t = e;
      return t.path ? t.path : t.composedPath ? t.composedPath() : nt(t)
    }

    function at(e, t, i, r) {
      const s = Xe(Qe, i) ? {
        passive: !0
      } : void 0;
      e && e.addEventListener && e.addEventListener(t, i, r, s)
    }
    var lt = class e {
      constructor() {
        this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.lastChangeSetIdLookup = {}, this.propertyListenerId = 0, this.isAlive = () => !this.destroyed
      }
      getFrameworkOverrides() {
        return this.frameworkOverrides
      }
      getContext() {
        return this.context
      }
      destroy() {
        for (let e = 0; e < this.destroyFunctions.length; e++) this.destroyFunctions[e]();
        this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchEvent({
          type: e.EVENT_DESTROYED
        })
      }
      addEventListener(e, t) {
        this.localEventService || (this.localEventService = new Re), this.localEventService.addEventListener(e, t)
      }
      removeEventListener(e, t) {
        this.localEventService && this.localEventService.removeEventListener(e, t)
      }
      dispatchEvent(e) {
        this.localEventService && this.localEventService.dispatchEvent(e)
      }
      addManagedListener(e, t, i) {
        if (this.destroyed) return;
        e instanceof HTMLElement ? at(this.getFrameworkOverrides(), e, t, i) : e.addEventListener(t, i);
        const r = () => (e.removeEventListener(t, i), null);
        return this.destroyFunctions.push(r), () => (r(), this.destroyFunctions = this.destroyFunctions.filter(e => e !== r), null)
      }
      setupGridOptionListener(e, t) {
        this.gos.addEventListener(e, t);
        const i = () => (this.gos.removeEventListener(e, t), null);
        return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter(e => e !== i), null)
      }
      addManagedPropertyListener(e, t) {
        return this.destroyed ? () => null : this.setupGridOptionListener(e, t)
      }
      addManagedPropertyListeners(e, t) {
        if (this.destroyed) return;
        const i = e.join("-") + this.propertyListenerId++,
          r = e => {
            if (e.changeSet) {
              if (e.changeSet && e.changeSet.id === this.lastChangeSetIdLookup[i]) return;
              this.lastChangeSetIdLookup[i] = e.changeSet.id
            }
            const r = {
              type: "gridPropertyChanged",
              changeSet: e.changeSet,
              source: e.source
            };
            t(r)
          };
        e.forEach(e => this.setupGridOptionListener(e, r))
      }
      addDestroyFunc(e) {
        this.isAlive() ? this.destroyFunctions.push(e) : e()
      }
      createManagedBean(e, t) {
        const i = this.createBean(e, t);
        return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i
      }
      createBean(e, t, i) {
        return (t || this.getContext()).createBean(e, i)
      }
      destroyBean(e, t) {
        return (t || this.getContext()).destroyBean(e)
      }
      destroyBeans(e, t) {
        if (e)
          for (let i = 0; i < e.length; i++) this.destroyBean(e[i], t);
        return []
      }
    };
    lt.EVENT_DESTROYED = "destroyed", C([fe("frameworkOverrides")], lt.prototype, "frameworkOverrides", 2), C([fe("context")], lt.prototype, "context", 2), C([fe("eventService")], lt.prototype, "eventService", 2), C([fe("gridOptionsService")], lt.prototype, "gos", 2), C([fe("localeService")], lt.prototype, "localeService", 2), C([fe("environment")], lt.prototype, "environment", 2), C([Ee], lt.prototype, "destroy", 1);
    var ct = lt,
      ht = class extends ct {
        setBeans(e) {
          this.logger = e.create("ColumnFactory")
        }
        createColumnTree(e, t, i, r) {
          const s = new b,
            {
              existingCols: n,
              existingGroups: o,
              existingColKeys: a
            } = this.extractExistingTreeData(i);
          s.addExistingKeys(a);
          const l = this.recursivelyCreateColumns(e, 0, t, n, s, o, r),
            c = this.findMaxDept(l, 0);
          this.logger.log("Number of levels for grouped columns is " + c);
          const h = this.balanceColumnTree(l, 0, c, s);
          return ut(null, h, (e, t) => {
            e instanceof ye && e.setupExpandable(), e.setOriginalParent(t)
          }), {
            columnTree: h,
            treeDept: c
          }
        }
        extractExistingTreeData(e) {
          const t = [],
            i = [],
            r = [];
          return e && ut(null, e, e => {
            if (e instanceof ye) {
              const t = e;
              i.push(t)
            } else {
              const i = e;
              r.push(i.getId()), t.push(i)
            }
          }), {
            existingCols: t,
            existingGroups: i,
            existingColKeys: r
          }
        }
        createForAutoGroups(e, t) {
          return e.map(e => this.createAutoGroupTreeItem(t, e))
        }
        createAutoGroupTreeItem(e, t) {
          const i = this.findDepth(e);
          let r = t;
          for (let e = i - 1; e >= 0; e--) {
            const i = new ye(null, `FAKE_PATH_${t.getId()}}_${e}`, !0, e);
            this.createBean(i), i.setChildren([r]), r.setOriginalParent(i), r = i
          }
          return 0 === i && t.setOriginalParent(null), r
        }
        findDepth(e) {
          let t = 0,
            i = e;
          for (; i && i[0] && i[0] instanceof ye;) t++, i = i[0].getChildren();
          return t
        }
        balanceColumnTree(e, t, i, r) {
          const s = [];
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            if (o instanceof ye) {
              const e = o,
                n = this.balanceColumnTree(e.getChildren(), t + 1, i, r);
              e.setChildren(n), s.push(e)
            } else {
              let n, a;
              for (let e = i - 1; e >= t; e--) {
                const e = r.getUniqueKey(null, null),
                  i = this.createMergedColGroupDef(null),
                  s = new ye(i, e, !0, t);
                this.createBean(s), a && a.setChildren([s]), a = s, n || (n = a)
              }
              if (n && a) {
                s.push(n);
                if (e.some(e => e instanceof ye)) {
                  a.setChildren([o]);
                  continue
                }
                a.setChildren(e);
                break
              }
              s.push(o)
            }
          }
          return s
        }
        findMaxDept(e, t) {
          let i = t;
          for (let r = 0; r < e.length; r++) {
            const s = e[r];
            if (s instanceof ye) {
              const e = s,
                r = this.findMaxDept(e.getChildren(), t + 1);
              i < r && (i = r)
            }
          }
          return i
        }
        recursivelyCreateColumns(e, t, i, r, s, n, o) {
          if (!e) return [];
          const a = new Array(e.length);
          for (let l = 0; l < a.length; l++) {
            const c = e[l];
            this.isColumnGroup(c) ? a[l] = this.createColumnGroup(i, c, t, r, s, n, o) : a[l] = this.createColumn(i, c, r, s, o)
          }
          return a
        }
        createColumnGroup(e, t, i, r, s, n, o) {
          const a = this.createMergedColGroupDef(t),
            l = s.getUniqueKey(a.groupId || null, null),
            c = new ye(a, l, !1, i);
          this.createBean(c);
          const h = this.findExistingGroup(t, n);
          h && n.splice(h.idx, 1);
          let u = null == h ? void 0 : h.group;
          u && c.setExpanded(u.isExpanded());
          const d = this.recursivelyCreateColumns(a.children, i + 1, e, r, s, n, o);
          return c.setChildren(d), c
        }
        createMergedColGroupDef(e) {
          const t = {};
          return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t
        }
        createColumn(e, t, i, r, s) {
          const n = this.findExistingColumn(t, i);
          n && (null == i || i.splice(n.idx, 1));
          let o = null == n ? void 0 : n.column;
          if (o) {
            const e = this.addColumnDefaultAndTypes(t, o.getColId());
            o.setColDef(e, t, s), this.applyColumnState(o, e, s)
          } else {
            const i = r.getUniqueKey(t.colId, t.field),
              s = this.addColumnDefaultAndTypes(t, i);
            o = new Le(s, t, i, e), this.context.createBean(o)
          }
          return this.dataTypeService.addColumnListeners(o), o
        }
        applyColumnState(e, t, i) {
          const r = L(t.flex);
          void 0 !== r && e.setFlex(r);
          if (e.getFlex() <= 0) {
            const r = L(t.width);
            if (null != r) e.setActualWidth(r, i);
            else {
              const t = e.getActualWidth();
              e.setActualWidth(t, i)
            }
          }
          void 0 !== t.sort && ("asc" == t.sort || "desc" == t.sort ? e.setSort(t.sort, i) : e.setSort(void 0, i));
          const s = L(t.sortIndex);
          void 0 !== s && e.setSortIndex(s);
          const n = _(t.hide);
          void 0 !== n && e.setVisible(!n, i), void 0 !== t.pinned && e.setPinned(t.pinned)
        }
        findExistingColumn(e, t) {
          if (t)
            for (let i = 0; i < t.length; i++) {
              const r = t[i].getUserProvidedColDef();
              if (!r) continue;
              if (null != e.colId) {
                if (t[i].getId() === e.colId) return {
                  idx: i,
                  column: t[i]
                };
                continue
              }
              if (null != e.field) {
                if (r.field === e.field) return {
                  idx: i,
                  column: t[i]
                }
              } else if (r === e) return {
                idx: i,
                column: t[i]
              }
            }
        }
        findExistingGroup(e, t) {
          if (null != e.groupId)
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.getColGroupDef() && r.getId() === e.groupId) return {
                idx: i,
                group: r
              }
            }
        }
        addColumnDefaultAndTypes(e, t) {
          const i = {};
          k(i, this.gos.get("defaultColDef"), !1, !0);
          const r = this.dataTypeService.updateColDefAndGetColumnType(i, e, t);
          r && this.assignColumnTypes(r, i), k(i, e, !1, !0);
          const s = this.gos.get("autoGroupColumnDef"),
            n = this.gos.isColumnsSortingCoupledToGroup();
          return e.rowGroup && s && n && k(i, {
            sort: s.sort,
            initialSort: s.initialSort
          }, !1, !0), this.dataTypeService.validateColDef(i), i
        }
        assignColumnTypes(e, t) {
          if (!e.length) return;
          const i = Object.assign({}, we);
          x(this.gos.get("columnTypes") || {}, (e, t) => {
            if (e in i) console.warn(`AG Grid: the column type '${e}' is a default column type and cannot be overridden.`);
            else {
              t.type && z("Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."), i[e] = t
            }
          }), e.forEach(e => {
            const r = i[e.trim()];
            r ? k(t, r, !1, !0) : console.warn("AG Grid: colDef.type '" + e + "' does not correspond to defined gridOptions.columnTypes")
          })
        }
        isColumnGroup(e) {
          return void 0 !== e.children
        }
      };

    function ut(e, t, i) {
      if (t)
        for (let r = 0; r < t.length; r++) {
          const s = t[r];
          s instanceof ye && ut(s, s.getChildren(), i), i(s, e)
        }
    }
    C([fe("dataTypeService")], ht.prototype, "dataTypeService", 2), C([S(0, Ce("loggerFactory"))], ht.prototype, "setBeans", 1), ht = C([ge("columnFactory")], ht);
    var dt = class e {
      constructor(e, t, i, r) {
        this.displayedChildren = [], this.localEventService = new Re, this.groupId = t, this.partId = i, this.providedColumnGroup = e, this.pinned = r
      }
      static createUniqueId(e, t) {
        return e + "_" + t
      }
      reset() {
        this.parent = null, this.children = null, this.displayedChildren = null
      }
      getParent() {
        return this.parent
      }
      setParent(e) {
        this.parent = e
      }
      getUniqueId() {
        return e.createUniqueId(this.groupId, this.partId)
      }
      isEmptyGroup() {
        return 0 === this.displayedChildren.length
      }
      isMoving() {
        const e = this.getProvidedColumnGroup().getLeafColumns();
        return !(!e || 0 === e.length) && e.every(e => e.isMoving())
      }
      checkLeft() {
        if (this.displayedChildren.forEach(t => {
            t instanceof e && t.checkLeft()
          }), this.displayedChildren.length > 0)
          if (this.gos.get("enableRtl")) {
            const e = Me(this.displayedChildren).getLeft();
            this.setLeft(e)
          } else {
            const e = this.displayedChildren[0].getLeft();
            this.setLeft(e)
          }
        else this.setLeft(null)
      }
      getLeft() {
        return this.left
      }
      getOldLeft() {
        return this.oldLeft
      }
      setLeft(t) {
        this.oldLeft = this.left, this.left !== t && (this.left = t, this.localEventService.dispatchEvent(this.createAgEvent(e.EVENT_LEFT_CHANGED)))
      }
      getPinned() {
        return this.pinned
      }
      createAgEvent(e) {
        return {
          type: e
        }
      }
      addEventListener(e, t) {
        this.localEventService.addEventListener(e, t)
      }
      removeEventListener(e, t) {
        this.localEventService.removeEventListener(e, t)
      }
      getGroupId() {
        return this.groupId
      }
      getPartId() {
        return this.partId
      }
      isChildInThisGroupDeepSearch(t) {
        let i = !1;
        return this.children.forEach(r => {
          t === r && (i = !0), r instanceof e && r.isChildInThisGroupDeepSearch(t) && (i = !0)
        }), i
      }
      getActualWidth() {
        let e = 0;
        return this.displayedChildren && this.displayedChildren.forEach(t => {
          e += t.getActualWidth()
        }), e
      }
      isResizable() {
        if (!this.displayedChildren) return !1;
        let e = !1;
        return this.displayedChildren.forEach(t => {
          t.isResizable() && (e = !0)
        }), e
      }
      getMinWidth() {
        let e = 0;
        return this.displayedChildren.forEach(t => {
          e += t.getMinWidth() || 0
        }), e
      }
      addChild(e) {
        this.children || (this.children = []), this.children.push(e)
      }
      getDisplayedChildren() {
        return this.displayedChildren
      }
      getLeafColumns() {
        const e = [];
        return this.addLeafColumns(e), e
      }
      getDisplayedLeafColumns() {
        const e = [];
        return this.addDisplayedLeafColumns(e), e
      }
      getDefinition() {
        return this.providedColumnGroup.getColGroupDef()
      }
      getColGroupDef() {
        return this.providedColumnGroup.getColGroupDef()
      }
      isPadding() {
        return this.providedColumnGroup.isPadding()
      }
      isExpandable() {
        return this.providedColumnGroup.isExpandable()
      }
      isExpanded() {
        return this.providedColumnGroup.isExpanded()
      }
      setExpanded(e) {
        this.providedColumnGroup.setExpanded(e)
      }
      addDisplayedLeafColumns(t) {
        this.displayedChildren.forEach(i => {
          i instanceof Le ? t.push(i) : i instanceof e && i.addDisplayedLeafColumns(t)
        })
      }
      addLeafColumns(t) {
        this.children.forEach(i => {
          i instanceof Le ? t.push(i) : i instanceof e && i.addLeafColumns(t)
        })
      }
      getChildren() {
        return this.children
      }
      getColumnGroupShow() {
        return this.providedColumnGroup.getColumnGroupShow()
      }
      getProvidedColumnGroup() {
        return this.providedColumnGroup
      }
      getPaddingLevel() {
        const e = this.getParent();
        return this.isPadding() && e && e.isPadding() ? 1 + e.getPaddingLevel() : 0
      }
      calculateDisplayedColumns() {
        this.displayedChildren = [];
        let t = this;
        for (; null != t && t.isPadding();) t = t.getParent();
        if (!(!!t && t.providedColumnGroup.isExpandable())) return this.displayedChildren = this.children, void this.localEventService.dispatchEvent(this.createAgEvent(e.EVENT_DISPLAYED_CHILDREN_CHANGED));
        this.children.forEach(i => {
          if (i instanceof e && (!i.displayedChildren || !i.displayedChildren.length)) return;
          switch (i.getColumnGroupShow()) {
            case "open":
              t.providedColumnGroup.isExpanded() && this.displayedChildren.push(i);
              break;
            case "closed":
              t.providedColumnGroup.isExpanded() || this.displayedChildren.push(i);
              break;
            default:
              this.displayedChildren.push(i)
          }
        }), this.localEventService.dispatchEvent(this.createAgEvent(e.EVENT_DISPLAYED_CHILDREN_CHANGED))
      }
    };
    dt.EVENT_LEFT_CHANGED = "leftChanged", dt.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged", C([fe("gridOptionsService")], dt.prototype, "gos", 2);
    var pt = dt,
      Et = class {};
    Et.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged", Et.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded", Et.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged", Et.EVENT_PIVOT_MAX_COLUMNS_EXCEEDED = "pivotMaxColumnsExceeded", Et.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged", Et.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll", Et.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged", Et.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged", Et.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged", Et.EVENT_COLUMN_MOVED = "columnMoved", Et.EVENT_COLUMN_VISIBLE = "columnVisible", Et.EVENT_COLUMN_PINNED = "columnPinned", Et.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened", Et.EVENT_COLUMN_RESIZED = "columnResized", Et.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged", Et.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED = "suppressMovableColumns", Et.EVENT_SUPPRESS_MENU_HIDE_CHANGED = "suppressMenuHide", Et.EVENT_SUPPRESS_FIELD_DOT_NOTATION = "suppressFieldDotNotation", Et.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged", Et.EVENT_COLUMN_HEADER_MOUSE_OVER = "columnHeaderMouseOver", Et.EVENT_COLUMN_HEADER_MOUSE_LEAVE = "columnHeaderMouseLeave", Et.EVENT_COLUMN_HEADER_CLICKED = "columnHeaderClicked", Et.EVENT_COLUMN_HEADER_CONTEXT_MENU = "columnHeaderContextMenu", Et.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed", Et.EVENT_ROW_GROUP_OPENED = "rowGroupOpened", Et.EVENT_ROW_DATA_UPDATED = "rowDataUpdated", Et.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged", Et.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged", Et.EVENT_CHART_CREATED = "chartCreated", Et.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged", Et.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged", Et.EVENT_CHART_DESTROYED = "chartDestroyed", Et.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged", Et.EVENT_TOOL_PANEL_SIZE_CHANGED = "toolPanelSizeChanged", Et.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart", Et.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd", Et.EVENT_MODEL_UPDATED = "modelUpdated", Et.EVENT_CUT_START = "cutStart", Et.EVENT_CUT_END = "cutEnd", Et.EVENT_PASTE_START = "pasteStart", Et.EVENT_PASTE_END = "pasteEnd", Et.EVENT_FILL_START = "fillStart", Et.EVENT_FILL_END = "fillEnd", Et.EVENT_RANGE_DELETE_START = "rangeDeleteStart", Et.EVENT_RANGE_DELETE_END = "rangeDeleteEnd", Et.EVENT_UNDO_STARTED = "undoStarted", Et.EVENT_UNDO_ENDED = "undoEnded", Et.EVENT_REDO_STARTED = "redoStarted", Et.EVENT_REDO_ENDED = "redoEnded", Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_START = "keyShortcutChangedCellStart", Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_END = "keyShortcutChangedCellEnd", Et.EVENT_CELL_CLICKED = "cellClicked", Et.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked", Et.EVENT_CELL_MOUSE_DOWN = "cellMouseDown", Et.EVENT_CELL_CONTEXT_MENU = "cellContextMenu", Et.EVENT_CELL_VALUE_CHANGED = "cellValueChanged", Et.EVENT_CELL_EDIT_REQUEST = "cellEditRequest", Et.EVENT_ROW_VALUE_CHANGED = "rowValueChanged", Et.EVENT_CELL_FOCUSED = "cellFocused", Et.EVENT_CELL_FOCUS_CLEARED = "cellFocusCleared", Et.EVENT_FULL_WIDTH_ROW_FOCUSED = "fullWidthRowFocused", Et.EVENT_ROW_SELECTED = "rowSelected", Et.EVENT_SELECTION_CHANGED = "selectionChanged", Et.EVENT_TOOLTIP_SHOW = "tooltipShow", Et.EVENT_TOOLTIP_HIDE = "tooltipHide", Et.EVENT_CELL_KEY_DOWN = "cellKeyDown", Et.EVENT_CELL_MOUSE_OVER = "cellMouseOver", Et.EVENT_CELL_MOUSE_OUT = "cellMouseOut", Et.EVENT_FILTER_CHANGED = "filterChanged", Et.EVENT_FILTER_MODIFIED = "filterModified", Et.EVENT_FILTER_OPENED = "filterOpened", Et.EVENT_ADVANCED_FILTER_BUILDER_VISIBLE_CHANGED = "advancedFilterBuilderVisibleChanged", Et.EVENT_SORT_CHANGED = "sortChanged", Et.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved", Et.EVENT_ROW_CLICKED = "rowClicked", Et.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked", Et.EVENT_GRID_READY = "gridReady", Et.EVENT_GRID_PRE_DESTROYED = "gridPreDestroyed", Et.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged", Et.EVENT_VIEWPORT_CHANGED = "viewportChanged", Et.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged", Et.EVENT_FIRST_DATA_RENDERED = "firstDataRendered", Et.EVENT_DRAG_STARTED = "dragStarted", Et.EVENT_DRAG_STOPPED = "dragStopped", Et.EVENT_CHECKBOX_CHANGED = "checkboxChanged", Et.EVENT_ROW_EDITING_STARTED = "rowEditingStarted", Et.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped", Et.EVENT_CELL_EDITING_STARTED = "cellEditingStarted", Et.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped", Et.EVENT_BODY_SCROLL = "bodyScroll", Et.EVENT_BODY_SCROLL_END = "bodyScrollEnd", Et.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged", Et.EVENT_PAGINATION_CHANGED = "paginationChanged", Et.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged", Et.EVENT_STORE_REFRESHED = "storeRefreshed", Et.EVENT_STATE_UPDATED = "stateUpdated", Et.EVENT_COLUMN_MENU_VISIBLE_CHANGED = "columnMenuVisibleChanged", Et.EVENT_CONTEXT_MENU_VISIBLE_CHANGED = "contextMenuVisibleChanged", Et.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged", Et.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED = "columnContainerWidthChanged", Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged", Et.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged", Et.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged", Et.EVENT_FLASH_CELLS = "flashCells", Et.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged", Et.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged", Et.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged", Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged", Et.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged", Et.EVENT_HEADER_HEIGHT_CHANGED = "headerHeightChanged", Et.EVENT_COLUMN_HEADER_HEIGHT_CHANGED = "columnHeaderHeightChanged", Et.EVENT_ROW_DRAG_ENTER = "rowDragEnter", Et.EVENT_ROW_DRAG_MOVE = "rowDragMove", Et.EVENT_ROW_DRAG_LEAVE = "rowDragLeave", Et.EVENT_ROW_DRAG_END = "rowDragEnd", Et.EVENT_GRID_STYLES_CHANGED = "gridStylesChanged", Et.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest", Et.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest", Et.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest", Et.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest", Et.EVENT_STORE_UPDATED = "storeUpdated", Et.EVENT_FILTER_DESTROYED = "filterDestroyed", Et.EVENT_ROW_DATA_UPDATE_STARTED = "rowDataUpdateStarted", Et.EVENT_ROW_COUNT_READY = "rowCountReady", Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED = "advancedFilterEnabledChanged", Et.EVENT_DATA_TYPES_INFERRED = "dataTypesInferred", Et.EVENT_FIELD_VALUE_CHANGED = "fieldValueChanged", Et.EVENT_FIELD_PICKER_VALUE_SELECTED = "fieldPickerValueSelected", Et.EVENT_SIDE_BAR_UPDATED = "sideBarUpdated";
    var gt = new Set([Et.EVENT_GRID_PRE_DESTROYED, Et.EVENT_FILL_START]),
      ft = class {
        constructor() {
          this.existingIds = {}
        }
        getInstanceIdForKey(e) {
          const t = this.existingIds[e];
          let i;
          return i = "number" != typeof t ? 0 : t + 1, this.existingIds[e] = i, i
        }
      },
      Tt = "ag-Grid-AutoColumn",
      mt = class extends ct {
        createAutoGroupColumns(e) {
          const t = [],
            i = this.gos.get("treeData");
          let r = this.gos.isGroupMultiAutoColumn();
          return i && r && (console.warn('AG Grid: you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data'), r = !1), r ? e.forEach((e, i) => {
            t.push(this.createOneAutoGroupColumn(e, i))
          }) : t.push(this.createOneAutoGroupColumn()), t
        }
        updateAutoGroupColumns(e, t) {
          e.forEach((e, i) => this.updateOneAutoGroupColumn(e, i, t))
        }
        createOneAutoGroupColumn(e, t) {
          let i;
          i = e ? `${Tt}-${e.getId()}` : Tt;
          const r = this.createAutoGroupColDef(i, e, t);
          r.colId = i;
          const s = new Le(r, null, i, !0);
          return this.context.createBean(s), s
        }
        updateOneAutoGroupColumn(e, t, i) {
          const r = e.getColDef(),
            s = "string" == typeof r.showRowGroup ? r.showRowGroup : void 0,
            n = null != s ? this.columnModel.getPrimaryColumn(s) : void 0,
            o = this.createAutoGroupColDef(e.getId(), null != n ? n : void 0, t);
          e.setColDef(o, null, i), this.columnFactory.applyColumnState(e, o, i)
        }
        createAutoGroupColDef(e, t, i) {
          let r = this.createBaseColDef(t);
          if (k(r, this.gos.get("autoGroupColumnDef")), r = this.columnFactory.addColumnDefaultAndTypes(r, e), !this.gos.get("treeData")) {
            N(r.field) && N(r.valueGetter) && N(r.filterValueGetter) && "agGroupColumnFilter" !== r.filter && (r.filter = !1)
          }
          i && i > 0 && (r.headerCheckboxSelection = !1);
          const s = this.gos.isColumnsSortingCoupledToGroup(),
            n = r.valueGetter || null != r.field;
          return s && !n && (r.sortIndex = void 0, r.initialSort = void 0), r
        }
        createBaseColDef(e) {
          const t = this.gos.get("autoGroupColumnDef"),
            i = {
              headerName: this.localeService.getLocaleTextFunc()("group", "Group")
            };
          if (t && (t.cellRenderer || t.cellRendererSelector) || (i.cellRenderer = "agGroupCellRenderer"), e) {
            const t = e.getColDef();
            Object.assign(i, {
              headerName: this.columnModel.getDisplayNameForColumn(e, "header"),
              headerValueGetter: t.headerValueGetter
            }), t.cellRenderer && Object.assign(i, {
              cellRendererParams: {
                innerRenderer: t.cellRenderer,
                innerRendererParams: t.cellRendererParams
              }
            }), i.showRowGroup = e.getColId()
          } else i.showRowGroup = !0;
          return i
        }
      };
    C([fe("columnModel")], mt.prototype, "columnModel", 2), C([fe("columnFactory")], mt.prototype, "columnFactory", 2), mt = C([ge("autoGroupColService")], mt);
    var Ct = {};
    m(Ct, {
      camelCaseToHumanText: () => It,
      camelCaseToHyphenated: () => Ot,
      capitalise: () => vt,
      escapeString: () => Nt,
      utf8_encode: () => At
    });
    var St = /[&<>"']/g,
      Rt = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };

    function At(e) {
      const t = String.fromCharCode;

      function i(e, i) {
        return t(e >> i & 63 | 128)
      }

      function r(e) {
        if (e >= 0 && e <= 31 && 10 !== e) {
          return `_x${e.toString(16).toUpperCase().padStart(4,"0")}_`
        }
        if (!(4294967168 & e)) return t(e);
        let r = "";
        return 4294965248 & e ? 4294901760 & e ? 4292870144 & e || (r = t(e >> 18 & 7 | 240), r += i(e, 12), r += i(e, 6)) : (! function(e) {
          if (e >= 55296 && e <= 57343) throw Error("Lone surrogate U+" + e.toString(16).toUpperCase() + " is not a scalar value")
        }(e), r = t(e >> 12 & 15 | 224), r += i(e, 6)) : r = t(e >> 6 & 31 | 192), r += t(63 & e | 128), r
      }
      const s = function(e) {
          const t = [];
          if (!e) return [];
          const i = e.length;
          let r, s, n = 0;
          for (; n < i;) r = e.charCodeAt(n++), r >= 55296 && r <= 56319 && n < i ? (s = e.charCodeAt(n++), 56320 == (64512 & s) ? t.push(((1023 & r) << 10) + (1023 & s) + 65536) : (t.push(r), n--)) : t.push(r);
          return t
        }(e),
        n = s.length;
      let o, a = -1,
        l = "";
      for (; ++a < n;) o = s[a], l += r(o);
      return l
    }

    function vt(e) {
      return e[0].toUpperCase() + e.substring(1).toLowerCase()
    }

    function Nt(e, t) {
      if (null == e) return null;
      const i = e.toString().toString();
      return t ? i : i.replace(St, e => Rt[e])
    }

    function It(e) {
      if (!e || null == e) return null;
      return e.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z])([a-z])/g, "$1 $2$3").replace(/\./g, " ").split(" ").map(e => e.substring(0, 1).toUpperCase() + (e.length > 1 ? e.substring(1, e.length) : "")).join(" ")
    }

    function Ot(e) {
      return e.replace(/[A-Z]/g, e => `-${e.toLocaleLowerCase()}`)
    }
    var Lt = {};

    function _t(e) {
      const t = new Map;
      return e.forEach(e => t.set(e[0], e[1])), t
    }

    function yt(e, t) {
      const i = new Map;
      return e.forEach(e => i.set(t(e), e)), i
    }

    function wt(e) {
      const t = [];
      return e.forEach((e, i) => t.push(i)), t
    }
    m(Lt, {
      convertToMap: () => _t,
      keys: () => wt,
      mapById: () => yt
    });
    var Dt = class extends ct {
      constructor() {
        super(...arguments), this.primaryHeaderRowCount = 0, this.secondaryHeaderRowCount = 0, this.gridHeaderRowCount = 0, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.displayedColumnsAndGroupsMap = {}, this.viewportColumns = [], this.viewportColumnsHash = "", this.headerViewportColumns = [], this.viewportColumnsCenter = [], this.headerViewportColumnsCenter = [], this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.autoHeightActiveAtLeastOnce = !1, this.rowGroupColumns = [], this.valueColumns = [], this.pivotColumns = [], this.ready = !1, this.changeEventsDispatching = !1, this.autoGroupsNeedBuilding = !1, this.forceRecreateAutoGroups = !1, this.pivotMode = !1, this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = []
      }
      init() {
        this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
        const e = this.gos.get("pivotMode");
        this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"], e => this.buildAutoGroupColumns(Pt(e.source))), this.addManagedPropertyListener("autoGroupColumnDef", e => this.onAutoGroupColumnDefChanged(Pt(e.source))), this.addManagedPropertyListeners(["defaultColDef", "columnTypes", "suppressFieldDotNotation"], e => this.onSharedColDefChanged(Pt(e.source))), this.addManagedPropertyListener("pivotMode", e => this.setPivotMode(this.gos.get("pivotMode"), Pt(e.source))), this.addManagedListener(this.eventService, Et.EVENT_FIRST_DATA_RENDERED, () => this.onFirstDataRendered())
      }
      buildAutoGroupColumns(e) {
        this.columnDefs && (this.autoGroupsNeedBuilding = !0, this.forceRecreateAutoGroups = !0, this.updateGridColumns(), this.updateDisplayedColumns(e))
      }
      onAutoGroupColumnDefChanged(e) {
        this.groupAutoColumns && this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, e)
      }
      onSharedColDefChanged(e) {
        this.gridColumns && (this.groupAutoColumns && this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, e), this.createColumnsFromColumnDefs(!0, e))
      }
      setColumnDefs(e, t) {
        const i = !!this.columnDefs;
        this.columnDefs = e, this.createColumnsFromColumnDefs(i, t)
      }
      recreateColumnDefs(e) {
        this.onSharedColDefChanged(e)
      }
      destroyOldColumns(e, t) {
        const i = {};
        if (!e) return;
        ut(null, e, e => {
          i[e.getInstanceId()] = e
        }), t && ut(null, t, e => {
          i[e.getInstanceId()] = null
        });
        const r = Object.values(i).filter(e => null != e);
        this.destroyBeans(r)
      }
      destroyColumns() {
        this.destroyOldColumns(this.primaryColumnTree), this.destroyOldColumns(this.secondaryBalancedTree), this.destroyOldColumns(this.groupAutoColsBalancedTree)
      }
      createColumnsFromColumnDefs(e, t) {
        const i = e ? this.compareColumnStatesAndDispatchEvents(t) : void 0;
        this.valueCache.expire(), this.autoGroupsNeedBuilding = !0;
        const r = this.primaryColumns,
          s = this.primaryColumnTree,
          n = this.columnFactory.createColumnTree(this.columnDefs, !0, s, t);
        this.destroyOldColumns(this.primaryColumnTree, n.columnTree), this.primaryColumnTree = n.columnTree, this.primaryHeaderRowCount = n.treeDept + 1, this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree), this.primaryColumnsMap = {}, this.primaryColumns.forEach(e => this.primaryColumnsMap[e.getId()] = e), this.extractRowGroupColumns(t, r), this.extractPivotColumns(t, r), this.extractValueColumns(t, r), this.ready = !0;
        const o = void 0 === this.gridColsArePrimary;
        (this.gridColsArePrimary || o || this.autoGroupsNeedBuilding) && (this.updateGridColumns(), e && this.gridColsArePrimary && !this.gos.get("maintainColumnOrder") && this.orderGridColumnsLikePrimary(), this.updateDisplayedColumns(t), this.checkViewportColumns()), this.dispatchEverythingChanged(t), this.changeEventsDispatching = !0, i && i(), this.changeEventsDispatching = !1, this.dispatchNewColumnsLoaded(t)
      }
      shouldRowModelIgnoreRefresh() {
        return this.changeEventsDispatching
      }
      dispatchNewColumnsLoaded(e) {
        const t = {
          type: Et.EVENT_NEW_COLUMNS_LOADED,
          source: e
        };
        this.eventService.dispatchEvent(t), "gridInitializing" === e && this.onColumnsReady()
      }
      dispatchEverythingChanged(e) {
        const t = {
          type: Et.EVENT_COLUMN_EVERYTHING_CHANGED,
          source: e
        };
        this.eventService.dispatchEvent(t)
      }
      orderGridColumnsLikePrimary() {
        const e = this.primaryColumns;
        if (!e) return;
        const t = e.filter(e => this.gridColumns.indexOf(e) >= 0),
          i = this.gridColumns.filter(e => t.indexOf(e) < 0);
        this.gridColumns = [...i, ...t], this.gridColumns = this.placeLockedColumns(this.gridColumns)
      }
      getAllDisplayedAutoHeightCols() {
        return this.displayedAutoHeightCols
      }
      setViewport() {
        this.gos.get("enableRtl") ? (this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth, this.viewportRight = this.bodyWidth - this.scrollPosition) : (this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition)
      }
      checkViewportColumns(e = !1) {
        if (null == this.displayedColumnsCenter) return;
        if (!this.extractViewport()) return;
        const t = {
          type: Et.EVENT_VIRTUAL_COLUMNS_CHANGED,
          afterScroll: e
        };
        this.eventService.dispatchEvent(t)
      }
      setViewportPosition(e, t, i = !1) {
        (e !== this.scrollWidth || t !== this.scrollPosition || this.bodyWidthDirty) && (this.scrollWidth = e, this.scrollPosition = t, this.bodyWidthDirty = !0, this.setViewport(), this.ready && this.checkViewportColumns(i))
      }
      isPivotMode() {
        return this.pivotMode
      }
      isPivotSettingAllowed(e) {
        return !e || !this.gos.get("treeData") || (z("Pivot mode not available with treeData."), !1)
      }
      setPivotMode(e, t) {
        if (e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) return;
        if (this.pivotMode = e, !this.gridColumns) return;
        this.autoGroupsNeedBuilding = !0, this.updateGridColumns(), this.updateDisplayedColumns(t);
        const i = {
          type: Et.EVENT_COLUMN_PIVOT_MODE_CHANGED
        };
        this.eventService.dispatchEvent(i)
      }
      getSecondaryPivotColumn(e, t) {
        if (N(this.secondaryColumns)) return null;
        const i = this.getPrimaryColumn(t);
        let r = null;
        return this.secondaryColumns.forEach(t => {
          const s = t.getColDef().pivotKeys,
            n = t.getColDef().pivotValueColumn;
          Fe(s, e) && n === i && (r = t)
        }), r
      }
      setBeans(e) {
        this.logger = e.create("columnModel")
      }
      setFirstRightAndLastLeftPinned(e) {
        let t, i;
        this.gos.get("enableRtl") ? (t = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null, i = this.displayedColumnsRight ? Me(this.displayedColumnsRight) : null) : (t = this.displayedColumnsLeft ? Me(this.displayedColumnsLeft) : null, i = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null), this.gridColumns.forEach(r => {
          r.setLastLeftPinned(r === t, e), r.setFirstRightPinned(r === i, e)
        })
      }
      autoSizeColumns(e) {
        if (this.shouldQueueResizeOperations) return void this.resizeOperationQueue.push(() => this.autoSizeColumns(e));
        const {
          columns: t,
          skipHeader: i,
          skipHeaderGroups: r,
          stopAtGroup: s,
          source: n = "api"
        } = e;
        this.animationFrameService.flushAllFrames();
        const o = [];
        let a = -1;
        const l = null != i ? i : this.gos.get("skipHeaderOnAutoSize"),
          c = null != r ? r : l;
        for (; 0 !== a;) a = 0, this.actionOnGridColumns(t, e => {
          if (o.indexOf(e) >= 0) return !1;
          const t = this.autoWidthCalculator.getPreferredWidthForColumn(e, l);
          if (t > 0) {
            const i = this.normaliseColumnWidth(e, t);
            e.setActualWidth(i, n), o.push(e), a++
          }
          return !0
        }, n);
        c || this.autoSizeColumnGroupsByColumns(t, n, s), this.dispatchColumnResizedEvent(o, !0, "autosizeColumns")
      }
      dispatchColumnResizedEvent(e, t, i, r = null) {
        if (e && e.length) {
          const s = {
            type: Et.EVENT_COLUMN_RESIZED,
            columns: e,
            column: 1 === e.length ? e[0] : null,
            flexColumns: r,
            finished: t,
            source: i
          };
          this.eventService.dispatchEvent(s)
        }
      }
      dispatchColumnChangedEvent(e, t, i) {
        const r = {
          type: e,
          columns: t,
          column: t && 1 == t.length ? t[0] : null,
          source: i
        };
        this.eventService.dispatchEvent(r)
      }
      dispatchColumnMovedEvent(e) {
        const {
          movedColumns: t,
          source: i,
          toIndex: r,
          finished: s
        } = e, n = {
          type: Et.EVENT_COLUMN_MOVED,
          columns: t,
          column: t && 1 === t.length ? t[0] : null,
          toIndex: r,
          finished: s,
          source: i
        };
        this.eventService.dispatchEvent(n)
      }
      dispatchColumnPinnedEvent(e, t) {
        if (!e.length) return;
        const i = 1 === e.length ? e[0] : null,
          r = this.getCommonValue(e, e => e.getPinned()),
          s = {
            type: Et.EVENT_COLUMN_PINNED,
            pinned: null != r ? r : null,
            columns: e,
            column: i,
            source: t
          };
        this.eventService.dispatchEvent(s)
      }
      dispatchColumnVisibleEvent(e, t) {
        if (!e.length) return;
        const i = 1 === e.length ? e[0] : null,
          r = this.getCommonValue(e, e => e.isVisible()),
          s = {
            type: Et.EVENT_COLUMN_VISIBLE,
            visible: r,
            columns: e,
            column: i,
            source: t
          };
        this.eventService.dispatchEvent(s)
      }
      autoSizeColumn(e, t, i) {
        e && this.autoSizeColumns({
          columns: [e],
          skipHeader: i,
          skipHeaderGroups: !0,
          source: t
        })
      }
      autoSizeColumnGroupsByColumns(e, t, i) {
        const r = new Set;
        let s;
        this.getGridColumns(e).forEach(e => {
          let t = e.getParent();
          for (; t && t != i;) t.isPadding() || r.add(t), t = t.getParent()
        });
        for (const e of r) {
          for (const t of this.ctrlsService.getHeaderRowContainerCtrls())
            if (s = t.getHeaderCtrlForColumn(e), s) break;
          s && s.resizeLeafColumnsToFit(t)
        }
        return []
      }
      autoSizeAllColumns(e, t) {
        if (this.shouldQueueResizeOperations) return void this.resizeOperationQueue.push(() => this.autoSizeAllColumns(e, t));
        const i = this.getAllDisplayedColumns();
        this.autoSizeColumns({
          columns: i,
          skipHeader: t,
          source: e
        })
      }
      getColumnsFromTree(e) {
        const t = [],
          i = e => {
            for (let r = 0; r < e.length; r++) {
              const s = e[r];
              s instanceof Le ? t.push(s) : s instanceof ye && i(s.getChildren())
            }
          };
        return i(e), t
      }
      getAllDisplayedTrees() {
        return this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre ? this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight) : null
      }
      getPrimaryColumnTree() {
        return this.primaryColumnTree
      }
      getHeaderRowCount() {
        return this.gridHeaderRowCount
      }
      getDisplayedTreeLeft() {
        return this.displayedTreeLeft
      }
      getDisplayedTreeRight() {
        return this.displayedTreeRight
      }
      getDisplayedTreeCentre() {
        return this.displayedTreeCentre
      }
      isColumnDisplayed(e) {
        return this.getAllDisplayedColumns().indexOf(e) >= 0
      }
      getAllDisplayedColumns() {
        return this.displayedColumns
      }
      getViewportColumns() {
        return this.viewportColumns
      }
      getDisplayedLeftColumnsForRow(e) {
        return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsLeft) : this.displayedColumnsLeft
      }
      getDisplayedRightColumnsForRow(e) {
        return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsRight) : this.displayedColumnsRight
      }
      isColSpanActive() {
        return this.colSpanActive
      }
      getDisplayedColumnsForRow(e, t, i, r) {
        const s = [];
        let n = null;
        for (let o = 0; o < t.length; o++) {
          const a = t[o],
            l = t.length - o,
            c = Math.min(a.getColSpan(e), l),
            h = [a];
          if (c > 1) {
            const e = c - 1;
            for (let i = 1; i <= e; i++) h.push(t[o + i]);
            o += e
          }
          let u;
          if (i ? (u = !1, h.forEach(e => {
              i(e) && (u = !0)
            })) : u = !0, u) {
            if (0 === s.length && n) {
              !!r && r(a) && s.push(n)
            }
            s.push(a)
          }
          n = a
        }
        return s
      }
      getViewportCenterColumnsForRow(e) {
        if (!this.colSpanActive) return this.viewportColumnsCenter;
        const t = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this);
        return this.getDisplayedColumnsForRow(e, this.displayedColumnsCenter, t, e => {
          const t = e.getLeft();
          return v(t) && t > this.viewportLeft
        })
      }
      isColumnAtEdge(e, t) {
        const i = this.getAllDisplayedColumns();
        if (!i.length) return !1;
        const r = "first" === t;
        let s;
        if (e instanceof pt) {
          const t = e.getDisplayedLeafColumns();
          if (!t.length) return !1;
          s = r ? t[0] : Me(t)
        } else s = e;
        return (r ? i[0] : Me(i)) === s
      }
      getAriaColumnIndex(e) {
        let t;
        return t = e instanceof pt ? e.getLeafColumns()[0] : e, this.ariaOrderColumns.indexOf(t) + 1
      }
      isColumnInHeaderViewport(e) {
        return !!e.isAutoHeaderHeight() || this.isColumnInRowViewport(e)
      }
      isColumnInRowViewport(e) {
        if (e.isAutoHeight()) return !0;
        const t = e.getLeft() || 0,
          i = t + e.getActualWidth(),
          r = this.viewportLeft - 200,
          s = this.viewportRight + 200;
        return !(t < r && i < r) && !(t > s && i > s)
      }
      getDisplayedColumnsLeftWidth() {
        return this.getWidthOfColsInList(this.displayedColumnsLeft)
      }
      getDisplayedColumnsRightWidth() {
        return this.getWidthOfColsInList(this.displayedColumnsRight)
      }
      updatePrimaryColumnList(e, t, i, r, s, n) {
        if (!e || I(e)) return;
        let o = !1;
        if (e.forEach(e => {
            if (!e) return;
            const s = this.getPrimaryColumn(e);
            if (s) {
              if (i) {
                if (t.indexOf(s) >= 0) return;
                t.push(s)
              } else {
                if (t.indexOf(s) < 0) return;
                ke(t, s)
              }
              r(s), o = !0
            }
          }), !o) return;
        this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(n);
        const a = {
          type: s,
          columns: t,
          column: 1 === t.length ? t[0] : null,
          source: n
        };
        this.eventService.dispatchEvent(a)
      }
      setRowGroupColumns(e, t) {
        this.autoGroupsNeedBuilding = !0, this.setPrimaryColumnList(e, this.rowGroupColumns, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, !0, this.setRowGroupActive.bind(this), t)
      }
      setRowGroupActive(e, t, i) {
        e !== t.isRowGroupActive() && (t.setRowGroupActive(e, i), e && !this.gos.get("suppressRowGroupHidesColumns") && this.setColumnsVisible([t], !1, i), e || this.gos.get("suppressMakeColumnVisibleAfterUnGroup") || this.setColumnsVisible([t], !0, i))
      }
      addRowGroupColumns(e, t) {
        this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(e, this.rowGroupColumns, !0, this.setRowGroupActive.bind(this, !0), Et.EVENT_COLUMN_ROW_GROUP_CHANGED, t)
      }
      removeRowGroupColumns(e, t) {
        this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(e, this.rowGroupColumns, !1, this.setRowGroupActive.bind(this, !1), Et.EVENT_COLUMN_ROW_GROUP_CHANGED, t)
      }
      addPivotColumns(e, t) {
        this.updatePrimaryColumnList(e, this.pivotColumns, !0, e => e.setPivotActive(!0, t), Et.EVENT_COLUMN_PIVOT_CHANGED, t)
      }
      setPivotColumns(e, t) {
        this.setPrimaryColumnList(e, this.pivotColumns, Et.EVENT_COLUMN_PIVOT_CHANGED, !0, (e, i) => {
          i.setPivotActive(e, t)
        }, t)
      }
      removePivotColumns(e, t) {
        this.updatePrimaryColumnList(e, this.pivotColumns, !1, e => e.setPivotActive(!1, t), Et.EVENT_COLUMN_PIVOT_CHANGED, t)
      }
      setPrimaryColumnList(e, t, i, r, s, n) {
        if (!this.gridColumns) return;
        const o = new Map;
        t.forEach((e, t) => o.set(e, t)), t.length = 0, v(e) && e.forEach(e => {
          const i = this.getPrimaryColumn(e);
          i && t.push(i)
        }), t.forEach((e, t) => {
          const i = o.get(e);
          void 0 !== i ? r && i !== t || o.delete(e) : o.set(e, 0)
        }), (this.primaryColumns || []).forEach(e => {
          const i = t.indexOf(e) >= 0;
          s(i, e)
        }), this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(n), this.dispatchColumnChangedEvent(i, [...o.keys()], n)
      }
      setValueColumns(e, t) {
        this.setPrimaryColumnList(e, this.valueColumns, Et.EVENT_COLUMN_VALUE_CHANGED, !1, this.setValueActive.bind(this), t)
      }
      setValueActive(e, t, i) {
        if (e !== t.isValueActive() && (t.setValueActive(e, i), e && !t.getAggFunc() && this.aggFuncService)) {
          const e = this.aggFuncService.getDefaultAggFunc(t);
          t.setAggFunc(e)
        }
      }
      addValueColumns(e, t) {
        this.updatePrimaryColumnList(e, this.valueColumns, !0, this.setValueActive.bind(this, !0), Et.EVENT_COLUMN_VALUE_CHANGED, t)
      }
      removeValueColumns(e, t) {
        this.updatePrimaryColumnList(e, this.valueColumns, !1, this.setValueActive.bind(this, !1), Et.EVENT_COLUMN_VALUE_CHANGED, t)
      }
      normaliseColumnWidth(e, t) {
        const i = e.getMinWidth();
        v(i) && t < i && (t = i);
        const r = e.getMaxWidth();
        return v(r) && e.isGreaterThanMax(t) && (t = r), t
      }
      getPrimaryOrGridColumn(e) {
        return this.getPrimaryColumn(e) || this.getGridColumn(e)
      }
      setColumnWidths(e, t, i, r) {
        const s = [];
        e.forEach(e => {
          const i = this.getPrimaryOrGridColumn(e.key);
          if (!i) return;
          s.push({
            width: e.newWidth,
            ratios: [1],
            columns: [i]
          });
          if ("shift" === this.gos.get("colResizeDefault") && (t = !t), t) {
            const t = this.getDisplayedColAfter(i);
            if (!t) return;
            const r = i.getActualWidth() - e.newWidth,
              n = t.getActualWidth() + r;
            s.push({
              width: n,
              ratios: [1],
              columns: [t]
            })
          }
        }), 0 !== s.length && this.resizeColumnSets({
          resizeSets: s,
          finished: i,
          source: r
        })
      }
      checkMinAndMaxWidthsForSet(e) {
        const {
          columns: t,
          width: i
        } = e;
        let r = 0,
          s = 0,
          n = !0;
        t.forEach(e => {
          const t = e.getMinWidth();
          r += t || 0;
          const i = e.getMaxWidth();
          v(i) && i > 0 ? s += i : n = !1
        });
        return i >= r && (!n || i <= s)
      }
      resizeColumnSets(e) {
        const {
          resizeSets: t,
          finished: i,
          source: r
        } = e;
        if (!(!t || t.every(e => this.checkMinAndMaxWidthsForSet(e)))) {
          if (i) {
            const e = t && t.length > 0 ? t[0].columns : null;
            this.dispatchColumnResizedEvent(e, i, r)
          }
          return
        }
        const s = [],
          n = [];
        t.forEach(e => {
          const {
            width: t,
            columns: i,
            ratios: o
          } = e, a = {}, l = {};
          i.forEach(e => n.push(e));
          let c = !0,
            h = 0;
          for (; c;) {
            if (h++, h > 1e3) {
              console.error("AG Grid: infinite loop in resizeColumnSets");
              break
            }
            c = !1;
            const e = [];
            let r = 0,
              s = t;
            i.forEach((t, i) => {
              if (l[t.getId()]) s -= a[t.getId()];
              else {
                e.push(t);
                const s = o[i];
                r += s
              }
            });
            const n = 1 / r;
            e.forEach((i, r) => {
              let h;
              r === e.length - 1 ? h = s : (h = Math.round(o[r] * t * n), s -= h);
              const u = i.getMinWidth(),
                d = i.getMaxWidth();
              v(u) && h < u ? (h = u, l[i.getId()] = !0, c = !0) : v(d) && d > 0 && h > d && (h = d, l[i.getId()] = !0, c = !0), a[i.getId()] = h
            })
          }
          i.forEach(e => {
            const t = a[e.getId()];
            e.getActualWidth() !== t && (e.setActualWidth(t, r), s.push(e))
          })
        });
        const o = s.length > 0;
        let a = [];
        o && (a = this.refreshFlexedColumns({
          resizingCols: n,
          skipSetLeft: !0
        }), this.setLeftValues(r), this.updateBodyWidths(), this.checkViewportColumns());
        const l = n.concat(a);
        (o || i) && this.dispatchColumnResizedEvent(l, i, r, a)
      }
      setColumnAggFunc(e, t, i) {
        if (!e) return;
        const r = this.getPrimaryColumn(e);
        r && (r.setAggFunc(t), this.dispatchColumnChangedEvent(Et.EVENT_COLUMN_VALUE_CHANGED, [r], i))
      }
      moveRowGroupColumn(e, t, i) {
        if (this.isRowGroupEmpty()) return;
        const r = this.rowGroupColumns[e],
          s = this.rowGroupColumns.slice(e, t);
        this.rowGroupColumns.splice(e, 1), this.rowGroupColumns.splice(t, 0, r);
        const n = {
          type: Et.EVENT_COLUMN_ROW_GROUP_CHANGED,
          columns: s,
          column: 1 === s.length ? s[0] : null,
          source: i
        };
        this.eventService.dispatchEvent(n)
      }
      moveColumns(e, t, i, r = !0) {
        if (!this.gridColumns) return;
        if (this.columnAnimationService.start(), t > this.gridColumns.length - e.length) return console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + t), void console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
        const s = this.getGridColumns(e);
        !this.doesMovePassRules(s, t) || (Ke(this.gridColumns, s, t), this.updateDisplayedColumns(i), this.dispatchColumnMovedEvent({
          movedColumns: s,
          source: i,
          toIndex: t,
          finished: r
        }), this.columnAnimationService.finish())
      }
      doesMovePassRules(e, t) {
        const i = this.getProposedColumnOrder(e, t);
        return this.doesOrderPassRules(i)
      }
      doesOrderPassRules(e) {
        return !!this.doesMovePassMarryChildren(e) && !!this.doesMovePassLockedPositions(e)
      }
      getProposedColumnOrder(e, t) {
        const i = this.gridColumns.slice();
        return Ke(i, e, t), i
      }
      sortColumnsLikeGridColumns(e) {
        if (!e || e.length <= 1) return;
        e.filter(e => this.gridColumns.indexOf(e) < 0).length > 0 || e.sort((e, t) => this.gridColumns.indexOf(e) - this.gridColumns.indexOf(t))
      }
      doesMovePassLockedPositions(e) {
        let t = 0,
          i = !0;
        return e.forEach(e => {
          const r = (s = e.getColDef().lockPosition) ? !0 === s || "left" === s ? 0 : 2 : 1;
          var s;
          r < t && (i = !1), t = r
        }), i
      }
      doesMovePassMarryChildren(e) {
        let t = !0;
        return ut(null, this.gridBalancedTree, i => {
          if (!(i instanceof ye)) return;
          const r = i,
            s = r.getColGroupDef();
          if (!(s && s.marryChildren)) return;
          const n = [];
          r.getLeafColumns().forEach(t => {
            const i = e.indexOf(t);
            n.push(i)
          });
          Math.max.apply(Math, n) - Math.min.apply(Math, n) > r.getLeafColumns().length - 1 && (t = !1)
        }), t
      }
      moveColumnByIndex(e, t, i) {
        if (!this.gridColumns) return;
        const r = this.gridColumns[e];
        this.moveColumns([r], t, i)
      }
      getColumnDefs() {
        if (!this.primaryColumns) return;
        const e = this.primaryColumns.slice();
        return this.gridColsArePrimary ? e.sort((e, t) => this.gridColumns.indexOf(e) - this.gridColumns.indexOf(t)) : this.lastPrimaryOrder && e.sort((e, t) => this.lastPrimaryOrder.indexOf(e) - this.lastPrimaryOrder.indexOf(t)), this.columnDefFactory.buildColumnDefs(e, this.rowGroupColumns, this.pivotColumns)
      }
      getBodyContainerWidth() {
        return this.bodyWidth
      }
      getContainerWidth(e) {
        switch (e) {
          case "left":
            return this.leftWidth;
          case "right":
            return this.rightWidth;
          default:
            return this.bodyWidth
        }
      }
      updateBodyWidths() {
        const e = this.getWidthOfColsInList(this.displayedColumnsCenter),
          t = this.getWidthOfColsInList(this.displayedColumnsLeft),
          i = this.getWidthOfColsInList(this.displayedColumnsRight);
        this.bodyWidthDirty = this.bodyWidth !== e;
        if (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== i) {
          this.bodyWidth = e, this.leftWidth = t, this.rightWidth = i;
          const r = {
            type: Et.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED
          };
          this.eventService.dispatchEvent(r);
          const s = {
            type: Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED
          };
          this.eventService.dispatchEvent(s)
        }
      }
      getValueColumns() {
        return this.valueColumns ? this.valueColumns : []
      }
      getPivotColumns() {
        return this.pivotColumns ? this.pivotColumns : []
      }
      isPivotActive() {
        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode
      }
      getRowGroupColumns() {
        return this.rowGroupColumns ? this.rowGroupColumns : []
      }
      getDisplayedCenterColumns() {
        return this.displayedColumnsCenter
      }
      getDisplayedLeftColumns() {
        return this.displayedColumnsLeft
      }
      getDisplayedRightColumns() {
        return this.displayedColumnsRight
      }
      getAllPrimaryColumns() {
        return this.primaryColumns ? this.primaryColumns : null
      }
      getSecondaryColumns() {
        return this.secondaryColumns ? this.secondaryColumns : null
      }
      getAllColumnsForQuickFilter() {
        return this.columnsForQuickFilter
      }
      getAllGridColumns() {
        var e;
        return null != (e = this.gridColumns) ? e : []
      }
      isRowGroupEmpty() {
        return I(this.rowGroupColumns)
      }
      setColumnsVisible(e, t = !1, i) {
        this.applyColumnState({
          state: e.map(e => ({
            colId: "string" == typeof e ? e : e.getColId(),
            hide: !t
          }))
        }, i)
      }
      setColumnsPinned(e, t, i) {
        if (!this.gridColumns) return;
        if (this.gos.isDomLayout("print")) return void console.warn("AG Grid: Changing the column pinning status is not allowed with domLayout='print'");
        let r;
        this.columnAnimationService.start(), r = !0 === t || "left" === t ? "left" : "right" === t ? "right" : null, this.actionOnGridColumns(e, e => e.getPinned() !== r && (e.setPinned(r), !0), i, () => ({
          type: Et.EVENT_COLUMN_PINNED,
          pinned: r,
          column: null,
          columns: null,
          source: i
        })), this.columnAnimationService.finish()
      }
      actionOnGridColumns(e, t, i, r) {
        if (I(e)) return;
        const s = [];
        if (e.forEach(e => {
            if (!e) return;
            const i = this.getGridColumn(e);
            if (!i) return;
            !1 !== t(i) && s.push(i)
          }), s.length && (this.updateDisplayedColumns(i), v(r) && r)) {
          const e = r();
          e.columns = s, e.column = 1 === s.length ? s[0] : null, this.eventService.dispatchEvent(e)
        }
      }
      getDisplayedColBefore(e) {
        const t = this.getAllDisplayedColumns(),
          i = t.indexOf(e);
        return i > 0 ? t[i - 1] : null
      }
      getDisplayedColAfter(e) {
        const t = this.getAllDisplayedColumns(),
          i = t.indexOf(e);
        return i < t.length - 1 ? t[i + 1] : null
      }
      getDisplayedGroupAtDirection(e, t) {
        const i = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(),
          r = e.getDisplayedLeafColumns(),
          s = "After" === t ? Me(r) : r[0],
          n = `getDisplayedCol${t}`;
        for (;;) {
          const t = this[n](s);
          if (!t) return null;
          const r = this.getColumnGroupAtLevel(t, i);
          if (r !== e) return r
        }
      }
      getColumnGroupAtLevel(e, t) {
        let i, r, s = e.getParent();
        for (;;) {
          if (i = s.getProvidedColumnGroup().getLevel(), r = s.getPaddingLevel(), i + r <= t) break;
          s = s.getParent()
        }
        return s
      }
      isPinningLeft() {
        return this.displayedColumnsLeft.length > 0
      }
      isPinningRight() {
        return this.displayedColumnsRight.length > 0
      }
      getPrimaryAndSecondaryAndAutoColumns() {
        return [].concat(this.primaryColumns || [], this.groupAutoColumns || [], this.secondaryColumns || [])
      }
      createStateItemFromColumn(e) {
        const t = e.isRowGroupActive() ? this.rowGroupColumns.indexOf(e) : null,
          i = e.isPivotActive() ? this.pivotColumns.indexOf(e) : null,
          r = e.isValueActive() ? e.getAggFunc() : null,
          s = null != e.getSort() ? e.getSort() : null,
          n = null != e.getSortIndex() ? e.getSortIndex() : null,
          o = null != e.getFlex() && e.getFlex() > 0 ? e.getFlex() : null;
        return {
          colId: e.getColId(),
          width: e.getActualWidth(),
          hide: !e.isVisible(),
          pinned: e.getPinned(),
          sort: s,
          sortIndex: n,
          aggFunc: r,
          rowGroup: e.isRowGroupActive(),
          rowGroupIndex: t,
          pivot: e.isPivotActive(),
          pivotIndex: i,
          flex: o
        }
      }
      getColumnState() {
        if (N(this.primaryColumns) || !this.isAlive()) return [];
        const e = this.getPrimaryAndSecondaryAndAutoColumns().map(this.createStateItemFromColumn.bind(this));
        return this.orderColumnStateList(e), e
      }
      orderColumnStateList(e) {
        const t = _t(this.gridColumns.map((e, t) => [e.getColId(), t]));
        e.sort((e, i) => (t.has(e.colId) ? t.get(e.colId) : -1) - (t.has(i.colId) ? t.get(i.colId) : -1))
      }
      resetColumnState(e) {
        if (I(this.primaryColumns)) return;
        const t = this.getColumnsFromTree(this.primaryColumnTree),
          i = [];
        let r = 1e3,
          s = 1e3,
          n = [];
        this.groupAutoColumns && (n = n.concat(this.groupAutoColumns)), t && (n = n.concat(t)), n.forEach(e => {
          const t = this.getColumnStateFromColDef(e);
          N(t.rowGroupIndex) && t.rowGroup && (t.rowGroupIndex = r++), N(t.pivotIndex) && t.pivot && (t.pivotIndex = s++), i.push(t)
        }), this.applyColumnState({
          state: i,
          applyOrder: !0
        }, e)
      }
      getColumnStateFromColDef(e) {
        const t = (e, t) => null != e ? e : null != t ? t : null,
          i = e.getColDef(),
          r = t(i.sort, i.initialSort),
          s = t(i.sortIndex, i.initialSortIndex),
          n = t(i.hide, i.initialHide),
          o = t(i.pinned, i.initialPinned),
          a = t(i.width, i.initialWidth),
          l = t(i.flex, i.initialFlex);
        let c = t(i.rowGroupIndex, i.initialRowGroupIndex),
          h = t(i.rowGroup, i.initialRowGroup);
        null != c || null != h && 0 != h || (c = null, h = null);
        let u = t(i.pivotIndex, i.initialPivotIndex),
          d = t(i.pivot, i.initialPivot);
        null != u || null != d && 0 != d || (u = null, d = null);
        const p = t(i.aggFunc, i.initialAggFunc);
        return {
          colId: e.getColId(),
          sort: r,
          sortIndex: s,
          hide: n,
          pinned: o,
          width: a,
          flex: l,
          rowGroup: h,
          rowGroupIndex: c,
          pivot: d,
          pivotIndex: u,
          aggFunc: p
        }
      }
      applyColumnState(e, t) {
        if (I(this.primaryColumns)) return !1;
        if (e && e.state && !e.state.forEach) return console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), !1;
        const i = (i, r, s) => {
          const n = this.compareColumnStatesAndDispatchEvents(t);
          this.autoGroupsNeedBuilding = !0;
          const o = r.slice(),
            a = {},
            l = {},
            c = [],
            h = [];
          let u = 0;
          const d = this.rowGroupColumns.slice(),
            p = this.pivotColumns.slice();
          i.forEach(i => {
            const r = i.colId || "";
            if (r.startsWith(Tt)) return c.push(i), void h.push(i);
            const n = s(r);
            n ? (this.syncColumnWithStateItem(n, i, e.defaultState, a, l, !1, t), ke(o, n)) : (h.push(i), u += 1)
          });
          const E = i => this.syncColumnWithStateItem(i, null, e.defaultState, a, l, !1, t);
          o.forEach(E);
          const g = (e, t, i, r) => {
            const s = e[i.getId()],
              n = e[r.getId()],
              o = null != s,
              a = null != n;
            if (o && a) return s - n;
            if (o) return -1;
            if (a) return 1;
            const l = t.indexOf(i),
              c = t.indexOf(r),
              h = l >= 0;
            return h && c >= 0 ? l - c : h ? -1 : 1
          };
          this.rowGroupColumns.sort(g.bind(this, a, d)), this.pivotColumns.sort(g.bind(this, l, p)), this.updateGridColumns();
          const f = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
          return c.forEach(i => {
            const r = this.getAutoColumn(i.colId);
            ke(f, r), this.syncColumnWithStateItem(r, i, e.defaultState, null, null, !0, t)
          }), f.forEach(E), this.applyOrderAfterApplyState(e), this.updateDisplayedColumns(t), this.dispatchEverythingChanged(t), n(), {
            unmatchedAndAutoStates: h,
            unmatchedCount: u
          }
        };
        this.columnAnimationService.start();
        let {
          unmatchedAndAutoStates: r,
          unmatchedCount: s
        } = i(e.state || [], this.primaryColumns || [], e => this.getPrimaryColumn(e));
        return (r.length > 0 || v(e.defaultState)) && (s = i(r, this.secondaryColumns || [], e => this.getSecondaryColumn(e)).unmatchedCount), this.columnAnimationService.finish(), 0 === s
      }
      applyOrderAfterApplyState(e) {
        if (!e.applyOrder || !e.state) return;
        let t = [];
        const i = {};
        e.state.forEach(e => {
          if (!e.colId || i[e.colId]) return;
          const r = this.gridColumnsMap[e.colId];
          r && (t.push(r), i[e.colId] = !0)
        });
        let r = 0;
        this.gridColumns.forEach(e => {
          const s = e.getColId();
          if (null != i[s]) return;
          s.startsWith(Tt) ? We(t, e, r++) : t.push(e)
        }), t = this.placeLockedColumns(t), this.doesMovePassMarryChildren(t) ? this.gridColumns = t : console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.")
      }
      compareColumnStatesAndDispatchEvents(e) {
        const t = {
            rowGroupColumns: this.rowGroupColumns.slice(),
            pivotColumns: this.pivotColumns.slice(),
            valueColumns: this.valueColumns.slice()
          },
          i = this.getColumnState(),
          r = {};
        return i.forEach(e => {
          r[e.colId] = e
        }), () => {
          const s = this.getPrimaryAndSecondaryAndAutoColumns(),
            n = (t, i, r, s) => {
              if (Fe(i.map(s), r.map(s))) return;
              const n = new Set(i);
              r.forEach(e => {
                n.delete(e) || n.add(e)
              });
              const o = [...n],
                a = {
                  type: t,
                  columns: o,
                  column: 1 === o.length ? o[0] : null,
                  source: e
                };
              this.eventService.dispatchEvent(a)
            },
            o = e => {
              const t = [];
              return s.forEach(i => {
                const s = r[i.getColId()];
                s && e(s, i) && t.push(i)
              }), t
            },
            a = e => e.getColId();
          n(Et.EVENT_COLUMN_ROW_GROUP_CHANGED, t.rowGroupColumns, this.rowGroupColumns, a), n(Et.EVENT_COLUMN_PIVOT_CHANGED, t.pivotColumns, this.pivotColumns, a);
          const l = o((e, t) => {
            const i = null != e.aggFunc,
              r = i != t.isValueActive(),
              s = i && e.aggFunc != t.getAggFunc();
            return r || s
          });
          l.length > 0 && this.dispatchColumnChangedEvent(Et.EVENT_COLUMN_VALUE_CHANGED, l, e);
          this.dispatchColumnResizedEvent(o((e, t) => e.width != t.getActualWidth()), !0, e);
          this.dispatchColumnPinnedEvent(o((e, t) => e.pinned != t.getPinned()), e);
          this.dispatchColumnVisibleEvent(o((e, t) => e.hide == t.isVisible()), e);
          const c = o((e, t) => e.sort != t.getSort() || e.sortIndex != t.getSortIndex());
          c.length > 0 && this.sortController.dispatchSortChangedEvents(e, c), this.normaliseColumnMovedEventForColumnState(i, e)
        }
      }
      getCommonValue(e, t) {
        if (!e || 0 == e.length) return;
        const i = t(e[0]);
        for (let r = 1; r < e.length; r++)
          if (i !== t(e[r])) return;
        return i
      }
      normaliseColumnMovedEventForColumnState(e, t) {
        const i = this.getColumnState(),
          r = {};
        i.forEach(e => r[e.colId] = e);
        const s = {};
        e.forEach(e => {
          r[e.colId] && (s[e.colId] = !0)
        });
        const n = e.filter(e => s[e.colId]),
          o = i.filter(e => s[e.colId]),
          a = [];
        o.forEach((e, t) => {
          const i = n && n[t];
          if (i && i.colId !== e.colId) {
            const e = this.getGridColumn(i.colId);
            e && a.push(e)
          }
        }), a.length && this.dispatchColumnMovedEvent({
          movedColumns: a,
          source: t,
          finished: !0
        })
      }
      syncColumnWithStateItem(e, t, i, r, s, n, o) {
        var a;
        if (!e) return;
        const l = (e, r) => {
            const s = {
              value1: void 0,
              value2: void 0
            };
            let n = !1;
            return t && (void 0 !== t[e] && (s.value1 = t[e], n = !0), v(r) && void 0 !== t[r] && (s.value2 = t[r], n = !0)), !n && i && (void 0 !== i[e] && (s.value1 = i[e]), v(r) && void 0 !== i[r] && (s.value2 = i[r])), s
          },
          c = l("hide").value1;
        void 0 !== c && e.setVisible(!c, o);
        const h = l("pinned").value1;
        void 0 !== h && e.setPinned(h);
        const u = null != (a = e.getColDef().minWidth) ? a : this.environment.getMinColWidth(),
          d = l("flex").value1;
        if (void 0 !== d && e.setFlex(d), null == d) {
          const t = l("width").value1;
          null != t && null != u && t >= u && e.setActualWidth(t, o)
        }
        const p = l("sort").value1;
        void 0 !== p && ("desc" === p || "asc" === p ? e.setSort(p, o) : e.setSort(void 0, o));
        const E = l("sortIndex").value1;
        if (void 0 !== E && e.setSortIndex(E), n || !e.isPrimary()) return;
        const g = l("aggFunc").value1;
        void 0 !== g && ("string" == typeof g ? (e.setAggFunc(g), e.isValueActive() || (e.setValueActive(!0, o), this.valueColumns.push(e))) : (v(g) && console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), e.isValueActive() && (e.setValueActive(!1, o), ke(this.valueColumns, e))));
        const {
          value1: f,
          value2: T
        } = l("rowGroup", "rowGroupIndex");
        void 0 === f && void 0 === T || ("number" == typeof T || f ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, o), this.rowGroupColumns.push(e)), r && "number" == typeof T && (r[e.getId()] = T)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, o), ke(this.rowGroupColumns, e)));
        const {
          value1: m,
          value2: C
        } = l("pivot", "pivotIndex");
        void 0 === m && void 0 === C || ("number" == typeof C || m ? (e.isPivotActive() || (e.setPivotActive(!0, o), this.pivotColumns.push(e)), s && "number" == typeof C && (s[e.getId()] = C)) : e.isPivotActive() && (e.setPivotActive(!1, o), ke(this.pivotColumns, e)))
      }
      getGridColumns(e) {
        return this.getColumns(e, this.getGridColumn.bind(this))
      }
      getColumns(e, t) {
        const i = [];
        return e && e.forEach(e => {
          const r = t(e);
          r && i.push(r)
        }), i
      }
      getColumnWithValidation(e) {
        if (null == e) return null;
        const t = this.getGridColumn(e);
        return t || console.warn("AG Grid: could not find column " + e), t
      }
      getPrimaryColumn(e) {
        return this.primaryColumns ? this.getColumn(e, this.primaryColumns, this.primaryColumnsMap) : null
      }
      getGridColumn(e) {
        return this.getColumn(e, this.gridColumns, this.gridColumnsMap)
      }
      lookupGridColumn(e) {
        return this.gridColumnsMap[e]
      }
      getSecondaryColumn(e) {
        return this.secondaryColumns ? this.getColumn(e, this.secondaryColumns, this.secondaryColumnsMap) : null
      }
      getColumn(e, t, i) {
        if (!e || !i) return null;
        if ("string" == typeof e && i[e]) return i[e];
        for (let i = 0; i < t.length; i++)
          if (this.columnsMatch(t[i], e)) return t[i];
        return this.getAutoColumn(e)
      }
      getSourceColumnsForGroupColumn(e) {
        const t = e.getColDef().showRowGroup;
        if (!t) return null;
        if (!0 === t) return this.rowGroupColumns.slice(0);
        const i = this.getPrimaryColumn(t);
        return i ? [i] : null
      }
      getAutoColumn(e) {
        return this.groupAutoColumns && v(this.groupAutoColumns) && !N(this.groupAutoColumns) && this.groupAutoColumns.find(t => this.columnsMatch(t, e)) || null
      }
      columnsMatch(e, t) {
        const i = e === t,
          r = e.getColDef() === t,
          s = e.getColId() == t;
        return i || r || s
      }
      getDisplayNameForColumn(e, t, i = !1) {
        if (!e) return null;
        const r = this.getHeaderName(e.getColDef(), e, null, null, t);
        return i ? this.wrapHeaderNameWithAggFunc(e, r) : r
      }
      getDisplayNameForProvidedColumnGroup(e, t, i) {
        const r = t ? t.getColGroupDef() : null;
        return r ? this.getHeaderName(r, null, e, t, i) : null
      }
      getDisplayNameForColumnGroup(e, t) {
        return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t)
      }
      getHeaderName(e, t, i, r, s) {
        const n = e.headerValueGetter;
        if (n) {
          const o = this.gos.addGridCommonParams({
            colDef: e,
            column: t,
            columnGroup: i,
            providedColumnGroup: r,
            location: s
          });
          return "function" == typeof n ? n(o) : "string" == typeof n ? this.expressionService.evaluate(n, o) : (console.warn("AG Grid: headerValueGetter must be a function or a string"), "")
        }
        return null != e.headerName ? e.headerName : e.field ? It(e.field) : ""
      }
      wrapHeaderNameWithAggFunc(e, t) {
        if (this.gos.get("suppressAggFuncInHeader")) return t;
        const i = e.getColDef().pivotValueColumn;
        let r, s = null;
        if (v(i)) {
          const n = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && 1 === this.valueColumns.length,
            o = void 0 !== e.getColDef().pivotTotalColumnIds;
          if (n && !o) return t;
          s = i ? i.getAggFunc() : null, r = !0
        } else {
          const t = e.isValueActive(),
            i = this.pivotMode || !this.isRowGroupEmpty();
          t && i ? (s = e.getAggFunc(), r = !0) : r = !1
        }
        if (r) {
          const e = "string" == typeof s ? s : "func";
          return `${this.localeService.getLocaleTextFunc()(e,e)}(${t})`
        }
        return t
      }
      getColumnGroup(e, t) {
        if (!e) return null;
        if (e instanceof pt) return e;
        const i = this.getAllDisplayedTrees(),
          r = "number" == typeof t;
        let s = null;
        return bt(i, !1, i => {
          if (i instanceof pt) {
            const n = i;
            let o;
            o = r ? e === n.getGroupId() && t === n.getPartId() : e === n.getGroupId(), o && (s = n)
          }
        }), s
      }
      isReady() {
        return this.ready
      }
      extractValueColumns(e, t) {
        this.valueColumns = this.extractColumns(t, this.valueColumns, (t, i) => t.setValueActive(i, e), () => {}, () => {}, e => {
          const t = e.aggFunc;
          return null === t || "" === t ? null : void 0 !== t ? !!t : void 0
        }, e => null != e.initialAggFunc && "" != e.initialAggFunc), this.valueColumns.forEach(e => {
          const t = e.getColDef();
          null != t.aggFunc && "" != t.aggFunc ? e.setAggFunc(t.aggFunc) : e.getAggFunc() || e.setAggFunc(t.initialAggFunc)
        })
      }
      extractRowGroupColumns(e, t) {
        this.rowGroupColumns = this.extractColumns(t, this.rowGroupColumns, (t, i) => t.setRowGroupActive(i, e), e => e.rowGroupIndex, e => e.initialRowGroupIndex, e => e.rowGroup, e => e.initialRowGroup)
      }
      extractColumns(e = [], t = [], i, r, s, n, o) {
        const a = [],
          l = [];
        (this.primaryColumns || []).forEach(i => {
          const c = e.indexOf(i) < 0,
            h = i.getColDef(),
            u = _(n(h)),
            d = _(o(h)),
            p = L(r(h)),
            E = L(s(h));
          let g;
          if (g = void 0 !== u ? u : void 0 !== p ? null !== p && p >= 0 : c ? void 0 !== d ? d : !!(void 0 !== E) && (null != E && E >= 0) : t.indexOf(i) >= 0, g) {
            (c ? null != p || null != E : null != p) ? a.push(i): l.push(i)
          }
        });
        const c = e => {
          const t = r(e.getColDef()),
            i = s(e.getColDef());
          return null != t ? t : i
        };
        a.sort((e, t) => {
          const i = c(e),
            r = c(t);
          return i === r ? 0 : i < r ? -1 : 1
        });
        const h = [].concat(a);
        return t.forEach(e => {
          l.indexOf(e) >= 0 && h.push(e)
        }), l.forEach(e => {
          h.indexOf(e) < 0 && h.push(e)
        }), t.forEach(e => {
          h.indexOf(e) < 0 && i(e, !1)
        }), h.forEach(e => {
          t.indexOf(e) < 0 && i(e, !0)
        }), h
      }
      extractPivotColumns(e, t) {
        this.pivotColumns = this.extractColumns(t, this.pivotColumns, (t, i) => t.setPivotActive(i, e), e => e.pivotIndex, e => e.initialPivotIndex, e => e.pivot, e => e.initialPivot)
      }
      resetColumnGroupState(e) {
        if (!this.primaryColumnTree) return;
        const t = [];
        ut(null, this.primaryColumnTree, e => {
          if (e instanceof ye) {
            const i = e.getColGroupDef(),
              r = {
                groupId: e.getGroupId(),
                open: i ? i.openByDefault : void 0
              };
            t.push(r)
          }
        }), this.setColumnGroupState(t, e)
      }
      getColumnGroupState() {
        const e = [];
        return ut(null, this.gridBalancedTree, t => {
          t instanceof ye && e.push({
            groupId: t.getGroupId(),
            open: t.isExpanded()
          })
        }), e
      }
      setColumnGroupState(e, t) {
        if (!this.gridBalancedTree) return;
        this.columnAnimationService.start();
        const i = [];
        if (e.forEach(e => {
            const t = e.groupId,
              r = e.open,
              s = this.getProvidedColumnGroup(t);
            s && s.isExpanded() !== r && (this.logger.log("columnGroupOpened(" + s.getGroupId() + "," + r + ")"), s.setExpanded(r), i.push(s))
          }), this.updateGroupsAndDisplayedColumns(t), this.setFirstRightAndLastLeftPinned(t), i.length) {
          const e = {
            type: Et.EVENT_COLUMN_GROUP_OPENED,
            columnGroup: 1 === ye.length ? i[0] : void 0,
            columnGroups: i
          };
          this.eventService.dispatchEvent(e)
        }
        this.columnAnimationService.finish()
      }
      setColumnGroupOpened(e, t, i) {
        let r;
        r = e instanceof ye ? e.getId() : e || "", this.setColumnGroupState([{
          groupId: r,
          open: t
        }], i)
      }
      getProvidedColumnGroup(e) {
        "string" != typeof e && console.error("AG Grid: group key must be a string");
        let t = null;
        return ut(null, this.gridBalancedTree, i => {
          i instanceof ye && i.getId() === e && (t = i)
        }), t
      }
      calculateColumnsForDisplay() {
        let e;
        return e = this.pivotMode && N(this.secondaryColumns) ? this.gridColumns.filter(e => {
          const t = this.groupAutoColumns && Xe(this.groupAutoColumns, e),
            i = this.valueColumns && Xe(this.valueColumns, e);
          return t || i
        }) : this.gridColumns.filter(e => this.groupAutoColumns && Xe(this.groupAutoColumns, e) || e.isVisible()), e
      }
      checkColSpanActiveInCols(e) {
        let t = !1;
        return e.forEach(e => {
          v(e.getColDef().colSpan) && (t = !0)
        }), t
      }
      calculateColumnsForGroupDisplay() {
        this.groupDisplayColumns = [], this.groupDisplayColumnsMap = {};
        this.gridColumns.forEach(e => {
          const t = e.getColDef(),
            i = t.showRowGroup;
          t && v(i) && (this.groupDisplayColumns.push(e), "string" == typeof i ? this.groupDisplayColumnsMap[i] = e : !0 === i && this.getRowGroupColumns().forEach(t => {
            this.groupDisplayColumnsMap[t.getId()] = e
          }))
        })
      }
      getGroupDisplayColumns() {
        return this.groupDisplayColumns
      }
      getGroupDisplayColumnForGroup(e) {
        return this.groupDisplayColumnsMap[e]
      }
      updateDisplayedColumns(e) {
        const t = this.calculateColumnsForDisplay();
        this.buildDisplayedTrees(t), this.updateGroupsAndDisplayedColumns(e), this.setFirstRightAndLastLeftPinned(e)
      }
      isSecondaryColumnsPresent() {
        return v(this.secondaryColumns)
      }
      setSecondaryColumns(e, t) {
        if (!this.gridColumns) return;
        const i = e;
        if (i || !N(this.secondaryColumns)) {
          if (i) {
            this.processSecondaryColumnDefinitions(e);
            const i = this.columnFactory.createColumnTree(e, !1, this.secondaryBalancedTree || this.previousSecondaryColumns || void 0, t);
            this.destroyOldColumns(this.secondaryBalancedTree, i.columnTree), this.secondaryBalancedTree = i.columnTree, this.secondaryHeaderRowCount = i.treeDept + 1, this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree), this.secondaryColumnsMap = {}, this.secondaryColumns.forEach(e => this.secondaryColumnsMap[e.getId()] = e), this.previousSecondaryColumns = null
          } else this.previousSecondaryColumns = this.secondaryBalancedTree, this.secondaryBalancedTree = null, this.secondaryHeaderRowCount = -1, this.secondaryColumns = null, this.secondaryColumnsMap = {};
          this.updateGridColumns(), this.updateDisplayedColumns(t)
        }
      }
      processSecondaryColumnDefinitions(e) {
        const t = this.gos.get("processPivotResultColDef"),
          i = this.gos.get("processPivotResultColGroupDef");
        if (!t && !i) return;
        const r = e => {
          e.forEach(e => {
            if (v(e.children)) {
              const t = e;
              i && i(t), r(t.children)
            } else {
              t && t(e)
            }
          })
        };
        e && r(e)
      }
      updateGridColumns() {
        const e = this.gridBalancedTree;
        this.gridColsArePrimary ? this.lastPrimaryOrder = this.gridColumns : this.lastSecondaryOrder = this.gridColumns;
        if (this.createGroupAutoColumnsIfNeeded()) {
          const e = _t(this.groupAutoColumns.map(e => [e, !0]));
          this.lastPrimaryOrder && (this.lastPrimaryOrder = this.lastPrimaryOrder.filter(t => !e.has(t)), this.lastPrimaryOrder = [...this.groupAutoColumns, ...this.lastPrimaryOrder]), this.lastSecondaryOrder && (this.lastSecondaryOrder = this.lastSecondaryOrder.filter(t => !e.has(t)), this.lastSecondaryOrder = [...this.groupAutoColumns, ...this.lastSecondaryOrder])
        }
        let t;
        if (this.secondaryColumns && this.secondaryBalancedTree) {
          const e = this.secondaryColumns.some(e => void 0 !== this.gridColumnsMap[e.getColId()]);
          this.gridBalancedTree = this.secondaryBalancedTree.slice(), this.gridHeaderRowCount = this.secondaryHeaderRowCount, this.gridColumns = this.secondaryColumns.slice(), this.gridColsArePrimary = !1, e && (t = this.lastSecondaryOrder)
        } else this.primaryColumns && (this.gridBalancedTree = this.primaryColumnTree.slice(), this.gridHeaderRowCount = this.primaryHeaderRowCount, this.gridColumns = this.primaryColumns.slice(), this.gridColsArePrimary = !0, t = this.lastPrimaryOrder);
        if (this.addAutoGroupToGridColumns(), this.orderGridColsLike(t), this.gridColumns = this.placeLockedColumns(this.gridColumns), this.calculateColumnsForGroupDisplay(), this.refreshQuickFilterColumns(), this.clearDisplayedAndViewportColumns(), this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns), this.gridColumnsMap = {}, this.gridColumns.forEach(e => this.gridColumnsMap[e.getId()] = e), this.setAutoHeightActive(), !Fe(e, this.gridBalancedTree)) {
          const e = {
            type: Et.EVENT_GRID_COLUMNS_CHANGED
          };
          this.eventService.dispatchEvent(e)
        }
      }
      setAutoHeightActive() {
        if (this.autoHeightActive = this.gridColumns.filter(e => e.isAutoHeight()).length > 0, this.autoHeightActive) {
          this.autoHeightActiveAtLeastOnce = !0;
          this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide") || z("autoHeight columns only work with Client Side Row Model and Server Side Row Model.")
        }
      }
      orderGridColsLike(e) {
        if (N(e)) return;
        const t = _t(e.map((e, t) => [e, t]));
        let i = !0;
        if (this.gridColumns.forEach(e => {
            t.has(e) && (i = !1)
          }), i) return;
        const r = _t(this.gridColumns.map(e => [e, !0])),
          s = e.filter(e => r.has(e)),
          n = _t(s.map(e => [e, !0])),
          o = this.gridColumns.filter(e => !n.has(e)),
          a = s.slice();
        o.forEach(e => {
          let t = e.getOriginalParent();
          if (!t) return void a.push(e);
          const i = [];
          for (; !i.length && t;) {
            t.getLeafColumns().forEach(e => {
              const t = a.indexOf(e) >= 0,
                r = i.indexOf(e) < 0;
              t && r && i.push(e)
            }), t = t.getOriginalParent()
          }
          if (!i.length) return void a.push(e);
          const r = i.map(e => a.indexOf(e)),
            s = Math.max(...r);
          We(a, e, s + 1)
        }), this.gridColumns = a
      }
      isPrimaryColumnGroupsPresent() {
        return this.primaryHeaderRowCount > 1
      }
      refreshQuickFilterColumns() {
        var e;
        let t = null != (e = this.isPivotMode() && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? this.secondaryColumns : this.primaryColumns) ? e : [];
        this.groupAutoColumns && (t = t.concat(this.groupAutoColumns)), this.columnsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? t : t.filter(e => e.isVisible() || e.isRowGroupActive())
      }
      placeLockedColumns(e) {
        const t = [],
          i = [],
          r = [];
        return e.forEach(e => {
          const s = e.getColDef().lockPosition;
          "right" === s ? r.push(e) : "left" === s || !0 === s ? t.push(e) : i.push(e)
        }), [...t, ...i, ...r]
      }
      addAutoGroupToGridColumns() {
        if (N(this.groupAutoColumns)) return this.destroyOldColumns(this.groupAutoColsBalancedTree), void(this.groupAutoColsBalancedTree = null);
        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
        const e = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
        this.destroyOldColumns(this.groupAutoColsBalancedTree, e), this.groupAutoColsBalancedTree = e, this.gridBalancedTree = e.concat(this.gridBalancedTree)
      }
      clearDisplayedAndViewportColumns() {
        this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.ariaOrderColumns = [], this.viewportColumns = [], this.headerViewportColumns = [], this.viewportColumnsHash = ""
      }
      updateGroupsAndDisplayedColumns(e) {
        this.updateOpenClosedVisibilityInColumnGroups(), this.deriveDisplayedColumns(e), this.refreshFlexedColumns(), this.extractViewport(), this.updateBodyWidths();
        const t = {
          type: Et.EVENT_DISPLAYED_COLUMNS_CHANGED
        };
        this.eventService.dispatchEvent(t)
      }
      deriveDisplayedColumns(e) {
        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight), this.joinColumnsAriaOrder(), this.joinDisplayedColumns(), this.setLeftValues(e), this.displayedAutoHeightCols = this.displayedColumns.filter(e => e.isAutoHeight())
      }
      isAutoRowHeightActive() {
        return this.autoHeightActive
      }
      wasAutoRowHeightEverActive() {
        return this.autoHeightActiveAtLeastOnce
      }
      joinColumnsAriaOrder() {
        const e = this.getAllGridColumns(),
          t = [],
          i = [],
          r = [];
        for (const s of e) {
          const e = s.getPinned();
          e ? !0 === e || "left" === e ? t.push(s) : r.push(s) : i.push(s)
        }
        this.ariaOrderColumns = t.concat(i).concat(r)
      }
      joinDisplayedColumns() {
        this.gos.get("enableRtl") ? this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft) : this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight)
      }
      setLeftValues(e) {
        this.setLeftValuesOfColumns(e), this.setLeftValuesOfGroups()
      }
      setLeftValuesOfColumns(e) {
        if (!this.primaryColumns) return;
        const t = this.getPrimaryAndSecondaryAndAutoColumns().slice(0),
          i = this.gos.get("enableRtl");
        [this.displayedColumnsLeft, this.displayedColumnsRight, this.displayedColumnsCenter].forEach(r => {
          if (i) {
            let t = this.getWidthOfColsInList(r);
            r.forEach(i => {
              t -= i.getActualWidth(), i.setLeft(t, e)
            })
          } else {
            let t = 0;
            r.forEach(i => {
              i.setLeft(t, e), t += i.getActualWidth()
            })
          }
          Be(t, r)
        }), t.forEach(t => {
          t.setLeft(null, e)
        })
      }
      setLeftValuesOfGroups() {
        [this.displayedTreeLeft, this.displayedTreeRight, this.displayedTreeCentre].forEach(e => {
          e.forEach(e => {
            if (e instanceof pt) {
              e.checkLeft()
            }
          })
        })
      }
      derivedDisplayedColumnsFromDisplayedTree(e, t) {
        t.length = 0, bt(e, !0, e => {
          e instanceof Le && t.push(e)
        })
      }
      isColumnVirtualisationSuppressed() {
        return this.suppressColumnVirtualisation || 0 === this.viewportRight
      }
      extractViewportColumns() {
        this.isColumnVirtualisationSuppressed() ? (this.viewportColumnsCenter = this.displayedColumnsCenter, this.headerViewportColumnsCenter = this.displayedColumnsCenter) : (this.viewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this)), this.headerViewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this))), this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight), this.headerViewportColumns = this.headerViewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight)
      }
      getVirtualHeaderGroupRow(e, t) {
        let i;
        switch (e) {
          case "left":
            i = this.viewportRowLeft[t];
            break;
          case "right":
            i = this.viewportRowRight[t];
            break;
          default:
            i = this.viewportRowCenter[t]
        }
        return N(i) && (i = []), i
      }
      calculateHeaderRows() {
        this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {};
        const e = {};
        this.headerViewportColumns.forEach(t => e[t.getId()] = !0);
        const t = (i, r, s) => {
          let n = !1;
          for (let o = 0; o < i.length; o++) {
            const a = i[o];
            let l = !1;
            if (a instanceof Le) l = !0 === e[a.getId()];
            else {
              const e = a.getDisplayedChildren();
              e && (l = t(e, r, s + 1))
            }
            l && (n = !0, r[s] || (r[s] = []), r[s].push(a))
          }
          return n
        };
        t(this.displayedTreeLeft, this.viewportRowLeft, 0), t(this.displayedTreeRight, this.viewportRowRight, 0), t(this.displayedTreeCentre, this.viewportRowCenter, 0)
      }
      extractViewport() {
        this.extractViewportColumns();
        const e = this.viewportColumns.map(e => `${e.getId()}-${e.getPinned()||"normal"}`).join("#"),
          t = this.viewportColumnsHash !== e;
        return t && (this.viewportColumnsHash = e, this.calculateHeaderRows()), t
      }
      refreshFlexedColumns(e = {}) {
        var t;
        const i = e.source ? e.source : "flex";
        if (null != e.viewportWidth && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth) return [];
        let r = -1;
        if (e.resizingCols) {
          const t = new Set(e.resizingCols);
          let i = this.displayedColumnsCenter;
          for (let e = i.length - 1; e >= 0; e--)
            if (t.has(i[e])) {
              r = e;
              break
            }
        }
        let s = 0,
          n = [],
          o = 0,
          a = 0;
        for (let e = 0; e < this.displayedColumnsCenter.length; e++) {
          this.displayedColumnsCenter[e].getFlex() && e > r ? (n.push(this.displayedColumnsCenter[e]), a += this.displayedColumnsCenter[e].getFlex(), o += null != (t = this.displayedColumnsCenter[e].getMinWidth()) ? t : 0) : s += this.displayedColumnsCenter[e].getActualWidth()
        }
        if (!n.length) return [];
        let l = [];
        s + o > this.flexViewportWidth && (n.forEach(e => {
          var t;
          return e.setActualWidth(null != (t = e.getMinWidth()) ? t : 0, i)
        }), l = n, n = []);
        const c = [];
        let h;
        e: for (;;) {
          h = this.flexViewportWidth - s;
          const e = h / a;
          for (let t = 0; t < n.length; t++) {
            const r = n[t],
              o = e * r.getFlex();
            let h = 0;
            const u = r.getMinWidth(),
              d = r.getMaxWidth();
            if (v(u) && o < u ? h = u : v(d) && o > d && (h = d), h) {
              r.setActualWidth(h, i), He(n, r), a -= r.getFlex(), l.push(r), s += r.getActualWidth();
              continue e
            }
            c[t] = Math.round(o)
          }
          break
        }
        let u = h;
        return n.forEach((e, t) => {
          e.setActualWidth(Math.min(c[t], u), i), l.push(e), u -= c[t]
        }), e.skipSetLeft || this.setLeftValues(i), e.updateBodyWidths && this.updateBodyWidths(), e.fireResizedEvent && this.dispatchColumnResizedEvent(l, !0, i, n), n
      }
      sizeColumnsToFit(e, t = "sizeColumnsToFit", i, r) {
        var s, n, o, a, l;
        if (this.shouldQueueResizeOperations) return void this.resizeOperationQueue.push(() => this.sizeColumnsToFit(e, t, i, r));
        const c = {};
        r && (null == (s = null == r ? void 0 : r.columnLimits) || s.forEach(e => {
          var t = e,
            {
              key: i
            } = t,
            r = ((e, t) => {
              var i = {};
              for (var r in e) p.call(e, r) && t.indexOf(r) < 0 && (i[r] = e[r]);
              if (null != e && d)
                for (var r of d(e)) t.indexOf(r) < 0 && E.call(e, r) && (i[r] = e[r]);
              return i
            })(t, ["key"]);
          c["string" == typeof i ? i : i.getColId()] = r
        }));
        const h = this.getAllDisplayedColumns(),
          u = e === this.getWidthOfColsInList(h);
        if (e <= 0 || !h.length || u) return;
        const g = [],
          f = [];
        h.forEach(e => {
          !0 === e.getColDef().suppressSizeToFit ? f.push(e) : g.push(e)
        });
        const T = g.slice(0);
        let m = !1;
        const C = e => {
          ke(g, e), f.push(e)
        };
        for (g.forEach(e => {
            var i, s;
            e.resetActualWidth(t);
            const n = null == c ? void 0 : c[e.getId()],
              o = null != (i = null == n ? void 0 : n.minWidth) ? i : null == r ? void 0 : r.defaultMinWidth,
              a = null != (s = null == n ? void 0 : n.maxWidth) ? s : null == r ? void 0 : r.defaultMaxWidth,
              l = e.getActualWidth();
            "number" == typeof o && l < o ? e.setActualWidth(o, t, !0) : "number" == typeof a && l > a && e.setActualWidth(a, t, !0)
          }); !m;) {
          m = !0;
          const i = e - this.getWidthOfColsInList(f);
          if (i <= 0) g.forEach(e => {
            var i, s;
            const n = null != (s = null == (i = null == c ? void 0 : c[e.getId()]) ? void 0 : i.minWidth) ? s : null == r ? void 0 : r.defaultMinWidth;
            "number" != typeof n ? e.setMinimum(t) : e.setActualWidth(n, t, !0)
          });
          else {
            const e = i / this.getWidthOfColsInList(g);
            let s = i;
            for (let i = g.length - 1; i >= 0; i--) {
              const h = g[i],
                u = null == c ? void 0 : c[h.getId()],
                d = null != (n = null == u ? void 0 : u.minWidth) ? n : null == r ? void 0 : r.defaultMinWidth,
                p = null != (o = null == u ? void 0 : u.maxWidth) ? o : null == r ? void 0 : r.defaultMaxWidth,
                E = null != (a = h.getMinWidth()) ? a : 0,
                f = null != (l = h.getMaxWidth()) ? l : Number.MAX_VALUE,
                T = "number" == typeof d && d > E ? d : h.getMinWidth(),
                S = "number" == typeof p && p < f ? p : h.getMaxWidth();
              let R = Math.round(h.getActualWidth() * e);
              v(T) && R < T ? (R = T, C(h), m = !1) : v(S) && R > S ? (R = S, C(h), m = !1) : 0 === i && (R = s), h.setActualWidth(R, t, !0), s -= R
            }
          }
        }
        T.forEach(e => {
          e.fireColumnWidthChangedEvent(t)
        }), this.setLeftValues(t), this.updateBodyWidths(), i || this.dispatchColumnResizedEvent(T, !0, t)
      }
      buildDisplayedTrees(e) {
        const t = [],
          i = [],
          r = [];
        e.forEach(e => {
          switch (e.getPinned()) {
            case "left":
              t.push(e);
              break;
            case "right":
              i.push(e);
              break;
            default:
              r.push(e)
          }
        });
        const s = new ft;
        this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(t, s, "left", this.displayedTreeLeft), this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(i, s, "right", this.displayedTreeRight), this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(r, s, null, this.displayedTreeCentre), this.updateDisplayedMap()
      }
      updateDisplayedMap() {
        this.displayedColumnsAndGroupsMap = {};
        const e = e => {
          this.displayedColumnsAndGroupsMap[e.getUniqueId()] = e
        };
        bt(this.displayedTreeCentre, !1, e), bt(this.displayedTreeLeft, !1, e), bt(this.displayedTreeRight, !1, e)
      }
      isDisplayed(e) {
        return this.displayedColumnsAndGroupsMap[e.getUniqueId()] === e
      }
      updateOpenClosedVisibilityInColumnGroups() {
        bt(this.getAllDisplayedTrees(), !1, e => {
          e instanceof pt && e.calculateDisplayedColumns()
        })
      }
      getGroupAutoColumns() {
        return this.groupAutoColumns
      }
      createGroupAutoColumnsIfNeeded() {
        const e = this.forceRecreateAutoGroups;
        if (this.forceRecreateAutoGroups = !1, !this.autoGroupsNeedBuilding) return !1;
        this.autoGroupsNeedBuilding = !1;
        const t = this.gos.isGroupUseEntireRow(this.pivotMode),
          i = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isGroupSuppressAutoColumn();
        if ((this.rowGroupColumns.length > 0 || this.gos.get("treeData")) && !i && !t) {
          const t = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);
          if (!this.autoColsEqual(t, this.groupAutoColumns) || e) return this.groupAutoColumns = t, !0
        } else this.groupAutoColumns = null;
        return !1
      }
      isGroupSuppressAutoColumn() {
        if ("custom" === this.gos.get("groupDisplayType")) return !0;
        return "custom" === this.gos.get("treeDataDisplayType")
      }
      autoColsEqual(e, t) {
        return Fe(e, t, (e, t) => e.getColId() === t.getColId())
      }
      getWidthOfColsInList(e) {
        return e.reduce((e, t) => e + t.getActualWidth(), 0)
      }
      getFirstDisplayedColumn() {
        const e = this.gos.get("enableRtl"),
          t = ["getDisplayedLeftColumns", "getDisplayedCenterColumns", "getDisplayedRightColumns"];
        e && t.reverse();
        for (let i = 0; i < t.length; i++) {
          const r = this[t[i]]();
          if (r.length) return e ? Me(r) : r[0]
        }
        return null
      }
      setColumnHeaderHeight(e, t) {
        if (e.setAutoHeaderHeight(t)) {
          const t = {
            type: Et.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
            column: e,
            columns: [e],
            source: "autosizeColumnHeaderHeight"
          };
          this.eventService.dispatchEvent(t)
        }
      }
      getColumnGroupHeaderRowHeight() {
        return this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight()
      }
      getColumnHeaderRowHeight() {
        const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(),
          t = this.getAllDisplayedColumns().filter(e => e.isAutoHeaderHeight()).map(e => e.getAutoHeaderHeight() || 0);
        return Math.max(e, ...t)
      }
      getHeaderHeight() {
        var e;
        return null != (e = this.gos.get("headerHeight")) ? e : this.environment.getFromTheme(25, "headerHeight")
      }
      getFloatingFiltersHeight() {
        var e;
        return null != (e = this.gos.get("floatingFiltersHeight")) ? e : this.getHeaderHeight()
      }
      getGroupHeaderHeight() {
        var e;
        return null != (e = this.gos.get("groupHeaderHeight")) ? e : this.getHeaderHeight()
      }
      getPivotHeaderHeight() {
        var e;
        return null != (e = this.gos.get("pivotHeaderHeight")) ? e : this.getHeaderHeight()
      }
      getPivotGroupHeaderHeight() {
        var e;
        return null != (e = this.gos.get("pivotGroupHeaderHeight")) ? e : this.getGroupHeaderHeight()
      }
      queueResizeOperations() {
        this.shouldQueueResizeOperations = !0
      }
      processResizeOperations() {
        this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach(e => e()), this.resizeOperationQueue = []
      }
      resetColumnDefIntoColumn(e, t) {
        const i = e.getUserProvidedColDef();
        if (!i) return !1;
        const r = this.columnFactory.addColumnDefaultAndTypes(i, e.getColId());
        return e.setColDef(r, i, t), !0
      }
      isColumnGroupingLocked(e) {
        const t = this.gos.get("groupLockGroupColumns");
        if (!e.isRowGroupActive() || 0 === t) return !1;
        if (-1 === t) return !0;
        return t > this.rowGroupColumns.findIndex(t => t.getColId() === e.getColId())
      }
      generateColumnStateForRowGroupAndPivotIndexes(e, t) {
        let i = {};
        const r = (e, t, r, s, n, o) => {
          if (!t.length || !this.primaryColumns) return [];
          const a = Object.keys(e),
            l = new Set(a),
            c = new Set(a),
            h = new Set(t.map(e => {
              const t = e.getColId();
              return c.delete(t), t
            }).concat(a)),
            u = [],
            d = {};
          let p = 0;
          for (let e = 0; e < this.primaryColumns.length; e++) {
            const t = this.primaryColumns[e].getColId();
            h.has(t) && (u.push(t), d[t] = p++)
          }
          let E = 1e3,
            g = !1,
            f = 0;
          const T = t => {
            const i = d[t];
            for (let t = f; t < i; t++) {
              const i = u[t];
              c.has(i) && (e[i][n] = E++, c.delete(i))
            }
            f = i
          };
          t.forEach(t => {
            const a = t.getColId();
            if (l.has(a)) T(a), e[a][n] = E++;
            else {
              const l = t.getColDef();
              if (null === l[n] || void 0 === l[n] && null == l[o]) {
                if (!g) {
                  l[r] || void 0 === l[r] && l[s] ? T(a) : (c.forEach(t => {
                    e[t][n] = E + d[t]
                  }), E += u.length, g = !0)
                }
                i[a] || (i[a] = {
                  colId: a
                }), i[a][n] = E++
              }
            }
          })
        };
        return r(e, this.rowGroupColumns, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex"), r(t, this.pivotColumns, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex"), Object.values(i)
      }
      onColumnsReady() {
        const e = this.gos.get("autoSizeStrategy");
        if (!e) return;
        const {
          type: t
        } = e;
        setTimeout(() => {
          if ("fitGridWidth" === t) {
            const {
              columnLimits: t,
              defaultMinWidth: i,
              defaultMaxWidth: r
            } = e, s = null == t ? void 0 : t.map(({
              colId: e,
              minWidth: t,
              maxWidth: i
            }) => ({
              key: e,
              minWidth: t,
              maxWidth: i
            }));
            this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
              defaultMinWidth: i,
              defaultMaxWidth: r,
              columnLimits: s
            })
          } else "fitProvidedWidth" === t && this.sizeColumnsToFit(e.width, "sizeColumnsToFit")
        })
      }
      onFirstDataRendered() {
        const e = this.gos.get("autoSizeStrategy");
        if ("fitCellContents" !== (null == e ? void 0 : e.type)) return;
        const {
          colIds: t,
          skipHeader: i
        } = e;
        setTimeout(() => {
          t ? this.autoSizeColumns({
            columns: t,
            skipHeader: i,
            source: "autosizeColumns"
          }) : this.autoSizeAllColumns("autosizeColumns", i)
        })
      }
    };

    function Pt(e) {
      return "gridOptionsUpdated" === e ? "gridOptionsChanged" : e
    }

    function bt(e, t, i) {
      if (e)
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          if (s instanceof pt) {
            bt(t ? s.getDisplayedChildren() : s.getChildren(), t, i)
          }
          i(s)
        }
    }
    C([fe("expressionService")], Dt.prototype, "expressionService", 2), C([fe("columnFactory")], Dt.prototype, "columnFactory", 2), C([fe("displayedGroupCreator")], Dt.prototype, "displayedGroupCreator", 2), C([fe("ctrlsService")], Dt.prototype, "ctrlsService", 2), C([fe("autoWidthCalculator")], Dt.prototype, "autoWidthCalculator", 2), C([fe("columnAnimationService")], Dt.prototype, "columnAnimationService", 2), C([fe("autoGroupColService")], Dt.prototype, "autoGroupColService", 2), C([fe("valueCache")], Dt.prototype, "valueCache", 2), C([fe("animationFrameService")], Dt.prototype, "animationFrameService", 2), C([fe("sortController")], Dt.prototype, "sortController", 2), C([fe("columnDefFactory")], Dt.prototype, "columnDefFactory", 2), C([Te("aggFuncService")], Dt.prototype, "aggFuncService", 2), C([pe], Dt.prototype, "init", 1), C([Ee], Dt.prototype, "destroyColumns", 1), C([S(0, Ce("loggerFactory"))], Dt.prototype, "setBeans", 1), Dt = C([ge("columnModel")], Dt);
    var Mt = class extends ct {
      createDisplayedGroups(e, t, i, r) {
        const s = this.mapOldGroupsById(r),
          n = [];
        let o = e;
        for (; o.length;) {
          const e = o;
          o = [];
          let r = 0;
          const a = a => {
            const l = r;
            r = a;
            const c = e[l],
              h = (c instanceof pt ? c.getProvidedColumnGroup() : c).getOriginalParent();
            if (null == h) {
              for (let t = l; t < a; t++) n.push(e[t]);
              return
            }
            const u = this.createColumnGroup(h, t, s, i);
            for (let t = l; t < a; t++) u.addChild(e[t]);
            o.push(u)
          };
          for (let t = 1; t < e.length; t++) {
            const i = e[t],
              s = (i instanceof pt ? i.getProvidedColumnGroup() : i).getOriginalParent(),
              n = e[r];
            s !== (n instanceof pt ? n.getProvidedColumnGroup() : n).getOriginalParent() && a(t)
          }
          r < e.length && a(e.length)
        }
        return this.setupParentsIntoColumns(n, null), n
      }
      createColumnGroup(e, t, i, r) {
        const s = e.getGroupId(),
          n = t.getInstanceIdForKey(s);
        let o = i[pt.createUniqueId(s, n)];
        return o && o.getProvidedColumnGroup() !== e && (o = null), v(o) ? o.reset() : (o = new pt(e, s, n, r), this.context.createBean(o)), o
      }
      mapOldGroupsById(e) {
        const t = {},
          i = e => {
            e.forEach(e => {
              if (e instanceof pt) {
                const r = e;
                t[e.getUniqueId()] = r, i(r.getChildren())
              }
            })
          };
        return e && i(e), t
      }
      setupParentsIntoColumns(e, t) {
        e.forEach(e => {
          if (e.setParent(t), e instanceof pt) {
            const t = e;
            this.setupParentsIntoColumns(t.getChildren(), t)
          }
        })
      }
    };
    Mt = C([ge("displayedGroupCreator")], Mt);
    var Ft = {
        enableBrowserTooltips: !0,
        tooltipTrigger: !0,
        tooltipMouseTrack: !0,
        tooltipShowMode: !0,
        tooltipInteraction: !0,
        defaultColGroupDef: !0,
        suppressAutoSize: !0,
        skipHeaderOnAutoSize: !0,
        autoSizeStrategy: !0,
        components: !0,
        stopEditingWhenCellsLoseFocus: !0,
        undoRedoCellEditing: !0,
        undoRedoCellEditingLimit: !0,
        excelStyles: !0,
        cacheQuickFilter: !0,
        excludeHiddenColumnsFromQuickFilter: !0,
        advancedFilterModel: !0,
        customChartThemes: !0,
        chartThemeOverrides: !0,
        enableChartToolPanelsButton: !0,
        suppressChartToolPanelsButton: !0,
        chartToolPanelsDef: !0,
        loadingCellRendererSelector: !0,
        localeText: !0,
        keepDetailRows: !0,
        keepDetailRowsCount: !0,
        detailRowHeight: !0,
        detailRowAutoHeight: !0,
        tabIndex: !0,
        valueCache: !0,
        valueCacheNeverExpires: !0,
        enableCellExpressions: !0,
        suppressParentsInRowNodes: !0,
        suppressTouch: !0,
        suppressAsyncEvents: !0,
        suppressBrowserResizeObserver: !0,
        suppressPropertyNamesCheck: !0,
        debug: !0,
        loadingOverlayComponent: !0,
        suppressLoadingOverlay: !0,
        noRowsOverlayComponent: !0,
        paginationPageSizeSelector: !0,
        paginateChildRows: !0,
        pivotPanelShow: !0,
        pivotSuppressAutoColumn: !0,
        suppressExpandablePivotGroups: !0,
        aggFuncs: !0,
        suppressAggFuncInHeader: !0,
        suppressAggAtRootLevel: !0,
        removePivotHeaderRowWhenSingleValueColumn: !0,
        allowShowChangeAfterFilter: !0,
        ensureDomOrder: !0,
        enableRtl: !0,
        suppressColumnVirtualisation: !0,
        suppressMaxRenderedRowRestriction: !0,
        suppressRowVirtualisation: !0,
        rowDragText: !0,
        suppressGroupMaintainValueType: !0,
        groupLockGroupColumns: !0,
        rowGroupPanelSuppressSort: !0,
        suppressGroupRowsSticky: !0,
        rowModelType: !0,
        cacheOverflowSize: !0,
        infiniteInitialRowCount: !0,
        serverSideInitialRowCount: !0,
        suppressServerSideInfiniteScroll: !0,
        maxBlocksInCache: !0,
        maxConcurrentDatasourceRequests: !0,
        blockLoadDebounceMillis: !0,
        serverSideOnlyRefreshFilteredGroups: !0,
        serverSidePivotResultFieldSeparator: !0,
        viewportRowModelPageSize: !0,
        viewportRowModelBufferSize: !0,
        debounceVerticalScrollbar: !0,
        suppressAnimationFrame: !0,
        suppressPreventDefaultOnMouseWheel: !0,
        scrollbarWidth: !0,
        icons: !0,
        suppressRowTransform: !0,
        gridId: !0,
        functionsPassive: !0,
        enableGroupEdit: !0,
        initialState: !0,
        processUnpinnedColumns: !0,
        createChartContainer: !0,
        getLocaleText: !0,
        getRowId: !0,
        reactiveCustomComponents: !0,
        columnMenu: !0
      },
      xt = class {};
    xt.STRING_PROPERTIES = ["rowSelection", "overlayLoadingTemplate", "overlayNoRowsTemplate", "gridId", "quickFilterText", "rowModelType", "editType", "domLayout", "clipboardDelimiter", "rowGroupPanelShow", "multiSortKey", "pivotColumnGroupTotals", "pivotRowTotals", "pivotPanelShow", "fillHandleDirection", "groupDisplayType", "treeDataDisplayType", "colResizeDefault", "tooltipTrigger", "serverSidePivotResultFieldSeparator", "columnMenu", "tooltipShowMode", "grandTotalRow"], xt.OBJECT_PROPERTIES = ["components", "rowStyle", "context", "autoGroupColumnDef", "localeText", "icons", "datasource", "serverSideDatasource", "viewportDatasource", "groupRowRendererParams", "aggFuncs", "fullWidthCellRendererParams", "defaultColGroupDef", "defaultColDef", "defaultCsvExportParams", "defaultExcelExportParams", "columnTypes", "rowClassRules", "detailCellRendererParams", "loadingCellRendererParams", "loadingOverlayComponentParams", "noRowsOverlayComponentParams", "popupParent", "statusBar", "sideBar", "chartThemeOverrides", "customChartThemes", "chartToolPanelsDef", "dataTypeDefinitions", "advancedFilterModel", "advancedFilterParent", "advancedFilterBuilderParams", "initialState", "autoSizeStrategy"], xt.ARRAY_PROPERTIES = ["sortingOrder", "alignedGrids", "rowData", "columnDefs", "excelStyles", "pinnedTopRowData", "pinnedBottomRowData", "chartThemes", "rowClass", "paginationPageSizeSelector"], xt.NUMBER_PROPERTIES = ["rowHeight", "detailRowHeight", "rowBuffer", "headerHeight", "groupHeaderHeight", "groupLockGroupColumns", "floatingFiltersHeight", "pivotHeaderHeight", "pivotGroupHeaderHeight", "groupDefaultExpanded", "pivotDefaultExpanded", "viewportRowModelPageSize", "viewportRowModelBufferSize", "autoSizePadding", "maxBlocksInCache", "maxConcurrentDatasourceRequests", "tooltipShowDelay", "tooltipHideDelay", "cacheOverflowSize", "paginationPageSize", "cacheBlockSize", "infiniteInitialRowCount", "serverSideInitialRowCount", "scrollbarWidth", "asyncTransactionWaitMillis", "blockLoadDebounceMillis", "keepDetailRowsCount", "undoRedoCellEditingLimit", "cellFlashDelay", "cellFadeDelay", "cellFlashDuration", "cellFadeDuration", "tabIndex", "pivotMaxGeneratedColumns"], xt.BOOLEAN_PROPERTIES = ["suppressMakeColumnVisibleAfterUnGroup", "suppressRowClickSelection", "suppressCellFocus", "suppressHeaderFocus", "suppressHorizontalScroll", "groupSelectsChildren", "alwaysShowHorizontalScroll", "alwaysShowVerticalScroll", "debug", "enableBrowserTooltips", "enableCellExpressions", "groupIncludeTotalFooter", "groupSuppressBlankHeader", "suppressMenuHide", "suppressRowDeselection", "unSortIcon", "suppressMultiSort", "alwaysMultiSort", "singleClickEdit", "suppressLoadingOverlay", "suppressNoRowsOverlay", "suppressAutoSize", "skipHeaderOnAutoSize", "suppressParentsInRowNodes", "suppressColumnMoveAnimation", "suppressMovableColumns", "suppressFieldDotNotation", "enableRangeSelection", "enableRangeHandle", "enableFillHandle", "suppressClearOnFillReduction", "deltaSort", "suppressTouch", "suppressAsyncEvents", "allowContextMenuWithControlKey", "suppressContextMenu", "enableCellChangeFlash", "suppressDragLeaveHidesColumns", "suppressRowGroupHidesColumns", "suppressMiddleClickScrolls", "suppressPreventDefaultOnMouseWheel", "suppressCopyRowsToClipboard", "copyHeadersToClipboard", "copyGroupHeadersToClipboard", "pivotMode", "suppressAggFuncInHeader", "suppressColumnVirtualisation", "alwaysAggregateAtRootLevel", "suppressAggAtRootLevel", "suppressFocusAfterRefresh", "functionsPassive", "functionsReadOnly", "animateRows", "groupSelectsFiltered", "groupRemoveSingleChildren", "groupRemoveLowestSingleChildren", "enableRtl", "suppressClickEdit", "rowDragEntireRow", "rowDragManaged", "suppressRowDrag", "suppressMoveWhenRowDragging", "rowDragMultiRow", "enableGroupEdit", "embedFullWidthRows", "suppressPaginationPanel", "groupHideOpenParents", "groupAllowUnbalanced", "pagination", "paginationAutoPageSize", "suppressScrollOnNewData", "suppressScrollWhenPopupsAreOpen", "purgeClosedRowNodes", "cacheQuickFilter", "includeHiddenColumnsInQuickFilter", "excludeHiddenColumnsFromQuickFilter", "ensureDomOrder", "accentedSort", "suppressChangeDetection", "valueCache", "valueCacheNeverExpires", "aggregateOnlyChangedColumns", "suppressAnimationFrame", "suppressExcelExport", "suppressCsvExport", "includeHiddenColumnsInAdvancedFilter", "suppressMultiRangeSelection", "enterMovesDown", "enterMovesDownAfterEdit", "enterNavigatesVerticallyAfterEdit", "enterNavigatesVertically", "suppressPropertyNamesCheck", "rowMultiSelectWithClick", "suppressRowHoverHighlight", "suppressRowTransform", "suppressClipboardPaste", "suppressLastEmptyLineOnPaste", "enableCharts", "enableChartToolPanelsButton", "suppressChartToolPanelsButton", "suppressMaintainUnsortedOrder", "enableCellTextSelection", "suppressBrowserResizeObserver", "suppressMaxRenderedRowRestriction", "excludeChildrenWhenTreeDataFiltering", "tooltipMouseTrack", "tooltipInteraction", "keepDetailRows", "paginateChildRows", "preventDefaultOnContextMenu", "undoRedoCellEditing", "allowDragFromColumnsToolPanel", "pivotSuppressAutoColumn", "suppressExpandablePivotGroups", "debounceVerticalScrollbar", "detailRowAutoHeight", "serverSideFilterAllLevels", "serverSideSortAllLevels", "serverSideEnableClientSideSort", "serverSideOnlyRefreshFilteredGroups", "serverSideSortOnServer", "serverSideFilterOnServer", "suppressAggFilteredOnly", "showOpenedGroup", "suppressClipboardApi", "suppressModelUpdateAfterUpdateTransaction", "stopEditingWhenCellsLoseFocus", "maintainColumnOrder", "groupMaintainOrder", "columnHoverHighlight", "readOnlyEdit", "suppressRowVirtualisation", "enableCellEditingOnBackspace", "resetRowDataOnUpdate", "removePivotHeaderRowWhenSingleValueColumn", "suppressCopySingleCellRanges", "suppressGroupRowsSticky", "suppressCutToClipboard", "suppressServerSideInfiniteScroll", "rowGroupPanelSuppressSort", "allowShowChangeAfterFilter", "enableAdvancedFilter", "masterDetail", "treeData", "suppressGroupMaintainValueType", "reactiveCustomComponents", "applyQuickFilterBeforePivotOrAgg", "suppressServerSideFullWidthLoadingRow", "suppressAdvancedFilterEval"], xt.OTHER_PROPERTIES = ["suppressStickyTotalRow"], xt.FUNCTIONAL_PROPERTIES = ["doesExternalFilterPass", "processPivotResultColDef", "processPivotResultColGroupDef", "getBusinessKeyForNode", "isRowSelectable", "rowDragText", "groupRowRenderer", "fullWidthCellRenderer", "loadingCellRenderer", "loadingOverlayComponent", "noRowsOverlayComponent", "detailCellRenderer", "quickFilterParser", "quickFilterMatcher"], xt.CALLBACK_PROPERTIES = ["getLocaleText", "isExternalFilterPresent", "getRowHeight", "getRowClass", "getRowStyle", "getContextMenuItems", "getMainMenuItems", "processRowPostCreate", "processCellForClipboard", "getGroupRowAgg", "isFullWidthRow", "sendToClipboard", "navigateToNextHeader", "tabToNextHeader", "navigateToNextCell", "tabToNextCell", "processCellFromClipboard", "getDocument", "postProcessPopup", "getChildCount", "getDataPath", "isRowMaster", "postSortRows", "processHeaderForClipboard", "processUnpinnedColumns", "processGroupHeaderForClipboard", "paginationNumberFormatter", "processDataFromClipboard", "getServerSideGroupKey", "isServerSideGroup", "createChartContainer", "getChartToolbarItems", "fillOperation", "isApplyServerSideTransaction", "getServerSideGroupLevelParams", "isServerSideGroupOpenByDefault", "isGroupOpenByDefault", "initialGroupOrderComparator", "groupIncludeFooter", "loadingCellRendererSelector", "getRowId", "groupAggFiltering", "chartMenuItems", "groupTotalRow"], xt.FUNCTION_PROPERTIES = [...xt.FUNCTIONAL_PROPERTIES, ...xt.CALLBACK_PROPERTIES], xt.ALL_PROPERTIES = [...xt.ARRAY_PROPERTIES, ...xt.OBJECT_PROPERTIES, ...xt.STRING_PROPERTIES, ...xt.NUMBER_PROPERTIES, ...xt.FUNCTION_PROPERTIES, ...xt.BOOLEAN_PROPERTIES, ...xt.OTHER_PROPERTIES];
    var Gt = xt,
      Ut = class e {
        static getCallbackForEvent(e) {
          return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substring(1)
        }
        static getGridOptionKeys() {
          return this.ALL_PROPERTIES_AND_CALLBACKS
        }
        static combineAttributesAndGridOptions(t, i) {
          "object" != typeof t && (t = {});
          const r = f({}, t);
          return e.getGridOptionKeys().forEach(t => {
            const s = i[t];
            void 0 !== s && s !== e.VUE_OMITTED_PROPERTY && (r[t] = s)
          }), r
        }
        static processOnChange(t, i, r) {
          if (!t) return;
          const s = {};
          let n = !1;
          if (Object.keys(t).filter(t => e.ALL_PROPERTIES_AND_CALLBACKS_SET.has(t)).forEach(e => {
              s[e] = t[e], n = !0
            }), !n) return;
          i.__internalUpdateGridOptions(s, !0);
          const o = {
            type: Et.EVENT_COMPONENT_STATE_CHANGED
          };
          x(s, (e, t) => {
            o[e] = t
          }), i.dispatchEvent(o)
        }
      };
    Ut.EVENTS = P(Et), Ut.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY", Ut.EXCLUDED_INTERNAL_EVENTS = [Et.EVENT_SCROLLBAR_WIDTH_CHANGED, Et.EVENT_CHECKBOX_CHANGED, Et.EVENT_HEIGHT_SCALE_CHANGED, Et.EVENT_BODY_HEIGHT_CHANGED, Et.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, Et.EVENT_SCROLL_VISIBILITY_CHANGED, Et.EVENT_COLUMN_HOVER_CHANGED, Et.EVENT_FLASH_CELLS, Et.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, Et.EVENT_DISPLAYED_ROWS_CHANGED, Et.EVENT_LEFT_PINNED_WIDTH_CHANGED, Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED, Et.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, Et.EVENT_STORE_UPDATED, Et.EVENT_COLUMN_PANEL_ITEM_DRAG_START, Et.EVENT_COLUMN_PANEL_ITEM_DRAG_END, Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, Et.EVENT_FULL_WIDTH_ROW_FOCUSED, Et.EVENT_HEADER_HEIGHT_CHANGED, Et.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, Et.EVENT_CELL_FOCUS_CLEARED, Et.EVENT_GRID_STYLES_CHANGED, Et.EVENT_FILTER_DESTROYED, Et.EVENT_ROW_DATA_UPDATE_STARTED, Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, Et.EVENT_DATA_TYPES_INFERRED, Et.EVENT_FIELD_VALUE_CHANGED, Et.EVENT_FIELD_PICKER_VALUE_SELECTED, Et.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED, Et.EVENT_SUPPRESS_MENU_HIDE_CHANGED, Et.EVENT_SUPPRESS_FIELD_DOT_NOTATION, Et.EVENT_ROW_COUNT_READY, Et.EVENT_SIDE_BAR_UPDATED], Ut.PUBLIC_EVENTS = Ut.EVENTS.filter(e => !Xe(Ut.EXCLUDED_INTERNAL_EVENTS, e)), Ut.EVENT_CALLBACKS = Ut.EVENTS.map(e => Ut.getCallbackForEvent(e)), Ut.BOOLEAN_PROPERTIES = Gt.BOOLEAN_PROPERTIES, Ut.ALL_PROPERTIES = Gt.ALL_PROPERTIES, Ut.ALL_PROPERTIES_AND_CALLBACKS = [...Ut.ALL_PROPERTIES, ...Ut.EVENT_CALLBACKS], Ut.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Ut.ALL_PROPERTIES_AND_CALLBACKS);
    var Ht = Ut,
      kt = class extends ct {
        constructor() {
          super(...arguments), this.componentsMappedByName = {}
        }
        setupComponents(e) {
          e && e.forEach(e => this.addComponent(e))
        }
        addComponent(e) {
          const t = e.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase().toUpperCase();
          this.componentsMappedByName[t] = e.componentClass
        }
        getComponentClass(e) {
          return this.componentsMappedByName[e]
        }
      };
    kt = C([ge("agStackComponentsRegistry")], kt);
    var Bt = {};

    function Vt(e, t, i) {
      null == i || "string" == typeof i && "" == i ? Yt(e, t) : Wt(e, t, i)
    }

    function Wt(e, t, i) {
      e.setAttribute(Kt(t), i.toString())
    }

    function Yt(e, t) {
      e.removeAttribute(Kt(t))
    }

    function Kt(e) {
      return `aria-${e}`
    }

    function Xt(e, t) {
      t ? e.setAttribute("role", t) : e.removeAttribute("role")
    }

    function zt(e) {
      let t;
      return t = "asc" === e ? "ascending" : "desc" === e ? "descending" : "mixed" === e ? "other" : "none", t
    }

    function $t(e) {
      return parseInt(e.getAttribute("aria-level"), 10)
    }

    function jt(e) {
      return parseInt(e.getAttribute("aria-posinset"), 10)
    }

    function Jt(e) {
      return e.getAttribute("aria-label")
    }

    function qt(e, t) {
      Vt(e, "label", t)
    }

    function Qt(e, t) {
      Vt(e, "labelledby", t)
    }

    function Zt(e, t) {
      Vt(e, "describedby", t)
    }

    function ei(e, t) {
      Vt(e, "live", t)
    }

    function ti(e, t) {
      Vt(e, "atomic", t)
    }

    function ii(e, t) {
      Vt(e, "relevant", t)
    }

    function ri(e, t) {
      Vt(e, "level", t)
    }

    function si(e, t) {
      Vt(e, "disabled", t)
    }

    function ni(e, t) {
      Vt(e, "hidden", t)
    }

    function oi(e, t) {
      Vt(e, "activedescendant", t)
    }

    function ai(e, t) {
      Wt(e, "expanded", t)
    }

    function li(e) {
      Yt(e, "expanded")
    }

    function ci(e, t) {
      Wt(e, "setsize", t)
    }

    function hi(e, t) {
      Wt(e, "posinset", t)
    }

    function ui(e, t) {
      Wt(e, "multiselectable", t)
    }

    function di(e, t) {
      Wt(e, "rowcount", t)
    }

    function pi(e, t) {
      Wt(e, "rowindex", t)
    }

    function Ei(e, t) {
      Wt(e, "colcount", t)
    }

    function gi(e, t) {
      Wt(e, "colindex", t)
    }

    function fi(e, t) {
      Wt(e, "colspan", t)
    }

    function Ti(e, t) {
      Wt(e, "sort", t)
    }

    function mi(e) {
      Yt(e, "sort")
    }

    function Ci(e, t) {
      Vt(e, "selected", t)
    }

    function Si(e, t) {
      Wt(e, "checked", void 0 === t ? "mixed" : t)
    }

    function Ri(e, t) {
      Vt(e, "controls", t.id), Qt(t, e.id)
    }

    function Ai(e, t) {
      return void 0 === t ? e("ariaIndeterminate", "indeterminate") : !0 === t ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked")
    }
    m(Bt, {
      getAriaCheckboxStateName: () => Ai,
      getAriaLabel: () => Jt,
      getAriaLevel: () => $t,
      getAriaPosInSet: () => jt,
      getAriaSortState: () => zt,
      removeAriaExpanded: () => li,
      removeAriaSort: () => mi,
      setAriaActiveDescendant: () => oi,
      setAriaAtomic: () => ti,
      setAriaChecked: () => Si,
      setAriaColCount: () => Ei,
      setAriaColIndex: () => gi,
      setAriaColSpan: () => fi,
      setAriaControls: () => Ri,
      setAriaDescribedBy: () => Zt,
      setAriaDisabled: () => si,
      setAriaExpanded: () => ai,
      setAriaHidden: () => ni,
      setAriaLabel: () => qt,
      setAriaLabelledBy: () => Qt,
      setAriaLevel: () => ri,
      setAriaLive: () => ei,
      setAriaMultiSelectable: () => ui,
      setAriaPosInSet: () => hi,
      setAriaRelevant: () => ii,
      setAriaRole: () => Xt,
      setAriaRowCount: () => di,
      setAriaRowIndex: () => pi,
      setAriaSelected: () => Ci,
      setAriaSetSize: () => ci,
      setAriaSort: () => Ti
    });
    var vi, Ni, Ii, Oi, Li, _i, yi, wi, Di = {};

    function Pi() {
      return void 0 === vi && (vi = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), vi
    }

    function bi() {
      if (void 0 === Ni)
        if (Pi()) {
          const e = navigator.userAgent.match(/version\/(\d+)/i);
          e && (Ni = null != e[1] ? parseFloat(e[1]) : 0)
        } else Ni = 0;
      return Ni
    }

    function Mi() {
      if (void 0 === Ii) {
        const e = window;
        Ii = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
      }
      return Ii
    }

    function Fi() {
      return void 0 === Oi && (Oi = /(firefox)/i.test(navigator.userAgent)), Oi
    }

    function xi() {
      return void 0 === Li && (Li = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), Li
    }

    function Gi() {
      return void 0 === _i && (_i = /iPad|iPhone|iPod/.test(navigator.platform) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1), _i
    }

    function Ui() {
      return !Pi() || bi() >= 15
    }

    function Hi(e) {
      if (!e) return null;
      const t = e.tabIndex,
        i = e.getAttribute("tabIndex");
      return -1 !== t || null !== i && ("" !== i || Fi()) ? t.toString() : null
    }

    function ki() {
      if (!document.body) return -1;
      let e = 1e6;
      const t = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9,
        i = document.createElement("div");
      for (document.body.appendChild(i);;) {
        const r = 2 * e;
        if (i.style.height = r + "px", r > t || i.clientHeight !== r) break;
        e = r
      }
      return document.body.removeChild(i), e
    }

    function Bi() {
      var e, t, i;
      return null != (i = null == (e = document.body) ? void 0 : e.clientWidth) ? i : window.innerHeight || (null == (t = document.documentElement) ? void 0 : t.clientWidth) || -1
    }

    function Vi() {
      var e, t, i;
      return null != (i = null == (e = document.body) ? void 0 : e.clientHeight) ? i : window.innerHeight || (null == (t = document.documentElement) ? void 0 : t.clientHeight) || -1
    }

    function Wi() {
      return null == wi && Yi(), wi
    }

    function Yi() {
      const e = document.body,
        t = document.createElement("div");
      t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
      let i = t.offsetWidth - t.clientWidth;
      0 === i && 0 === t.clientWidth && (i = null), t.parentNode && t.parentNode.removeChild(t), null != i && (wi = i, yi = 0 === i)
    }

    function Ki() {
      return null == yi && Yi(), yi
    }
    m(Di, {
      browserSupportsPreventScroll: () => Ui,
      getBodyHeight: () => Vi,
      getBodyWidth: () => Bi,
      getMaxDivHeight: () => ki,
      getSafariVersion: () => bi,
      getScrollbarWidth: () => Wi,
      getTabIndex: () => Hi,
      isBrowserChrome: () => Mi,
      isBrowserFirefox: () => Fi,
      isBrowserSafari: () => Pi,
      isIOSUserAgent: () => Gi,
      isInvisibleScrollbar: () => Ki,
      isMacOsUserAgent: () => xi
    });
    var Xi = {};
    m(Xi, {
      dateToFormattedString: () => rr,
      parseDateTimeFromString: () => sr,
      serialiseDate: () => tr
    });
    var zi = {};

    function $i(e, t) {
      return e.toString().padStart(t, "0")
    }

    function ji(e, t) {
      const i = [];
      for (let r = e; r <= t; r++) i.push(r);
      return i
    }

    function Ji(e) {
      return "string" == typeof e && (e = parseInt(e, 10)), "number" == typeof e ? Math.floor(e) : null
    }

    function qi(e, t) {
      let i = "";
      for (let r = 0; r < t; r++) i += String.fromCharCode(255 & e), e >>>= 8;
      return i
    }

    function Qi(e, t, i) {
      return "number" != typeof e ? "" : Zi(Math.round(100 * e) / 100, t, i)
    }

    function Zi(e, t, i) {
      return "number" != typeof e ? "" : e.toString().replace(".", i).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`)
    }

    function er(e) {
      return null == e ? null : e.reduce((e, t) => e + t, 0)
    }

    function tr(e, t = !0, i = "-") {
      if (!e) return null;
      let r = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map(e => $i(e, 2)).join(i);
      return t && (r += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map(e => $i(e, 2)).join(":")), r
    }
    m(zi, {
      cleanNumber: () => Ji,
      createArrayOfNumbers: () => ji,
      decToHex: () => qi,
      formatNumberCommas: () => Zi,
      formatNumberTwoDecimalPlacesAndCommas: () => Qi,
      padStartWidthZeros: () => $i,
      sum: () => er
    });
    var ir = e => {
      if (e > 3 && e < 21) return "th";
      switch (e % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd"
      }
      return "th"
    };

    function rr(e, t = "YYYY-MM-DD") {
      const i = $i(e.getFullYear(), 4),
        r = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        s = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        n = {
          YYYY: () => i.slice(i.length - 4, i.length),
          YY: () => i.slice(i.length - 2, i.length),
          Y: () => `${e.getFullYear()}`,
          MMMM: () => r[e.getMonth()],
          MMM: () => r[e.getMonth()].slice(0, 3),
          MM: () => $i(e.getMonth() + 1, 2),
          Mo: () => `${e.getMonth()+1}${ir(e.getMonth()+1)}`,
          M: () => `${e.getMonth()+1}`,
          Do: () => `${e.getDate()}${ir(e.getDate())}`,
          DD: () => $i(e.getDate(), 2),
          D: () => `${e.getDate()}`,
          dddd: () => s[e.getDay()],
          ddd: () => s[e.getDay()].slice(0, 3),
          dd: () => s[e.getDay()].slice(0, 2),
          do: () => `${e.getDay()}${ir(e.getDay())}`,
          d: () => `${e.getDay()}`
        },
        o = new RegExp(Object.keys(n).join("|"), "g");
      return t.replace(o, e => e in n ? n[e]() : e)
    }

    function sr(e) {
      if (!e) return null;
      const [t, i] = e.split(" ");
      if (!t) return null;
      const r = t.split("-").map(e => parseInt(e, 10));
      if (3 !== r.filter(e => !isNaN(e)).length) return null;
      const [s, n, o] = r, a = new Date(s, n - 1, o);
      if (a.getFullYear() !== s || a.getMonth() !== n - 1 || a.getDate() !== o) return null;
      if (!i || "00:00:00" === i) return a;
      const [l, c, h] = i.split(":").map(e => parseInt(e, 10));
      return l >= 0 && l < 24 && a.setHours(l), c >= 0 && c < 60 && a.setMinutes(c), h >= 0 && h < 60 && a.setSeconds(h), a
    }
    var nr, or = {};

    function ar(e, t, i) {
      const r = e.parentElement;
      let s = r && r.firstChild;
      for (; s;) t && s.classList.toggle(t, s === e), i && s.classList.toggle(i, s !== e), s = s.nextSibling
    }
    m(or, {
      FOCUSABLE_EXCLUDE: () => cr,
      FOCUSABLE_SELECTOR: () => lr,
      addOrRemoveAttribute: () => Wr,
      addStylesToElement: () => Pr,
      bindCellRendererToHtmlElement: () => Kr,
      clearElement: () => Nr,
      copyNodeList: () => Br,
      ensureDomOrder: () => yr,
      formatSize: () => Hr,
      getAbsoluteHeight: () => mr,
      getAbsoluteWidth: () => Cr,
      getElementRectWithOffset: () => Sr,
      getElementSize: () => gr,
      getInnerHeight: () => fr,
      getInnerWidth: () => Tr,
      getScrollLeft: () => Ar,
      insertWithDomOrder: () => Dr,
      isElementChildOfClass: () => Er,
      isFocusableFormField: () => hr,
      isHorizontalScrollShowing: () => br,
      isInDOM: () => Or,
      isNodeOrElement: () => kr,
      isRtlNegativeScroll: () => Rr,
      isVerticalScrollShowing: () => Mr,
      isVisible: () => Lr,
      iterateNamedNodeMap: () => Vr,
      loadTemplate: () => _r,
      nodeListForEach: () => Yr,
      radioCssClass: () => ar,
      removeFromParent: () => Ir,
      setDisabled: () => pr,
      setDisplayed: () => ur,
      setDomChildOrder: () => wr,
      setElementHeight: () => Gr,
      setElementWidth: () => Fr,
      setFixedHeight: () => Ur,
      setFixedWidth: () => xr,
      setScrollLeft: () => vr,
      setVisible: () => dr
    });
    var lr = "[tabindex], input, select, button, textarea, [href]",
      cr = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";

    function hr(e) {
      const t = Element.prototype.matches || Element.prototype.msMatchesSelector,
        i = t.call(e, "input, select, button, textarea"),
        r = t.call(e, cr),
        s = Lr(e);
      return i && !r && s
    }

    function ur(e, t, i = {}) {
      const {
        skipAriaHidden: r
      } = i;
      e.classList.toggle("ag-hidden", !t), r || ni(e, !t)
    }

    function dr(e, t, i = {}) {
      const {
        skipAriaHidden: r
      } = i;
      e.classList.toggle("ag-invisible", !t), r || ni(e, !t)
    }

    function pr(e, t) {
      const i = "disabled",
        r = t ? e => e.setAttribute(i, "") : e => e.removeAttribute(i);
      r(e), Yr(e.querySelectorAll("input"), e => r(e))
    }

    function Er(e, t, i) {
      let r = 0;
      for (; e;) {
        if (e.classList.contains(t)) return !0;
        if (e = e.parentElement, "number" == typeof i) {
          if (++r > i) break
        } else if (e === i) break
      }
      return !1
    }

    function gr(e) {
      const {
        height: t,
        width: i,
        borderTopWidth: r,
        borderRightWidth: s,
        borderBottomWidth: n,
        borderLeftWidth: o,
        paddingTop: a,
        paddingRight: l,
        paddingBottom: c,
        paddingLeft: h,
        marginTop: u,
        marginRight: d,
        marginBottom: p,
        marginLeft: E,
        boxSizing: g
      } = window.getComputedStyle(e);
      return {
        height: parseFloat(t || "0"),
        width: parseFloat(i || "0"),
        borderTopWidth: parseFloat(r || "0"),
        borderRightWidth: parseFloat(s || "0"),
        borderBottomWidth: parseFloat(n || "0"),
        borderLeftWidth: parseFloat(o || "0"),
        paddingTop: parseFloat(a || "0"),
        paddingRight: parseFloat(l || "0"),
        paddingBottom: parseFloat(c || "0"),
        paddingLeft: parseFloat(h || "0"),
        marginTop: parseFloat(u || "0"),
        marginRight: parseFloat(d || "0"),
        marginBottom: parseFloat(p || "0"),
        marginLeft: parseFloat(E || "0"),
        boxSizing: g
      }
    }

    function fr(e) {
      const t = gr(e);
      return "border-box" === t.boxSizing ? t.height - t.paddingTop - t.paddingBottom : t.height
    }

    function Tr(e) {
      const t = gr(e);
      return "border-box" === t.boxSizing ? t.width - t.paddingLeft - t.paddingRight : t.width
    }

    function mr(e) {
      const t = gr(e),
        i = t.marginBottom + t.marginTop;
      return Math.ceil(e.offsetHeight + i)
    }

    function Cr(e) {
      const t = gr(e),
        i = t.marginLeft + t.marginRight;
      return Math.ceil(e.offsetWidth + i)
    }

    function Sr(e) {
      const t = e.getBoundingClientRect(),
        {
          borderTopWidth: i,
          borderLeftWidth: r,
          borderRightWidth: s,
          borderBottomWidth: n
        } = gr(e);
      return {
        top: t.top + (i || 0),
        left: t.left + (r || 0),
        right: t.right + (s || 0),
        bottom: t.bottom + (n || 0)
      }
    }

    function Rr() {
      if ("boolean" == typeof nr) return nr;
      const e = document.createElement("div");
      return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = '<div style="width: 2px">\n            <span style="display: inline-block; width: 1px"></span>\n            <span style="display: inline-block; width: 1px"></span>\n        </div>', document.body.appendChild(e), e.scrollLeft = 1, nr = 0 === Math.floor(e.scrollLeft), document.body.removeChild(e), nr
    }

    function Ar(e, t) {
      let i = e.scrollLeft;
      return t && (i = Math.abs(i), Mi() && !Rr() && (i = e.scrollWidth - e.clientWidth - i)), i
    }

    function vr(e, t, i) {
      i && (Rr() ? t *= -1 : (Pi() || Mi()) && (t = e.scrollWidth - e.clientWidth - t)), e.scrollLeft = t
    }

    function Nr(e) {
      for (; e && e.firstChild;) e.removeChild(e.firstChild)
    }

    function Ir(e) {
      e && e.parentNode && e.parentNode.removeChild(e)
    }

    function Or(e) {
      return !!e.offsetParent
    }

    function Lr(e) {
      const t = e;
      if (t.checkVisibility) return t.checkVisibility({
        checkVisibilityCSS: !0
      });
      return !(!Or(e) || "visible" !== window.getComputedStyle(e).visibility)
    }

    function _r(e) {
      const t = document.createElement("div");
      return t.innerHTML = (e || "").trim(), t.firstChild
    }

    function yr(e, t, i) {
      i && i.nextSibling === t || (i ? i.nextSibling ? e.insertBefore(t, i.nextSibling) : e.appendChild(t) : e.firstChild && e.firstChild !== t && e.insertAdjacentElement("afterbegin", t))
    }

    function wr(e, t) {
      for (let i = 0; i < t.length; i++) {
        const r = t[i],
          s = e.children[i];
        s !== r && e.insertBefore(r, s)
      }
    }

    function Dr(e, t, i) {
      i ? i.insertAdjacentElement("afterend", t) : e.firstChild ? e.insertAdjacentElement("afterbegin", t) : e.appendChild(t)
    }

    function Pr(e, t) {
      if (t)
        for (const [i, r] of Object.entries(t)) {
          if (!i || !i.length || null == r) continue;
          const t = Ot(i),
            s = r.toString(),
            n = s.replace(/\s*!important/g, ""),
            o = n.length != s.length ? "important" : void 0;
          e.style.setProperty(t, n, o)
        }
    }

    function br(e) {
      return e.clientWidth < e.scrollWidth
    }

    function Mr(e) {
      return e.clientHeight < e.scrollHeight
    }

    function Fr(e, t) {
      "flex" === t ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : xr(e, t)
    }

    function xr(e, t) {
      t = Hr(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString()
    }

    function Gr(e, t) {
      "flex" === t ? (e.style.removeProperty("height"), e.style.removeProperty("minHeight"), e.style.removeProperty("maxHeight"), e.style.flex = "1 1 auto") : Ur(e, t)
    }

    function Ur(e, t) {
      t = Hr(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString()
    }

    function Hr(e) {
      return "number" == typeof e ? `${e}px` : e
    }

    function kr(e) {
      return e instanceof Node || e instanceof HTMLElement
    }

    function Br(e) {
      if (null == e) return [];
      const t = [];
      return Yr(e, e => t.push(e)), t
    }

    function Vr(e, t) {
      if (e)
        for (let i = 0; i < e.length; i++) {
          const r = e[i];
          t(r.name, r.value)
        }
    }

    function Wr(e, t, i) {
      null == i ? e.removeAttribute(t) : e.setAttribute(t, i.toString())
    }

    function Yr(e, t) {
      if (null != e)
        for (let i = 0; i < e.length; i++) t(e[i])
    }

    function Kr(e, t) {
      e.then(e => {
        const i = e.getGui();
        null != i && ("object" == typeof i ? t.appendChild(i) : t.innerHTML = i)
      })
    }
    var Xr = {};

    function zr(e, t, i) {
      const r = {},
        s = e.filter(e => !t.some(t => t === e));
      return s.length > 0 && s.forEach(e => r[e] = $r(e, i).values), r
    }

    function $r(e, t, i, r) {
      let s = t.map((t, i) => ({
        value: t,
        relevance: jr(e.toLowerCase(), t.toLocaleLowerCase()),
        idx: i
      }));
      if (s.sort((e, t) => t.relevance - e.relevance), i && (s = s.filter(e => 0 !== e.relevance)), s.length > 0 && r && r > 0) {
        const e = s[0].relevance * r;
        s = s.filter(t => e - t.relevance < 0)
      }
      const n = [],
        o = [];
      for (const e of s) n.push(e.value), o.push(e.idx);
      return {
        values: n,
        indices: o
      }
    }

    function jr(e, t) {
      const i = e.replace(/\s/g, ""),
        r = t.replace(/\s/g, "");
      let s = 0,
        n = -1;
      for (let e = 0; e < i.length; e++) {
        const t = r.indexOf(i[e], n + 1); - 1 !== t && (n = t, s += 100 - 100 * n / 1e4 * 100)
      }
      return s
    }
    m(Xr, {
      fuzzyCheckStrings: () => zr,
      fuzzySuggestions: () => $r
    });
    var Jr = {};
    m(Jr, {
      createIcon: () => Qr,
      createIconNoSpan: () => Zr,
      iconNameClassMap: () => qr
    });
    var qr = {
      columnGroupOpened: "expanded",
      columnGroupClosed: "contracted",
      columnSelectClosed: "tree-closed",
      columnSelectOpen: "tree-open",
      columnSelectIndeterminate: "tree-indeterminate",
      columnMovePin: "pin",
      columnMoveHide: "eye-slash",
      columnMoveMove: "arrows",
      columnMoveLeft: "left",
      columnMoveRight: "right",
      columnMoveGroup: "group",
      columnMoveValue: "aggregation",
      columnMovePivot: "pivot",
      dropNotAllowed: "not-allowed",
      groupContracted: "tree-closed",
      groupExpanded: "tree-open",
      setFilterGroupClosed: "tree-closed",
      setFilterGroupOpen: "tree-open",
      setFilterGroupIndeterminate: "tree-indeterminate",
      chart: "chart",
      close: "cross",
      cancel: "cancel",
      check: "tick",
      first: "first",
      previous: "previous",
      next: "next",
      last: "last",
      linked: "linked",
      unlinked: "unlinked",
      colorPicker: "color-picker",
      groupLoading: "loading",
      menu: "menu",
      menuAlt: "menu-alt",
      filter: "filter",
      columns: "columns",
      maximize: "maximize",
      minimize: "minimize",
      menuPin: "pin",
      menuValue: "aggregation",
      menuAddRowGroup: "group",
      menuRemoveRowGroup: "group",
      clipboardCopy: "copy",
      clipboardCut: "cut",
      clipboardPaste: "paste",
      pivotPanel: "pivot",
      rowGroupPanel: "group",
      valuePanel: "aggregation",
      columnDrag: "grip",
      rowDrag: "grip",
      save: "save",
      csvExport: "csv",
      excelExport: "excel",
      smallDown: "small-down",
      smallLeft: "small-left",
      smallRight: "small-right",
      smallUp: "small-up",
      sortAscending: "asc",
      sortDescending: "desc",
      sortUnSort: "none",
      advancedFilterBuilder: "group",
      advancedFilterBuilderDrag: "grip",
      advancedFilterBuilderInvalid: "not-allowed",
      advancedFilterBuilderMoveUp: "up",
      advancedFilterBuilderMoveDown: "down",
      advancedFilterBuilderAdd: "plus",
      advancedFilterBuilderRemove: "minus",
      chartsMenuEdit: "chart",
      chartsMenuAdvancedSettings: "settings",
      chartsMenuAdd: "plus"
    };

    function Qr(e, t, i) {
      const r = Zr(e, t, i);
      if (r) {
        const {
          className: e
        } = r;
        if ("string" == typeof e && e.indexOf("ag-icon") > -1 || "object" == typeof e && e["ag-icon"]) return r
      }
      const s = document.createElement("span");
      return s.appendChild(r), s
    }

    function Zr(e, t, i, r) {
      let s = null;
      const n = i && i.getColDef().icons;
      if (n && (s = n[e]), t && !s) {
        const i = t.get("icons");
        i && (s = i[e])
      }
      if (!s) {
        const t = document.createElement("span");
        let i = qr[e];
        return i || (r ? i = e : (console.warn(`AG Grid: Did not find icon ${e}`), i = "")), t.setAttribute("class", `ag-icon ag-icon-${i}`), t.setAttribute("unselectable", "on"), Xt(t, "presentation"), t
      } {
        let e;
        if ("function" == typeof s) e = s();
        else {
          if ("string" != typeof s) throw new Error("icon from grid options needs to be a string or a function");
          e = s
        }
        if ("string" == typeof e) return _r(e);
        if (kr(e)) return e;
        console.warn("AG Grid: iconRenderer should return back a string or a dom object")
      }
    }
    var es = {};
    m(es, {
      isDeleteKey: () => ds,
      isEventFromPrintableCharacter: () => ls,
      isUserSuppressingHeaderKeyboardEvent: () => hs,
      isUserSuppressingKeyboardEvent: () => cs,
      normaliseQwertyAzerty: () => us
    });
    var ts = class {};
    ts.BACKSPACE = "Backspace", ts.TAB = "Tab", ts.ENTER = "Enter", ts.ESCAPE = "Escape", ts.SPACE = " ", ts.LEFT = "ArrowLeft", ts.UP = "ArrowUp", ts.RIGHT = "ArrowRight", ts.DOWN = "ArrowDown", ts.DELETE = "Delete", ts.F2 = "F2", ts.PAGE_UP = "PageUp", ts.PAGE_DOWN = "PageDown", ts.PAGE_HOME = "Home", ts.PAGE_END = "End", ts.A = "KeyA", ts.C = "KeyC", ts.D = "KeyD", ts.V = "KeyV", ts.X = "KeyX", ts.Y = "KeyY", ts.Z = "KeyZ";
    var is = 65,
      rs = 67,
      ss = 86,
      ns = 68,
      os = 90,
      as = 89;

    function ls(e) {
      if (e.altKey || e.ctrlKey || e.metaKey) return !1;
      return 1 === e.key.length
    }

    function cs(e, t, i, r, s) {
      const n = r ? r.getColDef().suppressKeyboardEvent : void 0;
      if (!n) return !1;
      const o = e.addGridCommonParams({
        event: t,
        editing: s,
        column: r,
        node: i,
        data: i.data,
        colDef: r.getColDef()
      });
      if (n) {
        if (n(o)) return !0
      }
      return !1
    }

    function hs(e, t, i, r) {
      const s = r.getDefinition(),
        n = s && s.suppressHeaderKeyboardEvent;
      if (!v(n)) return !1;
      return !!n(e.addGridCommonParams({
        colDef: s,
        column: r,
        headerRowIndex: i,
        event: t
      }))
    }

    function us(e) {
      const {
        keyCode: t
      } = e;
      let i;
      switch (t) {
        case is:
          i = ts.A;
          break;
        case rs:
          i = ts.C;
          break;
        case ss:
          i = ts.V;
          break;
        case ns:
          i = ts.D;
          break;
        case os:
          i = ts.Z;
          break;
        case as:
          i = ts.Y;
          break;
        default:
          i = e.code
      }
      return i
    }

    function ds(e, t = !1) {
      return e === ts.DELETE || !t && e === ts.BACKSPACE && xi()
    }
    var ps = {};

    function Es(e, t, i) {
      if (0 === i) return !1;
      const r = Math.abs(e.clientX - t.clientX),
        s = Math.abs(e.clientY - t.clientY);
      return Math.max(r, s) <= i
    }
    m(ps, {
      areEventsNear: () => Es
    });
    var gs = {};

    function fs(e, t) {
      if (!e) return !1;
      const i = (e, i) => {
        const r = t[e.id],
          s = t[i.id],
          n = void 0 !== r,
          o = void 0 !== s;
        return n && o ? r - s : !n && !o ? e.__objectId - i.__objectId : n ? 1 : -1
      };
      let r, s, n = !1;
      for (let t = 0; t < e.length - 1; t++)
        if (r = e[t], s = e[t + 1], i(r, s) > 0) {
          n = !0;
          break
        } return !!n && (e.sort(i), !0)
    }
    m(gs, {
      sortRowNodesByOrder: () => fs
    });
    var Ts = {};

    function ms(e) {
      const t = new Set;
      return e.forEach(e => t.add(e)), t
    }
    m(Ts, {
      convertToSet: () => ms
    });
    var Cs = f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f({}, Bt), Pe), Di), Xi), or), De), Y), Xr), R), Jr), es), Lt), ps), zi), M), gs), Ts), Ct),
      Ss = class {
        constructor(e = 0, t = 1) {
          this.nextValue = e, this.step = t
        }
        next() {
          const e = this.nextValue;
          return this.nextValue += this.step, e
        }
        peek() {
          return this.nextValue
        }
        skip(e) {
          this.nextValue += e
        }
      },
      Rs = class e {
        constructor(e) {
          this.status = 0, this.resolution = null, this.waiters = [], e(e => this.onDone(e), e => this.onReject(e))
        }
        static all(t) {
          return new e(e => {
            let i = t.length;
            const r = new Array(i);
            t.forEach((t, s) => {
              t.then(t => {
                r[s] = t, i--, 0 === i && e(r)
              })
            })
          })
        }
        static resolve(t = null) {
          return new e(e => e(t))
        }
        then(t) {
          return new e(e => {
            1 === this.status ? e(t(this.resolution)) : this.waiters.push(i => e(t(i)))
          })
        }
        resolveNow(e, t) {
          return 1 === this.status ? t(this.resolution) : e
        }
        onDone(e) {
          this.status = 1, this.resolution = e, this.waiters.forEach(t => t(e))
        }
        onReject(e) {
          console.warn("TBI")
        }
      },
      As = class {
        constructor(e) {
          this.cssClassStates = {}, this.getGui = e
        }
        addCssClass(e) {
          const t = (e || "").split(" ");
          if (t.length > 1) return void t.forEach(e => this.addCssClass(e));
          if (!0 !== this.cssClassStates[e] && e.length) {
            const t = this.getGui();
            t && t.classList.add(e), this.cssClassStates[e] = !0
          }
        }
        removeCssClass(e) {
          const t = (e || "").split(" ");
          if (t.length > 1) return void t.forEach(e => this.removeCssClass(e));
          if (!1 !== this.cssClassStates[e] && e.length) {
            const t = this.getGui();
            t && t.classList.remove(e), this.cssClassStates[e] = !1
          }
        }
        containsCssClass(e) {
          const t = this.getGui();
          return !!t && t.classList.contains(e)
        }
        addOrRemoveCssClass(e, t) {
          if (!e) return;
          if (e.indexOf(" ") >= 0) {
            const i = (e || "").split(" ");
            if (i.length > 1) return void i.forEach(e => this.addOrRemoveCssClass(e, t))
          }
          if (this.cssClassStates[e] !== t && e.length) {
            const i = this.getGui();
            i && i.classList.toggle(e, t), this.cssClassStates[e] = t
          }
        }
      },
      vs = class e extends ct {
        constructor(e, t, i, r) {
          super(), this.parentComp = e, this.tooltipShowDelayOverride = t, this.tooltipHideDelayOverride = i, this.shouldDisplayTooltip = r, this.SHOW_QUICK_TOOLTIP_DIFF = 1e3, this.FADE_OUT_TOOLTIP_TIMEOUT = 1e3, this.INTERACTIVE_HIDE_DELAY = 100, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1
        }
        postConstruct() {
          this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
          const e = this.parentComp.getGui();
          0 === this.tooltipTrigger && (this.addManagedListener(e, "mouseenter", this.onMouseEnter.bind(this)), this.addManagedListener(e, "mouseleave", this.onMouseLeave.bind(this))), 1 === this.tooltipTrigger && (this.addManagedListener(e, "focusin", this.onFocusIn.bind(this)), this.addManagedListener(e, "focusout", this.onFocusOut.bind(this))), this.addManagedListener(e, "mousemove", this.onMouseMove.bind(this)), this.interactionEnabled || (this.addManagedListener(e, "mousedown", this.onMouseDown.bind(this)), this.addManagedListener(e, "keydown", this.onKeyDown.bind(this)))
        }
        getGridOptionsTooltipDelay(e) {
          const t = this.gos.get(e);
          return t < 0 && z(`${e} should not be lower than 0`), Math.max(200, t)
        }
        getTooltipDelay(e) {
          var t, i;
          return "show" === e ? null != (t = this.tooltipShowDelayOverride) ? t : this.getGridOptionsTooltipDelay("tooltipShowDelay") : null != (i = this.tooltipHideDelayOverride) ? i : this.getGridOptionsTooltipDelay("tooltipHideDelay")
        }
        destroy() {
          this.setToDoNothing(), super.destroy()
        }
        getTooltipTrigger() {
          const e = this.gos.get("tooltipTrigger");
          return e && "hover" !== e ? 1 : 0
        }
        onMouseEnter(t) {
          this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), Gi() || (e.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
            this.prepareToShowTooltip(t)
          }, this.INTERACTIVE_HIDE_DELAY) : this.prepareToShowTooltip(t))
        }
        onMouseMove(e) {
          this.lastMouseEvent && (this.lastMouseEvent = e), this.tooltipMouseTrack && 2 === this.state && this.tooltipComp && this.positionTooltip()
        }
        onMouseDown() {
          this.setToDoNothing()
        }
        onMouseLeave() {
          this.interactionEnabled ? this.lockService() : this.setToDoNothing()
        }
        onFocusIn() {
          this.prepareToShowTooltip()
        }
        onFocusOut(e) {
          var t;
          const i = e.relatedTarget,
            r = this.parentComp.getGui(),
            s = null == (t = this.tooltipComp) ? void 0 : t.getGui();
          this.isInteractingWithTooltip || r.contains(i) || this.interactionEnabled && (null == s ? void 0 : s.contains(i)) || this.setToDoNothing()
        }
        onKeyDown() {
          this.setToDoNothing()
        }
        prepareToShowTooltip(t) {
          if (0 != this.state || e.isLocked) return;
          let i = 0;
          t && (i = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), i), this.state = 1
        }
        isLastTooltipHiddenRecently() {
          return (new Date).getTime() - e.lastTooltipHideTime < this.SHOW_QUICK_TOOLTIP_DIFF
        }
        setToDoNothing() {
          2 === this.state && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null
        }
        showTooltip() {
          const e = f({}, this.parentComp.getTooltipParams());
          if (!v(e.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) return void this.setToDoNothing();
          this.state = 2, this.tooltipInstanceCount++;
          const t = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
          this.userComponentFactory.getTooltipCompDetails(e).newAgStackInstance().then(t)
        }
        hideTooltip(t) {
          if (!t && this.isInteractingWithTooltip) return;
          this.tooltipComp && (this.destroyTooltipComp(), e.lastTooltipHideTime = (new Date).getTime());
          const i = {
            type: Et.EVENT_TOOLTIP_HIDE,
            parentGui: this.parentComp.getGui()
          };
          this.eventService.dispatchEvent(i), this.state = 0
        }
        newTooltipComponentCallback(e, t) {
          if (2 !== this.state || this.tooltipInstanceCount !== e) return void this.getContext().destroyBean(t);
          const i = t.getGui();
          this.tooltipComp = t, i.classList.contains("ag-tooltip") || i.classList.add("ag-tooltip-custom"), 0 === this.tooltipTrigger && i.classList.add("ag-tooltip-animate"), this.interactionEnabled && i.classList.add("ag-tooltip-interactive");
          const r = this.localeService.getLocaleTextFunc(),
            s = this.popupService.addPopup({
              eChild: i,
              ariaLabel: r("ariaLabelTooltip", "Tooltip")
            });
          s && (this.tooltipPopupDestroyFunc = s.hideFunc), this.positionTooltip(), 1 === this.tooltipTrigger && (this.onBodyScrollEventCallback = this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL, this.setToDoNothing.bind(this)), this.onColumnMovedEventCallback = this.addManagedListener(this.eventService, Et.EVENT_COLUMN_MOVED, this.setToDoNothing.bind(this))), this.interactionEnabled && (0 === this.tooltipTrigger ? (this.tooltipMouseEnterListener = this.addManagedListener(i, "mouseenter", this.onTooltipMouseEnter.bind(this)) || null, this.tooltipMouseLeaveListener = this.addManagedListener(i, "mouseleave", this.onTooltipMouseLeave.bind(this)) || null) : (this.tooltipFocusInListener = this.addManagedListener(i, "focusin", this.onTooltipFocusIn.bind(this)) || null, this.tooltipFocusOutListener = this.addManagedListener(i, "focusout", this.onTooltipFocusOut.bind(this)) || null));
          const n = {
            type: Et.EVENT_TOOLTIP_SHOW,
            tooltipGui: i,
            parentGui: this.parentComp.getGui()
          };
          this.eventService.dispatchEvent(n), this.startHideTimeout()
        }
        onTooltipMouseEnter() {
          this.isInteractingWithTooltip = !0, this.unlockService()
        }
        onTooltipMouseLeave() {
          this.isInteractingWithTooltip = !1, this.lockService()
        }
        onTooltipFocusIn() {
          this.isInteractingWithTooltip = !0
        }
        onTooltipFocusOut(e) {
          var t;
          const i = this.parentComp.getGui(),
            r = null == (t = this.tooltipComp) ? void 0 : t.getGui(),
            s = e.relatedTarget;
          (null == r ? void 0 : r.contains(s)) || (this.isInteractingWithTooltip = !1, i.contains(s) ? this.startHideTimeout() : this.hideTooltip())
        }
        positionTooltip() {
          const e = {
            type: "tooltip",
            ePopup: this.tooltipComp.getGui(),
            nudgeY: 18,
            skipObserver: this.tooltipMouseTrack
          };
          this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent(T(f({}, e), {
            mouseEvent: this.lastMouseEvent
          })) : this.popupService.positionPopupByComponent(T(f({}, e), {
            eventSource: this.parentComp.getGui(),
            position: "under",
            keepWithinBounds: !0,
            nudgeY: 5
          }))
        }
        destroyTooltipComp() {
          this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
          const e = this.tooltipPopupDestroyFunc,
            t = this.tooltipComp,
            i = 0 === this.tooltipTrigger ? this.FADE_OUT_TOOLTIP_TIMEOUT : 0;
          window.setTimeout(() => {
            e(), this.getContext().destroyBean(t)
          }, i), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0
        }
        clearTooltipListeners() {
          [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener, this.tooltipFocusInListener, this.tooltipFocusOutListener].forEach(e => {
            e && e()
          }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null
        }
        lockService() {
          e.isLocked = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
            this.unlockService(), this.setToDoNothing()
          }, this.INTERACTIVE_HIDE_DELAY)
        }
        unlockService() {
          e.isLocked = !1, this.clearInteractiveTimeout()
        }
        startHideTimeout() {
          this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"))
        }
        clearShowTimeout() {
          this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0)
        }
        clearHideTimeout() {
          this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0)
        }
        clearInteractiveTimeout() {
          this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0)
        }
        clearTimeouts() {
          this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout()
        }
      };
    vs.isLocked = !1, C([fe("popupService")], vs.prototype, "popupService", 2), C([fe("userComponentFactory")], vs.prototype, "userComponentFactory", 2), C([pe], vs.prototype, "postConstruct", 1);
    var Ns = vs,
      Is = class extends ct {
        constructor(e, t) {
          super(), this.ctrl = e, t && (this.beans = t)
        }
        postConstruct() {
          this.refreshToolTip()
        }
        setBrowserTooltip(e) {
          const t = "title",
            i = this.ctrl.getGui();
          i && (null != e && "" != e ? i.setAttribute(t, e) : i.removeAttribute(t))
        }
        updateTooltipText() {
          this.tooltip = this.ctrl.getTooltipValue()
        }
        createTooltipFeatureIfNeeded() {
          var e, t, i, r;
          if (null != this.tooltipManager) return;
          const s = {
            getTooltipParams: () => this.getTooltipParams(),
            getGui: () => this.ctrl.getGui()
          };
          this.tooltipManager = this.createBean(new Ns(s, null == (t = (e = this.ctrl).getTooltipShowDelayOverride) ? void 0 : t.call(e), null == (r = (i = this.ctrl).getTooltipHideDelayOverride) ? void 0 : r.call(i), this.ctrl.shouldDisplayTooltip), this.beans.context)
        }
        refreshToolTip() {
          this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded())
        }
        getTooltipParams() {
          const e = this.ctrl,
            t = e.getColumn ? e.getColumn() : void 0,
            i = e.getColDef ? e.getColDef() : void 0,
            r = e.getRowNode ? e.getRowNode() : void 0;
          return {
            location: e.getLocation(),
            colDef: i,
            column: t,
            rowIndex: e.getRowIndex ? e.getRowIndex() : void 0,
            node: r,
            data: r ? r.data : void 0,
            value: this.getTooltipText(),
            valueFormatted: e.getValueFormatted ? e.getValueFormatted() : void 0,
            hideTooltipCallback: () => {
              var e;
              return null == (e = this.tooltipManager) ? void 0 : e.hideTooltip(!0)
            }
          }
        }
        getTooltipText() {
          return this.tooltip
        }
        destroy() {
          this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy()
        }
      };
    C([fe("beans")], Is.prototype, "beans", 2), C([pe], Is.prototype, "postConstruct", 1);
    var Os = new Ss,
      Ls = class e extends ct {
        constructor(e) {
          super(), this.displayed = !0, this.visible = !0, this.compId = Os.next(), this.cssClassManager = new As(() => this.eGui), e && this.setTemplate(e)
        }
        preConstructOnComponent() {
          this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips")
        }
        getCompId() {
          return this.compId
        }
        getTooltipParams() {
          return {
            value: this.tooltipText,
            location: "UNKNOWN"
          }
        }
        setTooltip(e) {
          const {
            newTooltipText: t,
            showDelayOverride: i,
            hideDelayOverride: r,
            location: s,
            shouldDisplayTooltip: n
          } = e || {};
          this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== t && (this.tooltipText = t);
          const o = () => this.tooltipText;
          null != t && (this.tooltipFeature = this.createBean(new Is({
            getTooltipValue: o,
            getGui: () => this.getGui(),
            getLocation: () => null != s ? s : "UNKNOWN",
            getColDef: null == e ? void 0 : e.getColDef,
            getColumn: null == e ? void 0 : e.getColumn,
            getTooltipShowDelayOverride: null != i ? () => i : void 0,
            getTooltipHideDelayOverride: null != r ? () => r : void 0,
            shouldDisplayTooltip: n
          })))
        }
        createChildComponentsFromTags(e, t) {
          Br(e.childNodes).forEach(i => {
            if (!(i instanceof HTMLElement)) return;
            const r = this.createComponentFromElement(i, e => {
              e.getGui() && this.copyAttributesFromNode(i, e.getGui())
            }, t);
            if (r) {
              if (r.addItems && i.children.length) {
                this.createChildComponentsFromTags(i, t);
                const e = Array.prototype.slice.call(i.children);
                r.addItems(e)
              }
              this.swapComponentForNode(r, e, i)
            } else i.childNodes && this.createChildComponentsFromTags(i, t)
          })
        }
        createComponentFromElement(t, i, r) {
          const s = t.nodeName,
            n = r ? r[t.getAttribute("ref")] : void 0,
            o = this.agStackComponentsRegistry.getComponentClass(s);
          if (o) {
            e.elementGettingCreated = t;
            const r = new o(n);
            return r.setParentComponent(this), this.createBean(r, null, i), r
          }
          return null
        }
        copyAttributesFromNode(e, t) {
          Vr(e.attributes, (e, i) => t.setAttribute(e, i))
        }
        swapComponentForNode(e, t, i) {
          const r = e.getGui();
          t.replaceChild(r, i), t.insertBefore(document.createComment(i.nodeName), r), this.addDestroyFunc(this.destroyBean.bind(this, e)), this.swapInComponentForQuerySelectors(e, i)
        }
        swapInComponentForQuerySelectors(e, t) {
          const i = this;
          this.iterateOverQuerySelectors(r => {
            i[r.attributeName] === t && (i[r.attributeName] = e)
          })
        }
        iterateOverQuerySelectors(e) {
          let t = Object.getPrototypeOf(this);
          for (; null != t;) {
            const i = t.__agComponentMetaData,
              r = J(t.constructor);
            i && i[r] && i[r].querySelectors && i[r].querySelectors.forEach(t => e(t)), t = Object.getPrototypeOf(t)
          }
        }
        activateTabIndex(e) {
          const t = this.gos.get("tabIndex");
          e || (e = []), e.length || e.push(this.getGui()), e.forEach(e => e.setAttribute("tabindex", t.toString()))
        }
        setTemplate(e, t) {
          const i = _r(e);
          this.setTemplateFromElement(i, t)
        }
        setTemplateFromElement(e, t) {
          this.eGui = e, this.eGui.__agComponent = this, this.wireQuerySelectors(), this.getContext() && this.createChildComponentsFromTags(this.getGui(), t)
        }
        createChildComponentsPreConstruct() {
          this.getGui() && this.createChildComponentsFromTags(this.getGui())
        }
        wireQuerySelectors() {
          if (!this.eGui) return;
          const e = this;
          this.iterateOverQuerySelectors(t => {
            const i = i => e[t.attributeName] = i;
            if (t.refSelector && this.getAttribute("ref") === t.refSelector) i(this.eGui);
            else {
              const e = this.eGui.querySelector(t.querySelector);
              e && i(e.__agComponent || e)
            }
          })
        }
        getGui() {
          return this.eGui
        }
        getFocusableElement() {
          return this.eGui
        }
        getAriaElement() {
          return this.getFocusableElement()
        }
        setParentComponent(e) {
          this.parentComponent = e
        }
        getParentComponent() {
          return this.parentComponent
        }
        setGui(e) {
          this.eGui = e
        }
        queryForHtmlElement(e) {
          return this.eGui.querySelector(e)
        }
        queryForHtmlInputElement(e) {
          return this.eGui.querySelector(e)
        }
        appendChild(e, t) {
          if (null != e)
            if (t || (t = this.eGui), kr(e)) t.appendChild(e);
            else {
              const i = e;
              t.appendChild(i.getGui())
            }
        }
        isDisplayed() {
          return this.displayed
        }
        setVisible(e, t = {}) {
          if (e !== this.visible) {
            this.visible = e;
            const {
              skipAriaHidden: i
            } = t;
            dr(this.eGui, e, {
              skipAriaHidden: i
            })
          }
        }
        setDisplayed(t, i = {}) {
          if (t !== this.displayed) {
            this.displayed = t;
            const {
              skipAriaHidden: r
            } = i;
            ur(this.eGui, t, {
              skipAriaHidden: r
            });
            const s = {
              type: e.EVENT_DISPLAYED_CHANGED,
              visible: this.displayed
            };
            this.dispatchEvent(s)
          }
        }
        destroy() {
          this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
          const e = this.eGui;
          e && e.__agComponent && (e.__agComponent = void 0), super.destroy()
        }
        addGuiEventListener(e, t, i) {
          this.eGui.addEventListener(e, t, i), this.addDestroyFunc(() => this.eGui.removeEventListener(e, t))
        }
        addCssClass(e) {
          this.cssClassManager.addCssClass(e)
        }
        removeCssClass(e) {
          this.cssClassManager.removeCssClass(e)
        }
        containsCssClass(e) {
          return this.cssClassManager.containsCssClass(e)
        }
        addOrRemoveCssClass(e, t) {
          this.cssClassManager.addOrRemoveCssClass(e, t)
        }
        getAttribute(e) {
          const {
            eGui: t
          } = this;
          return t ? t.getAttribute(e) : null
        }
        getRefElement(e) {
          return this.queryForHtmlElement(`[ref="${e}"]`)
        }
      };
    Ls.EVENT_DISPLAYED_CHANGED = "displayedChanged", C([fe("agStackComponentsRegistry")], Ls.prototype, "agStackComponentsRegistry", 2), C([de], Ls.prototype, "preConstructOnComponent", 1), C([de], Ls.prototype, "createChildComponentsPreConstruct", 1);
    var _s = Ls;

    function ys(e) {
      return ws.bind(this, `[ref=${e}]`, e)
    }

    function ws(e, t, i, r, s) {
      null !== e ? "number" != typeof s ? function(e, t, i) {
        const r = function(e, t) {
          e.__agComponentMetaData || (e.__agComponentMetaData = {});
          e.__agComponentMetaData[t] || (e.__agComponentMetaData[t] = {});
          return e.__agComponentMetaData[t]
        }(e, J(e.constructor));
        r[t] || (r[t] = []);
        r[t].push(i)
      }(i, "querySelectors", {
        attributeName: r,
        querySelector: e,
        refSelector: t
      }) : console.error("AG Grid: QuerySelector should be on an attribute") : console.error("AG Grid: QuerySelector selector should not be null")
    }
    var Ds = class extends _s {
      constructor() {
        super('\n            <div class="ag-floating-filter-input" role="presentation">\n                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>\n            </div>')
      }
      destroy() {
        super.destroy()
      }
      init(e) {
        this.params = e;
        const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0),
          i = this.localeService.getLocaleTextFunc();
        this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${i("ariaFilterInput","Filter Input")}`)
      }
      onParentModelChanged(e) {
        null != e ? this.params.parentFilterInstance(t => {
          if (t.getModelAsString) {
            const i = t.getModelAsString(e);
            this.eFloatingFilterText.setValue(i)
          }
        }) : this.eFloatingFilterText.setValue("")
      }
      onParamsUpdated(e) {
        this.refresh(e)
      }
      refresh(e) {
        this.init(e)
      }
    };
    C([ys("eFloatingFilterText")], Ds.prototype, "eFloatingFilterText", 2), C([fe("columnModel")], Ds.prototype, "columnModel", 2);
    var Ps = class {
        constructor(e, t, i, r, s) {
          this.alive = !0, this.context = e, this.eParent = r;
          t.getDateCompDetails(i).newAgStackInstance().then(t => {
            this.alive ? (this.dateComp = t, t && (r.appendChild(t.getGui()), t.afterGuiAttached && t.afterGuiAttached(), this.tempValue && t.setDate(this.tempValue), null != this.disabled && this.setDateCompDisabled(this.disabled), null == s || s(this))) : e.destroyBean(t)
          })
        }
        destroy() {
          this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp)
        }
        getDate() {
          return this.dateComp ? this.dateComp.getDate() : this.tempValue
        }
        setDate(e) {
          this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e
        }
        setDisabled(e) {
          this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e
        }
        setDisplayed(e) {
          ur(this.eParent, e)
        }
        setInputPlaceholder(e) {
          this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e)
        }
        setInputAriaLabel(e) {
          this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e)
        }
        afterGuiAttached(e) {
          this.dateComp && "function" == typeof this.dateComp.afterGuiAttached && this.dateComp.afterGuiAttached(e)
        }
        updateParams(e) {
          var t, i;
          let r = !1;
          if ((null == (t = this.dateComp) ? void 0 : t.refresh) && "function" == typeof this.dateComp.refresh) {
            null !== this.dateComp.refresh(e) && (r = !0)
          }
          if (!r && (null == (i = this.dateComp) ? void 0 : i.onParamsUpdated) && "function" == typeof this.dateComp.onParamsUpdated) {
            null !== this.dateComp.onParamsUpdated(e) && z("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.")
          }
        }
        setDateCompDisabled(e) {
          null != this.dateComp && null != this.dateComp.setDisabled && this.dateComp.setDisabled(e)
        }
      },
      bs = class {
        constructor() {
          this.customFilterOptions = {}
        }
        init(e, t) {
          this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e)
        }
        getFilterOptions() {
          return this.filterOptions
        }
        mapCustomOptions() {
          this.filterOptions && this.filterOptions.forEach(e => {
            if ("string" == typeof e) return;
            [
              ["displayKey"],
              ["displayName"],
              ["predicate", "test"]
            ].every(t => !!t.some(t => null != e[t]) || (console.warn(`AG Grid: ignoring FilterOptionDef as it doesn't contain one of '${t}'`), !1)) ? this.customFilterOptions[e.displayKey] = e : this.filterOptions = this.filterOptions.filter(t => t === e) || []
          })
        }
        selectDefaultItem(e) {
          if (e.defaultOption) this.defaultOption = e.defaultOption;
          else if (this.filterOptions.length >= 1) {
            const e = this.filterOptions[0];
            "string" == typeof e ? this.defaultOption = e : e.displayKey ? this.defaultOption = e.displayKey : console.warn("AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'")
          } else console.warn("AG Grid: no filter options for filter")
        }
        getDefaultOption() {
          return this.defaultOption
        }
        getCustomOption(e) {
          return this.customFilterOptions[e]
        }
      },
      Ms = {
        applyFilter: "Apply",
        clearFilter: "Clear",
        resetFilter: "Reset",
        cancelFilter: "Cancel",
        textFilter: "Text Filter",
        numberFilter: "Number Filter",
        dateFilter: "Date Filter",
        setFilter: "Set Filter",
        filterOoo: "Filter...",
        empty: "Choose one",
        equals: "Equals",
        notEqual: "Does not equal",
        lessThan: "Less than",
        greaterThan: "Greater than",
        inRange: "Between",
        inRangeStart: "From",
        inRangeEnd: "To",
        lessThanOrEqual: "Less than or equal to",
        greaterThanOrEqual: "Greater than or equal to",
        contains: "Contains",
        notContains: "Does not contain",
        startsWith: "Begins with",
        endsWith: "Ends with",
        blank: "Blank",
        notBlank: "Not blank",
        before: "Before",
        after: "After",
        andCondition: "AND",
        orCondition: "OR",
        dateFormatOoo: "yyyy-mm-dd"
      },
      Fs = class e extends ct {
        constructor(e, t = {}) {
          super(), this.eFocusableElement = e, this.callbacks = t, this.callbacks = f({
            shouldStopEventPropagation: () => !1,
            onTabKeyDown: e => {
              if (e.defaultPrevented) return;
              const t = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e.shiftKey);
              t && (t.focus(), e.preventDefault())
            }
          }, t)
        }
        postConstruct() {
          this.eFocusableElement.classList.add(e.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn), this.callbacks.onFocusOut && this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut)
        }
        addKeyDownListeners(e) {
          this.addManagedListener(e, "keydown", e => {
            e.defaultPrevented || tt(e) || (this.callbacks.shouldStopEventPropagation(e) ? et(e) : e.key === ts.TAB ? this.callbacks.onTabKeyDown(e) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(e))
          })
        }
      };
    Fs.FOCUS_MANAGED_CLASS = "ag-focus-managed", C([fe("focusService")], Fs.prototype, "focusService", 2), C([pe], Fs.prototype, "postConstruct", 1);
    var xs = Fs,
      Gs = "ag-resizer-wrapper",
      Us = `<div class="${Gs}">\n        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>\n        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>\n        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>\n        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>\n        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>\n        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>\n        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>\n        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>\n    </div>`,
      Hs = class extends ct {
        constructor(e, t) {
          super(), this.element = e, this.dragStartPosition = {
            x: 0,
            y: 0
          }, this.position = {
            x: 0,
            y: 0
          }, this.lastSize = {
            width: -1,
            height: -1
          }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, {
            popup: !1
          }, t)
        }
        center() {
          const {
            clientHeight: e,
            clientWidth: t
          } = this.offsetParent, i = t / 2 - this.getWidth() / 2, r = e / 2 - this.getHeight() / 2;
          this.offsetElement(i, r)
        }
        initialisePosition() {
          if (this.positioned) return;
          const {
            centered: e,
            forcePopupParentAsOffsetParent: t,
            minWidth: i,
            width: r,
            minHeight: s,
            height: n,
            x: o,
            y: a
          } = this.config;
          this.offsetParent || this.setOffsetParent();
          let l = 0,
            c = 0;
          const h = Lr(this.element);
          if (h) {
            const e = this.findBoundaryElement(),
              t = window.getComputedStyle(e);
            if (null != t.minWidth) {
              const i = e.offsetWidth - this.element.offsetWidth;
              c = parseInt(t.minWidth, 10) - i
            }
            if (null != t.minHeight) {
              const i = e.offsetHeight - this.element.offsetHeight;
              l = parseInt(t.minHeight, 10) - i
            }
          }
          if (this.minHeight = s || l, this.minWidth = i || c, r && this.setWidth(r), n && this.setHeight(n), r && n || this.refreshSize(), e) this.center();
          else if (o || a) this.offsetElement(o, a);
          else if (h && t) {
            let e = this.boundaryEl,
              t = !0;
            if (e || (e = this.findBoundaryElement(), t = !1), e) {
              const i = parseFloat(e.style.top),
                r = parseFloat(e.style.left);
              t ? this.offsetElement(isNaN(r) ? 0 : r, isNaN(i) ? 0 : i) : this.setPosition(r, i)
            }
          }
          this.positioned = !!this.offsetParent
        }
        isPositioned() {
          return this.positioned
        }
        getPosition() {
          return this.position
        }
        setMovable(e, t) {
          if (!this.config.popup || e === this.movable) return;
          this.movable = e;
          const i = this.moveElementDragListener || {
            eElement: t,
            onDragStart: this.onMoveStart.bind(this),
            onDragging: this.onMove.bind(this),
            onDragStop: this.onMoveEnd.bind(this)
          };
          e ? (this.dragService.addDragSource(i), this.moveElementDragListener = i) : (this.dragService.removeDragSource(i), this.moveElementDragListener = void 0)
        }
        setResizable(e) {
          if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), "boolean" == typeof e) {
            if (!1 === e) return;
            e = {
              topLeft: e,
              top: e,
              topRight: e,
              right: e,
              bottomRight: e,
              bottom: e,
              bottomLeft: e,
              left: e
            }
          }
          Object.keys(e).forEach(t => {
            const i = !!e[t],
              r = this.getResizerElement(t),
              s = {
                dragStartPixels: 0,
                eElement: r,
                onDragStart: e => this.onResizeStart(e, t),
                onDragging: this.onResize.bind(this),
                onDragStop: e => this.onResizeEnd(e, t)
              };
            (i || !this.isAlive() && !i) && (i ? (this.dragService.addDragSource(s), this.resizeListeners.push(s), r.style.pointerEvents = "all") : r.style.pointerEvents = "none", this.resizable[t] = i)
          })
        }
        removeSizeFromEl() {
          this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex")
        }
        restoreLastSize() {
          this.element.style.flex = "0 0 auto";
          const {
            height: e,
            width: t
          } = this.lastSize; - 1 !== t && (this.element.style.width = `${t}px`), -1 !== e && (this.element.style.height = `${e}px`)
        }
        getHeight() {
          return this.element.offsetHeight
        }
        setHeight(e) {
          const {
            popup: t
          } = this.config, i = this.element;
          let r = !1;
          if ("string" == typeof e && -1 !== e.indexOf("%")) Ur(i, e), e = mr(i), r = !0;
          else if (e = Math.max(this.minHeight, e), this.positioned) {
            const t = this.getAvailableHeight();
            t && e > t && (e = t)
          }
          this.getHeight() !== e && (r ? (i.style.maxHeight = "unset", i.style.minHeight = "unset") : t ? Ur(i, e) : (i.style.height = `${e}px`, i.style.flex = "0 0 auto", this.lastSize.height = "number" == typeof e ? e : parseFloat(e)))
        }
        getAvailableHeight() {
          const {
            popup: e,
            forcePopupParentAsOffsetParent: t
          } = this.config;
          this.positioned || this.initialisePosition();
          const {
            clientHeight: i
          } = this.offsetParent;
          if (!i) return null;
          const r = this.element.getBoundingClientRect(),
            s = this.offsetParent.getBoundingClientRect(),
            n = e ? this.position.y : r.top,
            o = e ? 0 : s.top;
          let a = 0;
          if (t) {
            const e = this.element.parentElement;
            if (e) {
              const {
                bottom: t
              } = e.getBoundingClientRect();
              a = t - r.bottom
            }
          }
          return i + o - n - a
        }
        getWidth() {
          return this.element.offsetWidth
        }
        setWidth(e) {
          const t = this.element,
            {
              popup: i
            } = this.config;
          let r = !1;
          if ("string" == typeof e && -1 !== e.indexOf("%")) xr(t, e), e = Cr(t), r = !0;
          else if (this.positioned) {
            e = Math.max(this.minWidth, e);
            const {
              clientWidth: t
            } = this.offsetParent, r = i ? this.position.x : this.element.getBoundingClientRect().left;
            t && e + r > t && (e = t - r)
          }
          this.getWidth() !== e && (r ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? xr(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = "number" == typeof e ? e : parseFloat(e)))
        }
        offsetElement(e = 0, t = 0) {
          const {
            forcePopupParentAsOffsetParent: i
          } = this.config, r = i ? this.boundaryEl : this.element;
          r && (this.popupService.positionPopup({
            ePopup: r,
            keepWithinBounds: !0,
            skipObserver: this.movable || this.isResizable(),
            updatePosition: () => ({
              x: e,
              y: t
            })
          }), this.setPosition(parseFloat(r.style.left), parseFloat(r.style.top)))
        }
        constrainSizeToAvailableHeight(e) {
          if (!this.config.forcePopupParentAsOffsetParent) return;
          const t = () => {
            const e = this.getAvailableHeight();
            this.element.style.setProperty("max-height", `${e}px`)
          };
          e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(this.popupService.getPopupParent(), t) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0))
        }
        setPosition(e, t) {
          this.position.x = e, this.position.y = t
        }
        updateDragStartPosition(e, t) {
          this.dragStartPosition = {
            x: e,
            y: t
          }
        }
        calculateMouseMovement(e) {
          const {
            e: t,
            isLeft: i,
            isTop: r,
            anywhereWithin: s,
            topBuffer: n
          } = e, o = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y;
          return {
            movementX: this.shouldSkipX(t, !!i, !!s, o) ? 0 : o,
            movementY: this.shouldSkipY(t, !!r, n, a) ? 0 : a
          }
        }
        shouldSkipX(e, t, i, r) {
          const s = this.element.getBoundingClientRect(),
            n = this.offsetParent.getBoundingClientRect(),
            o = this.boundaryEl.getBoundingClientRect(),
            a = this.config.popup ? this.position.x : s.left;
          let l = a <= 0 && n.left >= e.clientX || n.right <= e.clientX && n.right <= o.right;
          return !!l || (l = t ? r < 0 && e.clientX > a + n.left || r > 0 && e.clientX < a + n.left : i ? r < 0 && e.clientX > o.right || r > 0 && e.clientX < a + n.left : r < 0 && e.clientX > o.right || r > 0 && e.clientX < o.right, l)
        }
        shouldSkipY(e, t, i = 0, r) {
          const s = this.element.getBoundingClientRect(),
            n = this.offsetParent.getBoundingClientRect(),
            o = this.boundaryEl.getBoundingClientRect(),
            a = this.config.popup ? this.position.y : s.top;
          let l = a <= 0 && n.top >= e.clientY || n.bottom <= e.clientY && n.bottom <= o.bottom;
          return !!l || (l = t ? r < 0 && e.clientY > a + n.top + i || r > 0 && e.clientY < a + n.top : r < 0 && e.clientY > o.bottom || r > 0 && e.clientY < o.bottom, l)
        }
        createResizeMap() {
          const e = this.element;
          this.resizerMap = {
            topLeft: {
              element: e.querySelector("[ref=eTopLeftResizer]")
            },
            top: {
              element: e.querySelector("[ref=eTopResizer]")
            },
            topRight: {
              element: e.querySelector("[ref=eTopRightResizer]")
            },
            right: {
              element: e.querySelector("[ref=eRightResizer]")
            },
            bottomRight: {
              element: e.querySelector("[ref=eBottomRightResizer]")
            },
            bottom: {
              element: e.querySelector("[ref=eBottomResizer]")
            },
            bottomLeft: {
              element: e.querySelector("[ref=eBottomLeftResizer]")
            },
            left: {
              element: e.querySelector("[ref=eLeftResizer]")
            }
          }
        }
        addResizers() {
          if (this.resizersAdded) return;
          const e = this.element;
          if (!e) return;
          const t = (new DOMParser).parseFromString(Us, "text/html").body;
          e.appendChild(t.firstChild), this.createResizeMap(), this.resizersAdded = !0
        }
        removeResizers() {
          this.resizerMap = void 0;
          const e = this.element.querySelector(`.${Gs}`);
          e && this.element.removeChild(e), this.resizersAdded = !1
        }
        getResizerElement(e) {
          return this.resizerMap[e].element
        }
        onResizeStart(e, t) {
          this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
            isTop: !!t.match(/top/i),
            isRight: !!t.match(/right/i),
            isBottom: !!t.match(/bottom/i),
            isLeft: !!t.match(/left/i)
          }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
          const {
            popup: i,
            forcePopupParentAsOffsetParent: r
          } = this.config;
          i || r || this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY)
        }
        getSiblings() {
          const e = this.element.parentElement;
          return e ? Array.prototype.slice.call(e.children).filter(e => !e.classList.contains("ag-hidden")) : null
        }
        getMinSizeOfSiblings() {
          const e = this.getSiblings() || [];
          let t = 0,
            i = 0;
          for (let r = 0; r < e.length; r++) {
            const s = e[r],
              n = !!s.style.flex && "0 0 auto" !== s.style.flex;
            if (s === this.element) continue;
            let o = this.minHeight || 0,
              a = this.minWidth || 0;
            if (n) {
              const e = window.getComputedStyle(s);
              e.minHeight && (o = parseInt(e.minHeight, 10)), e.minWidth && (a = parseInt(e.minWidth, 10))
            } else o = s.offsetHeight, a = s.offsetWidth;
            t += o, i += a
          }
          return {
            height: t,
            width: i
          }
        }
        applySizeToSiblings(e) {
          let t = null;
          const i = this.getSiblings();
          if (i) {
            for (let r = 0; r < i.length; r++) {
              const s = i[r];
              s !== t && (e ? s.style.height = `${s.offsetHeight}px` : s.style.width = `${s.offsetWidth}px`, s.style.flex = "0 0 auto", s === this.element && (t = i[r + 1]))
            }
            t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto")
          }
        }
        isResizable() {
          return Object.values(this.resizable).some(e => e)
        }
        onResize(e) {
          if (!this.isResizing || !this.currentResizer) return;
          const {
            popup: t,
            forcePopupParentAsOffsetParent: i
          } = this.config, {
            isTop: r,
            isRight: s,
            isBottom: n,
            isLeft: o
          } = this.currentResizer, a = s || o, l = n || r, {
            movementX: c,
            movementY: h
          } = this.calculateMouseMovement({
            e,
            isLeft: o,
            isTop: r
          }), u = this.position.x, d = this.position.y;
          let p = 0,
            E = 0;
          if (a && c) {
            const e = o ? -1 : 1,
              t = this.getWidth(),
              i = t + c * e;
            let r = !1;
            o && (p = t - i, (u + p <= 0 || i <= this.minWidth) && (r = !0, p = 0)), r || this.setWidth(i)
          }
          if (l && h) {
            const e = r ? -1 : 1,
              t = this.getHeight(),
              i = t + h * e;
            let s = !1;
            r ? (E = t - i, (d + E <= 0 || i <= this.minHeight) && (s = !0, E = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && t < i && this.getMinSizeOfSiblings().height + i > this.element.parentElement.offsetHeight && (s = !0), s || this.setHeight(i)
          }
          this.updateDragStartPosition(e.clientX, e.clientY), ((t || i) && p || E) && this.offsetElement(u + p, d + E)
        }
        onResizeEnd(e, t) {
          this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null;
          this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchEvent({
            type: "resize"
          })
        }
        refreshSize() {
          const e = this.element;
          this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight))
        }
        onMoveStart(e) {
          this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY)
        }
        onMove(e) {
          if (!this.isMoving) return;
          const {
            x: t,
            y: i
          } = this.position;
          let r;
          this.config.calculateTopBuffer && (r = this.config.calculateTopBuffer());
          const {
            movementX: s,
            movementY: n
          } = this.calculateMouseMovement({
            e,
            isTop: !0,
            anywhereWithin: !0,
            topBuffer: r
          });
          this.offsetElement(t + s, i + n), this.updateDragStartPosition(e.clientX, e.clientY)
        }
        onMoveEnd() {
          this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving")
        }
        setOffsetParent() {
          this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent
        }
        findBoundaryElement() {
          let e = this.element;
          for (; e;) {
            if ("static" !== window.getComputedStyle(e).position) return e;
            e = e.parentElement
          }
          return this.element
        }
        clearResizeListeners() {
          for (; this.resizeListeners.length;) {
            const e = this.resizeListeners.pop();
            this.dragService.removeDragSource(e)
          }
        }
        destroy() {
          super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers()
        }
      };
    C([fe("popupService")], Hs.prototype, "popupService", 2), C([fe("resizeObserverService")], Hs.prototype, "resizeObserverService", 2), C([fe("dragService")], Hs.prototype, "dragService", 2);
    var ks = class e extends _s {
      constructor(e) {
        super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.buttonListeners = []
      }
      postConstruct() {
        this.resetTemplate(), this.createManagedBean(new xs(this.getFocusableElement(), {
          handleKeyDown: this.handleKeyDown.bind(this)
        })), this.positionableFeature = new Hs(this.getPositionableElement(), {
          forcePopupParentAsOffsetParent: !0
        }), this.createBean(this.positionableFeature)
      }
      handleKeyDown(e) {}
      getFilterTitle() {
        return this.translate(this.filterNameKey)
      }
      isFilterActive() {
        return !!this.appliedModel
      }
      resetTemplate(e) {
        let t = this.getGui();
        t && t.removeEventListener("submit", this.onFormSubmit);
        const i = `\n            <form class="ag-filter-wrapper">\n                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" ref="eFilterBody">\n                    ${this.createBodyTemplate()}\n                </div>\n            </form>`;
        this.setTemplate(i, e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit)
      }
      isReadOnly() {
        return !!this.providedFilterParams.readOnly
      }
      init(e) {
        this.setParams(e), this.resetUiToDefaults(!0).then(() => {
          this.updateUiVisibility(), this.setupOnBtApplyDebounce()
        })
      }
      setParams(t) {
        this.providedFilterParams = t, this.applyActive = e.isUseApplyButton(t), this.resetButtonsPanel()
      }
      updateParams(t) {
        this.providedFilterParams = t, this.applyActive = e.isUseApplyButton(t), this.resetUiToActiveModel(this.getModel(), () => {
          this.updateUiVisibility(), this.setupOnBtApplyDebounce()
        })
      }
      resetButtonsPanel() {
        const {
          buttons: e
        } = this.providedFilterParams, t = e && e.length > 0 && !this.isReadOnly();
        if (this.eButtonsPanel ? (Nr(this.eButtonsPanel), this.buttonListeners.forEach(e => null == e ? void 0 : e()), this.buttonListeners = []) : t && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !t) return void(this.eButtonsPanel && Ir(this.eButtonsPanel));
        const i = document.createDocumentFragment(),
          r = e => {
            let t, r;
            switch (e) {
              case "apply":
                t = this.translate("applyFilter"), r = e => this.onBtApply(!1, !1, e);
                break;
              case "clear":
                t = this.translate("clearFilter"), r = () => this.onBtClear();
                break;
              case "reset":
                t = this.translate("resetFilter"), r = () => this.onBtReset();
                break;
              case "cancel":
                t = this.translate("cancelFilter"), r = e => {
                  this.onBtCancel(e)
                };
                break;
              default:
                return void console.warn("AG Grid: Unknown button type specified")
            }
            const s = _r(`<button\n                    type="${"apply"===e?"submit":"button"}"\n                    ref="${e}FilterButton"\n                    class="ag-button ag-standard-button ag-filter-apply-panel-button"\n                >${t}\n                </button>`);
            this.buttonListeners.push(this.addManagedListener(s, "click", r)), i.append(s)
          };
        ms(e).forEach(e => r(e)), this.eButtonsPanel.append(i), this.getGui().appendChild(this.eButtonsPanel)
      }
      getDefaultDebounceMs() {
        return 0
      }
      setupOnBtApplyDebounce() {
        const t = e.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs()),
          i = re(this.checkApplyDebounce.bind(this), t);
        this.onBtApplyDebounce = () => {
          this.debouncePending = !0, i()
        }
      }
      checkApplyDebounce() {
        this.debouncePending && (this.debouncePending = !1, this.onBtApply())
      }
      getModel() {
        return this.appliedModel ? this.appliedModel : null
      }
      setModel(e) {
        return (null != e ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
          this.updateUiVisibility(), this.applyModel("api")
        })
      }
      onBtCancel(e) {
        this.resetUiToActiveModel(this.getModel(), () => {
          this.handleCancelEnd(e)
        })
      }
      handleCancelEnd(e) {
        this.providedFilterParams.closeOnApply && this.close(e)
      }
      resetUiToActiveModel(e, t) {
        const i = () => {
          this.onUiChanged(!1, "prevent"), null == t || t()
        };
        null != e ? this.setModelIntoUi(e).then(i) : this.resetUiToDefaults().then(i)
      }
      onBtClear() {
        this.resetUiToDefaults().then(() => this.onUiChanged())
      }
      onBtReset() {
        this.onBtClear(), this.onBtApply()
      }
      applyModel(e = "api") {
        const t = this.getModelFromUi();
        if (!this.isModelValid(t)) return !1;
        const i = this.appliedModel;
        return this.appliedModel = t, !this.areModelsEqual(i, t)
      }
      isModelValid(e) {
        return !0
      }
      onFormSubmit(e) {
        e.preventDefault()
      }
      onBtApply(e = !1, t = !1, i) {
        if (i && i.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui")) {
          const i = "columnFilter";
          this.providedFilterParams.filterChangedCallback({
            afterFloatingFilter: e,
            afterDataChange: t,
            source: i
          })
        }
        const {
          closeOnApply: r
        } = this.providedFilterParams;
        r && this.applyActive && !e && !t && this.close(i)
      }
      onNewRowsLoaded() {}
      close(e) {
        if (!this.hidePopup) return;
        const t = e,
          i = t && t.key;
        let r;
        "Enter" !== i && "Space" !== i || (r = {
          keyboardEvent: t
        }), this.hidePopup(r), this.hidePopup = null
      }
      onUiChanged(e = !1, t) {
        if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
          const e = this.isModelValid(this.getModelFromUi()),
            t = this.getRefElement("applyFilterButton");
          t && pr(t, !e)
        }
        e && !t || "immediately" === t ? this.onBtApply(e) : (this.applyActive || t) && "debounce" !== t || this.onBtApplyDebounce()
      }
      afterGuiAttached(e) {
        e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(null == e ? void 0 : e.container)
      }
      refreshFilterResizer(e) {
        if (!this.positionableFeature || "toolPanel" === e) return;
        const t = "floatingFilter" === e || "columnFilter" === e,
          {
            positionableFeature: i,
            gos: r
          } = this;
        t ? (i.restoreLastSize(), i.setResizable(r.get("enableRtl") ? {
          bottom: !0,
          bottomLeft: !0,
          left: !0
        } : {
          bottom: !0,
          bottomRight: !0,
          right: !0
        })) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0)
      }
      afterGuiDetached() {
        this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1)
      }
      static getDebounceMs(t, i) {
        return e.isUseApplyButton(t) ? (null != t.debounceMs && console.warn("AG Grid: debounceMs is ignored when apply button is present"), 0) : null != t.debounceMs ? t.debounceMs : i
      }
      static isUseApplyButton(e) {
        return !!e.buttons && e.buttons.indexOf("apply") >= 0
      }
      refresh(e) {
        return this.providedFilterParams = e, !0
      }
      destroy() {
        const e = this.getGui();
        e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy()
      }
      translate(e) {
        return this.localeService.getLocaleTextFunc()(e, Ms[e])
      }
      getCellValue(e) {
        return this.providedFilterParams.getValue(e)
      }
      getPositionableElement() {
        return this.eFilterBody
      }
    };
    C([fe("rowModel")], ks.prototype, "rowModel", 2), C([ys("eFilterBody")], ks.prototype, "eFilterBody", 2), C([pe], ks.prototype, "postConstruct", 1);
    var Bs = ks,
      Vs = class extends _s {
        constructor(e, t) {
          super(t), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {}
        }
        postConstruct() {
          this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
          const {
            labelSeparator: e,
            label: t,
            labelWidth: i,
            labelAlignment: r,
            disabled: s
          } = this.config;
          null != s && this.setDisabled(s), null != e && this.setLabelSeparator(e), null != t && this.setLabel(t), null != i && this.setLabelWidth(i), this.setLabelAlignment(r || this.labelAlignment), this.refreshLabel()
        }
        refreshLabel() {
          Nr(this.eLabel), "string" == typeof this.label ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), "" === this.label ? (ur(this.eLabel, !1), Xt(this.eLabel, "presentation")) : (ur(this.eLabel, !0), Xt(this.eLabel, null))
        }
        setLabelSeparator(e) {
          return this.labelSeparator === e || (this.labelSeparator = e, null != this.label && this.refreshLabel()), this
        }
        getLabelId() {
          return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id
        }
        getLabel() {
          return this.label
        }
        setLabel(e) {
          return this.label === e || (this.label = e, this.refreshLabel()), this
        }
        setLabelAlignment(e) {
          const t = this.getGui().classList;
          return t.toggle("ag-label-align-left", "left" === e), t.toggle("ag-label-align-right", "right" === e), t.toggle("ag-label-align-top", "top" === e), this
        }
        setLabelEllipsis(e) {
          return this.eLabel.classList.toggle("ag-label-ellipsis", e), this
        }
        setLabelWidth(e) {
          return null == this.label || Fr(this.eLabel, e), this
        }
        setDisabled(e) {
          e = !!e;
          const t = this.getGui();
          return pr(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this
        }
        isDisabled() {
          return !!this.disabled
        }
      };
    C([pe], Vs.prototype, "postConstruct", 1);
    var Ws = class extends Vs {
        constructor(e, t, i) {
          super(e, t), this.className = i
        }
        postConstruct() {
          super.postConstruct();
          const {
            width: e,
            value: t,
            onValueChange: i
          } = this.config;
          null != e && this.setWidth(e), null != t && this.setValue(t), null != i && this.onValueChange(i), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy()
        }
        refreshAriaLabelledBy() {
          const e = this.getAriaElement(),
            t = this.getLabelId();
          null !== Jt(e) ? Qt(e, "") : Qt(e, null != t ? t : "")
        }
        setAriaLabel(e) {
          return qt(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this
        }
        onValueChange(e) {
          return this.addManagedListener(this, Et.EVENT_FIELD_VALUE_CHANGED, () => e(this.getValue())), this
        }
        getWidth() {
          return this.getGui().clientWidth
        }
        setWidth(e) {
          return xr(this.getGui(), e), this
        }
        getPreviousValue() {
          return this.previousValue
        }
        getValue() {
          return this.value
        }
        setValue(e, t) {
          return this.value === e || (this.previousValue = this.value, this.value = e, t || this.dispatchEvent({
            type: Et.EVENT_FIELD_VALUE_CHANGED
          })), this
        }
      },
      Ys = class extends Ws {
        constructor(e) {
          if (super(e, (null == e ? void 0 : e.template) || '\n    <div class="ag-picker-field" role="presentation">\n        <div ref="eLabel"></div>\n            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">\n            <div ref="eDisplayField" class="ag-picker-field-display"></div>\n            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>\n        </div>\n    </div>', null == e ? void 0 : e.className), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.ariaRole = null == e ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e) return;
          const {
            pickerGap: t,
            maxPickerHeight: i,
            variableWidth: r,
            minPickerWidth: s,
            maxPickerWidth: n
          } = e;
          null != t && (this.pickerGap = t), this.variableWidth = !!r, null != i && this.setPickerMaxHeight(i), null != s && this.setPickerMinWidth(s), null != n && this.setPickerMaxWidth(n)
        }
        postConstruct() {
          super.postConstruct(), this.setupAria();
          const e = `ag-${this.getCompId()}-display`;
          this.eDisplayField.setAttribute("id", e);
          const t = this.getAriaElement();
          this.addManagedListener(t, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(this.eLabel, "mousedown", this.onLabelOrWrapperMouseDown.bind(this)), this.addManagedListener(this.eWrapper, "mousedown", this.onLabelOrWrapperMouseDown.bind(this));
          const {
            pickerIcon: i,
            inputWidth: r
          } = this.config;
          if (i) {
            const e = Zr(i, this.gos);
            e && this.eIcon.appendChild(e)
          }
          null != r && this.setInputWidth(r)
        }
        setupAria() {
          const e = this.getAriaElement();
          e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), ai(e, !1), this.ariaRole && Xt(e, this.ariaRole)
        }
        onLabelOrWrapperMouseDown(e) {
          if (e) {
            const t = this.getFocusableElement();
            if (t !== this.eWrapper && (null == e ? void 0 : e.target) === t) return;
            e.preventDefault(), this.getFocusableElement().focus()
          }
          this.skipClick ? this.skipClick = !1 : this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker())
        }
        onKeyDown(e) {
          switch (e.key) {
            case ts.UP:
            case ts.DOWN:
            case ts.ENTER:
            case ts.SPACE:
              e.preventDefault(), this.onLabelOrWrapperMouseDown();
              break;
            case ts.ESCAPE:
              this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker())
          }
        }
        showPicker() {
          this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
          const e = this.pickerComponent.getGui();
          e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0)
        }
        renderAndPositionPicker() {
          const e = this.gos.getDocument(),
            t = this.pickerComponent.getGui();
          this.gos.get("suppressScrollWhenPopupsAreOpen") || (this.destroyMouseWheelFunc = this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL, () => {
            this.hidePicker()
          }));
          const i = this.localeService.getLocaleTextFunc(),
            {
              pickerAriaLabelKey: r,
              pickerAriaLabelValue: s,
              modalPicker: n = !0
            } = this.config,
            o = {
              modal: n,
              eChild: t,
              closeOnEsc: !0,
              closedCallback: () => {
                const t = this.gos.getActiveDomElement(),
                  i = !t || t === e.body;
                this.beforeHidePicker(), i && this.isAlive() && this.getFocusableElement().focus()
              },
              ariaLabel: i(r, s)
            },
            a = this.popupService.addPopup(o),
            {
              maxPickerHeight: l,
              minPickerWidth: c,
              maxPickerWidth: h,
              variableWidth: u
            } = this;
          u ? (c && (t.style.minWidth = c), t.style.width = Hr(Cr(this.eWrapper)), h && (t.style.maxWidth = h)) : Fr(t, null != h ? h : Cr(this.eWrapper));
          const d = null != l ? l : `${fr(this.popupService.getPopupParent())}px`;
          return t.style.setProperty("max-height", d), t.style.position = "absolute", this.alignPickerToComponent(), a.hideFunc
        }
        alignPickerToComponent() {
          if (!this.pickerComponent) return;
          const {
            pickerType: e
          } = this.config, {
            pickerGap: t
          } = this, i = this.gos.get("enableRtl") ? "right" : "left";
          this.popupService.positionPopupByComponent({
            type: e,
            eventSource: this.eWrapper,
            ePopup: this.pickerComponent.getGui(),
            position: "under",
            alignSide: i,
            keepWithinBounds: !0,
            nudgeY: t
          })
        }
        beforeHidePicker() {
          this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
          const e = this.pickerComponent.getGui();
          e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null
        }
        toggleExpandedStyles(e) {
          if (!this.isAlive()) return;
          ai(this.getAriaElement(), e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e)
        }
        onPickerFocusIn() {
          this.togglePickerHasFocus(!0)
        }
        onPickerFocusOut(e) {
          var t;
          (null == (t = this.pickerComponent) ? void 0 : t.getGui().contains(e.relatedTarget)) || this.togglePickerHasFocus(!1)
        }
        togglePickerHasFocus(e) {
          this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e)
        }
        hidePicker() {
          this.hideCurrentPicker && this.hideCurrentPicker()
        }
        setInputWidth(e) {
          return Fr(this.eWrapper, e), this
        }
        getFocusableElement() {
          return this.eWrapper
        }
        setPickerGap(e) {
          return this.pickerGap = e, this
        }
        setPickerMinWidth(e) {
          return "number" == typeof e && (e = `${e}px`), this.minPickerWidth = null == e ? void 0 : e, this
        }
        setPickerMaxWidth(e) {
          return "number" == typeof e && (e = `${e}px`), this.maxPickerWidth = null == e ? void 0 : e, this
        }
        setPickerMaxHeight(e) {
          return "number" == typeof e && (e = `${e}px`), this.maxPickerHeight = null == e ? void 0 : e, this
        }
        destroy() {
          this.hidePicker(), super.destroy()
        }
      };
    C([fe("popupService")], Ys.prototype, "popupService", 2), C([ys("eLabel")], Ys.prototype, "eLabel", 2), C([ys("eWrapper")], Ys.prototype, "eWrapper", 2), C([ys("eDisplayField")], Ys.prototype, "eDisplayField", 2), C([ys("eIcon")], Ys.prototype, "eIcon", 2);
    var Ks = class e extends _s {
      constructor(e = "default", t = !1) {
        super(`<div class="ag-list ag-${e}-list" role="listbox"></div>`), this.cssIdentifier = e, this.unFocusable = t, this.options = [], this.itemEls = []
      }
      init() {
        const e = this.getGui();
        this.addManagedListener(e, "mouseleave", () => this.clearHighlighted()), this.unFocusable || this.addManagedListener(e, "keydown", this.handleKeyDown.bind(this))
      }
      handleKeyDown(e) {
        const t = e.key;
        switch (t) {
          case ts.ENTER:
            if (this.highlightedEl) {
              const e = this.itemEls.indexOf(this.highlightedEl);
              this.setValueByIndex(e)
            } else this.setValue(this.getValue());
            break;
          case ts.DOWN:
          case ts.UP:
            e.preventDefault(), this.navigate(t);
            break;
          case ts.PAGE_DOWN:
          case ts.PAGE_UP:
          case ts.PAGE_HOME:
          case ts.PAGE_END:
            e.preventDefault(), this.navigateToPage(t)
        }
      }
      navigate(e) {
        const t = e === ts.DOWN;
        let i;
        if (this.highlightedEl) {
          let e = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1);
          e = Math.min(Math.max(e, 0), this.itemEls.length - 1), i = this.itemEls[e]
        } else i = this.itemEls[t ? 0 : this.itemEls.length - 1];
        this.highlightItem(i)
      }
      navigateToPage(e) {
        if (!this.highlightedEl || 0 === this.itemEls.length) return;
        const t = this.itemEls.indexOf(this.highlightedEl),
          i = this.options.length - 1,
          r = this.itemEls[0].clientHeight,
          s = Math.floor(this.getGui().clientHeight / r);
        let n = -1;
        e === ts.PAGE_HOME ? n = 0 : e === ts.PAGE_END ? n = i : e === ts.PAGE_DOWN ? n = Math.min(t + s, i) : e === ts.PAGE_UP && (n = Math.max(t - s, 0)), -1 !== n && this.highlightItem(this.itemEls[n])
      }
      addOptions(e) {
        return e.forEach(e => this.addOption(e)), this
      }
      addOption(e) {
        const {
          value: t,
          text: i
        } = e, r = i || t;
        return this.options.push({
          value: t,
          text: r
        }), this.renderOption(t, r), this.updateIndices(), this
      }
      clearOptions() {
        this.options = [], this.reset(!0), this.itemEls.forEach(e => {
          Ir(e)
        }), this.itemEls = []
      }
      updateIndices() {
        const e = this.getGui().querySelectorAll(".ag-list-item");
        e.forEach((t, i) => {
          hi(t, i + 1), ci(t, e.length)
        })
      }
      renderOption(e, t) {
        const i = this.gos.getDocument(),
          r = i.createElement("div");
        Xt(r, "option"), r.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
        const s = i.createElement("span");
        r.appendChild(s), s.textContent = t, this.unFocusable || (r.tabIndex = -1), this.itemEls.push(r), this.addManagedListener(r, "mousemove", () => this.highlightItem(r)), this.addManagedListener(r, "mousedown", t => {
          t.preventDefault(), this.setValue(e)
        }), this.createManagedBean(new Is({
          getTooltipValue: () => t,
          getGui: () => r,
          getLocation: () => "UNKNOWN",
          shouldDisplayTooltip: () => s.scrollWidth > s.clientWidth
        })), this.getGui().appendChild(r)
      }
      setValue(e, t) {
        if (this.value === e) return this.fireItemSelected(), this;
        if (null == e) return this.reset(t), this;
        const i = this.options.findIndex(t => t.value === e);
        if (-1 !== i) {
          const e = this.options[i];
          this.value = e.value, this.displayValue = e.text, this.highlightItem(this.itemEls[i]), t || this.fireChangeEvent()
        }
        return this
      }
      setValueByIndex(e) {
        return this.setValue(this.options[e].value)
      }
      getValue() {
        return this.value
      }
      getDisplayValue() {
        return this.displayValue
      }
      refreshHighlighted() {
        this.clearHighlighted();
        const e = this.options.findIndex(e => e.value === this.value); - 1 !== e && this.highlightItem(this.itemEls[e])
      }
      reset(e) {
        this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent()
      }
      highlightItem(t) {
        if (!Lr(t)) return;
        this.clearHighlighted(), this.highlightedEl = t, this.highlightedEl.classList.add(e.ACTIVE_CLASS), Ci(this.highlightedEl, !0);
        const i = this.getGui(),
          {
            scrollTop: r,
            clientHeight: s
          } = i,
          {
            offsetTop: n,
            offsetHeight: o
          } = t;
        (n + o > r + s || n < r) && this.highlightedEl.scrollIntoView({
          block: "nearest"
        }), this.unFocusable || this.highlightedEl.focus()
      }
      clearHighlighted() {
        this.highlightedEl && Lr(this.highlightedEl) && (this.highlightedEl.classList.remove(e.ACTIVE_CLASS), Ci(this.highlightedEl, !1), this.highlightedEl = null)
      }
      fireChangeEvent() {
        this.dispatchEvent({
          type: Et.EVENT_FIELD_VALUE_CHANGED
        }), this.fireItemSelected()
      }
      fireItemSelected() {
        this.dispatchEvent({
          type: e.EVENT_ITEM_SELECTED
        })
      }
    };
    Ks.EVENT_ITEM_SELECTED = "selectedItem", Ks.ACTIVE_CLASS = "ag-active-item", C([pe], Ks.prototype, "init", 1);
    var Xs = Ks,
      zs = class e extends Ys {
        constructor(e) {
          super(f({
            pickerAriaLabelKey: "ariaLabelSelectField",
            pickerAriaLabelValue: "Select Field",
            pickerType: "ag-list",
            className: "ag-select",
            pickerIcon: "smallDown",
            ariaRole: "combobox"
          }, e))
        }
        postConstruct() {
          super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
          const {
            options: e,
            value: t,
            placeholder: i
          } = this.config;
          null != e && this.addOptions(e), null != t && this.setValue(t, !0), i && null == t && (this.eDisplayField.textContent = i), this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this))
        }
        onWrapperFocusOut(e) {
          this.eWrapper.contains(e.relatedTarget) || this.hidePicker()
        }
        createListComponent() {
          this.listComponent = this.createBean(new Xs("select", !0)), this.listComponent.setParentComponent(this);
          const t = this.listComponent.getAriaElement(),
            i = `ag-select-list-${this.listComponent.getCompId()}`;
          t.setAttribute("id", i), Ri(this.getAriaElement(), t), this.listComponent.addManagedListener(this.listComponent, Xs.EVENT_ITEM_SELECTED, () => {
            this.hidePicker(), this.dispatchEvent({
              type: e.EVENT_ITEM_SELECTED
            })
          }), this.listComponent.addManagedListener(this.listComponent, Et.EVENT_FIELD_VALUE_CHANGED, () => {
            this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker())
          })
        }
        createPickerComponent() {
          return this.listComponent
        }
        onKeyDown(e) {
          var t;
          const {
            key: i
          } = e;
          switch (i === ts.TAB && this.hidePicker(), i) {
            case ts.ENTER:
            case ts.UP:
            case ts.DOWN:
            case ts.PAGE_UP:
            case ts.PAGE_DOWN:
            case ts.PAGE_HOME:
            case ts.PAGE_END:
              e.preventDefault(), this.isPickerDisplayed ? null == (t = this.listComponent) || t.handleKeyDown(e) : super.onKeyDown(e);
              break;
            case ts.ESCAPE:
              super.onKeyDown(e)
          }
        }
        showPicker() {
          this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted())
        }
        addOptions(e) {
          return e.forEach(e => this.addOption(e)), this
        }
        addOption(e) {
          return this.listComponent.addOption(e), this
        }
        clearOptions() {
          var e;
          return null == (e = this.listComponent) || e.clearOptions(), this
        }
        setValue(e, t, i) {
          if (this.value === e || !this.listComponent) return this;
          i || this.listComponent.setValue(e, !0);
          if (this.listComponent.getValue() === this.getValue()) return this;
          let r = this.listComponent.getDisplayValue();
          return null == r && this.config.placeholder && (r = this.config.placeholder), this.eDisplayField.textContent = r, this.setTooltip({
            newTooltipText: null != r ? r : null,
            shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
          }), super.setValue(e, t)
        }
        destroy() {
          this.listComponent && (this.destroyBean(this.listComponent), this.listComponent = void 0), super.destroy()
        }
      };
    zs.EVENT_ITEM_SELECTED = "selectedItem";
    var $s = zs,
      js = class extends Ws {
        constructor(e, t, i = "text", r = "input") {
          super(e, `\n            <div role="presentation">\n                <div ref="eLabel" class="ag-input-field-label"></div>\n                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">\n                    <${r} ref="eInput" class="ag-input-field-input"></${r}>\n                </div>\n            </div>`, t), this.inputType = i, this.displayFieldTag = r
        }
        postConstruct() {
          super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
          const {
            inputName: e,
            inputWidth: t
          } = this.config;
          null != e && this.setInputName(e), null != t && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput])
        }
        addInputListeners() {
          this.addManagedListener(this.eInput, "input", e => this.setValue(e.target.value))
        }
        setInputType() {
          "input" === this.displayFieldTag && this.eInput.setAttribute("type", this.inputType)
        }
        getInputElement() {
          return this.eInput
        }
        setInputWidth(e) {
          return Fr(this.eWrapper, e), this
        }
        setInputName(e) {
          return this.getInputElement().setAttribute("name", e), this
        }
        getFocusableElement() {
          return this.eInput
        }
        setMaxLength(e) {
          return this.eInput.maxLength = e, this
        }
        setInputPlaceholder(e) {
          return Wr(this.eInput, "placeholder", e), this
        }
        setInputAriaLabel(e) {
          return qt(this.eInput, e), this.refreshAriaLabelledBy(), this
        }
        setDisabled(e) {
          return pr(this.eInput, e), super.setDisabled(e)
        }
        setAutoComplete(e) {
          if (!0 === e) Wr(this.eInput, "autocomplete", null);
          else {
            const t = "string" == typeof e ? e : "off";
            Wr(this.eInput, "autocomplete", t)
          }
          return this
        }
      };
    C([ys("eLabel")], js.prototype, "eLabel", 2), C([ys("eWrapper")], js.prototype, "eWrapper", 2), C([ys("eInput")], js.prototype, "eInput", 2);
    var Js = class extends js {
        constructor(e, t = "ag-checkbox", i = "checkbox") {
          super(e, t, i), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1
        }
        postConstruct() {
          super.postConstruct();
          const {
            readOnly: e,
            passive: t
          } = this.config;
          "boolean" == typeof e && this.setReadOnly(e), "boolean" == typeof t && this.setPassive(t)
        }
        addInputListeners() {
          this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this)), this.addManagedListener(this.eLabel, "click", this.toggle.bind(this))
        }
        getNextValue() {
          return void 0 === this.selected || !this.selected
        }
        setPassive(e) {
          this.passive = e
        }
        isReadOnly() {
          return this.readOnly
        }
        setReadOnly(e) {
          this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e
        }
        setDisabled(e) {
          return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e)
        }
        toggle() {
          if (this.eInput.disabled) return;
          const e = this.isSelected(),
            t = this.getNextValue();
          this.passive ? this.dispatchChange(t, e) : this.setValue(t)
        }
        getValue() {
          return this.isSelected()
        }
        setValue(e, t) {
          return this.refreshSelectedClass(e), this.setSelected(e, t), this
        }
        setName(e) {
          return this.getInputElement().name = e, this
        }
        isSelected() {
          return this.selected
        }
        setSelected(e, t) {
          this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = "boolean" == typeof e ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = void 0 === e, t || this.dispatchChange(this.selected, this.previousValue))
        }
        dispatchChange(e, t, i) {
          this.dispatchEvent({
            type: Et.EVENT_FIELD_VALUE_CHANGED,
            selected: e,
            previousValue: t,
            event: i
          });
          const r = this.getInputElement(),
            s = {
              type: Et.EVENT_CHECKBOX_CHANGED,
              id: r.id,
              name: r.name,
              selected: e,
              previousValue: t
            };
          this.eventService.dispatchEvent(s)
        }
        onCheckboxClick(e) {
          if (this.passive || this.eInput.disabled) return;
          const t = this.isSelected(),
            i = this.selected = e.target.checked;
          this.refreshSelectedClass(i), this.dispatchChange(i, t, e)
        }
        refreshSelectedClass(e) {
          this.eWrapper.classList.toggle("ag-checked", !0 === e), this.eWrapper.classList.toggle("ag-indeterminate", null == e)
        }
      },
      qs = class extends Js {
        constructor(e) {
          super(e, "ag-radio-button", "radio")
        }
        isSelected() {
          return this.eInput.checked
        }
        toggle() {
          this.eInput.disabled || this.isSelected() || this.setValue(!0)
        }
        addInputListeners() {
          super.addInputListeners(), this.addManagedListener(this.eventService, Et.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this))
        }
        onChange(e) {
          e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0)
        }
      },
      Qs = class {
        constructor(e, t, i) {
          this.localeService = e, this.optionsFactory = t, this.valueFormatter = i
        }
        getModelAsString(e) {
          if (!e) return null;
          const t = null != e.operator,
            i = this.localeService.getLocaleTextFunc();
          if (t) {
            const t = e;
            let {
              conditions: r
            } = t;
            if (!r) {
              const {
                condition1: e,
                condition2: i
              } = t;
              r = [e, i]
            }
            const s = r.map(e => this.getModelAsString(e)),
              n = "AND" === t.operator ? "andCondition" : "orCondition";
            return s.join(` ${i(n,Ms[n])} `)
          }
          if (e.type === en.BLANK || e.type === en.NOT_BLANK) return i(e.type, e.type); {
            const t = e,
              r = this.optionsFactory.getCustomOption(t.type),
              {
                displayKey: s,
                displayName: n,
                numberOfInputs: o
              } = r || {};
            return s && n && 0 === o ? (i(s, n), n) : this.conditionToString(t, r)
          }
        }
        updateParams(e) {
          this.optionsFactory = e.optionsFactory
        }
        formatValue(e) {
          var t;
          return this.valueFormatter ? null != (t = this.valueFormatter(null != e ? e : null)) ? t : "" : String(e)
        }
      },
      Zs = class e extends Bs {
        constructor() {
          super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0
        }
        getNumberOfInputs(t) {
          const i = this.optionsFactory.getCustomOption(t);
          if (i) {
            const {
              numberOfInputs: e
            } = i;
            return null != e ? e : 1
          }
          const r = [e.EMPTY, e.NOT_BLANK, e.BLANK];
          return t && r.indexOf(t) >= 0 ? 0 : t === e.IN_RANGE ? 2 : 1
        }
        onFloatingFilterChanged(e, t) {
          this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0)
        }
        setTypeFromFloatingFilter(e) {
          this.eTypes.forEach((t, i) => {
            0 === i ? t.setValue(e, !0) : t.setValue(this.optionsFactory.getDefaultOption(), !0)
          })
        }
        getModelFromUi() {
          const e = this.getUiCompleteConditions();
          return 0 === e.length ? null : this.maxNumConditions > 1 && e.length > 1 ? {
            filterType: this.getFilterType(),
            operator: this.getJoinOperator(),
            condition1: e[0],
            condition2: e[1],
            conditions: e
          } : e[0]
        }
        getConditionTypes() {
          return this.eTypes.map(e => e.getValue())
        }
        getConditionType(e) {
          return this.eTypes[e].getValue()
        }
        getJoinOperator() {
          return 0 === this.eJoinOperatorsOr.length ? this.defaultJoinOperator : !0 === this.eJoinOperatorsOr[0].getValue() ? "OR" : "AND"
        }
        areModelsEqual(e, t) {
          if (!e && !t) return !0;
          if (!e && t || e && !t) return !1;
          const i = !e.operator,
            r = !t.operator;
          if (!i && r || i && !r) return !1;
          let s;
          if (i) {
            const i = e,
              r = t;
            s = this.areSimpleModelsEqual(i, r)
          } else {
            const i = e,
              r = t;
            s = i.operator === r.operator && Fe(i.conditions, r.conditions, (e, t) => this.areSimpleModelsEqual(e, t))
          }
          return s
        }
        shouldRefresh(e) {
          var t, i, r;
          const s = this.getModel(),
            n = s ? null != (t = s.conditions) ? t : [s] : null,
            o = null != (r = null == (i = e.filterOptions) ? void 0 : i.map(e => "string" == typeof e ? e : e.displayKey)) ? r : this.getDefaultFilterOptions();
          return !(n && !n.every(e => void 0 !== o.find(t => t === e.type))) && !("number" == typeof e.maxNumConditions && n && n.length > e.maxNumConditions)
        }
        refresh(e) {
          if (!this.shouldRefresh(e)) return !1;
          return !!super.refresh(e) && (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0)
        }
        setModelIntoUi(e) {
          if (e.operator) {
            let t = e;
            t.conditions || (t.conditions = [t.condition1, t.condition2]);
            const i = this.validateAndUpdateConditions(t.conditions),
              r = this.getNumConditions();
            if (i < r) this.removeConditionsAndOperators(i);
            else if (i > r)
              for (let e = r; e < i; e++) this.createJoinOperatorPanel(), this.createOption();
            const s = "OR" === t.operator;
            this.eJoinOperatorsAnd.forEach(e => e.setValue(!s, !0)), this.eJoinOperatorsOr.forEach(e => e.setValue(s, !0)), t.conditions.forEach((e, t) => {
              this.eTypes[t].setValue(e.type, !0), this.setConditionIntoUi(e, t)
            })
          } else {
            const t = e;
            this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(t.type, !0), this.setConditionIntoUi(t, 0)
          }
          return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), Rs.resolve()
        }
        validateAndUpdateConditions(e) {
          let t = e.length;
          return t > this.maxNumConditions && (e.splice(this.maxNumConditions), z('Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'), t = this.maxNumConditions), t
        }
        doesFilterPass(e) {
          var t;
          const i = this.getModel();
          if (null == i) return !0;
          const {
            operator: r
          } = i, s = [];
          if (r) {
            const e = i;
            s.push(...null != (t = e.conditions) ? t : [])
          } else s.push(i);
          return s[r && "OR" === r ? "some" : "every"](t => this.individualConditionPasses(e, t))
        }
        setParams(e) {
          super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new bs, this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1")
        }
        setNumConditions(e) {
          var t, i;
          null != e.suppressAndOrCondition && z('Since v29.2 "filterParams.suppressAndOrCondition" is deprecated. Use "filterParams.maxNumConditions = 1" instead.'), null != e.alwaysShowBothConditions && z('Since v29.2 "filterParams.alwaysShowBothConditions" is deprecated. Use "filterParams.numAlwaysVisibleConditions = 2" instead.'), this.maxNumConditions = null != (t = e.maxNumConditions) ? t : e.suppressAndOrCondition ? 1 : 2, this.maxNumConditions < 1 && (z('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = null != (i = e.numAlwaysVisibleConditions) ? i : e.alwaysShowBothConditions ? 2 : 1, this.numAlwaysVisibleConditions < 1 && (z('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (z('"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'), this.numAlwaysVisibleConditions = this.maxNumConditions)
        }
        createOption() {
          const e = this.createManagedBean(new $s);
          this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
          const t = this.createValueElement();
          this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
          const i = this.getNumConditions() - 1;
          this.forEachPositionInput(i, e => this.resetInput(e)), this.addChangedListeners(e, i)
        }
        createJoinOperatorPanel() {
          const e = document.createElement("div");
          this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
          const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"),
            i = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
          this.eFilterBody.appendChild(e);
          const r = this.eJoinOperatorPanels.length - 1,
            s = this.joinOperatorId++;
          this.resetJoinOperatorAnd(t, r, s), this.resetJoinOperatorOr(i, r, s), this.isReadOnly() || (t.onValueChange(this.listener), i.onValueChange(this.listener))
        }
        createJoinOperator(e, t, i) {
          const r = this.createManagedBean(new qs);
          return e.push(r), r.addCssClass("ag-filter-condition-operator"), r.addCssClass(`ag-filter-condition-operator-${i}`), t.appendChild(r.getGui()), r
        }
        getDefaultJoinOperator(e) {
          return "AND" === e || "OR" === e ? e : "AND"
        }
        createFilterListOptions() {
          const e = this.optionsFactory.getFilterOptions();
          this.filterListOptions = e.map(e => "string" == typeof e ? this.createBoilerplateListOption(e) : this.createCustomListOption(e))
        }
        putOptionsIntoDropdown(e) {
          this.filterListOptions.forEach(t => {
            e.addOption(t)
          }), e.setDisabled(this.filterListOptions.length <= 1)
        }
        createBoilerplateListOption(e) {
          return {
            value: e,
            text: this.translate(e)
          }
        }
        createCustomListOption(e) {
          const {
            displayKey: t
          } = e, i = this.optionsFactory.getCustomOption(e.displayKey);
          return {
            value: t,
            text: i ? this.localeService.getLocaleTextFunc()(i.displayKey, i.displayName) : this.translate(t)
          }
        }
        isAllowTwoConditions() {
          return this.maxNumConditions >= 2
        }
        createBodyTemplate() {
          return ""
        }
        getCssIdentifier() {
          return "simple-filter"
        }
        updateUiVisibility() {
          const e = this.getJoinOperator();
          this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e)
        }
        updateNumConditions() {
          var e;
          let t = -1,
            i = !0;
          for (let e = 0; e < this.getNumConditions(); e++) this.isConditionUiComplete(e) ? t = e : i = !1;
          if (this.shouldAddNewConditionAtEnd(i)) this.createJoinOperatorPanel(), this.createOption();
          else {
            const i = null != (e = this.lastUiCompletePosition) ? e : this.getNumConditions() - 2;
            if (t < i) {
              this.removeConditionsAndOperators(i + 1);
              const e = t + 1,
                r = i - e;
              r > 0 && this.removeConditionsAndOperators(e, r), this.createMissingConditionsAndOperators()
            }
          }
          this.lastUiCompletePosition = t
        }
        updateConditionStatusesAndValues(e, t) {
          this.eTypes.forEach((t, i) => {
            const r = this.isConditionDisabled(i, e);
            t.setDisabled(r || this.filterListOptions.length <= 1), 1 === i && (pr(this.eJoinOperatorPanels[0], r), this.eJoinOperatorsAnd[0].setDisabled(r), this.eJoinOperatorsOr[0].setDisabled(r))
          }), this.eConditionBodies.forEach((e, t) => {
            ur(e, this.isConditionBodyVisible(t))
          });
          const i = "OR" === (null != t ? t : this.getJoinOperator());
          this.eJoinOperatorsAnd.forEach((e, t) => {
            e.setValue(!i, !0)
          }), this.eJoinOperatorsOr.forEach((e, t) => {
            e.setValue(i, !0)
          }), this.forEachInput((t, i, r, s) => {
            this.setElementDisplayed(t, i < s), this.setElementDisabled(t, this.isConditionDisabled(r, e))
          }), this.resetPlaceholder()
        }
        shouldAddNewConditionAtEnd(e) {
          return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly()
        }
        removeConditionsAndOperators(e, t) {
          if (e >= this.getNumConditions()) return;
          this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
          const i = Math.max(e - 1, 0);
          this.removeElements(this.eJoinOperatorPanels, i, t), this.removeComponents(this.eJoinOperatorsAnd, i, t), this.removeComponents(this.eJoinOperatorsOr, i, t)
        }
        removeElements(e, t, i) {
          this.removeItems(e, t, i).forEach(e => Ir(e))
        }
        removeComponents(e, t, i) {
          this.removeItems(e, t, i).forEach(e => {
            Ir(e.getGui()), this.destroyBean(e)
          })
        }
        removeItems(e, t, i) {
          return null == i ? e.splice(t) : e.splice(t, i)
        }
        afterGuiAttached(e) {
          if (super.afterGuiAttached(e), this.resetPlaceholder(), !(null == e ? void 0 : e.suppressFocus))
            if (this.isReadOnly()) this.eFilterBody.focus();
            else {
              const e = this.getInputs(0)[0];
              if (!e) return;
              e instanceof js && e.getInputElement().focus()
            }
        }
        afterGuiDetached() {
          super.afterGuiDetached();
          const e = this.getModel();
          this.resetUiToActiveModel(e);
          let t = -1,
            i = -1,
            r = !1;
          const s = this.getJoinOperator();
          for (let e = this.getNumConditions() - 1; e >= 0; e--)
            if (this.isConditionUiComplete(e)) - 1 === t && (t = e, i = e);
            else {
              const s = e < t;
              (e >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(e - 1) || s) && (this.removeConditionsAndOperators(e, 1), r = !0, s && i--)
            } let n = !1;
          this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), n = !0), this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), n = !0), n && this.updateConditionStatusesAndValues(i, s), r && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = i
        }
        getPlaceholderText(e, t) {
          let i = this.translate(e);
          if (q(this.filterPlaceholder)) {
            const e = this.filterPlaceholder,
              r = this.eTypes[t].getValue();
            i = e({
              filterOptionKey: r,
              filterOption: this.translate(r),
              placeholder: i
            })
          } else "string" == typeof this.filterPlaceholder && (i = this.filterPlaceholder);
          return i
        }
        resetPlaceholder() {
          const e = this.localeService.getLocaleTextFunc();
          this.forEachInput((t, i, r, s) => {
            if (!(t instanceof js)) return;
            const n = 0 === i && s > 1 ? "inRangeStart" : 0 === i ? "filterOoo" : "inRangeEnd",
              o = 0 === i && s > 1 ? e("ariaFilterFromValue", "Filter from value") : 0 === i ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
            t.setInputPlaceholder(this.getPlaceholderText(n, r)), t.setInputAriaLabel(o)
          })
        }
        setElementValue(e, t, i) {
          e instanceof js && e.setValue(null != t ? String(t) : null, !0)
        }
        setElementDisplayed(e, t) {
          e instanceof _s && ur(e.getGui(), t)
        }
        setElementDisabled(e, t) {
          e instanceof _s && pr(e.getGui(), t)
        }
        attachElementOnChange(e, t) {
          e instanceof js && e.onValueChange(t)
        }
        forEachInput(e) {
          this.getConditionTypes().forEach((t, i) => {
            this.forEachPositionTypeInput(i, t, e)
          })
        }
        forEachPositionInput(e, t) {
          const i = this.getConditionType(e);
          this.forEachPositionTypeInput(e, i, t)
        }
        forEachPositionTypeInput(e, t, i) {
          const r = this.getNumberOfInputs(t),
            s = this.getInputs(e);
          for (let t = 0; t < s.length; t++) {
            const n = s[t];
            null != n && i(n, t, e, r)
          }
        }
        isConditionDisabled(e, t) {
          return !!this.isReadOnly() || 0 !== e && e > t + 1
        }
        isConditionBodyVisible(e) {
          const t = this.getConditionType(e);
          return this.getNumberOfInputs(t) > 0
        }
        isConditionUiComplete(t) {
          if (t >= this.getNumConditions()) return !1;
          return this.getConditionType(t) !== e.EMPTY && !this.getValues(t).some(e => null == e)
        }
        getNumConditions() {
          return this.eTypes.length
        }
        getUiCompleteConditions() {
          const e = [];
          for (let t = 0; t < this.getNumConditions(); t++) this.isConditionUiComplete(t) && e.push(this.createCondition(t));
          return e
        }
        createMissingConditionsAndOperators() {
          if (!this.isReadOnly())
            for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++) this.createJoinOperatorPanel(), this.createOption()
        }
        resetUiToDefaults(e) {
          return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach(e => this.resetType(e)), this.eJoinOperatorsAnd.forEach((e, t) => this.resetJoinOperatorAnd(e, t, this.joinOperatorId + t)), this.eJoinOperatorsOr.forEach((e, t) => this.resetJoinOperatorOr(e, t, this.joinOperatorId + t)), this.joinOperatorId++, this.forEachInput(e => this.resetInput(e)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), Rs.resolve()
        }
        resetType(e) {
          const t = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
          e.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(t).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1)
        }
        resetJoinOperatorAnd(e, t, i) {
          this.resetJoinOperator(e, t, this.isDefaultOperator("AND"), this.translate("andCondition"), i)
        }
        resetJoinOperatorOr(e, t, i) {
          this.resetJoinOperator(e, t, this.isDefaultOperator("OR"), this.translate("orCondition"), i)
        }
        resetJoinOperator(e, t, i, r, s) {
          this.updateJoinOperatorDisabled(e.setValue(i, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${s}`).setLabel(r), t)
        }
        updateJoinOperatorsDisabled() {
          this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t))
        }
        updateJoinOperatorDisabled(e, t) {
          e.setDisabled(this.isReadOnly() || t > 0)
        }
        resetInput(e) {
          this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly())
        }
        setConditionIntoUi(e, t) {
          const i = this.mapValuesFromModel(e);
          this.forEachInput((e, r, s, n) => {
            s === t && this.setElementValue(e, null != i[r] ? i[r] : null)
          })
        }
        setValueFromFloatingFilter(e) {
          this.forEachInput((t, i, r, s) => {
            this.setElementValue(t, 0 === i && 0 === r ? e : null, !0)
          })
        }
        isDefaultOperator(e) {
          return e === this.defaultJoinOperator
        }
        addChangedListeners(e, t) {
          this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, e => {
            this.attachElementOnChange(e, this.listener)
          }))
        }
        individualConditionPasses(e, t) {
          const i = this.getCellValue(e.node),
            r = this.mapValuesFromModel(t),
            s = this.optionsFactory.getCustomOption(t.type),
            n = this.evaluateCustomFilter(s, r, i);
          return null != n ? n : null == i ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(r, i, t, e)
        }
        evaluateCustomFilter(e, t, i) {
          if (null == e) return;
          const {
            predicate: r
          } = e;
          return null == r || t.some(e => null == e) ? void 0 : r(t, i)
        }
        isBlank(e) {
          return null == e || "string" == typeof e && 0 === e.trim().length
        }
        hasInvalidInputs() {
          return !1
        }
      };
    Zs.EMPTY = "empty", Zs.BLANK = "blank", Zs.NOT_BLANK = "notBlank", Zs.EQUALS = "equals", Zs.NOT_EQUAL = "notEqual", Zs.LESS_THAN = "lessThan", Zs.LESS_THAN_OR_EQUAL = "lessThanOrEqual", Zs.GREATER_THAN = "greaterThan", Zs.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", Zs.IN_RANGE = "inRange", Zs.CONTAINS = "contains", Zs.NOT_CONTAINS = "notContains", Zs.STARTS_WITH = "startsWith", Zs.ENDS_WITH = "endsWith";
    var en = Zs,
      tn = class e extends en {
        setParams(e) {
          super.setParams(e), this.scalarFilterParams = e
        }
        evaluateNullValue(t) {
          switch (t) {
            case e.EQUALS:
            case e.NOT_EQUAL:
              if (this.scalarFilterParams.includeBlanksInEquals) return !0;
              break;
            case e.GREATER_THAN:
            case e.GREATER_THAN_OR_EQUAL:
              if (this.scalarFilterParams.includeBlanksInGreaterThan) return !0;
              break;
            case e.LESS_THAN:
            case e.LESS_THAN_OR_EQUAL:
              if (this.scalarFilterParams.includeBlanksInLessThan) return !0;
              break;
            case e.IN_RANGE:
              if (this.scalarFilterParams.includeBlanksInRange) return !0;
              break;
            case e.BLANK:
              return !0;
            case e.NOT_BLANK:
              return !1
          }
          return !1
        }
        evaluateNonNullValue(t, i, r) {
          const s = this.comparator(),
            n = null != t[0] ? s(t[0], i) : 0;
          switch (r.type) {
            case e.EQUALS:
              return 0 === n;
            case e.NOT_EQUAL:
              return 0 !== n;
            case e.GREATER_THAN:
              return n > 0;
            case e.GREATER_THAN_OR_EQUAL:
              return n >= 0;
            case e.LESS_THAN:
              return n < 0;
            case e.LESS_THAN_OR_EQUAL:
              return n <= 0;
            case e.IN_RANGE: {
              const e = s(t[1], i);
              return this.scalarFilterParams.inRangeInclusive ? n >= 0 && e <= 0 : n > 0 && e < 0
            }
            case e.BLANK:
              return this.isBlank(i);
            case e.NOT_BLANK:
              return !this.isBlank(i);
            default:
              return console.warn('AG Grid: Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'), !0
          }
        }
      },
      rn = 1 / 0,
      sn = class extends Qs {
        constructor(e, t, i) {
          super(t, i), this.dateFilterParams = e
        }
        conditionToString(e, t) {
          const {
            type: i
          } = e, {
            numberOfInputs: r
          } = t || {}, s = i == en.IN_RANGE || 2 === r, n = sr(e.dateFrom), o = sr(e.dateTo), a = this.dateFilterParams.inRangeFloatingFilterDateFormat;
          if (s) {
            return `${null!==n?rr(n,a):"null"}-${null!==o?rr(o,a):"null"}`
          }
          return null != n ? rr(n, a) : `${i}`
        }
        updateParams(e) {
          super.updateParams(e), this.dateFilterParams = e.dateFilterParams
        }
      },
      nn = class e extends tn {
        constructor() {
          super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = 1e3, this.maxValidYear = rn, this.minValidDate = null, this.maxValidDate = null
        }
        afterGuiAttached(e) {
          super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e)
        }
        mapValuesFromModel(e) {
          const {
            dateFrom: t,
            dateTo: i,
            type: r
          } = e || {};
          return [t && sr(t) || null, i && sr(i) || null].slice(0, this.getNumberOfInputs(r))
        }
        comparator() {
          return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this)
        }
        defaultComparator(e, t) {
          return null == t || t < e ? -1 : t > e ? 1 : 0
        }
        setParams(e) {
          this.dateFilterParams = e, super.setParams(e);
          const t = (t, i) => {
            if (null != e[t]) {
              if (!isNaN(e[t])) return null == e[t] ? i : Number(e[t]);
              console.warn(`AG Grid: DateFilter ${t} is not a number`)
            }
            return i
          };
          this.minValidYear = t("minValidYear", 1e3), this.maxValidYear = t("maxValidYear", rn), this.minValidYear > this.maxValidYear && console.warn("AG Grid: DateFilter minValidYear should be <= maxValidYear"), e.minValidDate ? this.minValidDate = e.minValidDate instanceof Date ? e.minValidDate : sr(e.minValidDate) : this.minValidDate = null, e.maxValidDate ? this.maxValidDate = e.maxValidDate instanceof Date ? e.maxValidDate : sr(e.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && console.warn("AG Grid: DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new sn(this.dateFilterParams, this.localeService, this.optionsFactory)
        }
        createDateCompWrapper(e) {
          const t = new Ps(this.getContext(), this.userComponentFactory, {
            onDateChanged: () => this.onUiChanged(),
            filterParams: this.dateFilterParams
          }, e);
          return this.addDestroyFunc(() => t.destroy()), t
        }
        setElementValue(e, t) {
          e.setDate(t)
        }
        setElementDisplayed(e, t) {
          e.setDisplayed(t)
        }
        setElementDisabled(e, t) {
          e.setDisabled(t)
        }
        getDefaultFilterOptions() {
          return e.DEFAULT_FILTER_OPTIONS
        }
        createValueElement() {
          const e = this.gos.getDocument().createElement("div");
          return e.classList.add("ag-filter-body"), this.createFromToElement(e, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(e, this.eConditionPanelsTo, this.dateConditionToComps, "to"), e
        }
        createFromToElement(e, t, i, r) {
          const s = this.gos.getDocument().createElement("div");
          s.classList.add(`ag-filter-${r}`), s.classList.add(`ag-filter-date-${r}`), t.push(s), e.appendChild(s), i.push(this.createDateCompWrapper(s))
        }
        removeValueElements(e, t) {
          this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t)
        }
        removeDateComps(e, t, i) {
          this.removeItems(e, t, i).forEach(e => e.destroy())
        }
        isValidDateValue(e) {
          if (null === e) return !1;
          if (this.minValidDate) {
            if (e < this.minValidDate) return !1
          } else if (e.getUTCFullYear() < this.minValidYear) return !1;
          if (this.maxValidDate) {
            if (e > this.maxValidDate) return !1
          } else if (e.getUTCFullYear() > this.maxValidYear) return !1;
          return !0
        }
        isConditionUiComplete(e) {
          if (!super.isConditionUiComplete(e)) return !1;
          let t = !0;
          return this.forEachInput((i, r, s, n) => {
            s !== e || !t || r >= n || (t = t && this.isValidDateValue(i.getDate()))
          }), t
        }
        areSimpleModelsEqual(e, t) {
          return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type
        }
        getFilterType() {
          return "date"
        }
        createCondition(e) {
          const t = this.getConditionType(e),
            i = {},
            r = this.getValues(e);
          return r.length > 0 && (i.dateFrom = tr(r[0])), r.length > 1 && (i.dateTo = tr(r[1])), f({
            dateFrom: null,
            dateTo: null,
            filterType: this.getFilterType(),
            type: t
          }, i)
        }
        resetPlaceholder() {
          const e = this.localeService.getLocaleTextFunc(),
            t = this.translate("dateFormatOoo"),
            i = e("ariaFilterValue", "Filter Value");
          this.forEachInput(e => {
            e.setInputPlaceholder(t), e.setInputAriaLabel(i)
          })
        }
        getInputs(e) {
          return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]]
        }
        getValues(e) {
          const t = [];
          return this.forEachPositionInput(e, (e, i, r, s) => {
            i < s && t.push(e.getDate())
          }), t
        }
        translate(e) {
          return e === tn.LESS_THAN ? super.translate("before") : e === tn.GREATER_THAN ? super.translate("after") : super.translate(e)
        }
        getModelAsString(e) {
          var t;
          return null != (t = this.filterModelFormatter.getModelAsString(e)) ? t : ""
        }
      };
    nn.DEFAULT_FILTER_OPTIONS = [tn.EQUALS, tn.NOT_EQUAL, tn.LESS_THAN, tn.GREATER_THAN, tn.IN_RANGE, tn.BLANK, tn.NOT_BLANK], C([fe("userComponentFactory")], nn.prototype, "userComponentFactory", 2);
    var on = nn,
      an = class extends _s {
        getDefaultDebounceMs() {
          return 0
        }
        destroy() {
          super.destroy()
        }
        isEventFromFloatingFilter(e) {
          return e && e.afterFloatingFilter
        }
        isEventFromDataChange(e) {
          return null == e ? void 0 : e.afterDataChange
        }
        getLastType() {
          return this.lastType
        }
        isReadOnly() {
          return this.readOnly
        }
        setLastTypeFromModel(e) {
          if (!e) return void(this.lastType = this.optionsFactory.getDefaultOption());
          let t;
          if (e.operator) {
            t = e.conditions[0]
          } else t = e;
          this.lastType = t.type
        }
        canWeEditAfterModelFromParentFilter(e) {
          if (!e) return this.isTypeEditable(this.lastType);
          if (e.operator) return !1;
          const t = e;
          return this.isTypeEditable(t.type)
        }
        init(e) {
          this.setSimpleParams(e, !1)
        }
        setSimpleParams(e, t = !0) {
          this.optionsFactory = new bs, this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
          const i = this.isTypeEditable(this.optionsFactory.getDefaultOption());
          this.setEditable(i)
        }
        onParamsUpdated(e) {
          this.refresh(e)
        }
        refresh(e) {
          this.setSimpleParams(e)
        }
        doesFilterHaveSingleInput(e) {
          const t = this.optionsFactory.getCustomOption(e),
            {
              numberOfInputs: i
            } = t || {};
          return null == i || 1 == i
        }
        isTypeEditable(e) {
          const t = [en.IN_RANGE, en.EMPTY, en.BLANK, en.NOT_BLANK];
          return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0
        }
        getAriaLabel(e) {
          return `${this.columnModel.getDisplayNameForColumn(e.column,"header",!0)} ${this.localeService.getLocaleTextFunc()("ariaFilterInput","Filter Input")}`
        }
      };
    C([fe("columnModel")], an.prototype, "columnModel", 2);
    var ln = class extends an {
      constructor() {
        super('\n            <div class="ag-floating-filter-input" role="presentation">\n                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>\n                <div ref="eDateWrapper" style="display: flex;"></div>\n            </div>')
      }
      getDefaultFilterOptions() {
        return on.DEFAULT_FILTER_OPTIONS
      }
      init(e) {
        super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new sn(this.filterParams, this.localeService, this.optionsFactory);
        const t = this.localeService.getLocaleTextFunc();
        this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"))
      }
      onParamsUpdated(e) {
        this.refresh(e)
      }
      refresh(e) {
        super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({
          optionsFactory: this.optionsFactory,
          dateFilterParams: this.filterParams
        }), this.updateCompOnModelChange(e.currentParentModel())
      }
      updateCompOnModelChange(e) {
        const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
        if (this.setEditable(t), t) {
          if (e) {
            const t = e;
            this.dateComp.setDate(sr(t.dateFrom))
          } else this.dateComp.setDate(null);
          this.eReadOnlyText.setValue("")
        } else this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null)
      }
      setEditable(e) {
        ur(this.eDateWrapper, e), ur(this.eReadOnlyText.getGui(), !e)
      }
      onParentModelChanged(e, t) {
        this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e))
      }
      onDateChanged() {
        const e = tr(this.dateComp.getDate());
        this.params.parentFilterInstance(t => {
          if (t) {
            const i = sr(e);
            t.onFloatingFilterChanged(this.getLastType() || null, i)
          }
        })
      }
      getDateComponentParams() {
        const e = Bs.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
        return {
          onDateChanged: re(this.onDateChanged.bind(this), e),
          filterParams: this.params.column.getColDef().filterParams
        }
      }
      createDateComponent() {
        this.dateComp = new Ps(this.getContext(), this.userComponentFactory, this.getDateComponentParams(), this.eDateWrapper, e => {
          e.setInputAriaLabel(this.getAriaLabel(this.params))
        }), this.addDestroyFunc(() => this.dateComp.destroy())
      }
      updateDateComponent() {
        const e = this.gos.addGridCommonParams(this.getDateComponentParams());
        this.dateComp.updateParams(e)
      }
      getFilterModelFormatter() {
        return this.filterModelFormatter
      }
    };
    C([fe("userComponentFactory")], ln.prototype, "userComponentFactory", 2), C([ys("eReadOnlyText")], ln.prototype, "eReadOnlyText", 2), C([ys("eDateWrapper")], ln.prototype, "eDateWrapper", 2);
    var cn = class extends _s {
      constructor() {
        super('\n            <div class="ag-filter-filter">\n                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>\n            </div>')
      }
      destroy() {
        super.destroy()
      }
      init(e) {
        this.params = e, this.setParams(e);
        const t = this.eDateInput.getInputElement();
        this.addManagedListener(t, "mousedown", () => {
          this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus()
        }), this.addManagedListener(t, "input", e => {
          e.target === this.gos.getActiveDomElement() && (this.eDateInput.isDisabled() || this.params.onDateChanged())
        })
      }
      setParams(e) {
        const t = this.eDateInput.getInputElement(),
          i = this.shouldUseBrowserDatePicker(e);
        this.usingSafariDatePicker = i && Pi(), t.type = i ? "date" : "text";
        const {
          minValidYear: r,
          maxValidYear: s,
          minValidDate: n,
          maxValidDate: o
        } = e.filterParams || {};
        if (n && r && z("DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."), o && s && z("DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."), n && o) {
          const [e, t] = [n, o].map(e => e instanceof Date ? e : sr(e));
          e && t && e.getTime() > t.getTime() && z("DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.")
        }
        n ? n instanceof Date ? t.min = rr(n) : t.min = n : r && (t.min = `${r}-01-01`), o ? o instanceof Date ? t.max = rr(o) : t.max = o : s && (t.max = `${s}-12-31`)
      }
      onParamsUpdated(e) {
        this.refresh(e)
      }
      refresh(e) {
        this.params = e, this.setParams(e)
      }
      getDate() {
        return sr(this.eDateInput.getValue())
      }
      setDate(e) {
        this.eDateInput.setValue(tr(e, !1))
      }
      setInputPlaceholder(e) {
        this.eDateInput.setInputPlaceholder(e)
      }
      setInputAriaLabel(e) {
        this.eDateInput.setAriaLabel(e)
      }
      setDisabled(e) {
        this.eDateInput.setDisabled(e)
      }
      afterGuiAttached(e) {
        e && e.suppressFocus || this.eDateInput.getInputElement().focus()
      }
      shouldUseBrowserDatePicker(e) {
        return e.filterParams && null != e.filterParams.browserDatePicker ? e.filterParams.browserDatePicker : Mi() || Fi() || Pi() && bi() >= 14.1
      }
    };
    C([ys("eDateInput")], cn.prototype, "eDateInput", 2);
    var hn = class extends js {
        constructor(e, t = "ag-text-field", i = "text") {
          super(e, t, i)
        }
        postConstruct() {
          super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters()
        }
        setValue(e, t) {
          return this.eInput.value !== e && (this.eInput.value = v(e) ? e : ""), super.setValue(e, t)
        }
        setStartValue(e) {
          this.setValue(e, !0)
        }
        preventDisallowedCharacters() {
          const e = new RegExp(`[${this.config.allowedCharPattern}]`);
          this.addManagedListener(this.eInput, "keydown", t => {
            ls(t) && t.key && !e.test(t.key) && t.preventDefault()
          }), this.addManagedListener(this.eInput, "paste", t => {
            var i;
            const r = null == (i = t.clipboardData) ? void 0 : i.getData("text");
            r && r.split("").some(t => !e.test(t)) && t.preventDefault()
          })
        }
      },
      un = class extends hn {
        constructor(e) {
          super(e, "ag-number-field", "number")
        }
        postConstruct() {
          super.postConstruct(), this.addManagedListener(this.eInput, "blur", () => {
            const e = parseFloat(this.eInput.value),
              t = isNaN(e) ? "" : this.normalizeValue(e.toString());
            this.value !== t && this.setValue(t)
          }), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this)), this.eInput.step = "any";
          const {
            precision: e,
            min: t,
            max: i,
            step: r
          } = this.config;
          "number" == typeof e && this.setPrecision(e), "number" == typeof t && this.setMin(t), "number" == typeof i && this.setMax(i), "number" == typeof r && this.setStep(r)
        }
        onWheel(e) {
          this.gos.getActiveDomElement() === this.eInput && e.preventDefault()
        }
        normalizeValue(e) {
          if ("" === e) return "";
          null != this.precision && (e = this.adjustPrecision(e));
          const t = parseFloat(e);
          return null != this.min && t < this.min ? e = this.min.toString() : null != this.max && t > this.max && (e = this.max.toString()), e
        }
        adjustPrecision(e, t) {
          if (null == this.precision) return e;
          if (t) {
            const t = parseFloat(e).toFixed(this.precision);
            return parseFloat(t).toString()
          }
          const i = String(e).split(".");
          if (i.length > 1) {
            if (i[1].length <= this.precision) return e;
            if (this.precision > 0) return `${i[0]}.${i[1].slice(0,this.precision)}`
          }
          return i[0]
        }
        setMin(e) {
          return this.min === e || (this.min = e, Wr(this.eInput, "min", e)), this
        }
        setMax(e) {
          return this.max === e || (this.max = e, Wr(this.eInput, "max", e)), this
        }
        setPrecision(e) {
          return this.precision = e, this
        }
        setStep(e) {
          return this.step === e || (this.step = e, Wr(this.eInput, "step", e)), this
        }
        setValue(e, t) {
          return this.setValueOrInputValue(e => super.setValue(e, t), () => this, e)
        }
        setStartValue(e) {
          return this.setValueOrInputValue(e => super.setValue(e, !0), e => {
            this.eInput.value = e
          }, e)
        }
        setValueOrInputValue(e, t, i) {
          if (v(i)) {
            let r = this.isScientificNotation(i);
            if (r && this.eInput.validity.valid) return e(i);
            if (!r) {
              r = (i = this.adjustPrecision(i)) != this.normalizeValue(i)
            }
            if (r) return t(i)
          }
          return e(i)
        }
        getValue() {
          if (!this.eInput.validity.valid) return;
          const e = this.eInput.value;
          return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue()
        }
        isScientificNotation(e) {
          return "string" == typeof e && e.includes("e")
        }
      },
      dn = class extends Qs {
        conditionToString(e, t) {
          const {
            numberOfInputs: i
          } = t || {};
          return e.type == en.IN_RANGE || 2 === i ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : null != e.filter ? this.formatValue(e.filter) : `${e.type}`
        }
      };

    function pn(e) {
      const {
        allowedCharPattern: t
      } = null != e ? e : {};
      return null != t ? t : null
    }
    var En = class e extends tn {
      constructor() {
        super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = []
      }
      refresh(e) {
        return this.numberFilterParams.allowedCharPattern === e.allowedCharPattern && super.refresh(e)
      }
      mapValuesFromModel(e) {
        const {
          filter: t,
          filterTo: i,
          type: r
        } = e || {};
        return [this.processValue(t), this.processValue(i)].slice(0, this.getNumberOfInputs(r))
      }
      getDefaultDebounceMs() {
        return 500
      }
      comparator() {
        return (e, t) => e === t ? 0 : e < t ? 1 : -1
      }
      setParams(e) {
        this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new dn(this.localeService, this.optionsFactory, this.numberFilterParams.numberFormatter)
      }
      getDefaultFilterOptions() {
        return e.DEFAULT_FILTER_OPTIONS
      }
      setElementValue(e, t, i) {
        const r = !i && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(null != t ? t : null) : t;
        super.setElementValue(e, r)
      }
      createValueElement() {
        const e = pn(this.numberFilterParams),
          t = document.createElement("div");
        return t.classList.add("ag-filter-body"), Xt(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t
      }
      createFromToElement(e, t, i, r) {
        const s = this.createManagedBean(r ? new hn({
          allowedCharPattern: r
        }) : new un);
        s.addCssClass(`ag-filter-${i}`), s.addCssClass("ag-filter-filter"), t.push(s), e.appendChild(s.getGui())
      }
      removeValueElements(e, t) {
        this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t)
      }
      getValues(e) {
        const t = [];
        return this.forEachPositionInput(e, (e, i, r, s) => {
          i < s && t.push(this.processValue(this.stringToFloat(e.getValue())))
        }), t
      }
      areSimpleModelsEqual(e, t) {
        return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type
      }
      getFilterType() {
        return "number"
      }
      processValue(e) {
        return null == e || isNaN(e) ? null : e
      }
      stringToFloat(e) {
        if ("number" == typeof e) return e;
        let t = A(e);
        return null != t && "" === t.trim() && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : null == t || "-" === t.trim() ? null : parseFloat(t)
      }
      createCondition(e) {
        const t = this.getConditionType(e),
          i = {
            filterType: this.getFilterType(),
            type: t
          },
          r = this.getValues(e);
        return r.length > 0 && (i.filter = r[0]), r.length > 1 && (i.filterTo = r[1]), i
      }
      getInputs(e) {
        return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]]
      }
      getModelAsString(e) {
        var t;
        return null != (t = this.filterModelFormatter.getModelAsString(e)) ? t : ""
      }
      hasInvalidInputs() {
        let e = !1;
        return this.forEachInput(t => {
          t.getInputElement().validity.valid || (e = !0)
        }), e
      }
    };
    En.DEFAULT_FILTER_OPTIONS = [tn.EQUALS, tn.NOT_EQUAL, tn.GREATER_THAN, tn.GREATER_THAN_OR_EQUAL, tn.LESS_THAN, tn.LESS_THAN_OR_EQUAL, tn.IN_RANGE, tn.BLANK, tn.NOT_BLANK];
    var gn = En,
      fn = class extends Qs {
        conditionToString(e, t) {
          const {
            numberOfInputs: i
          } = t || {};
          return e.type == en.IN_RANGE || 2 === i ? `${e.filter}-${e.filterTo}` : null != e.filter ? `${e.filter}` : `${e.type}`
        }
      },
      Tn = class e extends en {
        constructor() {
          super("textFilter"), this.eValuesFrom = [], this.eValuesTo = []
        }
        static trimInput(e) {
          const t = e && e.trim();
          return "" === t ? e : t
        }
        getDefaultDebounceMs() {
          return 500
        }
        setParams(t) {
          this.textFilterParams = t, super.setParams(t), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? e.DEFAULT_FORMATTER : e.DEFAULT_LOWERCASE_FORMATTER), this.filterModelFormatter = new fn(this.localeService, this.optionsFactory)
        }
        getTextMatcher() {
          const t = this.textFilterParams.textCustomComparator;
          return t ? (Cs.warnOnce("textCustomComparator is deprecated, use textMatcher instead."), ({
            filterOption: e,
            value: i,
            filterText: r
          }) => t(e, i, r)) : this.textFilterParams.textMatcher || e.DEFAULT_MATCHER
        }
        createCondition(e) {
          const t = this.getConditionType(e),
            i = {
              filterType: this.getFilterType(),
              type: t
            },
            r = this.getValuesWithSideEffects(e, !0);
          return r.length > 0 && (i.filter = r[0]), r.length > 1 && (i.filterTo = r[1]), i
        }
        getFilterType() {
          return "text"
        }
        areSimpleModelsEqual(e, t) {
          return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type
        }
        getInputs(e) {
          return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]]
        }
        getValues(e) {
          return this.getValuesWithSideEffects(e, !1)
        }
        getValuesWithSideEffects(t, i) {
          const r = [];
          return this.forEachPositionInput(t, (t, s, n, o) => {
            var a;
            if (s < o) {
              let s = A(t.getValue());
              i && this.textFilterParams.trimInput && (s = null != (a = e.trimInput(s)) ? a : null, t.setValue(s, !0)), r.push(s)
            }
          }), r
        }
        getDefaultFilterOptions() {
          return e.DEFAULT_FILTER_OPTIONS
        }
        createValueElement() {
          const e = document.createElement("div");
          return e.classList.add("ag-filter-body"), Xt(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e
        }
        createFromToElement(e, t, i) {
          const r = this.createManagedBean(new hn);
          r.addCssClass(`ag-filter-${i}`), r.addCssClass("ag-filter-filter"), t.push(r), e.appendChild(r.getGui())
        }
        removeValueElements(e, t) {
          this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t)
        }
        mapValuesFromModel(e) {
          const {
            filter: t,
            filterTo: i,
            type: r
          } = e || {};
          return [t || null, i || null].slice(0, this.getNumberOfInputs(r))
        }
        evaluateNullValue(e) {
          const t = [en.NOT_EQUAL, en.NOT_CONTAINS, en.BLANK];
          return !!e && t.indexOf(e) >= 0
        }
        evaluateNonNullValue(e, t, i, r) {
          const s = e.map(e => this.formatter(e)) || [],
            n = this.formatter(t),
            {
              api: o,
              colDef: a,
              column: l,
              columnApi: c,
              context: h,
              textFormatter: u
            } = this.textFilterParams;
          if (i.type === en.BLANK) return this.isBlank(t);
          if (i.type === en.NOT_BLANK) return !this.isBlank(t);
          const d = {
            api: o,
            colDef: a,
            column: l,
            columnApi: c,
            context: h,
            node: r.node,
            data: r.data,
            filterOption: i.type,
            value: n,
            textFormatter: u
          };
          return s.some(e => this.matcher(T(f({}, d), {
            filterText: e
          })))
        }
        getModelAsString(e) {
          var t;
          return null != (t = this.filterModelFormatter.getModelAsString(e)) ? t : ""
        }
      };
    Tn.DEFAULT_FILTER_OPTIONS = [en.CONTAINS, en.NOT_CONTAINS, en.EQUALS, en.NOT_EQUAL, en.STARTS_WITH, en.ENDS_WITH, en.BLANK, en.NOT_BLANK], Tn.DEFAULT_FORMATTER = e => e, Tn.DEFAULT_LOWERCASE_FORMATTER = e => null == e ? null : e.toString().toLowerCase(), Tn.DEFAULT_MATCHER = ({
      filterOption: e,
      value: t,
      filterText: i
    }) => {
      if (null == i) return !1;
      switch (e) {
        case Tn.CONTAINS:
          return t.indexOf(i) >= 0;
        case Tn.NOT_CONTAINS:
          return t.indexOf(i) < 0;
        case Tn.EQUALS:
          return t === i;
        case Tn.NOT_EQUAL:
          return t != i;
        case Tn.STARTS_WITH:
          return 0 === t.indexOf(i);
        case Tn.ENDS_WITH:
          const e = t.lastIndexOf(i);
          return e >= 0 && e === t.length - i.length;
        default:
          return !1
      }
    };
    var mn = Tn,
      Cn = class extends ct {
        constructor(e) {
          super(), this.params = e, this.valueChangedListener = () => {}
        }
        setupGui(e) {
          var t;
          this.eFloatingFilterTextInput = this.createManagedBean(new hn(null == (t = this.params) ? void 0 : t.config));
          const i = this.eFloatingFilterTextInput.getGui();
          e.appendChild(i), this.addManagedListener(i, "input", e => this.valueChangedListener(e)), this.addManagedListener(i, "keydown", e => this.valueChangedListener(e))
        }
        setEditable(e) {
          this.eFloatingFilterTextInput.setDisabled(!e)
        }
        setAutoComplete(e) {
          this.eFloatingFilterTextInput.setAutoComplete(e)
        }
        getValue() {
          return this.eFloatingFilterTextInput.getValue()
        }
        setValue(e, t) {
          this.eFloatingFilterTextInput.setValue(e, t)
        }
        setValueChangedListener(e) {
          this.valueChangedListener = e
        }
        setParams(e) {
          this.setAriaLabel(e.ariaLabel), void 0 !== e.autoComplete && this.setAutoComplete(e.autoComplete)
        }
        setAriaLabel(e) {
          this.eFloatingFilterTextInput.setInputAriaLabel(e)
        }
      },
      Sn = class extends an {
        postConstruct() {
          this.setTemplate('\n            <div class="ag-floating-filter-input" role="presentation" ref="eFloatingFilterInputContainer"></div>\n        ')
        }
        getDefaultDebounceMs() {
          return 500
        }
        onParentModelChanged(e, t) {
          this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)))
        }
        init(e) {
          this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e)
        }
        setupFloatingFilterInputService(e) {
          this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer)
        }
        setTextInputParams(e) {
          var t;
          this.params = e;
          const i = null != (t = e.browserAutoComplete) && t;
          if (this.floatingFilterInputService.setParams({
              ariaLabel: this.getAriaLabel(e),
              autoComplete: i
            }), this.applyActive = Bs.isUseApplyButton(this.params.filterParams), !this.isReadOnly()) {
            const e = Bs.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()),
              t = re(this.syncUpWithParentFilter.bind(this), e);
            this.floatingFilterInputService.setValueChangedListener(t)
          }
        }
        onParamsUpdated(e) {
          this.refresh(e)
        }
        refresh(e) {
          super.refresh(e), this.setTextInputParams(e)
        }
        recreateFloatingFilterInputService(e) {
          const t = this.floatingFilterInputService.getValue();
          Nr(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, !0)
        }
        syncUpWithParentFilter(e) {
          const t = e.key === ts.ENTER;
          if (this.applyActive && !t) return;
          let i = this.floatingFilterInputService.getValue();
          this.params.filterParams.trimInput && (i = mn.trimInput(i), this.floatingFilterInputService.setValue(i, !0)), this.params.parentFilterInstance(e => {
            e && e.onFloatingFilterChanged(this.getLastType() || null, i || null)
          })
        }
        setEditable(e) {
          this.floatingFilterInputService.setEditable(e)
        }
      };
    C([ys("eFloatingFilterInputContainer")], Sn.prototype, "eFloatingFilterInputContainer", 2), C([pe], Sn.prototype, "postConstruct", 1);
    var Rn = class extends ct {
        constructor() {
          super(...arguments), this.valueChangedListener = () => {}, this.numberInputActive = !0
        }
        setupGui(e) {
          this.eFloatingFilterNumberInput = this.createManagedBean(new un), this.eFloatingFilterTextInput = this.createManagedBean(new hn), this.eFloatingFilterTextInput.setDisabled(!0);
          const t = this.eFloatingFilterNumberInput.getGui(),
            i = this.eFloatingFilterTextInput.getGui();
          e.appendChild(t), e.appendChild(i), this.setupListeners(t, e => this.valueChangedListener(e)), this.setupListeners(i, e => this.valueChangedListener(e))
        }
        setEditable(e) {
          this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive)
        }
        setAutoComplete(e) {
          this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e)
        }
        getValue() {
          return this.getActiveInputElement().getValue()
        }
        setValue(e, t) {
          this.getActiveInputElement().setValue(e, t)
        }
        getActiveInputElement() {
          return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput
        }
        setValueChangedListener(e) {
          this.valueChangedListener = e
        }
        setupListeners(e, t) {
          this.addManagedListener(e, "input", t), this.addManagedListener(e, "keydown", t)
        }
        setParams(e) {
          this.setAriaLabel(e.ariaLabel), void 0 !== e.autoComplete && this.setAutoComplete(e.autoComplete)
        }
        setAriaLabel(e) {
          this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e)
        }
      },
      An = class extends Sn {
        init(e) {
          var t;
          super.init(e), this.filterModelFormatter = new dn(this.localeService, this.optionsFactory, null == (t = e.filterParams) ? void 0 : t.numberFormatter)
        }
        onParamsUpdated(e) {
          this.refresh(e)
        }
        refresh(e) {
          pn(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({
            optionsFactory: this.optionsFactory
          })
        }
        getDefaultFilterOptions() {
          return gn.DEFAULT_FILTER_OPTIONS
        }
        getFilterModelFormatter() {
          return this.filterModelFormatter
        }
        createFloatingFilterInputService(e) {
          return this.allowedCharPattern = pn(e.filterParams), this.allowedCharPattern ? this.createManagedBean(new Cn({
            config: {
              allowedCharPattern: this.allowedCharPattern
            }
          })) : this.createManagedBean(new Rn)
        }
      },
      vn = class extends Sn {
        init(e) {
          super.init(e), this.filterModelFormatter = new fn(this.localeService, this.optionsFactory)
        }
        onParamsUpdated(e) {
          this.refresh(e)
        }
        refresh(e) {
          super.refresh(e), this.filterModelFormatter.updateParams({
            optionsFactory: this.optionsFactory
          })
        }
        getDefaultFilterOptions() {
          return mn.DEFAULT_FILTER_OPTIONS
        }
        getFilterModelFormatter() {
          return this.filterModelFormatter
        }
        createFloatingFilterInputService() {
          return this.createManagedBean(new Cn)
        }
      },
      Nn = class e {
        constructor(e, t = !1) {
          this.destroyFuncs = [], this.touching = !1, this.eventService = new Re, this.eElement = e, this.preventMouseClick = t;
          const i = this.onTouchStart.bind(this),
            r = this.onTouchMove.bind(this),
            s = this.onTouchEnd.bind(this);
          this.eElement.addEventListener("touchstart", i, {
            passive: !0
          }), this.eElement.addEventListener("touchmove", r, {
            passive: !0
          }), this.eElement.addEventListener("touchend", s, {
            passive: !1
          }), this.destroyFuncs.push(() => {
            this.eElement.removeEventListener("touchstart", i, {
              passive: !0
            }), this.eElement.removeEventListener("touchmove", r, {
              passive: !0
            }), this.eElement.removeEventListener("touchend", s, {
              passive: !1
            })
          })
        }
        getActiveTouch(e) {
          for (let t = 0; t < e.length; t++) {
            if (e[t].identifier === this.touchStart.identifier) return e[t]
          }
          return null
        }
        addEventListener(e, t) {
          this.eventService.addEventListener(e, t)
        }
        removeEventListener(e, t) {
          this.eventService.removeEventListener(e, t)
        }
        onTouchStart(t) {
          if (this.touching) return;
          this.touchStart = t.touches[0], this.touching = !0, this.moved = !1;
          const i = this.touchStart;
          window.setTimeout(() => {
            const r = this.touchStart === i;
            if (this.touching && r && !this.moved) {
              this.moved = !0;
              const i = {
                type: e.EVENT_LONG_TAP,
                touchStart: this.touchStart,
                touchEvent: t
              };
              this.eventService.dispatchEvent(i)
            }
          }, 500)
        }
        onTouchMove(e) {
          if (!this.touching) return;
          const t = this.getActiveTouch(e.touches);
          if (!t) return;
          !Es(t, this.touchStart, 4) && (this.moved = !0)
        }
        onTouchEnd(t) {
          if (this.touching) {
            if (!this.moved) {
              const t = {
                type: e.EVENT_TAP,
                touchStart: this.touchStart
              };
              this.eventService.dispatchEvent(t), this.checkForDoubleTap()
            }
            this.preventMouseClick && t.cancelable && t.preventDefault(), this.touching = !1
          }
        }
        checkForDoubleTap() {
          const t = (new Date).getTime();
          if (this.lastTapTime && this.lastTapTime > 0) {
            if (t - this.lastTapTime > e.DOUBLE_TAP_MILLIS) {
              const t = {
                type: e.EVENT_DOUBLE_TAP,
                touchStart: this.touchStart
              };
              this.eventService.dispatchEvent(t), this.lastTapTime = null
            } else this.lastTapTime = t
          } else this.lastTapTime = t
        }
        destroy() {
          this.destroyFuncs.forEach(e => e())
        }
      };
    Nn.EVENT_TAP = "tap", Nn.EVENT_DOUBLE_TAP = "doubleTap", Nn.EVENT_LONG_TAP = "longTap", Nn.DOUBLE_TAP_MILLIS = 500;
    var In = Nn,
      On = class e extends _s {
        constructor(t) {
          super(), t || this.setTemplate(e.TEMPLATE)
        }
        attachCustomElements(e, t, i, r, s) {
          this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = i, this.eSortMixed = r, this.eSortNone = s
        }
        setupSort(e, t = !1) {
          this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), (this.column.isSortable() || this.column.getColDef().showRowGroup) && (this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e), this.addManagedPropertyListener("unSortIcon", () => this.updateIcons()), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.updateIcons()), this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, () => this.onSortChanged()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onSortChanged()), this.onSortChanged())
        }
        addInIcon(e, t, i) {
          if (null == t) return;
          const r = Zr(e, this.gos, i);
          r && t.appendChild(r)
        }
        onSortChanged() {
          this.updateIcons(), this.suppressOrder || this.updateSortOrder()
        }
        updateIcons() {
          const e = this.sortController.getDisplaySortForColumn(this.column);
          if (this.eSortAsc) {
            const t = "asc" === e;
            ur(this.eSortAsc, t, {
              skipAriaHidden: !0
            })
          }
          if (this.eSortDesc) {
            const t = "desc" === e;
            ur(this.eSortDesc, t, {
              skipAriaHidden: !0
            })
          }
          if (this.eSortNone) {
            const t = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"),
              i = null == e;
            ur(this.eSortNone, !t && i, {
              skipAriaHidden: !0
            })
          }
        }
        setupMultiSortIndicator() {
          this.addInIcon("sortUnSort", this.eSortMixed, this.column);
          const e = this.column.getColDef().showRowGroup;
          this.gos.isColumnsSortingCoupledToGroup() && e && (this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, () => this.updateMultiSortIndicator()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateMultiSortIndicator()), this.updateMultiSortIndicator())
        }
        updateMultiSortIndicator() {
          if (this.eSortMixed) {
            const e = "mixed" === this.sortController.getDisplaySortForColumn(this.column);
            ur(this.eSortMixed, e, {
              skipAriaHidden: !0
            })
          }
        }
        updateSortOrder() {
          var e;
          if (!this.eSortOrder) return;
          const t = this.sortController.getColumnsWithSortingOrdered(),
            i = null != (e = this.sortController.getDisplaySortIndexForColumn(this.column)) ? e : -1,
            r = t.some(e => {
              var t;
              return null != (t = this.sortController.getDisplaySortIndexForColumn(e)) && t
            }),
            s = i >= 0 && r;
          ur(this.eSortOrder, s, {
            skipAriaHidden: !0
          }), i >= 0 ? this.eSortOrder.textContent = (i + 1).toString() : Nr(this.eSortOrder)
        }
      };
    On.TEMPLATE = '<span class="ag-sort-indicator-container">\n            <span ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>\n            <span ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>\n            <span ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>\n            <span ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>\n            <span ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>\n        </span>', C([ys("eSortOrder")], On.prototype, "eSortOrder", 2), C([ys("eSortAsc")], On.prototype, "eSortAsc", 2), C([ys("eSortDesc")], On.prototype, "eSortDesc", 2), C([ys("eSortMixed")], On.prototype, "eSortMixed", 2), C([ys("eSortNone")], On.prototype, "eSortNone", 2), C([fe("columnModel")], On.prototype, "columnModel", 2), C([fe("sortController")], On.prototype, "sortController", 2);
    var Ln = On,
      _n = class e extends _s {
        constructor() {
          super(...arguments), this.lastMovingChanged = 0
        }
        destroy() {
          super.destroy()
        }
        refresh(e) {
          const t = this.params;
          return this.params = e, this.workOutTemplate() == this.currentTemplate && this.workOutShowMenu() == this.currentShowMenu && this.workOutSort() == this.currentSort && this.shouldSuppressMenuHide() == this.currentSuppressMenuHide && t.enableFilterButton == e.enableFilterButton && t.enableFilterIcon == e.enableFilterIcon && (this.setDisplayName(e), !0)
        }
        workOutTemplate() {
          var t;
          let i = null != (t = this.params.template) ? t : e.TEMPLATE;
          return i = i && i.trim ? i.trim() : i, i
        }
        init(e) {
          this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(e)
        }
        setDisplayName(e) {
          if (this.currentDisplayName != e.displayName) {
            this.currentDisplayName = e.displayName;
            const t = Nt(this.currentDisplayName, !0);
            this.eText && (this.eText.textContent = t)
          }
        }
        addInIcon(e, t, i) {
          if (null == t) return;
          const r = Zr(e, this.gos, i);
          r && t.appendChild(r)
        }
        setupTap() {
          const {
            gos: e
          } = this;
          if (e.get("suppressTouch")) return;
          const t = new In(this.getGui(), !0),
            i = this.shouldSuppressMenuHide(),
            r = i && v(this.eMenu),
            s = r ? new In(this.eMenu, !0) : t;
          if (this.params.enableMenu) {
            const e = r ? "EVENT_TAP" : "EVENT_LONG_TAP",
              t = e => this.params.showColumnMenuAfterMouseClick(e.touchStart);
            this.addManagedListener(s, In[e], t)
          }
          if (this.params.enableSorting) {
            const e = e => {
              var t, r;
              const s = e.touchStart.target;
              i && ((null == (t = this.eMenu) ? void 0 : t.contains(s)) || (null == (r = this.eFilterButton) ? void 0 : r.contains(s))) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted")
            };
            this.addManagedListener(t, In.EVENT_TAP, e)
          }
          if (this.params.enableFilterButton) {
            const e = new In(this.eFilterButton, !0);
            this.addManagedListener(e, "tap", () => this.params.showFilter(this.eFilterButton)), this.addDestroyFunc(() => e.destroy())
          }
          this.addDestroyFunc(() => t.destroy()), r && this.addDestroyFunc(() => s.destroy())
        }
        workOutShowMenu() {
          return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled()
        }
        shouldSuppressMenuHide() {
          return this.menuService.isHeaderMenuButtonAlwaysShowEnabled()
        }
        setMenu() {
          if (!this.eMenu) return;
          if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) return Ir(this.eMenu), void(this.eMenu = void 0);
          const e = this.menuService.isLegacyMenuEnabled();
          this.addInIcon(e ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !e), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedListener(this.eMenu, "click", () => this.params.showColumnMenu(this.eMenu)), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide)
        }
        onMenuKeyboardShortcut(e) {
          var t, i, r, s;
          const {
            column: n
          } = this.params, o = this.menuService.isLegacyMenuEnabled();
          if (e && !o) {
            if (this.menuService.isFilterMenuInHeaderEnabled(n)) return this.params.showFilter(null != (i = null != (t = this.eFilterButton) ? t : this.eMenu) ? i : this.getGui()), !0
          } else if (this.params.enableMenu) return this.params.showColumnMenu(null != (s = null != (r = this.eMenu) ? r : this.eFilterButton) ? s : this.getGui()), !0;
          return !1
        }
        workOutSort() {
          return this.params.enableSorting
        }
        setupSort() {
          if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.context.createBean(new Ln(!0)), this.eSortIndicator.attachCustomElements(this.eSortOrder, this.eSortAsc, this.eSortDesc, this.eSortMixed, this.eSortNone)), this.eSortIndicator.setupSort(this.params.column), !this.currentSort) return;
          this.addManagedListener(this.params.column, Le.EVENT_MOVING_CHANGED, () => {
            this.lastMovingChanged = (new Date).getTime()
          }), this.eLabel && this.addManagedListener(this.eLabel, "click", e => {
            const t = this.params.column.isMoving(),
              i = (new Date).getTime() - this.lastMovingChanged < 50;
            if (!(t || i)) {
              const t = "ctrl" === this.gos.get("multiSortKey") ? e.ctrlKey || e.metaKey : e.shiftKey;
              this.params.progressSort(t)
            }
          });
          const e = () => {
            if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending()), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending()), this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone()), this.params.column.getColDef().showRowGroup) {
              const e = this.columnModel.getSourceColumnsForGroupColumn(this.params.column),
                t = !(null == e ? void 0 : e.every(e => this.params.column.getSort() == e.getSort()));
              this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", t)
            }
          };
          this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, e)
        }
        setupFilterIcon() {
          this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this))
        }
        setupFilterButton() {
          if (!this.eFilterButton) return;
          this.configureFilter(this.params.enableFilterButton, this.eFilterButton, this.onFilterChangedButton.bind(this)) ? this.addManagedListener(this.eFilterButton, "click", () => this.params.showFilter(this.eFilterButton)) : this.eFilterButton = void 0
        }
        configureFilter(e, t, i) {
          if (!e) return Ir(t), !1;
          const {
            column: r
          } = this.params;
          return this.addInIcon("filter", t, r), this.addManagedListener(r, Le.EVENT_FILTER_CHANGED, i), i(), !0
        }
        onFilterChangedIcon() {
          const e = this.params.column.isFilterActive();
          ur(this.eFilter, e, {
            skipAriaHidden: !0
          })
        }
        onFilterChangedButton() {
          const e = this.params.column.isFilterActive();
          this.eFilterButton.classList.toggle("ag-filter-active", e)
        }
        getAnchorElementForMenu(e) {
          var t, i, r, s;
          return e ? null != (i = null != (t = this.eFilterButton) ? t : this.eMenu) ? i : this.getGui() : null != (s = null != (r = this.eMenu) ? r : this.eFilterButton) ? s : this.getGui()
        }
      };
    _n.TEMPLATE = '<div class="ag-cell-label-container" role="presentation">\n            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>\n            <span ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>\n            <div ref="eLabel" class="ag-header-cell-label" role="presentation">\n                <span ref="eText" class="ag-header-cell-text"></span>\n                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>\n                <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>\n            </div>\n        </div>', C([fe("sortController")], _n.prototype, "sortController", 2), C([fe("menuService")], _n.prototype, "menuService", 2), C([fe("columnModel")], _n.prototype, "columnModel", 2), C([ys("eFilter")], _n.prototype, "eFilter", 2), C([ys("eFilterButton")], _n.prototype, "eFilterButton", 2), C([ys("eSortIndicator")], _n.prototype, "eSortIndicator", 2), C([ys("eMenu")], _n.prototype, "eMenu", 2), C([ys("eLabel")], _n.prototype, "eLabel", 2), C([ys("eText")], _n.prototype, "eText", 2), C([ys("eSortOrder")], _n.prototype, "eSortOrder", 2), C([ys("eSortAsc")], _n.prototype, "eSortAsc", 2), C([ys("eSortDesc")], _n.prototype, "eSortDesc", 2), C([ys("eSortMixed")], _n.prototype, "eSortMixed", 2), C([ys("eSortNone")], _n.prototype, "eSortNone", 2);
    var yn = _n,
      wn = class e extends _s {
        constructor() {
          super(e.TEMPLATE)
        }
        destroy() {
          super.destroy()
        }
        init(e) {
          this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons()
        }
        checkWarnings() {
          this.params.template && z("A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)")
        }
        setupExpandIcons() {
          this.addInIcon("columnGroupOpened", "agOpened"), this.addInIcon("columnGroupClosed", "agClosed");
          const e = e => {
            if (tt(e)) return;
            const t = !this.params.columnGroup.isExpanded();
            this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), t, "uiColumnExpanded")
          };
          this.addTouchAndClickListeners(this.eCloseIcon, e), this.addTouchAndClickListeners(this.eOpenIcon, e);
          const t = e => {
            et(e)
          };
          this.addManagedListener(this.eCloseIcon, "dblclick", t), this.addManagedListener(this.eOpenIcon, "dblclick", t), this.addManagedListener(this.getGui(), "dblclick", e), this.updateIconVisibility();
          const i = this.params.columnGroup.getProvidedColumnGroup();
          this.addManagedListener(i, ye.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this)), this.addManagedListener(i, ye.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this))
        }
        addTouchAndClickListeners(e, t) {
          const i = new In(e, !0);
          this.addManagedListener(i, In.EVENT_TAP, t), this.addDestroyFunc(() => i.destroy()), this.addManagedListener(e, "click", t)
        }
        updateIconVisibility() {
          if (this.params.columnGroup.isExpandable()) {
            const e = this.params.columnGroup.isExpanded();
            ur(this.eOpenIcon, e), ur(this.eCloseIcon, !e)
          } else ur(this.eOpenIcon, !1), ur(this.eCloseIcon, !1)
        }
        addInIcon(e, t) {
          const i = Zr(e, this.gos, null);
          i && this.getRefElement(t).appendChild(i)
        }
        addGroupExpandIcon() {
          if (!this.params.columnGroup.isExpandable()) return ur(this.eOpenIcon, !1), void ur(this.eCloseIcon, !1)
        }
        setupLabel() {
          var e;
          const {
            displayName: t,
            columnGroup: i
          } = this.params;
          if (v(t)) {
            const e = Nt(t, !0);
            this.getRefElement("agLabel").textContent = e
          }
          this.addOrRemoveCssClass("ag-sticky-label", !(null == (e = i.getColGroupDef()) ? void 0 : e.suppressStickyLabel))
        }
      };
    wn.TEMPLATE = '<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">\n            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>\n            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>\n            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>\n        </div>', C([fe("columnModel")], wn.prototype, "columnModel", 2), C([ys("agOpened")], wn.prototype, "eOpenIcon", 2), C([ys("agClosed")], wn.prototype, "eCloseIcon", 2);
    var Dn = wn,
      Pn = class extends _s {
        isPopup() {
          return !0
        }
        setParentComponent(e) {
          e.addCssClass("ag-has-popup"), super.setParentComponent(e)
        }
        destroy() {
          const e = this.parentComponent;
          e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy()
        }
      },
      bn = class e extends Pn {
        constructor() {
          super(e.TEMPLATE)
        }
        init(e) {
          this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), v(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex()
        }
        onKeyDown(e) {
          const t = e.key;
          (t === ts.LEFT || t === ts.UP || t === ts.RIGHT || t === ts.DOWN || e.shiftKey && t === ts.ENTER) && e.stopPropagation()
        }
        afterGuiAttached() {
          const e = this.localeService.getLocaleTextFunc();
          this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus()
        }
        getValue() {
          const e = this.eTextArea.getValue();
          return v(e) || v(this.params.value) ? this.params.parseValue(e) : this.params.value
        }
      };
    bn.TEMPLATE = '<div class="ag-large-text">\n            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>\n        </div>', C([ys("eTextArea")], bn.prototype, "eTextArea", 2);
    var Mn = bn,
      Fn = class extends Pn {
        constructor() {
          super('<div class="ag-cell-edit-wrapper">\n                <ag-select class="ag-cell-editor" ref="eSelect"></ag-select>\n            </div>'), this.startedByEnter = !1
        }
        init(e) {
          this.focusAfterAttached = e.cellStartedEdit;
          const {
            eSelect: t,
            valueService: i,
            gos: r
          } = this, {
            values: s,
            value: n,
            eventKey: o
          } = e;
          if (N(s)) return void console.warn("AG Grid: no values found for select cellEditor");
          this.startedByEnter = null != o && o === ts.ENTER;
          let a = !1;
          s.forEach(r => {
            const s = {
                value: r
              },
              o = i.formatValue(e.column, null, r),
              l = null != o;
            s.text = l ? o : r, t.addOption(s), a = a || n === r
          }), a ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
          const {
            valueListGap: l,
            valueListMaxWidth: c,
            valueListMaxHeight: h
          } = e;
          null != l && t.setPickerGap(l), null != h && t.setPickerMaxHeight(h), null != c && t.setPickerMaxWidth(c), "fullRow" !== r.get("editType") && this.addManagedListener(this.eSelect, $s.EVENT_ITEM_SELECTED, () => e.stopEditing())
        }
        afterGuiAttached() {
          this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
            this.isAlive() && this.eSelect.showPicker()
          })
        }
        focusIn() {
          this.eSelect.getFocusableElement().focus()
        }
        getValue() {
          return this.eSelect.getValue()
        }
        isPopup() {
          return !1
        }
      };
    C([fe("valueService")], Fn.prototype, "valueService", 2), C([ys("eSelect")], Fn.prototype, "eSelect", 2);
    var xn = class extends Pn {
      constructor(e) {
        super(`\n            <div class="ag-cell-edit-wrapper">\n                ${e.getTemplate()}\n            </div>`), this.cellEditorInput = e
      }
      init(e) {
        this.params = e;
        const t = this.eInput;
        let i;
        if (this.cellEditorInput.init(t, e), e.cellStartedEdit) {
          this.focusAfterAttached = !0;
          const t = e.eventKey;
          t === ts.BACKSPACE || e.eventKey === ts.DELETE ? i = "" : t && 1 === t.length ? i = t : (i = this.cellEditorInput.getStartValue(), t !== ts.F2 && (this.highlightAllOnFocus = !0))
        } else this.focusAfterAttached = !1, i = this.cellEditorInput.getStartValue();
        null != i && t.setStartValue(i), this.addManagedListener(t.getGui(), "keydown", e => {
          const {
            key: t
          } = e;
          t !== ts.PAGE_UP && t !== ts.PAGE_DOWN || e.preventDefault()
        })
      }
      afterGuiAttached() {
        var e, t;
        const i = this.localeService.getLocaleTextFunc(),
          r = this.eInput;
        if (r.setInputAriaLabel(i("ariaInputEditor", "Input Editor")), !this.focusAfterAttached) return;
        Pi() || r.getFocusableElement().focus();
        const s = r.getInputElement();
        this.highlightAllOnFocus ? s.select() : null == (t = (e = this.cellEditorInput).setCaret) || t.call(e)
      }
      focusIn() {
        const e = this.eInput,
          t = e.getFocusableElement(),
          i = e.getInputElement();
        t.focus(), i.select()
      }
      getValue() {
        return this.cellEditorInput.getValue()
      }
      isPopup() {
        return !1
      }
    };
    C([ys("eInput")], xn.prototype, "eInput", 2);
    var Gn = class {
        getTemplate() {
          return '<ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field>'
        }
        init(e, t) {
          this.eInput = e, this.params = t, null != t.maxLength && e.setMaxLength(t.maxLength)
        }
        getValue() {
          const e = this.eInput.getValue();
          return v(e) || v(this.params.value) ? this.params.parseValue(e) : this.params.value
        }
        getStartValue() {
          return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value
        }
        setCaret() {
          const e = this.eInput.getValue(),
            t = v(e) && e.length || 0;
          t && this.eInput.getInputElement().setSelectionRange(t, t)
        }
      },
      Un = class extends xn {
        constructor() {
          super(new Gn)
        }
      },
      Hn = class extends _s {
        constructor() {
          super(), this.refreshCount = 0;
          const e = document.createElement("span"),
            t = document.createElement("span");
          t.setAttribute("class", "ag-value-change-delta");
          const i = document.createElement("span");
          i.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(i), this.setTemplateFromElement(e)
        }
        init(e) {
          this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0)
        }
        showDelta(e, t) {
          const i = Math.abs(t),
            r = e.formatValue(i),
            s = v(r) ? r : i,
            n = t >= 0;
          this.eDelta.textContent = n ? "↑" + s : "↓" + s, this.eDelta.classList.toggle("ag-value-change-delta-up", n), this.eDelta.classList.toggle("ag-value-change-delta-down", !n)
        }
        setTimerToRemoveDelta() {
          this.refreshCount++;
          const e = this.refreshCount;
          this.getFrameworkOverrides().wrapIncoming(() => {
            window.setTimeout(() => {
              e === this.refreshCount && this.hideDeltaValue()
            }, 2e3)
          })
        }
        hideDeltaValue() {
          this.eValue.classList.remove("ag-value-change-value-highlight"), Nr(this.eDelta)
        }
        refresh(e, t = !1) {
          const i = e.value;
          if (i === this.lastValue) return !1;
          if (v(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : v(e.value) ? this.eValue.textContent = i : Nr(this.eValue), this.filterManager.isSuppressFlashingCellsBecauseFiltering()) return !1;
          if ("number" == typeof i && "number" == typeof this.lastValue) {
            const t = i - this.lastValue;
            this.showDelta(e, t)
          }
          return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = i, !0
        }
      };
    C([fe("filterManager")], Hn.prototype, "filterManager", 2);
    var kn = class extends _s {
      constructor() {
        super(), this.refreshCount = 0;
        const e = document.createElement("span"),
          t = document.createElement("span");
        t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current")
      }
      init(e) {
        this.refresh(e, !0)
      }
      addSlideAnimation() {
        this.refreshCount++;
        const e = this.refreshCount;
        this.ePrevious && this.getGui().removeChild(this.ePrevious);
        const t = document.createElement("span");
        t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
          window.setTimeout(() => {
            e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end")
          }, 50), window.setTimeout(() => {
            e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null)
          }, 3e3)
        })
      }
      refresh(e, t = !1) {
        let i = e.value;
        return N(i) && (i = ""), i !== this.lastValue && (!this.filterManager.isSuppressFlashingCellsBecauseFiltering() && (t || this.addSlideAnimation(), this.lastValue = i, v(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : v(e.value) ? this.eCurrent.textContent = i : Nr(this.eCurrent), !0))
      }
    };
    C([fe("filterManager")], kn.prototype, "filterManager", 2);
    var Bn = class e {
      constructor(t) {
        this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = e.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = t
      }
      setData(e) {
        this.setDataCommon(e, !1)
      }
      updateData(e) {
        this.setDataCommon(e, !0)
      }
      setDataCommon(e, t) {
        const i = this.data;
        this.data = e, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
        const r = this.createDataChangedEvent(e, i, t);
        this.dispatchLocalEvent(r)
      }
      updateDataOnDetailNode() {
        this.detailNode && (this.detailNode.data = this.data)
      }
      createDataChangedEvent(t, i, r) {
        return {
          type: e.EVENT_DATA_CHANGED,
          node: this,
          oldData: i,
          newData: t,
          update: r
        }
      }
      createLocalRowEvent(e) {
        return {
          type: e,
          node: this
        }
      }
      getRowIndexString() {
        return "top" === this.rowPinned ? "t-" + this.rowIndex : "bottom" === this.rowPinned ? "b-" + this.rowIndex : this.rowIndex.toString()
      }
      createDaemonNode() {
        const t = new e(this.beans);
        return t.id = this.id, t.data = this.data, t.__daemon = !0, t.selected = this.selected, t.level = this.level, t
      }
      setDataAndId(e, t) {
        const i = v(this.id) ? this.createDaemonNode() : null,
          r = this.data;
        this.data = e, this.updateDataOnDetailNode(), this.setId(t), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, i);
        const s = this.createDataChangedEvent(e, r, !1);
        this.dispatchLocalEvent(s)
      }
      checkRowSelectable() {
        const e = this.beans.gos.get("isRowSelectable");
        this.setRowSelectable(!e || e(this))
      }
      setRowSelectable(t, i) {
        if (this.selectable !== t) {
          if (this.selectable = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_SELECTABLE_CHANGED)), i) return;
          if (this.beans.gos.get("groupSelectsChildren")) {
            const e = this.calculateSelectedFromChildren();
            return void this.setSelectedParams({
              newValue: null != e && e,
              source: "selectableChanged"
            })
          }
          this.isSelected() && !this.selectable && this.setSelectedParams({
            newValue: !1,
            source: "selectableChanged"
          })
        }
      }
      setId(t) {
        const i = this.beans.gos.getCallback("getRowId");
        if (i)
          if (this.data) {
            const t = this.getGroupKeys(!0);
            this.id = i({
              data: this.data,
              parentKeys: t.length > 0 ? t : void 0,
              level: this.level
            }), null !== this.id && "string" == typeof this.id && this.id.startsWith(e.ID_PREFIX_ROW_GROUP) && console.error(`AG Grid: Row IDs cannot start with ${e.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`), null !== this.id && "string" != typeof this.id && (this.id = "" + this.id)
          } else this.id = void 0;
        else this.id = t
      }
      getGroupKeys(e = !1) {
        const t = [];
        let i = this;
        for (e && (i = i.parent); i && i.level >= 0;) t.push(i.key), i = i.parent;
        return t.reverse(), t
      }
      isPixelInRange(e) {
        return !(!v(this.rowTop) || !v(this.rowHeight)) && (e >= this.rowTop && e < this.rowTop + this.rowHeight)
      }
      setFirstChild(t) {
        this.firstChild !== t && (this.firstChild = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_FIRST_CHILD_CHANGED)))
      }
      setLastChild(t) {
        this.lastChild !== t && (this.lastChild = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_LAST_CHILD_CHANGED)))
      }
      setChildIndex(t) {
        this.childIndex !== t && (this.childIndex = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_CHILD_INDEX_CHANGED)))
      }
      setRowTop(t) {
        this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_TOP_CHANGED)), this.setDisplayed(null !== t))
      }
      clearRowTopAndRowIndex() {
        this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null)
      }
      setDisplayed(t) {
        this.displayed !== t && (this.displayed = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_DISPLAYED_CHANGED)))
      }
      setDragging(t) {
        this.dragging !== t && (this.dragging = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_DRAGGING_CHANGED)))
      }
      setHighlighted(t) {
        t !== this.highlighted && (this.highlighted = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_HIGHLIGHT_CHANGED)))
      }
      setHovered(e) {
        this.hovered !== e && (this.hovered = e)
      }
      isHovered() {
        return this.hovered
      }
      setAllChildrenCount(t) {
        this.allChildrenCount !== t && (this.allChildrenCount = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_ALL_CHILDREN_COUNT_CHANGED)))
      }
      setMaster(t) {
        this.master !== t && (this.master && !t && (this.expanded = !1), this.master = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_MASTER_CHANGED)))
      }
      setGroup(t) {
        this.group !== t && (this.group && !t && (this.expanded = !1), this.group = t, this.updateHasChildren(), this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_GROUP_CHANGED)))
      }
      setRowHeight(t, i = !1) {
        this.rowHeight = t, this.rowHeightEstimated = i, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_HEIGHT_CHANGED))
      }
      setRowAutoHeight(e, t) {
        this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[t.getId()] = e, null != e && (null == this.checkAutoHeightsDebounced && (this.checkAutoHeightsDebounced = re(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced())
      }
      checkAutoHeights() {
        let e = !1,
          t = !0,
          i = 0;
        const r = this.__autoHeights;
        if (null == r) return;
        if (this.beans.columnModel.getAllDisplayedAutoHeightCols().forEach(s => {
            let n = r[s.getId()];
            if (null == n) {
              if (!this.beans.columnModel.isColSpanActive()) return void(e = !0); {
                let t = [];
                switch (s.getPinned()) {
                  case "left":
                    t = this.beans.columnModel.getDisplayedLeftColumnsForRow(this);
                    break;
                  case "right":
                    t = this.beans.columnModel.getDisplayedRightColumnsForRow(this);
                    break;
                  case null:
                    t = this.beans.columnModel.getViewportCenterColumnsForRow(this)
                }
                if (t.includes(s)) return void(e = !0);
                n = -1
              }
            } else t = !1;
            n > i && (i = n)
          }), e) return;
        if ((t || i < 10) && (i = this.beans.gos.getRowHeightForNode(this).height), i == this.rowHeight) return;
        this.setRowHeight(i);
        const s = this.beans.rowModel;
        s.onRowHeightChangedDebounced && s.onRowHeightChangedDebounced()
      }
      setRowIndex(t) {
        this.rowIndex !== t && (this.rowIndex = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_ROW_INDEX_CHANGED)))
      }
      setUiLevel(t) {
        this.uiLevel !== t && (this.uiLevel = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_UI_LEVEL_CHANGED)))
      }
      setExpanded(t, i, r) {
        if (this.expanded === t) return;
        this.expanded = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_EXPANDED_CHANGED));
        const s = Object.assign({}, this.createGlobalRowEvent(Et.EVENT_ROW_GROUP_OPENED), {
          expanded: t,
          event: i || null
        });
        this.beans.rowNodeEventThrottle.dispatchExpanded(s, r), this.beans.rowRenderer.refreshCells({
          rowNodes: [this]
        })
      }
      createGlobalRowEvent(e) {
        return this.beans.gos.addGridCommonParams({
          type: e,
          node: this,
          data: this.data,
          rowIndex: this.rowIndex,
          rowPinned: this.rowPinned
        })
      }
      dispatchLocalEvent(e) {
        this.eventService && this.eventService.dispatchEvent(e)
      }
      setDataValue(e, t, i) {
        const r = (() => {
            var t;
            return "string" != typeof e ? e : null != (t = this.beans.columnModel.getGridColumn(e)) ? t : this.beans.columnModel.getPrimaryColumn(e)
          })(),
          s = this.getValueFromValueService(r);
        if (this.beans.gos.get("readOnlyEdit")) return this.dispatchEventForSaveValueReadOnly(r, s, t, i), !1;
        const n = this.beans.valueService.setValue(this, r, t, i);
        return this.dispatchCellChangedEvent(r, t, s), this.checkRowSelectable(), n
      }
      getValueFromValueService(e) {
        var t, i;
        const r = this.leafGroup && this.beans.columnModel.isPivotMode(),
          s = this.group && this.expanded && !this.footer && !r;
        let n = !1;
        const o = null != (t = this.beans.gos.get("groupTotalRow")) ? t : this.beans.gos.get("groupIncludeFooter");
        if ("function" != typeof o) n = !!o;
        else {
          n = !!(null != (i = this.beans.gos.getCallback("groupTotalRow")) ? i : this.beans.gos.getCallback("groupIncludeFooter"))({
            node: this
          })
        }
        const a = this.beans.gos.get("groupSuppressBlankHeader"),
          l = s && n && !a;
        return this.beans.valueService.getValue(e, this, !1, l)
      }
      dispatchEventForSaveValueReadOnly(e, t, i, r) {
        const s = this.beans.gos.addGridCommonParams({
          type: Et.EVENT_CELL_EDIT_REQUEST,
          event: null,
          rowIndex: this.rowIndex,
          rowPinned: this.rowPinned,
          column: e,
          colDef: e.getColDef(),
          data: this.data,
          node: this,
          oldValue: t,
          newValue: i,
          value: i,
          source: r
        });
        this.beans.eventService.dispatchEvent(s)
      }
      setGroupValue(e, t) {
        const i = this.beans.columnModel.getGridColumn(e);
        N(this.groupData) && (this.groupData = {});
        const r = i.getColId(),
          s = this.groupData[r];
        s !== t && (this.groupData[r] = t, this.dispatchCellChangedEvent(i, t, s))
      }
      setAggData(e) {
        const t = this.aggData;
        if (this.aggData = e, this.eventService) {
          const i = e => {
            const i = this.aggData ? this.aggData[e] : void 0,
              r = t ? t[e] : void 0;
            if (i === r) return;
            const s = this.beans.columnModel.lookupGridColumn(e);
            s && this.dispatchCellChangedEvent(s, i, r)
          };
          for (const e in this.aggData) i(e);
          for (const t in e) t in this.aggData || i(t)
        }
      }
      updateHasChildren() {
        let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
        if (this.beans.gos.isRowModelType("serverSide")) {
          const e = this.beans.gos.get("treeData"),
            i = this.beans.gos.get("isServerSideGroup");
          t = !this.stub && !this.footer && (e ? !!i && i(this.data) : !!this.group)
        }
        t !== this.__hasChildren && (this.__hasChildren = !!t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(e.EVENT_HAS_CHILDREN_CHANGED)))
      }
      hasChildren() {
        return null == this.__hasChildren && this.updateHasChildren(), this.__hasChildren
      }
      isEmptyRowGroupNode() {
        return this.group && I(this.childrenAfterGroup)
      }
      dispatchCellChangedEvent(t, i, r) {
        const s = {
          type: e.EVENT_CELL_CHANGED,
          node: this,
          column: t,
          newValue: i,
          oldValue: r
        };
        this.dispatchLocalEvent(s)
      }
      resetQuickFilterAggregateText() {
        this.quickFilterAggregateText = null
      }
      isExpandable() {
        return !this.footer && (this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master)
      }
      isSelected() {
        return this.footer ? this.sibling.isSelected() : this.selected
      }
      depthFirstSearch(e) {
        this.childrenAfterGroup && this.childrenAfterGroup.forEach(t => t.depthFirstSearch(e)), e(this)
      }
      calculateSelectedFromChildren() {
        var e;
        let t = !1,
          i = !1,
          r = !1;
        if (!(null == (e = this.childrenAfterGroup) ? void 0 : e.length)) return this.selectable ? this.selected : null;
        for (let e = 0; e < this.childrenAfterGroup.length; e++) {
          const s = this.childrenAfterGroup[e];
          let n = s.isSelected();
          if (!s.selectable) {
            const e = s.calculateSelectedFromChildren();
            if (null === e) continue;
            n = e
          }
          switch (n) {
            case !0:
              t = !0;
              break;
            case !1:
              i = !0;
              break;
            default:
              r = !0
          }
        }
        return r || t && i ? void 0 : !!t || !i && (this.selectable ? this.selected : null)
      }
      setSelectedInitialValue(e) {
        this.selected = e
      }
      selectThisNode(t, i, r = "api") {
        const s = !this.selectable && t,
          n = this.selected === t;
        if (s || n) return !1;
        this.selected = t, this.eventService && this.dispatchLocalEvent(this.createLocalRowEvent(e.EVENT_ROW_SELECTED));
        const o = this.sibling;
        o && o.footer && o.eventService && o.dispatchLocalEvent(o.createLocalRowEvent(e.EVENT_ROW_SELECTED));
        const a = T(f({}, this.createGlobalRowEvent(Et.EVENT_ROW_SELECTED)), {
          event: i || null,
          source: r
        });
        return this.beans.eventService.dispatchEvent(a), !0
      }
      setSelected(e, t = !1, i = "api") {
        "boolean" != typeof i ? this.setSelectedParams({
          newValue: e,
          clearSelection: t,
          rangeSelect: !1,
          source: i
        }) : console.warn("AG Grid: since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.")
      }
      setSelectedParams(e) {
        return this.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), 0) : void 0 === this.id ? (console.warn("AG Grid: cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected(T(f({}, e), {
          nodes: [this.footer ? this.sibling : this]
        }))
      }
      isRowPinned() {
        return "top" === this.rowPinned || "bottom" === this.rowPinned
      }
      isParentOfNode(e) {
        let t = this.parent;
        for (; t;) {
          if (t === e) return !0;
          t = t.parent
        }
        return !1
      }
      addEventListener(e, t) {
        var i, r;
        this.eventService || (this.eventService = new Re), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.eventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new Ae(this.beans.frameworkOverrides));
        const s = null != (r = null == (i = this.frameworkEventListenerService) ? void 0 : i.wrap(t)) ? r : t;
        this.eventService.addEventListener(e, s)
      }
      removeEventListener(e, t) {
        var i, r;
        if (!this.eventService) return;
        const s = null != (r = null == (i = this.frameworkEventListenerService) ? void 0 : i.unwrap(t)) ? r : t;
        this.eventService.removeEventListener(e, s), this.eventService.noRegisteredListenersExist() && (this.eventService = null)
      }
      onMouseEnter() {
        this.dispatchLocalEvent(this.createLocalRowEvent(e.EVENT_MOUSE_ENTER))
      }
      onMouseLeave() {
        this.dispatchLocalEvent(this.createLocalRowEvent(e.EVENT_MOUSE_LEAVE))
      }
      getFirstChildOfFirstChild(e) {
        let t = this,
          i = !0,
          r = !1,
          s = null;
        for (; i && !r;) {
          const n = t.parent;
          v(n) && t.firstChild ? n.rowGroupColumn === e && (r = !0, s = n) : i = !1, t = n
        }
        return r ? s : null
      }
      isFullWidthCell() {
        if (this.detail) return !0;
        const e = this.beans.gos.getCallback("isFullWidthRow");
        return !!e && e({
          rowNode: this
        })
      }
      getRoute() {
        if (null == this.key) return;
        const e = [];
        let t = this;
        for (; null != t.key;) e.push(t.key), t = t.parent;
        return e.reverse()
      }
      createFooter() {
        if (this.sibling) return;
        const t = new Set(["eventService", "__objectId", "sticky"]),
          i = new e(this.beans);
        Object.keys(this).forEach(e => {
          t.has(e) || (i[e] = this[e])
        }), i.footer = !0, i.setRowTop(null), i.setRowIndex(null), i.oldRowTop = null, i.id = "rowGroupFooter_" + this.id, i.sibling = this, this.sibling = i
      }
      destroyFooter() {
        this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0)
      }
    };
    Bn.ID_PREFIX_ROW_GROUP = "row-group-", Bn.ID_PREFIX_TOP_PINNED = "t-", Bn.ID_PREFIX_BOTTOM_PINNED = "b-", Bn.OBJECT_ID_SEQUENCE = 0, Bn.EVENT_ROW_SELECTED = "rowSelected", Bn.EVENT_DATA_CHANGED = "dataChanged", Bn.EVENT_CELL_CHANGED = "cellChanged", Bn.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged", Bn.EVENT_MASTER_CHANGED = "masterChanged", Bn.EVENT_GROUP_CHANGED = "groupChanged", Bn.EVENT_MOUSE_ENTER = "mouseEnter", Bn.EVENT_MOUSE_LEAVE = "mouseLeave", Bn.EVENT_HEIGHT_CHANGED = "heightChanged", Bn.EVENT_TOP_CHANGED = "topChanged", Bn.EVENT_DISPLAYED_CHANGED = "displayedChanged", Bn.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged", Bn.EVENT_LAST_CHILD_CHANGED = "lastChildChanged", Bn.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged", Bn.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged", Bn.EVENT_EXPANDED_CHANGED = "expandedChanged", Bn.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged", Bn.EVENT_SELECTABLE_CHANGED = "selectableChanged", Bn.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged", Bn.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged", Bn.EVENT_DRAGGING_CHANGED = "draggingChanged";
    var Vn = Bn,
      Wn = class extends _s {
        constructor() {
          super('\n            <div class="ag-selection-checkbox" role="presentation">\n                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>\n            </div>')
        }
        postConstruct() {
          this.eCheckbox.setPassive(!0)
        }
        getCheckboxId() {
          return this.eCheckbox.getInputElement().id
        }
        onDataChanged() {
          this.onSelectionChanged()
        }
        onSelectableChanged() {
          this.showOrHideSelect()
        }
        onSelectionChanged() {
          const e = this.localeService.getLocaleTextFunc(),
            t = this.rowNode.isSelected(),
            i = Ai(e, t),
            [r, s] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"],
            n = e(r, s);
          this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${n} (${i})`)
        }
        onClicked(e, t, i) {
          return this.rowNode.setSelectedParams({
            newValue: e,
            rangeSelect: i.shiftKey,
            groupSelectsFiltered: t,
            event: i,
            source: "checkboxSelected"
          })
        }
        init(e) {
          this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", e => {
            et(e)
          }), this.addManagedListener(this.eCheckbox.getInputElement(), "click", e => {
            et(e);
            const t = this.gos.get("groupSelectsFiltered"),
              i = this.eCheckbox.getValue();
            if (this.shouldHandleIndeterminateState(i, t)) {
              0 === this.onClicked(!0, t, e || {}) && this.onClicked(!1, t, e)
            } else i ? this.onClicked(!1, t, e) : this.onClicked(!0, t, e || {})
          }), this.addManagedListener(this.rowNode, Vn.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_DATA_CHANGED, this.onDataChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this));
          if (this.gos.get("isRowSelectable") || "function" == typeof this.getIsVisible()) {
            const e = this.showOrHideSelect.bind(this);
            this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.rowNode, Vn.EVENT_DATA_CHANGED, e), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, e), this.showOrHideSelect()
          }
          this.eCheckbox.getInputElement().setAttribute("tabindex", "-1")
        }
        shouldHandleIndeterminateState(e, t) {
          return t && (void 0 === this.eCheckbox.getPreviousValue() || void 0 === e) && this.gos.isRowModelType("clientSide")
        }
        showOrHideSelect() {
          var e, t, i;
          let r = this.rowNode.selectable;
          const s = this.getIsVisible();
          if (r)
            if ("function" == typeof s) {
              const t = null == (e = this.overrides) ? void 0 : e.callbackParams;
              if (this.column) {
                const e = this.column.createColumnFunctionCallbackParams(this.rowNode);
                r = s(f(f({}, t), e))
              } else r = s(T(f({}, t), {
                node: this.rowNode,
                data: this.rowNode.data
              }))
            } else r = null != s && s;
          if (null == (t = this.column) ? void 0 : t.getColDef().showDisabledCheckboxes) return this.eCheckbox.setDisabled(!r), this.setVisible(!0), void this.setDisplayed(!0);
          (null == (i = this.overrides) ? void 0 : i.removeHidden) ? this.setDisplayed(r): this.setVisible(r)
        }
        getIsVisible() {
          var e, t;
          return this.overrides ? this.overrides.isVisible : null == (t = null == (e = this.column) ? void 0 : e.getColDef()) ? void 0 : t.checkboxSelection
        }
      };
    C([ys("eCheckbox")], Wn.prototype, "eCheckbox", 2), C([pe], Wn.prototype, "postConstruct", 1);
    var Yn = (e => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(Yn || {}),
      Kn = class extends ct {
        constructor() {
          super(...arguments), this.dragSourceAndParamsList = [], this.dropTargets = []
        }
        init() {
          this.ePinnedIcon = Qr("columnMovePin", this.gos, null), this.eHideIcon = Qr("columnMoveHide", this.gos, null), this.eMoveIcon = Qr("columnMoveMove", this.gos, null), this.eLeftIcon = Qr("columnMoveLeft", this.gos, null), this.eRightIcon = Qr("columnMoveRight", this.gos, null), this.eGroupIcon = Qr("columnMoveGroup", this.gos, null), this.eAggregateIcon = Qr("columnMoveValue", this.gos, null), this.ePivotIcon = Qr("columnMovePivot", this.gos, null), this.eDropNotAllowedIcon = Qr("dropNotAllowed", this.gos, null)
        }
        addDragSource(e, t = !1) {
          const i = {
            eElement: e.eElement,
            dragStartPixels: e.dragStartPixels,
            onDragStart: this.onDragStart.bind(this, e),
            onDragStop: this.onDragStop.bind(this),
            onDragging: this.onDragging.bind(this),
            includeTouch: t
          };
          this.dragSourceAndParamsList.push({
            params: i,
            dragSource: e
          }), this.dragService.addDragSource(i)
        }
        removeDragSource(e) {
          const t = this.dragSourceAndParamsList.find(t => t.dragSource === e);
          t && (this.dragService.removeDragSource(t.params), ke(this.dragSourceAndParamsList, t))
        }
        clearDragSourceParamsList() {
          this.dragSourceAndParamsList.forEach(e => this.dragService.removeDragSource(e.params)), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0
        }
        nudge() {
          this.dragging && this.onDragging(this.eventLastTime, !0)
        }
        onDragStart(e, t) {
          this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), this.lastDropTarget = void 0, this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost()
        }
        onDragStop(e) {
          if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
            const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
            this.lastDropTarget.onDragStop(t)
          }
          this.lastDropTarget = null, this.dragItem = null, this.removeGhost()
        }
        onDragging(e, t) {
          var i, r, s, n;
          const o = this.getHorizontalDirection(e),
            a = this.getVerticalDirection(e);
          this.eventLastTime = e, this.positionGhost(e);
          const l = this.dropTargets.filter(t => this.isMouseOnDropTarget(e, t)),
            c = this.findCurrentDropTarget(e, l);
          if (c !== this.lastDropTarget) this.leaveLastTargetIfExists(e, o, a, t), null !== this.lastDropTarget && null === c && (null == (r = (i = this.dragSource).onGridExit) || r.call(i, this.dragItem)), null === this.lastDropTarget && null !== c && (null == (n = (s = this.dragSource).onGridEnter) || n.call(s, this.dragItem)), this.enterDragTargetIfExists(c, e, o, a, t), this.lastDropTarget = c;
          else if (c && c.onDragging) {
            const i = this.createDropTargetEvent(c, e, o, a, t);
            c.onDragging(i)
          }
        }
        getAllContainersFromDropTarget(e) {
          const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null,
            i = [
              [e.getContainer()]
            ];
          return t ? i.concat(t) : i
        }
        allContainersIntersect(e, t) {
          for (const i of t) {
            const t = i.getBoundingClientRect();
            if (0 === t.width || 0 === t.height) return !1;
            const r = e.clientX >= t.left && e.clientX < t.right,
              s = e.clientY >= t.top && e.clientY < t.bottom;
            if (!r || !s) return !1
          }
          return !0
        }
        isMouseOnDropTarget(e, t) {
          const i = this.getAllContainersFromDropTarget(t);
          let r = !1;
          for (const t of i)
            if (this.allContainersIntersect(e, t)) {
              r = !0;
              break
            } return !(t.targetContainsSource && !t.getContainer().contains(this.dragSource.eElement)) && (r && t.isInterestedIn(this.dragSource.type, this.dragSource.eElement))
        }
        findCurrentDropTarget(e, t) {
          const i = t.length;
          if (0 === i) return null;
          if (1 === i) return t[0];
          const r = this.gos.getRootNode().elementsFromPoint(e.clientX, e.clientY);
          for (const e of r)
            for (const i of t) {
              if (-1 !== ze(this.getAllContainersFromDropTarget(i)).indexOf(e)) return i
            }
          return null
        }
        enterDragTargetIfExists(e, t, i, r, s) {
          if (e) {
            if (e.onDragEnter) {
              const n = this.createDropTargetEvent(e, t, i, r, s);
              e.onDragEnter(n)
            }
            this.setGhostIcon(e.getIconName ? e.getIconName() : null)
          }
        }
        leaveLastTargetIfExists(e, t, i, r) {
          if (this.lastDropTarget) {
            if (this.lastDropTarget.onDragLeave) {
              const s = this.createDropTargetEvent(this.lastDropTarget, e, t, i, r);
              this.lastDropTarget.onDragLeave(s)
            }
            this.setGhostIcon(null)
          }
        }
        addDropTarget(e) {
          this.dropTargets.push(e)
        }
        removeDropTarget(e) {
          this.dropTargets = this.dropTargets.filter(t => t.getContainer() !== e.getContainer())
        }
        hasExternalDropZones() {
          return this.dropTargets.some(e => e.external)
        }
        findExternalZone(e) {
          return this.dropTargets.filter(e => e.external).find(t => t.getContainer() === e.getContainer()) || null
        }
        getHorizontalDirection(e) {
          const t = this.eventLastTime && this.eventLastTime.clientX,
            i = e.clientX;
          return t === i ? null : t > i ? 0 : 1
        }
        getVerticalDirection(e) {
          const t = this.eventLastTime && this.eventLastTime.clientY,
            i = e.clientY;
          return t === i ? null : t > i ? 0 : 1
        }
        createDropTargetEvent(e, t, i, r, s) {
          const n = e.getContainer(),
            o = n.getBoundingClientRect(),
            {
              gridApi: a,
              columnApi: l,
              dragItem: c,
              dragSource: h
            } = this;
          return {
            event: t,
            x: t.clientX - o.left,
            y: t.clientY - o.top,
            vDirection: r,
            hDirection: i,
            dragSource: h,
            fromNudge: s,
            dragItem: c,
            api: a,
            columnApi: l,
            dropZoneTarget: n
          }
        }
        positionGhost(e) {
          const t = this.eGhost;
          if (!t) return;
          const i = t.getBoundingClientRect().height,
            r = Bi() - 2,
            s = Vi() - 2,
            n = Sr(t.offsetParent),
            {
              clientY: o,
              clientX: a
            } = e;
          let l = o - n.top - i / 2,
            c = a - n.left - 10;
          const h = this.gos.getDocument(),
            u = h.defaultView || window,
            d = u.pageYOffset || h.documentElement.scrollTop,
            p = u.pageXOffset || h.documentElement.scrollLeft;
          r > 0 && c + t.clientWidth > r + p && (c = r + p - t.clientWidth), c < 0 && (c = 0), s > 0 && l + t.clientHeight > s + d && (l = s + d - t.clientHeight), l < 0 && (l = 0), t.style.left = `${c}px`, t.style.top = `${l}px`
        }
        removeGhost() {
          this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null
        }
        createGhost() {
          this.eGhost = _r(Kn.GHOST_TEMPLATE), this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
          const {
            theme: e
          } = this.environment.getTheme();
          e && this.eGhost.classList.add(e), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
          const t = this.eGhost.querySelector(".ag-dnd-ghost-label");
          let i = this.dragSource.dragItemName;
          q(i) && (i = i()), t.innerHTML = Nt(i) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
          const r = this.gos.getDocument();
          let s = null,
            n = null;
          try {
            s = r.fullscreenElement
          } catch (e) {} finally {
            s || (s = this.gos.getRootNode());
            const e = s.querySelector("body");
            n = e || (s instanceof ShadowRoot ? s : s instanceof Document ? null == s ? void 0 : s.documentElement : s)
          }
          this.eGhostParent = n, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : console.warn("AG Grid: could not find document body, it is needed for dragging columns")
        }
        setGhostIcon(e, t = !1) {
          Nr(this.eGhostIcon);
          let i = null;
          switch (e || (e = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : Kn.ICON_NOT_ALLOWED), e) {
            case Kn.ICON_PINNED:
              i = this.ePinnedIcon;
              break;
            case Kn.ICON_MOVE:
              i = this.eMoveIcon;
              break;
            case Kn.ICON_LEFT:
              i = this.eLeftIcon;
              break;
            case Kn.ICON_RIGHT:
              i = this.eRightIcon;
              break;
            case Kn.ICON_GROUP:
              i = this.eGroupIcon;
              break;
            case Kn.ICON_AGGREGATE:
              i = this.eAggregateIcon;
              break;
            case Kn.ICON_PIVOT:
              i = this.ePivotIcon;
              break;
            case Kn.ICON_NOT_ALLOWED:
              i = this.eDropNotAllowedIcon;
              break;
            case Kn.ICON_HIDE:
              i = this.eHideIcon
          }
          this.eGhostIcon.classList.toggle("ag-shake-left-to-right", t), i === this.eHideIcon && this.gos.get("suppressDragLeaveHidesColumns") || i && this.eGhostIcon.appendChild(i)
        }
      };
    Kn.ICON_PINNED = "pinned", Kn.ICON_MOVE = "move", Kn.ICON_LEFT = "left", Kn.ICON_RIGHT = "right", Kn.ICON_GROUP = "group", Kn.ICON_AGGREGATE = "aggregate", Kn.ICON_PIVOT = "pivot", Kn.ICON_NOT_ALLOWED = "notAllowed", Kn.ICON_HIDE = "hide", Kn.GHOST_TEMPLATE = '<div class="ag-dnd-ghost ag-unselectable">\n            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>\n            <div class="ag-dnd-ghost-label"></div>\n        </div>', C([fe("dragService")], Kn.prototype, "dragService", 2), C([fe("mouseEventService")], Kn.prototype, "mouseEventService", 2), C([fe("columnApi")], Kn.prototype, "columnApi", 2), C([fe("gridApi")], Kn.prototype, "gridApi", 2), C([pe], Kn.prototype, "init", 1), C([Ee], Kn.prototype, "clearDragSourceParamsList", 1), Kn = C([ge("dragAndDropService")], Kn);
    var Xn = class extends _s {
      constructor(e, t, i, r, s, n) {
        super(), this.cellValueFn = e, this.rowNode = t, this.column = i, this.customGui = r, this.dragStartPixels = s, this.suppressVisibilityChange = n, this.dragSource = null
      }
      isCustomGui() {
        return null != this.customGui
      }
      postConstruct() {
        if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate('<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'), this.getGui().appendChild(Zr("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
          const e = this.gos.get("rowDragManaged") ? new jn(this, this.beans, this.rowNode, this.column) : new $n(this, this.beans, this.rowNode, this.column);
          this.createManagedBean(e, this.beans.context)
        }
      }
      setDragElement(e, t) {
        this.setTemplateFromElement(e), this.addDragSource(t)
      }
      getSelectedNodes() {
        if (!this.gos.get("rowDragMultiRow")) return [this.rowNode];
        const e = this.beans.selectionService.getSelectedNodes();
        return -1 !== e.indexOf(this.rowNode) ? e : [this.rowNode]
      }
      checkCompatibility() {
        const e = this.gos.get("rowDragManaged");
        this.gos.get("treeData") && e && z("If using row drag with tree data, you cannot have rowDragManaged=true")
      }
      getDragItem() {
        return {
          rowNode: this.rowNode,
          rowNodes: this.getSelectedNodes(),
          columns: this.column ? [this.column] : void 0,
          defaultTextValue: this.cellValueFn()
        }
      }
      getRowDragText(e) {
        if (e) {
          const t = e.getColDef();
          if (t.rowDragText) return t.rowDragText
        }
        return this.gos.get("rowDragText")
      }
      addDragSource(e = 4) {
        this.dragSource && this.removeDragSource();
        const t = this.localeService.getLocaleTextFunc();
        this.dragSource = {
          type: 2,
          eElement: this.getGui(),
          dragItemName: () => {
            var e;
            const i = this.getDragItem(),
              r = (null == (e = i.rowNodes) ? void 0 : e.length) || 1,
              s = this.getRowDragText(this.column);
            return s ? s(i, r) : 1 === r ? this.cellValueFn() : `${r} ${t("rowDragRows","rows")}`
          },
          getDragItem: () => this.getDragItem(),
          dragStartPixels: e,
          dragSourceDomDataKey: this.gos.getDomDataKey()
        }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0)
      }
      removeDragSource() {
        this.dragSource && this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null
      }
    };
    C([fe("beans")], Xn.prototype, "beans", 2), C([pe], Xn.prototype, "postConstruct", 1), C([Ee], Xn.prototype, "removeDragSource", 1);
    var zn = class extends ct {
        constructor(e, t, i) {
          super(), this.parent = e, this.rowNode = t, this.column = i
        }
        setDisplayedOrVisible(e) {
          const t = {
            skipAriaHidden: !0
          };
          if (e) this.parent.setDisplayed(!1, t);
          else {
            let e = !0,
              i = !1;
            this.column && (e = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), i = q(this.column.getColDef().rowDrag)), i ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(e, t)) : (this.parent.setDisplayed(e, t), this.parent.setVisible(!0, t))
          }
        }
      },
      $n = class extends zn {
        constructor(e, t, i, r) {
          super(e, i, r), this.beans = t
        }
        postConstruct() {
          this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.workOutVisibility()
        }
        onSuppressRowDrag() {
          this.workOutVisibility()
        }
        workOutVisibility() {
          const e = this.gos.get("suppressRowDrag");
          this.setDisplayedOrVisible(e)
        }
      };
    C([pe], $n.prototype, "postConstruct", 1);
    var jn = class extends zn {
      constructor(e, t, i, r) {
        super(e, i, r), this.beans = t
      }
      postConstruct() {
        this.addManagedListener(this.beans.eventService, Et.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, Et.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility()
      }
      onSuppressRowDrag() {
        this.workOutVisibility()
      }
      workOutVisibility() {
        const e = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(),
          t = e && e.shouldPreventRowMove(),
          i = this.gos.get("suppressRowDrag"),
          r = this.beans.dragAndDropService.hasExternalDropZones(),
          s = t && !r || i;
        this.setDisplayedOrVisible(s)
      }
    };
    C([pe], jn.prototype, "postConstruct", 1);
    var Jn = class extends ct {
      init(e, t, i, r, s, n, o) {
        var a, l, c, h;
        this.params = o, this.eGui = t, this.eCheckbox = i, this.eExpanded = r, this.eContracted = s, this.comp = e, this.compClass = n;
        const {
          node: u,
          value: d,
          colDef: p
        } = o, E = this.isTopLevelFooter();
        if (!E) {
          if (this.isEmbeddedRowMismatch()) return;
          if (u.footer && this.gos.get("groupHideOpenParents")) {
            if ((p && p.showRowGroup) !== (u.rowGroupColumn && u.rowGroupColumn.getColId())) return
          }
        }
        if (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), !E) {
          const e = o.node.footer && o.node.rowGroupIndex === this.columnModel.getRowGroupColumns().findIndex(e => {
              var t;
              return e.getColId() === (null == (t = o.colDef) ? void 0 : t.showRowGroup)
            }),
            t = "multipleColumns" != this.gos.get("groupDisplayType") || this.gos.get("treeData") || this.gos.get("showOpenedGroup") && !o.node.footer && (!o.node.group || null != o.node.rowGroupIndex && o.node.rowGroupIndex > this.columnModel.getRowGroupColumns().findIndex(e => {
              var t;
              return e.getColId() === (null == (t = o.colDef) ? void 0 : t.showRowGroup)
            })),
            i = !u.group && ((null == (a = this.params.colDef) ? void 0 : a.field) || (null == (l = this.params.colDef) ? void 0 : l.valueGetter)),
            r = this.isExpandable(),
            s = this.columnModel.isPivotMode() && u.leafGroup && (null == (c = u.rowGroupColumn) ? void 0 : c.getColId()) === (null == (h = o.column) ? void 0 : h.getColDef().showRowGroup);
          if (!(this.showingValueForOpenedParent || r || i || t || e || s)) return
        }
        this.addExpandAndContract(), this.addFullWidthRowDraggerIfNeeded(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent(), this.refreshAriaExpanded()
      }
      getCellAriaRole() {
        var e, t;
        const i = null == (e = this.params.colDef) ? void 0 : e.cellAriaRole,
          r = null == (t = this.params.column) ? void 0 : t.getColDef().cellAriaRole;
        return i || r || "gridcell"
      }
      destroy() {
        super.destroy(), this.expandListener = null
      }
      refreshAriaExpanded() {
        const {
          node: e,
          eGridCell: t
        } = this.params;
        if (this.expandListener && (this.expandListener = this.expandListener()), !this.isExpandable()) return void li(t);
        const i = () => {
          ai(t, !!e.expanded)
        };
        this.expandListener = this.addManagedListener(e, Vn.EVENT_EXPANDED_CHANGED, i) || null, i()
      }
      isTopLevelFooter() {
        if (!this.gos.getGrandTotalRow()) return !1;
        if (null != this.params.value || -1 != this.params.node.level) return !1;
        const e = this.params.colDef;
        if (null == e) return !0;
        if (!0 === e.showRowGroup) return !0;
        const t = this.columnModel.getRowGroupColumns();
        if (!t || 0 === t.length) return !0;
        return t[0].getId() === e.showRowGroup
      }
      isEmbeddedRowMismatch() {
        if (!this.params.fullWidth || !this.gos.get("embedFullWidthRows")) return !1;
        const e = "left" === this.params.pinned,
          t = "right" === this.params.pinned,
          i = !e && !t;
        return this.gos.get("enableRtl") ? this.columnModel.isPinningLeft() ? !t : !i : this.columnModel.isPinningLeft() ? !e : !i
      }
      findDisplayedGroupNode() {
        const e = this.params.column,
          t = this.params.node;
        if (this.showingValueForOpenedParent) {
          let i = t.parent;
          for (; null != i;) {
            if (i.rowGroupColumn && e.isRowGroupDisplayed(i.rowGroupColumn.getId())) {
              this.displayedGroupNode = i;
              break
            }
            i = i.parent
          }
        }
        N(this.displayedGroupNode) && (this.displayedGroupNode = t)
      }
      setupShowingValueForOpenedParent() {
        const e = this.params.node,
          t = this.params.column;
        if (!this.gos.get("groupHideOpenParents")) return void(this.showingValueForOpenedParent = !1);
        if (!e.groupData) return void(this.showingValueForOpenedParent = !1);
        if (null != e.rowGroupColumn) {
          const i = e.rowGroupColumn.getId();
          if (t.isRowGroupDisplayed(i)) return void(this.showingValueForOpenedParent = !1)
        }
        const i = null != e.groupData[t.getId()];
        this.showingValueForOpenedParent = i
      }
      addValueElement() {
        this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount())
      }
      addGroupValue() {
        var e;
        const t = this.adjustParamsWithDetailsFromRelatedColumn(),
          i = this.getInnerCompDetails(t),
          {
            valueFormatted: r,
            value: s
          } = t;
        let n = r;
        if (null == n) {
          const t = this.displayedGroupNode.rowGroupColumn && (null == (e = this.params.column) ? void 0 : e.isRowGroupDisplayed(this.displayedGroupNode.rowGroupColumn.getId()));
          if ("" === this.displayedGroupNode.key && this.displayedGroupNode.group && t) {
            n = this.localeService.getLocaleTextFunc()("blanks", "(Blanks)")
          } else n = null != s ? s : null
        }
        this.comp.setInnerRenderer(i, n)
      }
      adjustParamsWithDetailsFromRelatedColumn() {
        const e = this.displayedGroupNode.rowGroupColumn,
          t = this.params.column;
        if (!e) return this.params;
        if (null != t) {
          if (!t.isRowGroupDisplayed(e.getId())) return this.params
        }
        const i = this.params,
          {
            value: r,
            node: s
          } = this.params,
          n = this.valueService.formatValue(e, s, r);
        return T(f({}, i), {
          valueFormatted: n
        })
      }
      addFooterValue() {
        let e = this.params.totalValueGetter;
        if (!e) {
          const t = this.params.footerValueGetter;
          t && (e = t, z("As of v31.3, footerValueGetter is deprecated. Use `totalValueGetter` instead."))
        }
        let t = "";
        if (e) {
          const i = G(this.params);
          i.value = this.params.value, "function" == typeof e ? t = e(i) : "string" == typeof e ? t = this.expressionService.evaluate(e, i) : console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)")
        } else {
          t = this.localeService.getLocaleTextFunc()("footerTotal", "Total") + " " + (null != this.params.value ? this.params.value : "")
        }
        const i = this.getInnerCompDetails(this.params);
        this.comp.setInnerRenderer(i, t)
      }
      getInnerCompDetails(e) {
        if (e.fullWidth) return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(this.gos.get("groupRowRendererParams"), e);
        const t = this.userComponentFactory.getInnerRendererDetails(e, e),
          i = e => e && e.componentClass == this.compClass;
        if (t && !i(t)) return t;
        const r = this.displayedGroupNode.rowGroupColumn,
          s = r ? r.getColDef() : void 0;
        if (!s) return;
        const n = this.userComponentFactory.getCellRendererDetails(s, e);
        if (n && !i(n)) return n;
        if (i(n) && s.cellRendererParams && s.cellRendererParams.innerRenderer) {
          return this.userComponentFactory.getInnerRendererDetails(s.cellRendererParams, e)
        }
      }
      addChildCount() {
        this.params.suppressCount || (this.addManagedListener(this.displayedGroupNode, Vn.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this)), this.updateChildCount())
      }
      updateChildCount() {
        const e = this.displayedGroupNode.allChildrenCount,
          t = this.isShowRowGroupForThisRow() && null != e && e >= 0 ? `(${e})` : "";
        this.comp.setChildCount(t)
      }
      isShowRowGroupForThisRow() {
        if (this.gos.get("treeData")) return !0;
        const e = this.displayedGroupNode.rowGroupColumn;
        if (!e) return !1;
        const t = this.params.column;
        return null == t || t.isRowGroupDisplayed(e.getId())
      }
      addExpandAndContract() {
        var e;
        const t = this.params,
          i = Zr("groupExpanded", this.gos, null),
          r = Zr("groupContracted", this.gos, null);
        i && this.eExpanded.appendChild(i), r && this.eContracted.appendChild(r);
        const s = t.eGridCell;
        (null == (e = this.params.column) ? void 0 : e.isCellEditable(t.node)) && this.gos.get("enableGroupEdit") || !this.isExpandable() || t.suppressDoubleClickExpand || this.addManagedListener(s, "dblclick", this.onCellDblClicked.bind(this)), this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this)), this.addManagedListener(s, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(t.node, Vn.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this)), this.showExpandAndContractIcons();
        const n = this.onRowNodeIsExpandableChanged.bind(this);
        this.addManagedListener(this.displayedGroupNode, Vn.EVENT_ALL_CHILDREN_COUNT_CHANGED, n), this.addManagedListener(this.displayedGroupNode, Vn.EVENT_MASTER_CHANGED, n), this.addManagedListener(this.displayedGroupNode, Vn.EVENT_GROUP_CHANGED, n), this.addManagedListener(this.displayedGroupNode, Vn.EVENT_HAS_CHILDREN_CHANGED, n)
      }
      onExpandClicked(e) {
        tt(e) || (et(e), this.onExpandOrContract(e))
      }
      onExpandOrContract(e) {
        const t = this.displayedGroupNode,
          i = !t.expanded;
        !i && t.sticky && this.scrollToStickyNode(t), t.setExpanded(i, e)
      }
      scrollToStickyNode(e) {
        this.ctrlsService.getGridBodyCtrl().getScrollFeature().setVerticalScrollPosition(e.rowTop - e.stickyRowTop)
      }
      isExpandable() {
        if (this.showingValueForOpenedParent) return !0;
        const e = this.displayedGroupNode,
          t = this.columnModel.isPivotMode() && e.leafGroup;
        if (!(e.isExpandable() && !e.footer && !t)) return !1;
        const i = this.params.column;
        if (null != i && "string" == typeof i.getColDef().showRowGroup) {
          return this.isShowRowGroupForThisRow()
        }
        return !0
      }
      showExpandAndContractIcons() {
        const {
          params: e,
          displayedGroupNode: t,
          columnModel: i
        } = this, {
          node: r
        } = e, s = this.isExpandable();
        if (s) {
          const e = !!this.showingValueForOpenedParent || r.expanded;
          this.comp.setExpandedDisplayed(e), this.comp.setContractedDisplayed(!e)
        } else this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
        const n = i.isPivotMode(),
          o = n && t.leafGroup,
          a = s && !o,
          l = r.footer && -1 === r.level;
        this.comp.addOrRemoveCssClass("ag-cell-expandable", a), this.comp.addOrRemoveCssClass("ag-row-group", a), n ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", o) : l || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !a)
      }
      onRowNodeIsExpandableChanged() {
        this.showExpandAndContractIcons(), this.setIndent(), this.refreshAriaExpanded()
      }
      setupIndent() {
        const e = this.params.node;
        this.params.suppressPadding || (this.addManagedListener(e, Vn.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this)), this.setIndent())
      }
      setIndent() {
        if (this.gos.get("groupHideOpenParents")) return;
        const e = this.params,
          t = e.node,
          i = !!e.colDef,
          r = this.gos.get("treeData"),
          s = !i || r || !0 === e.colDef.showRowGroup ? t.uiLevel : 0;
        this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + s, this.comp.addOrRemoveCssClass(this.indentClass, !0)
      }
      addFullWidthRowDraggerIfNeeded() {
        if (!this.params.fullWidth || !this.params.rowDrag) return;
        const e = new Xn(() => this.params.value, this.params.node);
        this.createManagedBean(e, this.context), this.eGui.insertAdjacentElement("afterbegin", e.getGui())
      }
      isUserWantsSelected() {
        const e = this.params.checkbox;
        return "function" == typeof e || !0 === e
      }
      addCheckboxIfNeeded() {
        const e = this.displayedGroupNode,
          t = this.isUserWantsSelected() && !e.footer && !e.rowPinned && !e.detail;
        if (t) {
          const e = new Wn;
          this.getContext().createBean(e), e.init({
            rowNode: this.params.node,
            column: this.params.column,
            overrides: {
              isVisible: this.params.checkbox,
              callbackParams: this.params,
              removeHidden: !0
            }
          }), this.eCheckbox.appendChild(e.getGui()), this.addDestroyFunc(() => this.getContext().destroyBean(e))
        }
        this.comp.setCheckboxVisible(t)
      }
      onKeyDown(e) {
        if (!(e.key === ts.ENTER) || this.params.suppressEnterExpand) return;
        this.params.column && this.params.column.isCellEditable(this.params.node) || this.onExpandOrContract(e)
      }
      onCellDblClicked(e) {
        if (tt(e)) return;
        st(this.eExpanded, e) || st(this.eContracted, e) || this.onExpandOrContract(e)
      }
    };
    C([fe("expressionService")], Jn.prototype, "expressionService", 2), C([fe("valueService")], Jn.prototype, "valueService", 2), C([fe("columnModel")], Jn.prototype, "columnModel", 2), C([fe("userComponentFactory")], Jn.prototype, "userComponentFactory", 2), C([fe("ctrlsService")], Jn.prototype, "ctrlsService", 2);
    var qn = class e extends _s {
      constructor() {
        super(e.TEMPLATE)
      }
      init(e) {
        const t = {
            setInnerRenderer: (e, t) => this.setRenderDetails(e, t),
            setChildCount: e => this.eChildCount.textContent = e,
            addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
            setContractedDisplayed: e => ur(this.eContracted, e),
            setExpandedDisplayed: e => ur(this.eExpanded, e),
            setCheckboxVisible: e => this.eCheckbox.classList.toggle("ag-invisible", !e)
          },
          i = this.createManagedBean(new Jn),
          r = !e.colDef,
          s = this.getGui();
        i.init(t, s, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, e), r && Xt(s, i.getCellAriaRole())
      }
      setRenderDetails(e, t) {
        if (e) {
          const t = e.newAgStackInstance();
          if (!t) return;
          t.then(e => {
            if (!e) return;
            const t = () => this.context.destroyBean(e);
            this.isAlive() ? (this.eValue.appendChild(e.getGui()), this.addDestroyFunc(t)) : t()
          })
        } else this.eValue.innerText = t
      }
      destroy() {
        this.getContext().destroyBean(this.innerCellRenderer), super.destroy()
      }
      refresh() {
        return !1
      }
    };
    qn.TEMPLATE = '<span class="ag-cell-wrapper">\n            <span class="ag-group-expanded" ref="eExpanded"></span>\n            <span class="ag-group-contracted" ref="eContracted"></span>\n            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>\n            <span class="ag-group-value" ref="eValue"></span>\n            <span class="ag-group-child-count" ref="eChildCount"></span>\n        </span>', C([ys("eExpanded")], qn.prototype, "eExpanded", 2), C([ys("eContracted")], qn.prototype, "eContracted", 2), C([ys("eCheckbox")], qn.prototype, "eCheckbox", 2), C([ys("eValue")], qn.prototype, "eValue", 2), C([ys("eChildCount")], qn.prototype, "eChildCount", 2);
    var Qn = qn,
      Zn = class e extends _s {
        constructor() {
          super(e.TEMPLATE)
        }
        init(e) {
          e.node.failedLoad ? this.setupFailed() : this.setupLoading()
        }
        setupFailed() {
          const e = this.localeService.getLocaleTextFunc();
          this.eLoadingText.innerText = e("loadingError", "ERR")
        }
        setupLoading() {
          const e = Zr("groupLoading", this.gos, null);
          e && this.eLoadingIcon.appendChild(e);
          const t = this.localeService.getLocaleTextFunc();
          this.eLoadingText.innerText = t("loadingOoo", "Loading")
        }
        refresh(e) {
          return !1
        }
        destroy() {
          super.destroy()
        }
      };
    Zn.TEMPLATE = '<div class="ag-loading">\n            <span class="ag-loading-icon" ref="eLoadingIcon"></span>\n            <span class="ag-loading-text" ref="eLoadingText"></span>\n        </div>', C([ys("eLoadingIcon")], Zn.prototype, "eLoadingIcon", 2), C([ys("eLoadingText")], Zn.prototype, "eLoadingText", 2);
    var eo = Zn,
      to = class e extends _s {
        constructor() {
          super(e.TEMPLATE)
        }
        init(e) {
          const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
          this.getGui().setAttribute("id", t), this.addDestroyFunc(() => Qt(e.eParentOfValue)), Qt(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading()
        }
        setupFailed() {
          const e = this.localeService.getLocaleTextFunc();
          this.getGui().innerText = e("loadingError", "ERR");
          const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
          qt(this.getGui(), t)
        }
        setupLoading() {
          const e = this.gos.getDocument().createElement("div");
          e.classList.add("ag-skeleton-effect"), this.getGui().appendChild(e);
          const t = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
          qt(this.getGui(), t)
        }
        refresh(e) {
          return !1
        }
        destroy() {
          super.destroy()
        }
      };
    to.TEMPLATE = '<div class="ag-skeleton-container"></div>';
    var io = to,
      ro = class e extends _s {
        constructor() {
          super()
        }
        destroy() {
          super.destroy()
        }
        init(t) {
          const i = this.gos.get("overlayLoadingTemplate");
          if (this.setTemplate(null != i ? i : e.DEFAULT_LOADING_OVERLAY_TEMPLATE), !i) {
            const e = this.localeService.getLocaleTextFunc();
            setTimeout(() => {
              this.getGui().textContent = e("loadingOoo", "Loading...")
            })
          }
        }
      };
    ro.DEFAULT_LOADING_OVERLAY_TEMPLATE = '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>';
    var so = ro,
      no = class e extends _s {
        constructor() {
          super()
        }
        destroy() {
          super.destroy()
        }
        init(t) {
          const i = this.gos.get("overlayNoRowsTemplate");
          if (this.setTemplate(null != i ? i : e.DEFAULT_NO_ROWS_TEMPLATE), !i) {
            const e = this.localeService.getLocaleTextFunc();
            setTimeout(() => {
              this.getGui().textContent = e("noRowsToShow", "No Rows To Show")
            })
          }
        }
      };
    no.DEFAULT_NO_ROWS_TEMPLATE = '<span class="ag-overlay-no-rows-center"></span>';
    var oo = no,
      ao = class extends Pn {
        constructor() {
          super('<div class="ag-tooltip"></div>')
        }
        init(e) {
          const {
            value: t
          } = e;
          this.getGui().textContent = Nt(t, !0)
        }
      },
      lo = class {
        getTemplate() {
          return '<ag-input-number-field class="ag-cell-editor" ref="eInput"></ag-input-number-field>'
        }
        init(e, t) {
          this.eInput = e, this.params = t, null != t.max && e.setMax(t.max), null != t.min && e.setMin(t.min), null != t.precision && e.setPrecision(t.precision), null != t.step && e.setStep(t.step);
          const i = e.getInputElement();
          t.preventStepping ? e.addManagedListener(i, "keydown", this.preventStepping) : t.showStepperButtons && i.classList.add("ag-number-field-input-stepper")
        }
        preventStepping(e) {
          e.key !== ts.UP && e.key !== ts.DOWN || e.preventDefault()
        }
        getValue() {
          const e = this.eInput.getValue();
          if (!v(e) && !v(this.params.value)) return this.params.value;
          let t = this.params.parseValue(e);
          if (null == t) return t;
          if ("string" == typeof t) {
            if ("" === t) return null;
            t = Number(t)
          }
          return isNaN(t) ? null : t
        }
        getStartValue() {
          return this.params.value
        }
      },
      co = class extends xn {
        constructor() {
          super(new lo)
        }
      },
      ho = class {
        getTemplate() {
          return '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
        }
        init(e, t) {
          this.eInput = e, this.params = t, null != t.min && e.setMin(t.min), null != t.max && e.setMax(t.max), null != t.step && e.setStep(t.step)
        }
        getValue() {
          const e = this.eInput.getDate();
          return v(e) || v(this.params.value) ? null != e ? e : null : this.params.value
        }
        getStartValue() {
          const {
            value: e
          } = this.params;
          if (e instanceof Date) return tr(e, !1)
        }
      },
      uo = class extends xn {
        constructor() {
          super(new ho)
        }
      },
      po = class {
        constructor(e) {
          this.getDataTypeService = e
        }
        getTemplate() {
          return '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
        }
        init(e, t) {
          this.eInput = e, this.params = t, null != t.min && e.setMin(t.min), null != t.max && e.setMax(t.max), null != t.step && e.setStep(t.step)
        }
        getValue() {
          const e = this.formatDate(this.eInput.getDate());
          return v(e) || v(this.params.value) ? this.params.parseValue(null != e ? e : "") : this.params.value
        }
        getStartValue() {
          var e, t;
          return tr(null != (t = this.parseDate(null != (e = this.params.value) ? e : void 0)) ? t : null, !1)
        }
        parseDate(e) {
          return this.getDataTypeService().getDateParserFunction(this.params.column)(e)
        }
        formatDate(e) {
          return this.getDataTypeService().getDateFormatterFunction(this.params.column)(e)
        }
      },
      Eo = class extends xn {
        constructor() {
          super(new po(() => this.dataTypeService))
        }
      };
    C([fe("dataTypeService")], Eo.prototype, "dataTypeService", 2);
    var go = class e extends _s {
      constructor() {
        super(e.TEMPLATE)
      }
      init(e) {
        this.params = e, this.updateCheckbox(e);
        const t = this.eCheckbox.getInputElement();
        t.setAttribute("tabindex", "-1"), ei(t, "polite"), this.addManagedListener(t, "click", e => {
          if (et(e), this.eCheckbox.isDisabled()) return;
          const t = this.eCheckbox.getValue();
          this.onCheckboxChanged(t)
        }), this.addManagedListener(t, "dblclick", e => {
          et(e)
        }), this.addManagedListener(this.params.eGridCell, "keydown", e => {
          if (e.key === ts.SPACE && !this.eCheckbox.isDisabled()) {
            this.params.eGridCell === this.gos.getActiveDomElement() && this.eCheckbox.toggle();
            const t = this.eCheckbox.getValue();
            this.onCheckboxChanged(t), e.preventDefault()
          }
        })
      }
      refresh(e) {
        return this.params = e, this.updateCheckbox(e), !0
      }
      updateCheckbox(e) {
        var t, i, r;
        let s, n = !0;
        if (e.node.group && e.column) {
          const i = e.column.getColId();
          i.startsWith(Tt) ? s = null == e.value || "" === e.value ? void 0 : "true" === e.value : e.node.aggData && void 0 !== e.node.aggData[i] ? s = null != (t = e.value) ? t : void 0 : n = !1
        } else s = null != (i = e.value) ? i : void 0;
        if (!n) return void this.eCheckbox.setDisplayed(!1);
        this.eCheckbox.setValue(s);
        const o = null != e.disabled ? e.disabled : !(null == (r = e.column) ? void 0 : r.isCellEditable(e.node));
        this.eCheckbox.setDisabled(o);
        const a = this.localeService.getLocaleTextFunc(),
          l = Ai(a, s),
          c = o ? l : `${a("ariaToggleCellValue","Press SPACE to toggle cell value")} (${l})`;
        this.eCheckbox.setInputAriaLabel(c)
      }
      onCheckboxChanged(e) {
        const {
          column: t,
          node: i,
          rowIndex: r,
          value: s
        } = this.params, n = {
          type: Et.EVENT_CELL_EDITING_STARTED,
          column: t,
          colDef: null == t ? void 0 : t.getColDef(),
          data: i.data,
          node: i,
          rowIndex: r,
          rowPinned: i.rowPinned,
          value: s
        };
        this.eventService.dispatchEvent(n);
        const o = this.params.node.setDataValue(this.params.column, e, "edit"),
          a = {
            type: Et.EVENT_CELL_EDITING_STOPPED,
            column: t,
            colDef: null == t ? void 0 : t.getColDef(),
            data: i.data,
            node: i,
            rowIndex: r,
            rowPinned: i.rowPinned,
            value: s,
            oldValue: s,
            newValue: e,
            valueChanged: o
          };
        this.eventService.dispatchEvent(a)
      }
    };
    go.TEMPLATE = '\n        <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">\n            <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>\n        </div>', C([ys("eCheckbox")], go.prototype, "eCheckbox", 2);
    var fo = go,
      To = class extends Pn {
        constructor() {
          super('\n            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">\n                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>\n            </div>')
        }
        init(e) {
          var t;
          this.params = e;
          const i = null != (t = e.value) ? t : void 0;
          this.eCheckbox.setValue(i);
          this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(i), this.addManagedListener(this.eCheckbox, Et.EVENT_FIELD_VALUE_CHANGED, e => this.setAriaLabel(e.selected))
        }
        getValue() {
          return this.eCheckbox.getValue()
        }
        focusIn() {
          this.eCheckbox.getFocusableElement().focus()
        }
        afterGuiAttached() {
          this.params.cellStartedEdit && this.focusIn()
        }
        isPopup() {
          return !1
        }
        setAriaLabel(e) {
          const t = this.localeService.getLocaleTextFunc(),
            i = Ai(t, e),
            r = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
          this.eCheckbox.setInputAriaLabel(`${r} (${i})`)
        }
      };
    C([ys("eCheckbox")], To.prototype, "eCheckbox", 2);
    var mo = class extends _s {
        constructor() {
          super(), this.setTemplate("<div></div>")
        }
        init(e) {
          var t;
          this.params = e, this.cssClassPrefix = null != (t = this.params.cssClassPrefix) ? t : "ag-menu-option", this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu()
        }
        configureDefaults() {
          return !0
        }
        addIcon() {
          if (this.params.isCompact) return;
          const e = _r(`<span ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`);
          this.params.checked ? e.appendChild(Zr("check", this.gos)) : this.params.icon && (kr(this.params.icon) ? e.appendChild(this.params.icon) : "string" == typeof this.params.icon ? e.innerHTML = this.params.icon : console.warn("AG Grid: menu item icon must be DOM node or string")), this.getGui().appendChild(e)
        }
        addName() {
          const e = _r(`<span ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name||""}</span>`);
          this.getGui().appendChild(e)
        }
        addShortcut() {
          if (this.params.isCompact) return;
          const e = _r(`<span ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut||""}</span>`);
          this.getGui().appendChild(e)
        }
        addSubMenu() {
          const e = _r(`<span ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`),
            t = this.getGui();
          if (this.params.subMenu) {
            const i = this.gos.get("enableRtl") ? "smallLeft" : "smallRight";
            ai(t, !1), e.appendChild(Zr(i, this.gos))
          }
          t.appendChild(e)
        }
        getClassName(e) {
          return `${this.cssClassPrefix}-${e}`
        }
        destroy() {
          super.destroy()
        }
      },
      Co = class extends ct {
        constructor() {
          super(...arguments), this.agGridDefaults = {
            agDateInput: cn,
            agColumnHeader: yn,
            agColumnGroupHeader: Dn,
            agSortIndicator: Ln,
            agTextColumnFloatingFilter: vn,
            agNumberColumnFloatingFilter: An,
            agDateColumnFloatingFilter: ln,
            agReadOnlyFloatingFilter: Ds,
            agAnimateShowChangeCellRenderer: Hn,
            agAnimateSlideCellRenderer: kn,
            agGroupCellRenderer: Qn,
            agGroupRowRenderer: Qn,
            agLoadingCellRenderer: eo,
            agSkeletonCellRenderer: io,
            agCheckboxCellRenderer: fo,
            agCellEditor: Un,
            agTextCellEditor: Un,
            agNumberCellEditor: co,
            agDateCellEditor: uo,
            agDateStringCellEditor: Eo,
            agSelectCellEditor: Fn,
            agLargeTextCellEditor: Mn,
            agCheckboxCellEditor: To,
            agTextColumnFilter: mn,
            agNumberColumnFilter: gn,
            agDateColumnFilter: on,
            agLoadingOverlay: so,
            agNoRowsOverlay: oo,
            agTooltipComponent: ao,
            agMenuItem: mo
          }, this.enterpriseAgDefaultCompsModule = {
            agSetColumnFilter: "@ag-grid-enterprise/set-filter",
            agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
            agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
            agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
            agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
            agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
            agRichSelect: "@ag-grid-enterprise/rich-select",
            agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
            agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
            agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
          }, this.jsComps = {}
        }
        init() {
          const e = this.gos.get("components");
          null != e && x(e, (e, t) => this.registerJsComponent(e, t))
        }
        registerDefaultComponent(e, t) {
          this.agGridDefaults[e] ? console.error("Trying to overwrite a default component. You should call registerComponent") : this.agGridDefaults[e] = t
        }
        registerJsComponent(e, t) {
          this.jsComps[e] = t
        }
        retrieve(e, t) {
          const i = (e, t) => ({
              componentFromFramework: t,
              component: e
            }),
            r = this.getFrameworkOverrides().frameworkComponent(t, this.gos.get("components"));
          if (null != r) return i(r, !0);
          const s = this.jsComps[t];
          if (s) {
            return i(s, this.getFrameworkOverrides().isFrameworkComponent(s))
          }
          const n = this.agGridDefaults[t];
          if (n) return i(n, !1);
          const o = this.enterpriseAgDefaultCompsModule[t];
          return o ? he.__assertRegistered(o, `AG Grid '${e}' component: ${t}`, this.context.getGridId()) : X(() => {
            this.warnAboutMissingComponent(e, t)
          }, "MissingComp" + t), null
        }
        warnAboutMissingComponent(e, t) {
          const i = $r(t, [...Object.keys(this.agGridDefaults).filter(e => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(e)), ...Object.keys(this.jsComps)], !0, .8).values;
          console.warn(`AG Grid: Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`), i.length > 0 && console.warn(`         Did you mean: [${i.slice(0,3)}]?`), console.warn(`If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`)
        }
      };
    C([pe], Co.prototype, "init", 1), Co = C([ge("userComponentRegistry")], Co);
    var So = {
        propertyName: "dateComponent",
        cellRenderer: !1
      },
      Ro = {
        propertyName: "headerComponent",
        cellRenderer: !1
      },
      Ao = {
        propertyName: "headerGroupComponent",
        cellRenderer: !1
      },
      vo = {
        propertyName: "cellRenderer",
        cellRenderer: !0
      },
      No = {
        propertyName: "loadingCellRenderer",
        cellRenderer: !0
      },
      Io = {
        propertyName: "cellEditor",
        cellRenderer: !1
      },
      Oo = {
        propertyName: "innerRenderer",
        cellRenderer: !0
      },
      Lo = {
        propertyName: "loadingOverlayComponent",
        cellRenderer: !1
      },
      _o = {
        propertyName: "noRowsOverlayComponent",
        cellRenderer: !1
      },
      yo = {
        propertyName: "tooltipComponent",
        cellRenderer: !1
      },
      wo = {
        propertyName: "filter",
        cellRenderer: !1
      },
      Do = {
        propertyName: "floatingFilterComponent",
        cellRenderer: !1
      },
      Po = {
        propertyName: "toolPanel",
        cellRenderer: !1
      },
      bo = {
        propertyName: "statusPanel",
        cellRenderer: !1
      },
      Mo = {
        propertyName: "fullWidthCellRenderer",
        cellRenderer: !0
      },
      Fo = {
        propertyName: "loadingCellRenderer",
        cellRenderer: !0
      },
      xo = {
        propertyName: "groupRowRenderer",
        cellRenderer: !0
      },
      Go = {
        propertyName: "detailCellRenderer",
        cellRenderer: !0
      },
      Uo = {
        propertyName: "menuItem",
        cellRenderer: !1
      },
      Ho = class {
        static getFloatingFilterType(e) {
          return this.filterToFloatingFilterMapping[e]
        }
      };
    Ho.filterToFloatingFilterMapping = {
      set: "agSetColumnFloatingFilter",
      agSetColumnFilter: "agSetColumnFloatingFilter",
      multi: "agMultiColumnFloatingFilter",
      agMultiColumnFilter: "agMultiColumnFloatingFilter",
      group: "agGroupColumnFloatingFilter",
      agGroupColumnFilter: "agGroupColumnFloatingFilter",
      number: "agNumberColumnFloatingFilter",
      agNumberColumnFilter: "agNumberColumnFloatingFilter",
      date: "agDateColumnFloatingFilter",
      agDateColumnFilter: "agDateColumnFloatingFilter",
      text: "agTextColumnFloatingFilter",
      agTextColumnFilter: "agTextColumnFloatingFilter"
    };
    var ko = class extends ct {
      getHeaderCompDetails(e, t) {
        return this.getCompDetails(e, Ro, "agColumnHeader", t)
      }
      getHeaderGroupCompDetails(e) {
        const t = e.columnGroup.getColGroupDef();
        return this.getCompDetails(t, Ao, "agColumnGroupHeader", e)
      }
      getFullWidthCellRendererDetails(e) {
        return this.getCompDetails(this.gridOptions, Mo, null, e, !0)
      }
      getFullWidthLoadingCellRendererDetails(e) {
        return this.getCompDetails(this.gridOptions, Fo, "agLoadingCellRenderer", e, !0)
      }
      getFullWidthGroupCellRendererDetails(e) {
        return this.getCompDetails(this.gridOptions, xo, "agGroupRowRenderer", e, !0)
      }
      getFullWidthDetailCellRendererDetails(e) {
        return this.getCompDetails(this.gridOptions, Go, "agDetailCellRenderer", e, !0)
      }
      getInnerRendererDetails(e, t) {
        return this.getCompDetails(e, Oo, null, t)
      }
      getFullWidthGroupRowInnerCellRenderer(e, t) {
        return this.getCompDetails(e, Oo, null, t)
      }
      getCellRendererDetails(e, t) {
        return this.getCompDetails(e, vo, null, t)
      }
      getLoadingCellRendererDetails(e, t) {
        return this.getCompDetails(e, No, "agSkeletonCellRenderer", t, !0)
      }
      getCellEditorDetails(e, t) {
        return this.getCompDetails(e, Io, "agCellEditor", t, !0)
      }
      getFilterDetails(e, t, i) {
        return this.getCompDetails(e, wo, i, t, !0)
      }
      getDateCompDetails(e) {
        return this.getCompDetails(this.gridOptions, So, "agDateInput", e, !0)
      }
      getLoadingOverlayCompDetails(e) {
        return this.getCompDetails(this.gridOptions, Lo, "agLoadingOverlay", e, !0)
      }
      getNoRowsOverlayCompDetails(e) {
        return this.getCompDetails(this.gridOptions, _o, "agNoRowsOverlay", e, !0)
      }
      getTooltipCompDetails(e) {
        return this.getCompDetails(e.colDef, yo, "agTooltipComponent", e, !0)
      }
      getSetFilterCellRendererDetails(e, t) {
        return this.getCompDetails(e, vo, null, t)
      }
      getFloatingFilterCompDetails(e, t, i) {
        return this.getCompDetails(e, Do, i, t)
      }
      getToolPanelCompDetails(e, t) {
        return this.getCompDetails(e, Po, null, t, !0)
      }
      getStatusPanelCompDetails(e, t) {
        return this.getCompDetails(e, bo, null, t, !0)
      }
      getMenuItemCompDetails(e, t) {
        return this.getCompDetails(e, Uo, "agMenuItem", t, !0)
      }
      getCompDetails(e, t, i, r, s = !1) {
        const {
          propertyName: n,
          cellRenderer: o
        } = t;
        let {
          compName: a,
          jsComp: l,
          fwComp: c,
          paramsFromSelector: h,
          popupFromSelector: u,
          popupPositionFromSelector: d
        } = this.getCompKeys(e, t, r);
        const p = e => {
          const t = this.userComponentRegistry.retrieve(n, e);
          t && (l = t.componentFromFramework ? void 0 : t.component, c = t.componentFromFramework ? t.component : void 0)
        };
        if (null != a && p(a), null == l && null == c && null != i && p(i), l && o && !this.agComponentUtils.doesImplementIComponent(l) && (l = this.agComponentUtils.adaptFunction(n, l)), !l && !c) return void(s && console.error(`AG Grid: Could not find component ${a}, did you forget to configure this component?`));
        const E = this.mergeParamsWithApplicationProvidedParams(e, t, r, h),
          g = null == l,
          f = l || c;
        return {
          componentFromFramework: g,
          componentClass: f,
          params: E,
          type: t,
          popupFromSelector: u,
          popupPositionFromSelector: d,
          newAgStackInstance: () => this.newAgStackInstance(f, g, E, t)
        }
      }
      getCompKeys(e, t, i) {
        const {
          propertyName: r
        } = t;
        let s, n, o, a, l, c;
        if (e) {
          const t = e,
            h = t[r + "Selector"],
            u = h ? h(i) : null,
            d = e => {
              if ("string" == typeof e) s = e;
              else if (null != e && !0 !== e) {
                this.getFrameworkOverrides().isFrameworkComponent(e) ? o = e : n = e
              }
            };
          u ? (d(u.component), a = u.params, l = u.popup, c = u.popupPosition) : d(t[r])
        }
        return {
          compName: s,
          jsComp: n,
          fwComp: o,
          paramsFromSelector: a,
          popupFromSelector: l,
          popupPositionFromSelector: c
        }
      }
      newAgStackInstance(e, t, i, r) {
        const s = r.propertyName;
        let n;
        if (!t) n = new e;
        else {
          const t = this.componentMetadataProvider.retrieve(s);
          n = this.frameworkComponentWrapper.wrap(e, t.mandatoryMethodList, t.optionalMethodList, r)
        }
        const o = this.initComponent(n, i);
        return null == o ? Rs.resolve(n) : o.then(() => n)
      }
      mergeParamsWithApplicationProvidedParams(e, t, i, r = null) {
        const s = this.gos.getGridCommonParams();
        k(s, i);
        const n = e && e[t.propertyName + "Params"];
        if ("function" == typeof n) {
          k(s, n(i))
        } else "object" == typeof n && k(s, n);
        return k(s, r), s
      }
      initComponent(e, t) {
        if (this.context.createBean(e), null != e.init) return e.init(t)
      }
      getDefaultFloatingFilterType(e, t) {
        if (null == e) return null;
        let i = null,
          {
            compName: r,
            jsComp: s,
            fwComp: n
          } = this.getCompKeys(e, wo);
        if (r) i = Ho.getFloatingFilterType(r);
        else {
          null == s && null == n && !0 === e.filter && (i = t())
        }
        return i
      }
    };
    C([fe("gridOptions")], ko.prototype, "gridOptions", 2), C([fe("agComponentUtils")], ko.prototype, "agComponentUtils", 2), C([fe("componentMetadataProvider")], ko.prototype, "componentMetadataProvider", 2), C([fe("userComponentRegistry")], ko.prototype, "userComponentRegistry", 2), C([Te("frameworkComponentWrapper")], ko.prototype, "frameworkComponentWrapper", 2), ko = C([ge("userComponentFactory")], ko);
    var Bo = class {
        constructor(e) {
          this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = -1 !== e.scrollAxis.indexOf("x"), this.scrollVertically = -1 !== e.scrollAxis.indexOf("y"), this.scrollByTick = null != e.scrollByTick ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1)
        }
        check(e, t = !1) {
          const i = t || this.shouldSkipVerticalScroll();
          if (i && this.shouldSkipHorizontalScroll()) return;
          const r = this.scrollContainer.getBoundingClientRect(),
            s = this.scrollByTick;
          this.tickLeft = e.clientX < r.left + s, this.tickRight = e.clientX > r.right - s, this.tickUp = e.clientY < r.top + s && !i, this.tickDown = e.clientY > r.bottom - s && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared()
        }
        ensureTickingStarted() {
          null === this.tickingInterval && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0)
        }
        doTick() {
          let e;
          if (this.tickCount++, e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40, this.scrollVertically) {
            const t = this.getVerticalPosition();
            this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e)
          }
          if (this.scrollHorizontally) {
            const t = this.getHorizontalPosition();
            this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e)
          }
          this.onScrollCallback && this.onScrollCallback()
        }
        ensureCleared() {
          this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null)
        }
      },
      Vo = class extends ct {
        constructor(e) {
          super(), this.eContainer = e
        }
        postConstruct() {
          this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady(e => {
            const t = e.gridBodyCtrl;
            this.autoScrollService = new Bo({
              scrollContainer: t.getBodyViewportElement(),
              scrollAxis: "y",
              getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
              setVerticalPosition: e => t.getScrollFeature().setVerticalScrollPosition(e),
              onScrollCallback: () => {
                this.onDragging(this.lastDraggingEvent)
              }
            })
          })
        }
        getContainer() {
          return this.eContainer
        }
        isInterestedIn(e) {
          return 2 === e
        }
        getIconName() {
          return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? Kn.ICON_NOT_ALLOWED : Kn.ICON_MOVE
        }
        shouldPreventRowMove() {
          if (this.columnModel.getRowGroupColumns().length) return !0;
          if (this.filterManager.isAnyFilterPresent()) return !0;
          return !!this.sortController.isSortActive()
        }
        getRowNodes(e) {
          if (!this.isFromThisGrid(e)) return e.dragItem.rowNodes || [];
          const t = e.dragItem.rowNode;
          if (this.gos.get("rowDragMultiRow")) {
            const e = [...this.selectionService.getSelectedNodes()].sort((e, t) => null == e.rowIndex || null == t.rowIndex ? 0 : this.getRowIndexNumber(e) - this.getRowIndexNumber(t));
            if (-1 !== e.indexOf(t)) return e
          }
          return [t]
        }
        onDragEnter(e) {
          e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent(Et.EVENT_ROW_DRAG_ENTER, e), this.getRowNodes(e).forEach(e => {
            e.setDragging(!0)
          }), this.onEnterOrDragging(e)
        }
        onDragging(e) {
          this.onEnterOrDragging(e)
        }
        isFromThisGrid(e) {
          const {
            dragSourceDomDataKey: t
          } = e.dragSource;
          return t === this.gos.getDomDataKey()
        }
        isDropZoneWithinThisGrid(e) {
          const t = this.ctrlsService.getGridBodyCtrl().getGui(),
            {
              dropZoneTarget: i
            } = e;
          return !t.contains(i)
        }
        onEnterOrDragging(e) {
          this.dispatchGridEvent(Et.EVENT_ROW_DRAG_MOVE, e), this.lastDraggingEvent = e;
          const t = this.mouseEventService.getNormalisedPosition(e).y;
          this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event)
        }
        doManagedDrag(e, t) {
          const i = this.isFromThisGrid(e),
            r = this.gos.get("rowDragManaged"),
            s = e.dragItem.rowNodes;
          r && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !i ? this.isDropZoneWithinThisGrid(e) || this.clientSideRowModel.highlightRowAtPixel(s[0], t) : this.moveRows(s, t))
        }
        getRowIndexNumber(e) {
          return parseInt(Me(e.getRowIndexString().split("-")), 10)
        }
        moveRowAndClearHighlight(e) {
          const t = this.clientSideRowModel.getLastHighlightedRowNode(),
            i = t && 1 === t.highlighted,
            r = this.mouseEventService.getNormalisedPosition(e).y,
            s = e.dragItem.rowNodes;
          let n = i ? 1 : 0;
          if (this.isFromThisGrid(e)) s.forEach(e => {
            e.rowTop < r && (n -= 1)
          }), this.moveRows(s, r, n);
          else {
            const e = this.gos.getCallback("getRowId");
            let t = this.clientSideRowModel.getRowIndexAtPixel(r) + 1;
            0 === this.clientSideRowModel.getHighlightPosition(r) && t--, this.clientSideRowModel.updateRowData({
              add: s.map(e => e.data).filter(t => !this.clientSideRowModel.getRowNode(e ? e({
                data: t,
                level: 0
              }) : t.id)),
              addIndex: t
            })
          }
          this.clearRowHighlight()
        }
        clearRowHighlight() {
          this.clientSideRowModel.highlightRowAtPixel(null)
        }
        moveRows(e, t, i = 0) {
          var r;
          this.clientSideRowModel.ensureRowsAtPixel(e, t, i) && (this.focusService.clearFocusedCell(), null == (r = this.rangeService) || r.removeAllCellRanges())
        }
        addRowDropZone(e) {
          if (!e.getContainer()) return void z("addRowDropZone - A container target needs to be provided");
          if (this.dragAndDropService.findExternalZone(e)) return void console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
          let t = {
            getContainer: e.getContainer
          };
          e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = t => {
            e.onDragEnter(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_ENTER, t))
          }), e.onDragLeave && (t.onDragLeave = t => {
            e.onDragLeave(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_LEAVE, t))
          }), e.onDragging && (t.onDragging = t => {
            e.onDragging(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_MOVE, t))
          }), e.onDragStop && (t.onDragStop = t => {
            e.onDragStop(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_END, t))
          })), this.dragAndDropService.addDropTarget(f({
            isInterestedIn: e => 2 === e,
            getIconName: () => Kn.ICON_MOVE,
            external: !0
          }, t))
        }
        getRowDropZone(e) {
          const t = this.getContainer.bind(this),
            i = this.onDragEnter.bind(this),
            r = this.onDragLeave.bind(this),
            s = this.onDragging.bind(this),
            n = this.onDragStop.bind(this);
          return e ? {
            getContainer: t,
            onDragEnter: e.onDragEnter ? t => {
              i(t), e.onDragEnter(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_ENTER, t))
            } : i,
            onDragLeave: e.onDragLeave ? t => {
              r(t), e.onDragLeave(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_LEAVE, t))
            } : r,
            onDragging: e.onDragging ? t => {
              s(t), e.onDragging(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_MOVE, t))
            } : s,
            onDragStop: e.onDragStop ? t => {
              n(t), e.onDragStop(this.draggingToRowDragEvent(Et.EVENT_ROW_DRAG_END, t))
            } : n,
            fromGrid: !0
          } : {
            getContainer: t,
            onDragEnter: i,
            onDragLeave: r,
            onDragging: s,
            onDragStop: n,
            fromGrid: !0
          }
        }
        draggingToRowDragEvent(e, t) {
          const i = this.mouseEventService.getNormalisedPosition(t).y;
          let r, s, n = -1;
          switch (i > this.paginationProxy.getCurrentPageHeight() || (n = this.rowModel.getRowIndexAtPixel(i), r = this.rowModel.getRow(n)), t.vDirection) {
            case 1:
              s = "down";
              break;
            case 0:
              s = "up";
              break;
            default:
              s = null
          }
          return this.gos.addGridCommonParams({
            type: e,
            event: t.event,
            node: t.dragItem.rowNode,
            nodes: t.dragItem.rowNodes,
            overIndex: n,
            overNode: r,
            y: i,
            vDirection: s
          })
        }
        dispatchGridEvent(e, t) {
          const i = this.draggingToRowDragEvent(e, t);
          this.eventService.dispatchEvent(i)
        }
        onDragLeave(e) {
          this.dispatchGridEvent(Et.EVENT_ROW_DRAG_LEAVE, e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight()
        }
        onDragStop(e) {
          this.dispatchGridEvent(Et.EVENT_ROW_DRAG_END, e), this.stopDragging(e), !this.gos.get("rowDragManaged") || !this.gos.get("suppressMoveWhenRowDragging") && this.isFromThisGrid(e) || this.isDropZoneWithinThisGrid(e) || this.moveRowAndClearHighlight(e)
        }
        stopDragging(e) {
          this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach(e => {
            e.setDragging(!1)
          })
        }
      };
    C([fe("dragAndDropService")], Vo.prototype, "dragAndDropService", 2), C([fe("rowModel")], Vo.prototype, "rowModel", 2), C([fe("paginationProxy")], Vo.prototype, "paginationProxy", 2), C([fe("columnModel")], Vo.prototype, "columnModel", 2), C([fe("focusService")], Vo.prototype, "focusService", 2), C([fe("sortController")], Vo.prototype, "sortController", 2), C([fe("filterManager")], Vo.prototype, "filterManager", 2), C([fe("selectionService")], Vo.prototype, "selectionService", 2), C([fe("mouseEventService")], Vo.prototype, "mouseEventService", 2), C([fe("ctrlsService")], Vo.prototype, "ctrlsService", 2), C([Te("rangeService")], Vo.prototype, "rangeService", 2), C([pe], Vo.prototype, "postConstruct", 1);
    var Wo = class extends ct {
      constructor() {
        super(...arguments), this.dragEndFunctions = [], this.dragSources = []
      }
      removeAllListeners() {
        this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0
      }
      removeListener(e) {
        const t = e.dragSource.eElement,
          i = e.mouseDownListener;
        if (t.removeEventListener("mousedown", i), e.touchEnabled) {
          const i = e.touchStartListener;
          t.removeEventListener("touchstart", i, {
            passive: !0
          })
        }
      }
      removeDragSource(e) {
        const t = this.dragSources.find(t => t.dragSource === e);
        t && (this.removeListener(t), ke(this.dragSources, t))
      }
      isDragging() {
        return this.dragging
      }
      addDragSource(e) {
        const t = this.onMouseDown.bind(this, e),
          {
            eElement: i,
            includeTouch: r,
            stopPropagationForTouch: s
          } = e;
        i.addEventListener("mousedown", t);
        let n = null;
        const o = this.gos.get("suppressTouch");
        r && !o && (n = t => {
          hr(t.target) || (t.cancelable && (t.preventDefault(), s && t.stopPropagation()), this.onTouchStart(e, t))
        }, i.addEventListener("touchstart", n, {
          passive: !1
        })), this.dragSources.push({
          dragSource: e,
          mouseDownListener: t,
          touchStartListener: n,
          touchEnabled: !!r
        })
      }
      getStartTarget() {
        return this.startTarget
      }
      onTouchStart(e, t) {
        this.currentDragParams = e, this.dragging = !1;
        const i = t.touches[0];
        this.touchLastTime = i, this.touchStart = i;
        const r = t => this.onTouchUp(t, e.eElement),
          s = t.target,
          n = [{
            target: this.gos.getRootNode(),
            type: "touchmove",
            listener: e => {
              e.cancelable && e.preventDefault()
            },
            options: {
              passive: !1
            }
          }, {
            target: s,
            type: "touchmove",
            listener: t => this.onTouchMove(t, e.eElement),
            options: {
              passive: !0
            }
          }, {
            target: s,
            type: "touchend",
            listener: r,
            options: {
              passive: !0
            }
          }, {
            target: s,
            type: "touchcancel",
            listener: r,
            options: {
              passive: !0
            }
          }];
        this.addTemporaryEvents(n), 0 === e.dragStartPixels && this.onCommonMove(i, this.touchStart, e.eElement)
      }
      onMouseDown(e, t) {
        const i = t;
        if (e.skipMouseEvent && e.skipMouseEvent(t)) return;
        if (i._alreadyProcessedByDragService) return;
        if (i._alreadyProcessedByDragService = !0, 0 !== t.button) return;
        this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
        const r = this.gos.getRootNode(),
          s = [{
            target: r,
            type: "mousemove",
            listener: t => this.onMouseMove(t, e.eElement)
          }, {
            target: r,
            type: "mouseup",
            listener: t => this.onMouseUp(t, e.eElement)
          }, {
            target: r,
            type: "contextmenu",
            listener: e => e.preventDefault()
          }];
        this.addTemporaryEvents(s), 0 === e.dragStartPixels && this.onMouseMove(t, e.eElement)
      }
      addTemporaryEvents(e) {
        e.forEach(e => {
          const {
            target: t,
            type: i,
            listener: r,
            options: s
          } = e;
          t.addEventListener(i, r, s)
        }), this.dragEndFunctions.push(() => {
          e.forEach(e => {
            const {
              target: t,
              type: i,
              listener: r,
              options: s
            } = e;
            t.removeEventListener(i, r, s)
          })
        })
      }
      isEventNearStartEvent(e, t) {
        const {
          dragStartPixels: i
        } = this.currentDragParams;
        return Es(e, t, v(i) ? i : 4)
      }
      getFirstActiveTouch(e) {
        for (let t = 0; t < e.length; t++)
          if (e[t].identifier === this.touchStart.identifier) return e[t];
        return null
      }
      onCommonMove(e, t, i) {
        if (!this.dragging) {
          if (!this.dragging && this.isEventNearStartEvent(e, t)) return;
          this.dragging = !0;
          const r = {
            type: Et.EVENT_DRAG_STARTED,
            target: i
          };
          this.eventService.dispatchEvent(r), this.currentDragParams.onDragStart(t), this.currentDragParams.onDragging(t)
        }
        this.currentDragParams.onDragging(e)
      }
      onTouchMove(e, t) {
        const i = this.getFirstActiveTouch(e.touches);
        i && this.onCommonMove(i, this.touchStart, t)
      }
      onMouseMove(e, t) {
        var i;
        if (Pi()) {
          null == (i = this.gos.getDocument().getSelection()) || i.removeAllRanges()
        }
        this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t)
      }
      shouldPreventMouseEvent(e) {
        const t = this.gos.get("enableCellTextSelection"),
          i = "mousemove" === e.type;
        return t && i && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
      }
      isOverFormFieldElement(e) {
        const t = e.target,
          i = null == t ? void 0 : t.tagName.toLocaleLowerCase();
        return !!(null == i ? void 0 : i.match("^a$|textarea|input|select|button"))
      }
      onTouchUp(e, t) {
        let i = this.getFirstActiveTouch(e.changedTouches);
        i || (i = this.touchLastTime), this.onUpCommon(i, t)
      }
      onMouseUp(e, t) {
        this.onUpCommon(e, t)
      }
      onUpCommon(e, t) {
        if (this.dragging) {
          this.dragging = !1, this.currentDragParams.onDragStop(e);
          const i = {
            type: Et.EVENT_DRAG_STOPPED,
            target: t
          };
          this.eventService.dispatchEvent(i)
        }
        this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach(e => e()), this.dragEndFunctions.length = 0
      }
    };
    C([fe("mouseEventService")], Wo.prototype, "mouseEventService", 2), C([Ee], Wo.prototype, "removeAllListeners", 1), Wo = C([ge("dragService")], Wo);
    var Yo = "ag-list-item-hovered",
      Ko = class extends ct {
        constructor(e, t, i) {
          super(), this.comp = e, this.virtualList = t, this.params = i, this.currentDragValue = null, this.lastHoveredListItem = null
        }
        postConstruct() {
          this.addManagedListener(this.params.eventSource, this.params.listItemDragStartEvent, this.listItemDragStart.bind(this)), this.addManagedListener(this.params.eventSource, this.params.listItemDragEndEvent, this.listItemDragEnd.bind(this)), this.createDropTarget(), this.createAutoScrollService()
        }
        listItemDragStart(e) {
          this.currentDragValue = this.params.getCurrentDragValue(e), this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue)
        }
        listItemDragEnd() {
          window.setTimeout(() => {
            this.currentDragValue = null, this.moveBlocked = !1
          }, 10)
        }
        createDropTarget() {
          const e = {
            isInterestedIn: e => e === this.params.dragSourceType,
            getIconName: () => this.moveBlocked ? Kn.ICON_PINNED : Kn.ICON_MOVE,
            getContainer: () => this.comp.getGui(),
            onDragging: e => this.onDragging(e),
            onDragStop: () => this.onDragStop(),
            onDragLeave: () => this.onDragLeave()
          };
          this.dragAndDropService.addDropTarget(e)
        }
        createAutoScrollService() {
          const e = this.virtualList.getGui();
          this.autoScrollService = new Bo({
            scrollContainer: e,
            scrollAxis: "y",
            getVerticalPosition: () => e.scrollTop,
            setVerticalPosition: t => e.scrollTop = t
          })
        }
        onDragging(e) {
          if (!this.currentDragValue || this.moveBlocked) return;
          const t = this.getListDragItem(e),
            i = this.virtualList.getComponentAt(t.rowIndex);
          if (!i) return;
          const r = i.getGui().parentElement;
          this.lastHoveredListItem && this.lastHoveredListItem.rowIndex === t.rowIndex && this.lastHoveredListItem.position === t.position || (this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredListItem = t, ar(r, Yo), ar(r, `ag-item-highlight-${t.position}`))
        }
        getListDragItem(e) {
          const t = this.virtualList.getGui(),
            i = parseFloat(window.getComputedStyle(t).paddingTop),
            r = this.virtualList.getRowHeight(),
            s = this.virtualList.getScrollTop(),
            n = Math.max(0, (e.y - i + s) / r),
            o = this.params.getNumRows(this.comp) - 1,
            a = 0 | Math.min(o, n);
          return {
            rowIndex: a,
            position: Math.round(n) > n || n > o ? "bottom" : "top",
            component: this.virtualList.getComponentAt(a)
          }
        }
        onDragStop() {
          this.moveBlocked || (this.params.moveItem(this.currentDragValue, this.lastHoveredListItem), this.clearHoveredItems(), this.autoScrollService.ensureCleared())
        }
        onDragLeave() {
          this.clearHoveredItems(), this.autoScrollService.ensureCleared()
        }
        clearHoveredItems() {
          this.virtualList.getGui().querySelectorAll(`.${Yo}`).forEach(e => {
            [Yo, "ag-item-highlight-top", "ag-item-highlight-bottom"].forEach(t => {
              e.classList.remove(t)
            })
          }), this.lastHoveredListItem = null
        }
      };

    function Xo(e) {
      const t = e;
      return null != t && null != t.getFrameworkComponentInstance ? t.getFrameworkComponentInstance() : e
    }
    C([fe("dragAndDropService")], Ko.prototype, "dragAndDropService", 2), C([pe], Ko.prototype, "postConstruct", 1);
    var zo = class {
      constructor() {
        this.detailGridInfoMap = {}, this.destroyCalled = !1
      }
      init() {
        switch (this.rowModel.getType()) {
          case "clientSide":
            this.clientSideRowModel = this.rowModel;
            break;
          case "infinite":
            this.infiniteRowModel = this.rowModel;
            break;
          case "serverSide":
            this.serverSideRowModel = this.rowModel
        }
        this.ctrlsService.whenReady(e => {
          this.gridBodyCtrl = e.gridBodyCtrl
        })
      }
      __getAlignedGridService() {
        return this.alignedGridsService
      }
      getGridId() {
        return this.context.getGridId()
      }
      addDetailGridInfo(e, t) {
        this.detailGridInfoMap[e] = t
      }
      removeDetailGridInfo(e) {
        delete this.detailGridInfoMap[e]
      }
      getDetailGridInfo(e) {
        return this.detailGridInfoMap[e]
      }
      forEachDetailGridInfo(e) {
        let t = 0;
        x(this.detailGridInfoMap, (i, r) => {
          v(r) && (e(r, t), t++)
        })
      }
      getDataAsCsv(e) {
        if (he.__assertRegistered("@ag-grid-community/csv-export", "api.getDataAsCsv", this.context.getGridId())) return this.csvCreator.getDataAsCsv(e)
      }
      exportDataAsCsv(e) {
        he.__assertRegistered("@ag-grid-community/csv-export", "api.exportDataAsCsv", this.context.getGridId()) && this.csvCreator.exportDataAsCsv(e)
      }
      assertNotExcelMultiSheet(e, t) {
        return !!he.__assertRegistered("@ag-grid-enterprise/excel-export", "api." + e, this.context.getGridId()) && (1 !== this.excelCreator.getFactoryMode() || (console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'"), !1))
      }
      getDataAsExcel(e) {
        if (this.assertNotExcelMultiSheet("getDataAsExcel", e)) return this.excelCreator.getDataAsExcel(e)
      }
      exportDataAsExcel(e) {
        this.assertNotExcelMultiSheet("exportDataAsExcel", e) && this.excelCreator.exportDataAsExcel(e)
      }
      getSheetDataForExcel(e) {
        if (he.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getSheetDataForExcel", this.context.getGridId())) return this.excelCreator.setFactoryMode(1), this.excelCreator.getSheetDataForExcel(e)
      }
      getMultipleSheetsAsExcel(e) {
        if (he.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getMultipleSheetsAsExcel", this.context.getGridId())) return this.excelCreator.getMultipleSheetsAsExcel(e)
      }
      exportMultipleSheetsAsExcel(e) {
        he.__assertRegistered("@ag-grid-enterprise/excel-export", "api.exportMultipleSheetsAsExcel", this.context.getGridId()) && this.excelCreator.exportMultipleSheetsAsExcel(e)
      }
      setGridAriaProperty(e, t) {
        if (!e) return;
        const i = this.ctrlsService.getGridBodyCtrl().getGui(),
          r = `aria-${e}`;
        null === t ? i.removeAttribute(r) : i.setAttribute(r, t)
      }
      logMissingRowModel(e, ...t) {
        console.error(`AG Grid: api.${e} can only be called when gridOptions.rowModelType is ${t.join(" or ")}`)
      }
      logDeprecation(e, t, i, r) {
        z(`Since ${e} api.${t} is deprecated. Please use ${i} instead. ${null!=r?r:""}`)
      }
      getPinnedTopRowCount() {
        return this.pinnedRowModel.getPinnedTopRowCount()
      }
      getPinnedBottomRowCount() {
        return this.pinnedRowModel.getPinnedBottomRowCount()
      }
      getPinnedTopRow(e) {
        return this.pinnedRowModel.getPinnedTopRow(e)
      }
      getPinnedBottomRow(e) {
        return this.pinnedRowModel.getPinnedBottomRow(e)
      }
      expireValueCache() {
        this.valueCache.expire()
      }
      getVerticalPixelRange() {
        return this.gridBodyCtrl.getScrollFeature().getVScrollPosition()
      }
      getHorizontalPixelRange() {
        return this.gridBodyCtrl.getScrollFeature().getHScrollPosition()
      }
      refreshCells(e = {}) {
        this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.refreshCells(e))
      }
      flashCells(e = {}) {
        const t = e => z(`Since v31.1 api.flashCells parameter '${e}Delay' is deprecated. Please use '${e}Duration' instead.`);
        v(e.fadeDelay) && t("fade"), v(e.flashDelay) && t("flash"), this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.flashCells(e))
      }
      redrawRows(e = {}) {
        const t = e ? e.rowNodes : void 0;
        this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.redrawRows(t))
      }
      refreshHeader() {
        this.frameworkOverrides.wrapIncoming(() => this.ctrlsService.getHeaderRowContainerCtrls().forEach(e => e.refresh()))
      }
      isAnyFilterPresent() {
        return this.filterManager.isAnyFilterPresent()
      }
      isColumnFilterPresent() {
        return this.filterManager.isColumnFilterPresent() || this.filterManager.isAggregateFilterPresent()
      }
      isQuickFilterPresent() {
        return this.filterManager.isQuickFilterPresent()
      }
      getModel() {
        return z("Since v31.1 getModel() is deprecated. Please use the appropriate grid API methods instead."), this.rowModel
      }
      setRowNodeExpanded(e, t, i, r) {
        this.expansionService.setRowNodeExpanded(e, t, i, r)
      }
      onGroupExpandedOrCollapsed() {
        N(this.clientSideRowModel) ? this.logMissingRowModel("onGroupExpandedOrCollapsed", "clientSide") : this.expansionService.onGroupExpandedOrCollapsed()
      }
      refreshClientSideRowModel(e) {
        N(this.clientSideRowModel) ? this.logMissingRowModel("refreshClientSideRowModel", "clientSide") : this.clientSideRowModel.refreshModel(e)
      }
      isAnimationFrameQueueEmpty() {
        return this.animationFrameService.isQueueEmpty()
      }
      flushAllAnimationFrames() {
        this.animationFrameService.flushAllFrames()
      }
      getRowNode(e) {
        return this.rowModel.getRowNode(e)
      }
      getSizesForCurrentTheme() {
        return {
          rowHeight: this.gos.getRowHeightAsNumber(),
          headerHeight: this.columnModel.getHeaderHeight()
        }
      }
      expandAll() {
        this.clientSideRowModel || this.serverSideRowModel ? this.expansionService.expandAll(!0) : this.logMissingRowModel("expandAll", "clientSide", "serverSide")
      }
      collapseAll() {
        this.clientSideRowModel || this.serverSideRowModel ? this.expansionService.expandAll(!1) : this.logMissingRowModel("collapseAll", "clientSide", "serverSide")
      }
      addRenderedRowListener(e, t, i) {
        this.rowRenderer.addRenderedRowListener(e, t, i)
      }
      getQuickFilter() {
        return this.gos.get("quickFilterText")
      }
      getAdvancedFilterModel() {
        return he.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.getAdvancedFilterModel", this.context.getGridId()) ? this.filterManager.getAdvancedFilterModel() : null
      }
      setAdvancedFilterModel(e) {
        this.filterManager.setAdvancedFilterModel(e)
      }
      showAdvancedFilterBuilder() {
        he.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.setAdvancedFilterModel", this.context.getGridId()) && this.filterManager.showAdvancedFilterBuilder("api")
      }
      setNodesSelected(e) {
        if (!e.nodes.every(e => e.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), !1) : void 0 !== e.id || (console.warn("AG Grid: cannot select node until id for node is known"), !1))) return;
        const {
          nodes: t,
          source: i,
          newValue: r
        } = e, s = t;
        this.selectionService.setNodesSelected({
          nodes: s,
          source: null != i ? i : "api",
          newValue: r
        })
      }
      selectAll(e = "apiSelectAll") {
        this.selectionService.selectAllRowNodes({
          source: e
        })
      }
      deselectAll(e = "apiSelectAll") {
        this.selectionService.deselectAllRowNodes({
          source: e
        })
      }
      selectAllFiltered(e = "apiSelectAllFiltered") {
        this.selectionService.selectAllRowNodes({
          source: e,
          justFiltered: !0
        })
      }
      deselectAllFiltered(e = "apiSelectAllFiltered") {
        this.selectionService.deselectAllRowNodes({
          source: e,
          justFiltered: !0
        })
      }
      getServerSideSelectionState() {
        return N(this.serverSideRowModel) ? (this.logMissingRowModel("getServerSideSelectionState", "serverSide"), null) : this.selectionService.getSelectionState()
      }
      setServerSideSelectionState(e) {
        N(this.serverSideRowModel) ? this.logMissingRowModel("setServerSideSelectionState", "serverSide") : this.selectionService.setSelectionState(e, "api")
      }
      selectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
        this.selectionService.selectAllRowNodes({
          source: e,
          justCurrentPage: !0
        })
      }
      deselectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
        this.selectionService.deselectAllRowNodes({
          source: e,
          justCurrentPage: !0
        })
      }
      showLoadingOverlay() {
        this.overlayService.showLoadingOverlay()
      }
      showNoRowsOverlay() {
        this.overlayService.showNoRowsOverlay()
      }
      hideOverlay() {
        this.overlayService.hideOverlay()
      }
      getSelectedNodes() {
        return this.selectionService.getSelectedNodes()
      }
      getSelectedRows() {
        return this.selectionService.getSelectedRows()
      }
      getBestCostNodeSelection() {
        if (!N(this.clientSideRowModel)) return this.selectionService.getBestCostNodeSelection();
        this.logMissingRowModel("getBestCostNodeSelection", "clientSide")
      }
      getRenderedNodes() {
        return this.rowRenderer.getRenderedNodes()
      }
      ensureColumnVisible(e, t = "auto") {
        this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureColumnVisible(e, t), "ensureVisible")
      }
      ensureIndexVisible(e, t) {
        this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(e, t), "ensureVisible")
      }
      ensureNodeVisible(e, t = null) {
        this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureNodeVisible(e, t), "ensureVisible")
      }
      forEachLeafNode(e) {
        N(this.clientSideRowModel) ? this.logMissingRowModel("forEachLeafNode", "clientSide") : this.clientSideRowModel.forEachLeafNode(e)
      }
      forEachNode(e, t) {
        this.rowModel.forEachNode(e, t)
      }
      forEachNodeAfterFilter(e) {
        N(this.clientSideRowModel) ? this.logMissingRowModel("forEachNodeAfterFilter", "clientSide") : this.clientSideRowModel.forEachNodeAfterFilter(e)
      }
      forEachNodeAfterFilterAndSort(e) {
        N(this.clientSideRowModel) ? this.logMissingRowModel("forEachNodeAfterFilterAndSort", "clientSide") : this.clientSideRowModel.forEachNodeAfterFilterAndSort(e)
      }
      getFilterInstance(e, t) {
        return z("'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously."), this.filterManager.getFilterInstance(e, t)
      }
      getColumnFilterInstance(e) {
        return this.filterManager.getColumnFilterInstance(e)
      }
      destroyFilter(e) {
        const t = this.columnModel.getPrimaryColumn(e);
        if (t) return this.filterManager.destroyFilter(t, "api")
      }
      getStatusPanel(e) {
        if (!he.__assertRegistered("@ag-grid-enterprise/status-bar", "api.getStatusPanel", this.context.getGridId())) return;
        return Xo(this.statusBarService.getStatusPanel(e))
      }
      getColumnDef(e) {
        const t = this.columnModel.getPrimaryColumn(e);
        return t ? t.getColDef() : null
      }
      getColumnDefs() {
        return this.columnModel.getColumnDefs()
      }
      onFilterChanged(e = "api") {
        this.filterManager.onFilterChanged({
          source: e
        })
      }
      onSortChanged() {
        this.sortController.onSortChanged("api")
      }
      setFilterModel(e) {
        this.frameworkOverrides.wrapIncoming(() => this.filterManager.setFilterModel(e))
      }
      getFilterModel() {
        return this.filterManager.getFilterModel()
      }
      getColumnFilterModel(e) {
        return this.filterManager.getColumnFilterModel(e)
      }
      setColumnFilterModel(e, t) {
        return this.filterManager.setColumnFilterModel(e, t)
      }
      getFocusedCell() {
        return this.focusService.getFocusedCell()
      }
      clearFocusedCell() {
        return this.focusService.clearFocusedCell()
      }
      setFocusedCell(e, t, i) {
        this.focusService.setFocusedCell({
          rowIndex: e,
          column: t,
          rowPinned: i,
          forceBrowserFocus: !0
        })
      }
      addRowDropZone(e) {
        this.gridBodyCtrl.getRowDragFeature().addRowDropZone(e)
      }
      removeRowDropZone(e) {
        const t = this.dragAndDropService.findExternalZone(e);
        t && this.dragAndDropService.removeDropTarget(t)
      }
      getRowDropZoneParams(e) {
        return this.gridBodyCtrl.getRowDragFeature().getRowDropZone(e)
      }
      assertSideBarLoaded(e) {
        return he.__assertRegistered("@ag-grid-enterprise/side-bar", "api." + e, this.context.getGridId())
      }
      isSideBarVisible() {
        return this.assertSideBarLoaded("isSideBarVisible") && this.sideBarService.getSideBarComp().isDisplayed()
      }
      setSideBarVisible(e) {
        this.assertSideBarLoaded("setSideBarVisible") && this.sideBarService.getSideBarComp().setDisplayed(e)
      }
      setSideBarPosition(e) {
        this.assertSideBarLoaded("setSideBarPosition") && this.sideBarService.getSideBarComp().setSideBarPosition(e)
      }
      openToolPanel(e) {
        this.assertSideBarLoaded("openToolPanel") && this.sideBarService.getSideBarComp().openToolPanel(e, "api")
      }
      closeToolPanel() {
        this.assertSideBarLoaded("closeToolPanel") && this.sideBarService.getSideBarComp().close("api")
      }
      getOpenedToolPanel() {
        return this.assertSideBarLoaded("getOpenedToolPanel") ? this.sideBarService.getSideBarComp().openedItem() : null
      }
      refreshToolPanel() {
        this.assertSideBarLoaded("refreshToolPanel") && this.sideBarService.getSideBarComp().refresh()
      }
      isToolPanelShowing() {
        return this.assertSideBarLoaded("isToolPanelShowing") && this.sideBarService.getSideBarComp().isToolPanelShowing()
      }
      getToolPanelInstance(e) {
        if (this.assertSideBarLoaded("getToolPanelInstance")) {
          return Xo(this.sideBarService.getSideBarComp().getToolPanelInstance(e))
        }
      }
      getSideBar() {
        if (this.assertSideBarLoaded("getSideBar")) return this.sideBarService.getSideBarComp().getDef()
      }
      resetRowHeights() {
        if (v(this.clientSideRowModel)) {
          if (this.columnModel.isAutoRowHeightActive()) return void console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
          this.clientSideRowModel.resetRowHeights()
        }
      }
      setRowCount(e, t) {
        if (this.serverSideRowModel) return this.columnModel.isRowGroupEmpty() ? void this.serverSideRowModel.setRowCount(e, t) : void console.error("AG Grid: setRowCount cannot be used while using row grouping.");
        this.infiniteRowModel ? this.infiniteRowModel.setRowCount(e, t) : this.logMissingRowModel("setRowCount", "infinite", "serverSide")
      }
      onRowHeightChanged() {
        this.clientSideRowModel ? this.clientSideRowModel.onRowHeightChanged() : this.serverSideRowModel && this.serverSideRowModel.onRowHeightChanged()
      }
      getValue(e, t) {
        return this.logDeprecation("31.3", "getValue", "getCellValue"), this.getCellValue({
          colKey: e,
          rowNode: t
        })
      }
      getCellValue(e) {
        var t;
        const {
          colKey: i,
          rowNode: r,
          useFormatter: s
        } = e;
        let n = null != (t = this.columnModel.getPrimaryColumn(i)) ? t : this.columnModel.getGridColumn(i);
        if (N(n)) return null;
        const o = this.valueService.getValue(n, r);
        if (s) {
          const e = this.valueService.formatValue(n, r, o);
          return null != e ? e : Nt(o, !0)
        }
        return o
      }
      addEventListener(e, t) {
        this.apiEventService.addEventListener(e, t)
      }
      addGlobalListener(e) {
        this.apiEventService.addGlobalListener(e)
      }
      removeEventListener(e, t) {
        this.apiEventService.removeEventListener(e, t)
      }
      removeGlobalListener(e) {
        this.apiEventService.removeGlobalListener(e)
      }
      dispatchEvent(e) {
        this.eventService.dispatchEvent(e)
      }
      destroy() {
        var e;
        const t = `See ${this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed")}`;
        if (this.destroyCalled) return;
        const i = {
          type: Et.EVENT_GRID_PRE_DESTROYED,
          state: this.getState()
        };
        this.dispatchEvent(i), this.destroyCalled = !0, null == (e = this.ctrlsService.get("gridCtrl")) || e.destroyGridUi(), this.context.destroy(), this.detailGridInfoMap = {}, V(this, ["isDestroyed"], t)
      }
      isDestroyed() {
        return this.destroyCalled
      }
      resetQuickFilter() {
        this.filterManager.resetQuickFilterCache()
      }
      getCellRanges() {
        return this.rangeService ? this.rangeService.getCellRanges() : (he.__assertRegistered("@ag-grid-enterprise/range-selection", "api.getCellRanges", this.context.getGridId()), null)
      }
      addCellRange(e) {
        this.rangeService ? this.rangeService.addCellRange(e) : he.__assertRegistered("@ag-grid-enterprise/range-selection", "api.addCellRange", this.context.getGridId())
      }
      clearRangeSelection() {
        this.rangeService && this.rangeService.removeAllCellRanges(), he.__assertRegistered("@ag-grid-enterprise/range-selection", "gridApi.clearRangeSelection", this.context.getGridId())
      }
      undoCellEditing() {
        this.undoRedoService.undo("api")
      }
      redoCellEditing() {
        this.undoRedoService.redo("api")
      }
      getCurrentUndoSize() {
        return this.undoRedoService.getCurrentUndoStackSize()
      }
      getCurrentRedoSize() {
        return this.undoRedoService.getCurrentRedoStackSize()
      }
      assertChart(e, t) {
        if (he.__assertRegistered("@ag-grid-enterprise/charts", "api." + e, this.context.getGridId())) return this.frameworkOverrides.wrapIncoming(() => t())
      }
      getChartModels() {
        return this.assertChart("getChartModels", () => this.chartService.getChartModels())
      }
      getChartRef(e) {
        return this.assertChart("getChartRef", () => this.chartService.getChartRef(e))
      }
      getChartImageDataURL(e) {
        return this.assertChart("getChartImageDataURL", () => this.chartService.getChartImageDataURL(e))
      }
      downloadChart(e) {
        return this.assertChart("downloadChart", () => this.chartService.downloadChart(e))
      }
      openChartToolPanel(e) {
        return this.assertChart("openChartToolPanel", () => this.chartService.openChartToolPanel(e))
      }
      closeChartToolPanel(e) {
        return this.assertChart("closeChartToolPanel", () => this.chartService.closeChartToolPanel(e.chartId))
      }
      createRangeChart(e) {
        return this.assertChart("createRangeChart", () => this.chartService.createRangeChart(e))
      }
      createPivotChart(e) {
        return this.assertChart("createPivotChart", () => this.chartService.createPivotChart(e))
      }
      createCrossFilterChart(e) {
        return this.assertChart("createCrossFilterChart", () => this.chartService.createCrossFilterChart(e))
      }
      updateChart(e) {
        return this.assertChart("updateChart", () => this.chartService.updateChart(e))
      }
      restoreChart(e, t) {
        return this.assertChart("restoreChart", () => this.chartService.restoreChart(e, t))
      }
      assertClipboard(e, t) {
        he.__assertRegistered("@ag-grid-enterprise/clipboard", "api" + e, this.context.getGridId()) && t()
      }
      copyToClipboard(e) {
        this.assertClipboard("copyToClipboard", () => this.clipboardService.copyToClipboard(e))
      }
      cutToClipboard(e) {
        this.assertClipboard("cutToClipboard", () => this.clipboardService.cutToClipboard(e))
      }
      copySelectedRowsToClipboard(e) {
        this.assertClipboard("copySelectedRowsToClipboard", () => this.clipboardService.copySelectedRowsToClipboard(e))
      }
      copySelectedRangeToClipboard(e) {
        this.assertClipboard("copySelectedRangeToClipboard", () => this.clipboardService.copySelectedRangeToClipboard(e))
      }
      copySelectedRangeDown() {
        this.assertClipboard("copySelectedRangeDown", () => this.clipboardService.copyRangeDown())
      }
      pasteFromClipboard() {
        this.assertClipboard("pasteFromClipboard", () => this.clipboardService.pasteFromClipboard())
      }
      showColumnMenuAfterButtonClick(e, t) {
        z("'showColumnMenuAfterButtonClick' is deprecated. Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere.");
        const i = this.columnModel.getGridColumn(e);
        this.menuService.showColumnMenu({
          column: i,
          buttonElement: t,
          positionBy: "button"
        })
      }
      showColumnMenuAfterMouseClick(e, t) {
        z("'showColumnMenuAfterMouseClick' is deprecated. Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere.");
        let i = this.columnModel.getGridColumn(e);
        i || (i = this.columnModel.getPrimaryColumn(e)), i ? this.menuService.showColumnMenu({
          column: i,
          mouseEvent: t,
          positionBy: "mouse"
        }) : console.error(`AG Grid: column '${e}' not found`)
      }
      showContextMenu(e) {
        const {
          rowNode: t,
          column: i,
          value: r,
          x: s,
          y: n
        } = e || {};
        let {
          x: o,
          y: a
        } = this.menuService.getContextMenuPosition(t, i);
        null != s && (o = s), null != n && (a = n), this.menuService.showContextMenu({
          mouseEvent: new MouseEvent("mousedown", {
            clientX: o,
            clientY: a
          }),
          rowNode: t,
          column: i,
          value: r
        })
      }
      showColumnChooser(e) {
        this.menuService.showColumnChooser({
          chooserParams: e
        })
      }
      showColumnFilter(e) {
        const t = this.columnModel.getGridColumn(e);
        t ? this.menuService.showFilterMenu({
          column: t,
          containerType: "columnFilter",
          positionBy: "auto"
        }) : console.error(`AG Grid: column '${e}' not found`)
      }
      showColumnMenu(e) {
        const t = this.columnModel.getGridColumn(e);
        t ? this.menuService.showColumnMenu({
          column: t,
          positionBy: "auto"
        }) : console.error(`AG Grid: column '${e}' not found`)
      }
      hidePopupMenu() {
        this.menuService.hidePopupMenu()
      }
      hideColumnChooser() {
        this.menuService.hideColumnChooser()
      }
      tabToNextCell(e) {
        return this.navigationService.tabToNextCell(!1, e)
      }
      tabToPreviousCell(e) {
        return this.navigationService.tabToNextCell(!0, e)
      }
      getCellRendererInstances(e = {}) {
        return this.rowRenderer.getCellRendererInstances(e).map(Xo)
      }
      getCellEditorInstances(e = {}) {
        return this.rowRenderer.getCellEditorInstances(e).map(Xo)
      }
      getEditingCells() {
        return this.rowRenderer.getEditingCells()
      }
      stopEditing(e = !1) {
        this.rowRenderer.stopEditing(e)
      }
      startEditingCell(e) {
        const t = this.columnModel.getGridColumn(e.colKey);
        if (!t) return void console.warn(`AG Grid: no column found for ${e.colKey}`);
        const i = {
          rowIndex: e.rowIndex,
          rowPinned: e.rowPinned || null,
          column: t
        };
        null == e.rowPinned && this.ensureIndexVisible(e.rowIndex), this.ensureColumnVisible(e.colKey);
        const r = this.navigationService.getCellByPosition(i);
        r && (this.focusService.isCellFocused(i) || this.focusService.setFocusedCell(i), r.startRowOrCellEdit(e.key))
      }
      addAggFunc(e, t) {
        this.logDeprecation("v31.1", "addAggFunc(key, func)", "addAggFuncs({ key: func })"), this.aggFuncService && this.aggFuncService.addAggFuncs({
          key: t
        })
      }
      addAggFuncs(e) {
        this.aggFuncService && this.aggFuncService.addAggFuncs(e)
      }
      clearAggFuncs() {
        this.aggFuncService && this.aggFuncService.clear()
      }
      applyServerSideTransaction(e) {
        if (this.serverSideTransactionManager) return this.serverSideTransactionManager.applyTransaction(e);
        this.logMissingRowModel("applyServerSideTransaction", "serverSide")
      }
      applyServerSideTransactionAsync(e, t) {
        if (this.serverSideTransactionManager) return this.serverSideTransactionManager.applyTransactionAsync(e, t);
        this.logMissingRowModel("applyServerSideTransactionAsync", "serverSide")
      }
      applyServerSideRowData(e) {
        var t, i;
        const r = null != (t = e.startRow) ? t : 0,
          s = null != (i = e.route) ? i : [];
        r < 0 ? console.warn(`AG Grid: invalid value ${e.startRow} for startRow, the value should be >= 0`) : this.serverSideRowModel ? this.serverSideRowModel.applyRowData(e.successParams, r, s) : this.logMissingRowModel("setServerSideDatasource", "serverSide")
      }
      retryServerSideLoads() {
        this.serverSideRowModel ? this.serverSideRowModel.retryLoads() : this.logMissingRowModel("retryServerSideLoads", "serverSide")
      }
      flushServerSideAsyncTransactions() {
        if (this.serverSideTransactionManager) return this.serverSideTransactionManager.flushAsyncTransactions();
        this.logMissingRowModel("flushServerSideAsyncTransactions", "serverSide")
      }
      applyTransaction(e) {
        if (this.clientSideRowModel) return this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.updateRowData(e));
        this.logMissingRowModel("applyTransaction", "clientSide")
      }
      applyTransactionAsync(e, t) {
        this.clientSideRowModel ? this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.batchUpdateRowData(e, t)) : this.logMissingRowModel("applyTransactionAsync", "clientSide")
      }
      flushAsyncTransactions() {
        this.clientSideRowModel ? this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.flushAsyncTransactions()) : this.logMissingRowModel("flushAsyncTransactions", "clientSide")
      }
      refreshInfiniteCache() {
        this.infiniteRowModel ? this.infiniteRowModel.refreshCache() : this.logMissingRowModel("refreshInfiniteCache", "infinite")
      }
      purgeInfiniteCache() {
        this.infiniteRowModel ? this.infiniteRowModel.purgeCache() : this.logMissingRowModel("purgeInfiniteCache", "infinite")
      }
      refreshServerSide(e) {
        this.serverSideRowModel ? this.serverSideRowModel.refreshStore(e) : this.logMissingRowModel("refreshServerSide", "serverSide")
      }
      getServerSideGroupLevelState() {
        return this.serverSideRowModel ? this.serverSideRowModel.getStoreState() : (this.logMissingRowModel("getServerSideGroupLevelState", "serverSide"), [])
      }
      getInfiniteRowCount() {
        if (this.infiniteRowModel) return this.infiniteRowModel.getRowCount();
        this.logMissingRowModel("getInfiniteRowCount", "infinite")
      }
      isLastRowIndexKnown() {
        if (this.infiniteRowModel) return this.infiniteRowModel.isLastRowIndexKnown();
        this.logMissingRowModel("isLastRowIndexKnown", "infinite")
      }
      getCacheBlockState() {
        return this.rowNodeBlockLoader.getBlockState()
      }
      getFirstDisplayedRow() {
        return this.logDeprecation("v31.1", "getFirstDisplayedRow", "getFirstDisplayedRowIndex"), this.getFirstDisplayedRowIndex()
      }
      getFirstDisplayedRowIndex() {
        return this.rowRenderer.getFirstVirtualRenderedRow()
      }
      getLastDisplayedRow() {
        return this.logDeprecation("v31.1", "getLastDisplayedRow", "getLastDisplayedRowIndex"), this.getLastDisplayedRowIndex()
      }
      getLastDisplayedRowIndex() {
        return this.rowRenderer.getLastVirtualRenderedRow()
      }
      getDisplayedRowAtIndex(e) {
        return this.rowModel.getRow(e)
      }
      getDisplayedRowCount() {
        return this.rowModel.getRowCount()
      }
      paginationIsLastPageFound() {
        return this.paginationProxy.isLastPageFound()
      }
      paginationGetPageSize() {
        return this.paginationProxy.getPageSize()
      }
      paginationGetCurrentPage() {
        return this.paginationProxy.getCurrentPage()
      }
      paginationGetTotalPages() {
        return this.paginationProxy.getTotalPages()
      }
      paginationGetRowCount() {
        return this.paginationProxy.getMasterRowCount()
      }
      paginationGoToNextPage() {
        this.paginationProxy.goToNextPage()
      }
      paginationGoToPreviousPage() {
        this.paginationProxy.goToPreviousPage()
      }
      paginationGoToFirstPage() {
        this.paginationProxy.goToFirstPage()
      }
      paginationGoToLastPage() {
        this.paginationProxy.goToLastPage()
      }
      paginationGoToPage(e) {
        this.paginationProxy.goToPage(e)
      }
      sizeColumnsToFit(e) {
        "number" == typeof e ? this.columnModel.sizeColumnsToFit(e, "api") : this.gridBodyCtrl.sizeColumnsToFit(e)
      }
      setColumnGroupOpened(e, t) {
        this.columnModel.setColumnGroupOpened(e, t, "api")
      }
      getColumnGroup(e, t) {
        return this.columnModel.getColumnGroup(e, t)
      }
      getProvidedColumnGroup(e) {
        return this.columnModel.getProvidedColumnGroup(e)
      }
      getDisplayNameForColumn(e, t) {
        return this.columnModel.getDisplayNameForColumn(e, t) || ""
      }
      getDisplayNameForColumnGroup(e, t) {
        return this.columnModel.getDisplayNameForColumnGroup(e, t) || ""
      }
      getColumn(e) {
        return this.columnModel.getPrimaryColumn(e)
      }
      getColumns() {
        return this.columnModel.getAllPrimaryColumns()
      }
      applyColumnState(e) {
        return this.columnModel.applyColumnState(e, "api")
      }
      getColumnState() {
        return this.columnModel.getColumnState()
      }
      resetColumnState() {
        this.columnModel.resetColumnState("api")
      }
      getColumnGroupState() {
        return this.columnModel.getColumnGroupState()
      }
      setColumnGroupState(e) {
        this.columnModel.setColumnGroupState(e, "api")
      }
      resetColumnGroupState() {
        this.columnModel.resetColumnGroupState("api")
      }
      isPinning() {
        return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight()
      }
      isPinningLeft() {
        return this.columnModel.isPinningLeft()
      }
      isPinningRight() {
        return this.columnModel.isPinningRight()
      }
      getDisplayedColAfter(e) {
        return this.columnModel.getDisplayedColAfter(e)
      }
      getDisplayedColBefore(e) {
        return this.columnModel.getDisplayedColBefore(e)
      }
      setColumnVisible(e, t) {
        this.logDeprecation("v31.1", "setColumnVisible(key,visible)", "setColumnsVisible([key],visible)"), this.columnModel.setColumnsVisible([e], t, "api")
      }
      setColumnsVisible(e, t) {
        this.columnModel.setColumnsVisible(e, t, "api")
      }
      setColumnPinned(e, t) {
        this.logDeprecation("v31.1", "setColumnPinned(key,pinned)", "setColumnsPinned([key],pinned)"), this.columnModel.setColumnsPinned([e], t, "api")
      }
      setColumnsPinned(e, t) {
        this.columnModel.setColumnsPinned(e, t, "api")
      }
      getAllGridColumns() {
        return this.columnModel.getAllGridColumns()
      }
      getDisplayedLeftColumns() {
        return this.columnModel.getDisplayedLeftColumns()
      }
      getDisplayedCenterColumns() {
        return this.columnModel.getDisplayedCenterColumns()
      }
      getDisplayedRightColumns() {
        return this.columnModel.getDisplayedRightColumns()
      }
      getAllDisplayedColumns() {
        return this.columnModel.getAllDisplayedColumns()
      }
      getAllDisplayedVirtualColumns() {
        return this.columnModel.getViewportColumns()
      }
      moveColumn(e, t) {
        this.logDeprecation("v31.1", "moveColumn(key, toIndex)", "moveColumns([key], toIndex)"), this.columnModel.moveColumns([e], t, "api")
      }
      moveColumnByIndex(e, t) {
        this.columnModel.moveColumnByIndex(e, t, "api")
      }
      moveColumns(e, t) {
        this.columnModel.moveColumns(e, t, "api")
      }
      moveRowGroupColumn(e, t) {
        this.columnModel.moveRowGroupColumn(e, t, "api")
      }
      setColumnAggFunc(e, t) {
        this.columnModel.setColumnAggFunc(e, t, "api")
      }
      setColumnWidth(e, t, i = !0, r = "api") {
        this.logDeprecation("v31.1", "setColumnWidth(col, width)", "setColumnWidths([{key: col, newWidth: width}])"), this.columnModel.setColumnWidths([{
          key: e,
          newWidth: t
        }], !1, i, r)
      }
      setColumnWidths(e, t = !0, i = "api") {
        this.columnModel.setColumnWidths(e, !1, t, i)
      }
      isPivotMode() {
        return this.columnModel.isPivotMode()
      }
      getPivotResultColumn(e, t) {
        return this.columnModel.getSecondaryPivotColumn(e, t)
      }
      setValueColumns(e) {
        this.columnModel.setValueColumns(e, "api")
      }
      getValueColumns() {
        return this.columnModel.getValueColumns()
      }
      removeValueColumn(e) {
        this.logDeprecation("v31.1", "removeValueColumn(colKey)", "removeValueColumns([colKey])"), this.columnModel.removeValueColumns([e], "api")
      }
      removeValueColumns(e) {
        this.columnModel.removeValueColumns(e, "api")
      }
      addValueColumn(e) {
        this.logDeprecation("v31.1", "addValueColumn(colKey)", "addValueColumns([colKey])"), this.columnModel.addValueColumns([e], "api")
      }
      addValueColumns(e) {
        this.columnModel.addValueColumns(e, "api")
      }
      setRowGroupColumns(e) {
        this.columnModel.setRowGroupColumns(e, "api")
      }
      removeRowGroupColumn(e) {
        this.logDeprecation("v31.1", "removeRowGroupColumn(colKey)", "removeRowGroupColumns([colKey])"), this.columnModel.removeRowGroupColumns([e], "api")
      }
      removeRowGroupColumns(e) {
        this.columnModel.removeRowGroupColumns(e, "api")
      }
      addRowGroupColumn(e) {
        this.logDeprecation("v31.1", "addRowGroupColumn(colKey)", "addRowGroupColumns([colKey])"), this.columnModel.addRowGroupColumns([e], "api")
      }
      addRowGroupColumns(e) {
        this.columnModel.addRowGroupColumns(e, "api")
      }
      getRowGroupColumns() {
        return this.columnModel.getRowGroupColumns()
      }
      setPivotColumns(e) {
        this.columnModel.setPivotColumns(e, "api")
      }
      removePivotColumn(e) {
        this.logDeprecation("v31.1", "removePivotColumn(colKey)", "removePivotColumns([colKey])"), this.columnModel.removePivotColumns([e], "api")
      }
      removePivotColumns(e) {
        this.columnModel.removePivotColumns(e, "api")
      }
      addPivotColumn(e) {
        this.logDeprecation("v31.1", "addPivotColumn(colKey)", "addPivotColumns([colKey])"), this.columnModel.addPivotColumns([e], "api")
      }
      addPivotColumns(e) {
        this.columnModel.addPivotColumns(e, "api")
      }
      getPivotColumns() {
        return this.columnModel.getPivotColumns()
      }
      getLeftDisplayedColumnGroups() {
        return this.columnModel.getDisplayedTreeLeft()
      }
      getCenterDisplayedColumnGroups() {
        return this.columnModel.getDisplayedTreeCentre()
      }
      getRightDisplayedColumnGroups() {
        return this.columnModel.getDisplayedTreeRight()
      }
      getAllDisplayedColumnGroups() {
        return this.columnModel.getAllDisplayedTrees()
      }
      autoSizeColumn(e, t) {
        return this.logDeprecation("v31.1", "autoSizeColumn(key, skipHeader)", "autoSizeColumns([key], skipHeader)"), this.columnModel.autoSizeColumns({
          columns: [e],
          skipHeader: t,
          source: "api"
        })
      }
      autoSizeColumns(e, t) {
        this.columnModel.autoSizeColumns({
          columns: e,
          skipHeader: t,
          source: "api"
        })
      }
      autoSizeAllColumns(e) {
        this.columnModel.autoSizeAllColumns("api", e)
      }
      setPivotResultColumns(e) {
        this.columnModel.setSecondaryColumns(e, "api")
      }
      getPivotResultColumns() {
        return this.columnModel.getSecondaryColumns()
      }
      getState() {
        return this.stateService.getState()
      }
      getGridOption(e) {
        return this.gos.get(e)
      }
      setGridOption(e, t) {
        this.updateGridOptions({
          [e]: t
        })
      }
      updateGridOptions(e) {
        this.gos.updateGridOptions({
          options: e
        })
      }
      __internalUpdateGridOptions(e, t) {
        this.gos.updateGridOptions({
          options: e,
          force: t,
          source: "gridOptionsUpdated"
        })
      }
      deprecatedUpdateGridOption(e, t) {
        z(`set${e.charAt(0).toUpperCase()}${e.slice(1,e.length)} is deprecated. Please use 'api.setGridOption('${e}', newValue)' or 'api.updateGridOptions({ ${e}: newValue })' instead.`), this.setGridOption(e, t)
      }
      setPivotMode(e) {
        this.deprecatedUpdateGridOption("pivotMode", e)
      }
      setPinnedTopRowData(e) {
        this.deprecatedUpdateGridOption("pinnedTopRowData", e)
      }
      setPinnedBottomRowData(e) {
        this.deprecatedUpdateGridOption("pinnedBottomRowData", e)
      }
      setPopupParent(e) {
        this.deprecatedUpdateGridOption("popupParent", e)
      }
      setSuppressModelUpdateAfterUpdateTransaction(e) {
        this.deprecatedUpdateGridOption("suppressModelUpdateAfterUpdateTransaction", e)
      }
      setDataTypeDefinitions(e) {
        this.deprecatedUpdateGridOption("dataTypeDefinitions", e)
      }
      setPagination(e) {
        this.deprecatedUpdateGridOption("pagination", e)
      }
      paginationSetPageSize(e) {
        this.deprecatedUpdateGridOption("paginationPageSize", e)
      }
      setSideBar(e) {
        this.deprecatedUpdateGridOption("sideBar", e)
      }
      setSuppressClipboardPaste(e) {
        this.deprecatedUpdateGridOption("suppressClipboardPaste", e)
      }
      setGroupRemoveSingleChildren(e) {
        this.deprecatedUpdateGridOption("groupRemoveSingleChildren", e)
      }
      setGroupRemoveLowestSingleChildren(e) {
        this.deprecatedUpdateGridOption("groupRemoveLowestSingleChildren", e)
      }
      setGroupDisplayType(e) {
        this.deprecatedUpdateGridOption("groupDisplayType", e)
      }
      setGroupIncludeFooter(e) {
        this.deprecatedUpdateGridOption("groupIncludeFooter", e)
      }
      setGroupIncludeTotalFooter(e) {
        this.deprecatedUpdateGridOption("groupIncludeTotalFooter", e)
      }
      setRowClass(e) {
        this.deprecatedUpdateGridOption("rowClass", e)
      }
      setDeltaSort(e) {
        this.deprecatedUpdateGridOption("deltaSort", e)
      }
      setSuppressRowDrag(e) {
        this.deprecatedUpdateGridOption("suppressRowDrag", e)
      }
      setSuppressMoveWhenRowDragging(e) {
        this.deprecatedUpdateGridOption("suppressMoveWhenRowDragging", e)
      }
      setSuppressRowClickSelection(e) {
        this.deprecatedUpdateGridOption("suppressRowClickSelection", e)
      }
      setEnableAdvancedFilter(e) {
        this.deprecatedUpdateGridOption("enableAdvancedFilter", e)
      }
      setIncludeHiddenColumnsInAdvancedFilter(e) {
        this.deprecatedUpdateGridOption("includeHiddenColumnsInAdvancedFilter", e)
      }
      setAdvancedFilterParent(e) {
        this.deprecatedUpdateGridOption("advancedFilterParent", e)
      }
      setAdvancedFilterBuilderParams(e) {
        this.deprecatedUpdateGridOption("advancedFilterBuilderParams", e)
      }
      setQuickFilter(e) {
        z("setQuickFilter is deprecated. Please use 'api.setGridOption('quickFilterText', newValue)' or 'api.updateGridOptions({ quickFilterText: newValue })' instead."), this.gos.updateGridOptions({
          options: {
            quickFilterText: e
          }
        })
      }
      setExcludeHiddenColumnsFromQuickFilter(e) {
        this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", !e)
      }
      setIncludeHiddenColumnsInQuickFilter(e) {
        this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", e)
      }
      setQuickFilterParser(e) {
        this.deprecatedUpdateGridOption("quickFilterParser", e)
      }
      setQuickFilterMatcher(e) {
        this.deprecatedUpdateGridOption("quickFilterMatcher", e)
      }
      setAlwaysShowHorizontalScroll(e) {
        this.deprecatedUpdateGridOption("alwaysShowHorizontalScroll", e)
      }
      setAlwaysShowVerticalScroll(e) {
        this.deprecatedUpdateGridOption("alwaysShowVerticalScroll", e)
      }
      setFunctionsReadOnly(e) {
        this.deprecatedUpdateGridOption("functionsReadOnly", e)
      }
      setColumnDefs(e, t = "api") {
        z("setColumnDefs is deprecated. Please use 'api.setGridOption('columnDefs', newValue)' or 'api.updateGridOptions({ columnDefs: newValue })' instead."), this.gos.updateGridOptions({
          options: {
            columnDefs: e
          },
          source: t
        })
      }
      setAutoGroupColumnDef(e, t = "api") {
        z("setAutoGroupColumnDef is deprecated. Please use 'api.setGridOption('autoGroupColumnDef', newValue)' or 'api.updateGridOptions({ autoGroupColumnDef: newValue })' instead."), this.gos.updateGridOptions({
          options: {
            autoGroupColumnDef: e
          },
          source: t
        })
      }
      setDefaultColDef(e, t = "api") {
        z("setDefaultColDef is deprecated. Please use 'api.setGridOption('defaultColDef', newValue)' or 'api.updateGridOptions({ defaultColDef: newValue })' instead."), this.gos.updateGridOptions({
          options: {
            defaultColDef: e
          },
          source: t
        })
      }
      setColumnTypes(e, t = "api") {
        z("setColumnTypes is deprecated. Please use 'api.setGridOption('columnTypes', newValue)' or 'api.updateGridOptions({ columnTypes: newValue })' instead."), this.gos.updateGridOptions({
          options: {
            columnTypes: e
          },
          source: t
        })
      }
      setTreeData(e) {
        this.deprecatedUpdateGridOption("treeData", e)
      }
      setServerSideDatasource(e) {
        this.deprecatedUpdateGridOption("serverSideDatasource", e)
      }
      setCacheBlockSize(e) {
        this.deprecatedUpdateGridOption("cacheBlockSize", e)
      }
      setDatasource(e) {
        this.deprecatedUpdateGridOption("datasource", e)
      }
      setViewportDatasource(e) {
        this.deprecatedUpdateGridOption("viewportDatasource", e)
      }
      setRowData(e) {
        this.deprecatedUpdateGridOption("rowData", e)
      }
      setEnableCellTextSelection(e) {
        this.deprecatedUpdateGridOption("enableCellTextSelection", e)
      }
      setHeaderHeight(e) {
        this.deprecatedUpdateGridOption("headerHeight", e)
      }
      setDomLayout(e) {
        this.deprecatedUpdateGridOption("domLayout", e)
      }
      setFillHandleDirection(e) {
        this.deprecatedUpdateGridOption("fillHandleDirection", e)
      }
      setGroupHeaderHeight(e) {
        this.deprecatedUpdateGridOption("groupHeaderHeight", e)
      }
      setFloatingFiltersHeight(e) {
        this.deprecatedUpdateGridOption("floatingFiltersHeight", e)
      }
      setPivotHeaderHeight(e) {
        this.deprecatedUpdateGridOption("pivotHeaderHeight", e)
      }
      setPivotGroupHeaderHeight(e) {
        this.deprecatedUpdateGridOption("pivotGroupHeaderHeight", e)
      }
      setAnimateRows(e) {
        this.deprecatedUpdateGridOption("animateRows", e)
      }
      setIsExternalFilterPresent(e) {
        this.deprecatedUpdateGridOption("isExternalFilterPresent", e)
      }
      setDoesExternalFilterPass(e) {
        this.deprecatedUpdateGridOption("doesExternalFilterPass", e)
      }
      setNavigateToNextCell(e) {
        this.deprecatedUpdateGridOption("navigateToNextCell", e)
      }
      setTabToNextCell(e) {
        this.deprecatedUpdateGridOption("tabToNextCell", e)
      }
      setTabToNextHeader(e) {
        this.deprecatedUpdateGridOption("tabToNextHeader", e)
      }
      setNavigateToNextHeader(e) {
        this.deprecatedUpdateGridOption("navigateToNextHeader", e)
      }
      setRowGroupPanelShow(e) {
        this.deprecatedUpdateGridOption("rowGroupPanelShow", e)
      }
      setGetGroupRowAgg(e) {
        this.deprecatedUpdateGridOption("getGroupRowAgg", e)
      }
      setGetBusinessKeyForNode(e) {
        this.deprecatedUpdateGridOption("getBusinessKeyForNode", e)
      }
      setGetChildCount(e) {
        this.deprecatedUpdateGridOption("getChildCount", e)
      }
      setProcessRowPostCreate(e) {
        this.deprecatedUpdateGridOption("processRowPostCreate", e)
      }
      setGetRowId(e) {
        z("getRowId is a static property and can no longer be updated.")
      }
      setGetRowClass(e) {
        this.deprecatedUpdateGridOption("getRowClass", e)
      }
      setIsFullWidthRow(e) {
        this.deprecatedUpdateGridOption("isFullWidthRow", e)
      }
      setIsRowSelectable(e) {
        this.deprecatedUpdateGridOption("isRowSelectable", e)
      }
      setIsRowMaster(e) {
        this.deprecatedUpdateGridOption("isRowMaster", e)
      }
      setPostSortRows(e) {
        this.deprecatedUpdateGridOption("postSortRows", e)
      }
      setGetDocument(e) {
        this.deprecatedUpdateGridOption("getDocument", e)
      }
      setGetContextMenuItems(e) {
        this.deprecatedUpdateGridOption("getContextMenuItems", e)
      }
      setGetMainMenuItems(e) {
        this.deprecatedUpdateGridOption("getMainMenuItems", e)
      }
      setProcessCellForClipboard(e) {
        this.deprecatedUpdateGridOption("processCellForClipboard", e)
      }
      setSendToClipboard(e) {
        this.deprecatedUpdateGridOption("sendToClipboard", e)
      }
      setProcessCellFromClipboard(e) {
        this.deprecatedUpdateGridOption("processCellFromClipboard", e)
      }
      setProcessPivotResultColDef(e) {
        this.deprecatedUpdateGridOption("processPivotResultColDef", e)
      }
      setProcessPivotResultColGroupDef(e) {
        this.deprecatedUpdateGridOption("processPivotResultColGroupDef", e)
      }
      setPostProcessPopup(e) {
        this.deprecatedUpdateGridOption("postProcessPopup", e)
      }
      setInitialGroupOrderComparator(e) {
        this.deprecatedUpdateGridOption("initialGroupOrderComparator", e)
      }
      setGetChartToolbarItems(e) {
        this.deprecatedUpdateGridOption("getChartToolbarItems", e)
      }
      setPaginationNumberFormatter(e) {
        this.deprecatedUpdateGridOption("paginationNumberFormatter", e)
      }
      setGetServerSideGroupLevelParams(e) {
        this.deprecatedUpdateGridOption("getServerSideGroupLevelParams", e)
      }
      setIsServerSideGroupOpenByDefault(e) {
        this.deprecatedUpdateGridOption("isServerSideGroupOpenByDefault", e)
      }
      setIsApplyServerSideTransaction(e) {
        this.deprecatedUpdateGridOption("isApplyServerSideTransaction", e)
      }
      setIsServerSideGroup(e) {
        this.deprecatedUpdateGridOption("isServerSideGroup", e)
      }
      setGetServerSideGroupKey(e) {
        this.deprecatedUpdateGridOption("getServerSideGroupKey", e)
      }
      setGetRowStyle(e) {
        this.deprecatedUpdateGridOption("getRowStyle", e)
      }
      setGetRowHeight(e) {
        this.deprecatedUpdateGridOption("getRowHeight", e)
      }
    };
    C([fe("rowRenderer")], zo.prototype, "rowRenderer", 2), C([fe("navigationService")], zo.prototype, "navigationService", 2), C([fe("filterManager")], zo.prototype, "filterManager", 2), C([fe("columnModel")], zo.prototype, "columnModel", 2), C([fe("selectionService")], zo.prototype, "selectionService", 2), C([fe("gridOptionsService")], zo.prototype, "gos", 2), C([fe("valueService")], zo.prototype, "valueService", 2), C([fe("alignedGridsService")], zo.prototype, "alignedGridsService", 2), C([fe("eventService")], zo.prototype, "eventService", 2), C([fe("pinnedRowModel")], zo.prototype, "pinnedRowModel", 2), C([fe("context")], zo.prototype, "context", 2), C([fe("rowModel")], zo.prototype, "rowModel", 2), C([fe("sortController")], zo.prototype, "sortController", 2), C([fe("paginationProxy")], zo.prototype, "paginationProxy", 2), C([fe("focusService")], zo.prototype, "focusService", 2), C([fe("dragAndDropService")], zo.prototype, "dragAndDropService", 2), C([fe("menuService")], zo.prototype, "menuService", 2), C([fe("valueCache")], zo.prototype, "valueCache", 2), C([fe("animationFrameService")], zo.prototype, "animationFrameService", 2), C([fe("ctrlsService")], zo.prototype, "ctrlsService", 2), C([fe("overlayService")], zo.prototype, "overlayService", 2), C([fe("stateService")], zo.prototype, "stateService", 2), C([fe("expansionService")], zo.prototype, "expansionService", 2), C([fe("apiEventService")], zo.prototype, "apiEventService", 2), C([fe("frameworkOverrides")], zo.prototype, "frameworkOverrides", 2), C([fe("undoRedoService")], zo.prototype, "undoRedoService", 2), C([fe("rowNodeBlockLoader")], zo.prototype, "rowNodeBlockLoader", 2), C([Te("csvCreator")], zo.prototype, "csvCreator", 2), C([Te("excelCreator")], zo.prototype, "excelCreator", 2), C([Te("rangeService")], zo.prototype, "rangeService", 2), C([Te("clipboardService")], zo.prototype, "clipboardService", 2), C([Te("aggFuncService")], zo.prototype, "aggFuncService", 2), C([Te("statusBarService")], zo.prototype, "statusBarService", 2), C([Te("chartService")], zo.prototype, "chartService", 2), C([Te("ssrmTransactionManager")], zo.prototype, "serverSideTransactionManager", 2), C([Te("sideBarService")], zo.prototype, "sideBarService", 2), C([pe], zo.prototype, "init", 1), zo = C([ge("gridApi")], zo);
    var $o = class extends ct {
      constructor() {
        super(...arguments), this.quickFilter = null, this.quickFilterParts = null
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VISIBLE, () => {
          this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache()
        }), this.addManagedPropertyListener("quickFilterText", e => this.setQuickFilter(e.currentValue)), this.addManagedPropertyListeners(["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"], () => this.onQuickFilterColumnConfigChanged()), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setQuickFilterParserAndMatcher())
      }
      isQuickFilterPresent() {
        return null !== this.quickFilter
      }
      doesRowPassQuickFilter(e) {
        const t = this.gos.get("cacheQuickFilter");
        return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every(i => t ? this.doesRowPassQuickFilterCache(e, i) : this.doesRowPassQuickFilterNoCache(e, i))
      }
      resetQuickFilterCache() {
        this.rowModel.forEachNode(e => e.quickFilterAggregateText = null)
      }
      setQuickFilterParts() {
        const {
          quickFilter: e,
          parser: t
        } = this;
        this.quickFilterParts = e ? t ? t(e) : e.split(" ") : null
      }
      parseQuickFilter(e) {
        return v(e) ? this.gos.isRowModelType("clientSide") ? e.toUpperCase() : (console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model"), null) : null
      }
      setQuickFilter(e) {
        if (null != e && "string" != typeof e) return void console.warn("AG Grid - Grid option quickFilterText only supports string inputs, received: " + typeof e);
        const t = this.parseQuickFilter(e);
        this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchEvent({
          type: $o.EVENT_QUICK_FILTER_CHANGED
        }))
      }
      setQuickFilterParserAndMatcher() {
        const e = this.gos.get("quickFilterParser"),
          t = this.gos.get("quickFilterMatcher"),
          i = e !== this.parser || t !== this.matcher;
        this.parser = e, this.matcher = t, i && (this.setQuickFilterParts(), this.dispatchEvent({
          type: $o.EVENT_QUICK_FILTER_CHANGED
        }))
      }
      onQuickFilterColumnConfigChanged() {
        this.columnModel.refreshQuickFilterColumns(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchEvent({
          type: $o.EVENT_QUICK_FILTER_CHANGED
        })
      }
      doesRowPassQuickFilterNoCache(e, t) {
        return this.columnModel.getAllColumnsForQuickFilter().some(i => {
          const r = this.getQuickFilterTextForColumn(i, e);
          return v(r) && r.indexOf(t) >= 0
        })
      }
      doesRowPassQuickFilterCache(e, t) {
        return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0
      }
      doesRowPassQuickFilterMatcher(e, t) {
        let i;
        e ? (this.checkGenerateQuickFilterAggregateText(t), i = t.quickFilterAggregateText) : i = this.getQuickFilterAggregateText(t);
        const {
          quickFilterParts: r,
          matcher: s
        } = this;
        return s(r, i)
      }
      checkGenerateQuickFilterAggregateText(e) {
        e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e))
      }
      getQuickFilterTextForColumn(e, t) {
        let i = this.valueService.getValue(e, t, !0);
        const r = e.getColDef();
        if (r.getQuickFilterText) {
          const s = this.gos.addGridCommonParams({
            value: i,
            node: t,
            data: t.data,
            column: e,
            colDef: r
          });
          i = r.getQuickFilterText(s)
        }
        return v(i) ? i.toString().toUpperCase() : null
      }
      getQuickFilterAggregateText(e) {
        const t = [];
        return this.columnModel.getAllColumnsForQuickFilter().forEach(i => {
          const r = this.getQuickFilterTextForColumn(i, e);
          v(r) && t.push(r)
        }), t.join($o.QUICK_FILTER_SEPARATOR)
      }
    };
    $o.EVENT_QUICK_FILTER_CHANGED = "quickFilterChanged", $o.QUICK_FILTER_SEPARATOR = "\n", C([fe("valueService")], $o.prototype, "valueService", 2), C([fe("columnModel")], $o.prototype, "columnModel", 2), C([fe("rowModel")], $o.prototype, "rowModel", 2), C([pe], $o.prototype, "postConstruct", 1), $o = C([ge("quickFilterService")], $o);
    var jo = class extends ct {
      constructor() {
        super(...arguments), this.allColumnFilters = new Map, this.allColumnListeners = new Map, this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [], this.advancedFilterModelUpdateQueue = []
      }
      init() {
        var e, t, i;
        this.addManagedListener(this.eventService, Et.EVENT_GRID_COLUMNS_CHANGED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VALUE_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.updateAdvancedFilterColumns()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VISIBLE, () => this.updateAdvancedFilterColumns()), this.addManagedListener(this.eventService, Et.EVENT_ROW_DATA_UPDATED, () => this.onNewRowsLoaded("rowDataUpdated")), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
          this.onFilterChanged({
            source: "api"
          })
        }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
          this.updateAggFiltering(), this.onFilterChanged()
        }), this.addManagedPropertyListener("advancedFilterModel", e => this.setAdvancedFilterModel(e.currentValue)), this.addManagedListener(this.eventService, Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, ({
          enabled: e
        }) => this.onAdvancedFilterEnabledChanged(e)), this.addManagedListener(this.eventService, Et.EVENT_DATA_TYPES_INFERRED, () => this.processFilterModelUpdateQueue()), this.addManagedListener(this.quickFilterService, $o.EVENT_QUICK_FILTER_CHANGED, () => this.onFilterChanged({
          source: "quickFilter"
        })), this.initialFilterModel = f({}, null != (i = null == (t = null == (e = this.gos.get("initialState")) ? void 0 : e.filter) ? void 0 : t.filterModel) ? i : {})
      }
      isExternalFilterPresentCallback() {
        const e = this.gos.getCallback("isExternalFilterPresent");
        return "function" == typeof e && e({})
      }
      doesExternalFilterPass(e) {
        const t = this.gos.get("doesExternalFilterPass");
        return "function" == typeof t && t(e)
      }
      setFilterModel(e, t = "api") {
        if (this.isAdvancedFilterEnabled()) return void this.warnAdvancedFilters();
        if (this.dataTypeService.isPendingInference()) return void this.filterModelUpdateQueue.push({
          model: e,
          source: t
        });
        const i = [],
          r = this.getFilterModel();
        if (e) {
          const t = ms(Object.keys(e));
          this.allColumnFilters.forEach((r, s) => {
            const n = e[s];
            i.push(this.setModelOnFilterWrapper(r.filterPromise, n)), t.delete(s)
          }), t.forEach(t => {
            const r = this.columnModel.getPrimaryColumn(t) || this.columnModel.getGridColumn(t);
            if (!r) return void console.warn("AG Grid: setFilterModel() - no column found for colId: " + t);
            if (!r.isFilterAllowed()) return void console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + t);
            const s = this.getOrCreateFilterWrapper(r, "NO_UI");
            s ? i.push(this.setModelOnFilterWrapper(s.filterPromise, e[t])) : console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + t)
          })
        } else this.allColumnFilters.forEach(e => {
          i.push(this.setModelOnFilterWrapper(e.filterPromise, null))
        });
        Rs.all(i).then(() => {
          const e = this.getFilterModel(),
            i = [];
          this.allColumnFilters.forEach((t, s) => {
            const n = r ? r[s] : null,
              o = e ? e[s] : null;
            Cs.jsonEquals(n, o) || i.push(t.column)
          }), i.length > 0 && this.onFilterChanged({
            columns: i,
            source: t
          })
        })
      }
      setModelOnFilterWrapper(e, t) {
        return new Rs(i => {
          e.then(e => {
            "function" != typeof e.setModel && (console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel"), i()), (e.setModel(t) || Rs.resolve()).then(() => i())
          })
        })
      }
      getFilterModel() {
        const e = {};
        return this.allColumnFilters.forEach((t, i) => {
          const r = this.getModelFromFilterWrapper(t);
          v(r) && (e[i] = r)
        }), e
      }
      getModelFromFilterWrapper(e) {
        var t;
        const i = e.filterPromise.resolveNow(null, e => e);
        return null == i ? null != (t = this.initialFilterModel[e.column.getColId()]) ? t : null : "function" != typeof i.getModel ? (console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel"), null) : i.getModel()
      }
      isColumnFilterPresent() {
        return this.activeColumnFilters.length > 0
      }
      isAggregateFilterPresent() {
        return !!this.activeAggregateFilters.length
      }
      isExternalFilterPresent() {
        return this.externalFilterPresent
      }
      isChildFilterPresent() {
        return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent()
      }
      isAdvancedFilterPresent() {
        return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent()
      }
      onAdvancedFilterEnabledChanged(e) {
        var t;
        e ? this.allColumnFilters.size && (this.allColumnFilters.forEach(e => this.disposeFilterWrapper(e, "advancedFilterEnabled")), this.onFilterChanged({
          source: "advancedFilter"
        })) : (null == (t = this.advancedFilterService) ? void 0 : t.isFilterPresent()) && (this.advancedFilterService.setModel(null), this.onFilterChanged({
          source: "advancedFilter"
        }))
      }
      isAdvancedFilterEnabled() {
        var e;
        return !!(null == (e = this.advancedFilterService) ? void 0 : e.isEnabled())
      }
      isAdvancedFilterHeaderActive() {
        return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive()
      }
      doAggregateFiltersPass(e, t) {
        return this.doColumnFiltersPass(e, t, !0)
      }
      updateActiveFilters() {
        this.activeColumnFilters.length = 0, this.activeAggregateFilters.length = 0;
        const e = e => !!e && (e.isFilterActive ? e.isFilterActive() : (console.warn("AG Grid: Filter is missing isFilterActive() method"), !1)),
          t = !!this.gos.getGroupAggFiltering(),
          i = e => {
            if (!e.isPrimary()) return !0;
            const i = !this.columnModel.isPivotActive();
            return !(!e.isValueActive() || !i) && (!!this.columnModel.isPivotMode() || t)
          };
        this.allColumnFilters.forEach(t => {
          if (t.filterPromise.resolveNow(!1, e)) {
            const e = t.filterPromise.resolveNow(null, e => e);
            i(t.column) ? this.activeAggregateFilters.push(e) : this.activeColumnFilters.push(e)
          }
        })
      }
      updateFilterFlagInColumns(e, t) {
        this.allColumnFilters.forEach(i => {
          const r = i.filterPromise.resolveNow(!1, e => e.isFilterActive());
          i.column.setFilterActive(r, e, t)
        })
      }
      isAnyFilterPresent() {
        return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent()
      }
      doColumnFiltersPass(e, t, i) {
        const {
          data: r,
          aggData: s
        } = e, n = i ? this.activeAggregateFilters : this.activeColumnFilters, o = i ? s : r;
        for (let i = 0; i < n.length; i++) {
          const r = n[i];
          if (null != r && r !== t) {
            if ("function" != typeof r.doesFilterPass) throw new Error("Filter is missing method doesFilterPass");
            if (!r.doesFilterPass({
                node: e,
                data: o
              })) return !1
          }
        }
        return !0
      }
      resetQuickFilterCache() {
        this.quickFilterService.resetQuickFilterCache()
      }
      refreshFiltersForAggregations() {
        this.gos.getGroupAggFiltering() && this.onFilterChanged()
      }
      callOnFilterChangedOutsideRenderCycle(e) {
        const t = () => this.onFilterChanged(e);
        this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t()
      }
      onFilterChanged(e = {}) {
        const {
          source: t,
          filterInstance: i,
          additionalEventAttributes: r,
          columns: s
        } = e;
        this.updateDependantFilters(), this.updateActiveFilters(), this.updateFilterFlagInColumns("filterChanged", r), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.allColumnFilters.forEach(e => {
          e.filterPromise && e.filterPromise.then(e => {
            e && e !== i && e.onAnyFilterChanged && e.onAnyFilterChanged()
          })
        });
        const n = {
          source: t,
          type: Et.EVENT_FILTER_CHANGED,
          columns: s || []
        };
        r && k(n, r), this.processingFilterChange = !0, this.eventService.dispatchEvent(n), this.processingFilterChange = !1
      }
      isSuppressFlashingCellsBecauseFiltering() {
        var e;
        return !(null != (e = this.gos.get("allowShowChangeAfterFilter")) && e) && this.processingFilterChange
      }
      isQuickFilterPresent() {
        return this.quickFilterService.isQuickFilterPresent()
      }
      updateAggFiltering() {
        this.aggFiltering = !!this.gos.getGroupAggFiltering()
      }
      isAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg()
      }
      isNonAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg()
      }
      shouldApplyQuickFilterAfterAgg() {
        return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg")
      }
      doesRowPassOtherFilters(e, t) {
        return this.doesRowPassFilter({
          rowNode: t,
          filterInstanceToSkip: e
        })
      }
      doesRowPassAggregateFilters(e) {
        return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode)) && !(this.isAggregateFilterPresent() && !this.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip))
      }
      doesRowPassFilter(e) {
        return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode)) && (!(this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode)) && (!(this.isColumnFilterPresent() && !this.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip)) && !(this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode))))
      }
      onNewRowsLoaded(e) {
        this.allColumnFilters.forEach(e => {
          e.filterPromise.then(e => {
            e.onNewRowsLoaded && e.onNewRowsLoaded()
          })
        }), this.updateFilterFlagInColumns(e, {
          afterDataChange: !0
        }), this.updateActiveFilters()
      }
      createValueGetter(e) {
        return ({
          node: t
        }) => this.valueService.getValue(e, t, !0)
      }
      createGetValue(e) {
        return (t, i) => {
          const r = i ? this.columnModel.getGridColumn(i) : e;
          return r ? this.valueService.getValue(r, t, !0) : void 0
        }
      }
      getFilterComponent(e, t, i = !0) {
        var r;
        if (i) return (null == (r = this.getOrCreateFilterWrapper(e, t)) ? void 0 : r.filterPromise) || null;
        const s = this.cachedFilter(e);
        return s ? s.filterPromise : null
      }
      isFilterActive(e) {
        const t = this.cachedFilter(e);
        return !!t && t.filterPromise.resolveNow(!1, e => e.isFilterActive())
      }
      getOrCreateFilterWrapper(e, t) {
        if (!e.isFilterAllowed()) return null;
        let i = this.cachedFilter(e);
        return i || (i = this.createFilterWrapper(e, t), this.setColumnFilterWrapper(e, i)), i
      }
      cachedFilter(e) {
        return this.allColumnFilters.get(e.getColId())
      }
      getDefaultFilter(e) {
        let t;
        if (he.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId())) t = "agSetColumnFilter";
        else {
          const i = this.dataTypeService.getBaseDataType(e);
          t = "number" === i ? "agNumberColumnFilter" : "date" === i || "dateString" === i ? "agDateColumnFilter" : "agTextColumnFilter"
        }
        return t
      }
      getDefaultFloatingFilter(e) {
        let t;
        if (he.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId())) t = "agSetColumnFloatingFilter";
        else {
          const i = this.dataTypeService.getBaseDataType(e);
          t = "number" === i ? "agNumberColumnFloatingFilter" : "date" === i || "dateString" === i ? "agDateColumnFloatingFilter" : "agTextColumnFloatingFilter"
        }
        return t
      }
      createFilterInstance(e) {
        const t = this.getDefaultFilter(e),
          i = e.getColDef();
        let r;
        const s = T(f({}, this.createFilterParams(e, i)), {
            filterModifiedCallback: () => this.filterModifiedCallbackFactory(r, e)(),
            filterChangedCallback: t => this.filterChangedCallbackFactory(r, e)(t),
            doesRowPassOtherFilter: e => this.doesRowPassOtherFilters(r, e)
          }),
          n = this.userComponentFactory.getFilterDetails(i, s, t);
        return n ? {
          filterPromise: () => {
            const e = n.newAgStackInstance();
            return e && e.then(e => r = e), e
          },
          compDetails: n
        } : {
          filterPromise: null,
          compDetails: null
        }
      }
      createFilterParams(e, t) {
        return this.gos.addGridCommonParams({
          column: e,
          colDef: G(t),
          rowModel: this.rowModel,
          filterChangedCallback: () => {},
          filterModifiedCallback: () => {},
          valueGetter: this.createValueGetter(e),
          getValue: this.createGetValue(e),
          doesRowPassOtherFilter: () => !0
        })
      }
      createFilterWrapper(e, t) {
        var i;
        const r = {
            column: e,
            filterPromise: null,
            compiledElement: null,
            compDetails: null
          },
          {
            filterPromise: s,
            compDetails: n
          } = this.createFilterInstance(e);
        return r.filterPromise = null != (i = null == s ? void 0 : s()) ? i : null, r.compDetails = n, r
      }
      onColumnsChanged() {
        const e = [];
        this.allColumnFilters.forEach((t, i) => {
          let r;
          r = t.column.isPrimary() ? this.columnModel.getPrimaryColumn(i) : this.columnModel.getGridColumn(i), r && r === t.column || (e.push(t.column), this.disposeFilterWrapper(t, "columnChanged"), this.disposeColumnListener(i))
        }), e.length > 0 ? this.onFilterChanged({
          columns: e,
          source: "api"
        }) : this.updateDependantFilters()
      }
      updateDependantFilters() {
        const e = this.columnModel.getGroupAutoColumns();
        null == e || e.forEach(e => {
          "agGroupColumnFilter" === e.getColDef().filter && this.getOrCreateFilterWrapper(e, "NO_UI")
        })
      }
      isFilterAllowed(e) {
        var t, i;
        if (this.isAdvancedFilterEnabled()) return !1;
        if (!e.isFilterAllowed()) return !1;
        const r = this.allColumnFilters.get(e.getColId());
        return null == (i = null == (t = null == r ? void 0 : r.filterPromise) ? void 0 : t.resolveNow(!0, e => "function" != typeof(null == e ? void 0 : e.isFilterAllowed) || (null == e ? void 0 : e.isFilterAllowed()))) || i
      }
      getFloatingFilterCompDetails(e, t) {
        const i = t => {
            const i = this.getFilterComponent(e, "NO_UI");
            null != i && i.then(e => {
              t(Xo(e))
            })
          },
          r = e.getColDef(),
          s = T(f({}, this.createFilterParams(e, r)), {
            filterChangedCallback: () => i(t => this.filterChangedCallbackFactory(t, e)())
          }),
          n = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(r, wo, s);
        let o = this.userComponentFactory.getDefaultFloatingFilterType(r, () => this.getDefaultFloatingFilter(e));
        null == o && (o = "agReadOnlyFloatingFilter");
        const a = {
          column: e,
          filterParams: n,
          currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
          parentFilterInstance: i,
          showParentFilter: t,
          suppressFilterButton: !1
        };
        return this.userComponentFactory.getFloatingFilterCompDetails(r, a, o)
      }
      getCurrentFloatingFilterParentModel(e) {
        const t = this.getFilterComponent(e, "NO_UI", !1);
        return t ? t.resolveNow(null, e => e && e.getModel()) : null
      }
      destroyFilter(e, t = "api") {
        const i = e.getColId(),
          r = this.allColumnFilters.get(i);
        this.disposeColumnListener(i), delete this.initialFilterModel[i], r && (this.disposeFilterWrapper(r, t), this.onFilterChanged({
          columns: [e],
          source: "api"
        }))
      }
      disposeColumnListener(e) {
        const t = this.allColumnListeners.get(e);
        t && (this.allColumnListeners.delete(e), t())
      }
      disposeFilterWrapper(e, t) {
        e.filterPromise.then(i => {
          this.getContext().destroyBean(i), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId());
          const r = {
            type: Et.EVENT_FILTER_DESTROYED,
            source: t,
            column: e.column
          };
          this.eventService.dispatchEvent(r)
        })
      }
      filterModifiedCallbackFactory(e, t) {
        return () => {
          const i = {
            type: Et.EVENT_FILTER_MODIFIED,
            column: t,
            filterInstance: e
          };
          this.eventService.dispatchEvent(i)
        }
      }
      filterChangedCallbackFactory(e, t) {
        return i => {
          var r;
          const s = null != (r = null == i ? void 0 : i.source) ? r : "api",
            n = {
              filter: e,
              additionalEventAttributes: i,
              columns: [t],
              source: s
            };
          this.callOnFilterChangedOutsideRenderCycle(n)
        }
      }
      checkDestroyFilter(e) {
        const t = this.allColumnFilters.get(e);
        if (!t) return;
        const i = t.column,
          {
            compDetails: r
          } = i.isFilterAllowed() ? this.createFilterInstance(i) : {
            compDetails: null
          };
        if (this.areFilterCompsDifferent(t.compDetails, r)) return void this.destroyFilter(i, "paramsUpdated");
        const s = i.getColDef().filterParams;
        t.filterPromise ? t.filterPromise.then(e => {
          !1 === (!(null == e ? void 0 : e.refresh) || e.refresh(f(T(f({}, this.createFilterParams(i, i.getColDef())), {
            filterModifiedCallback: this.filterModifiedCallbackFactory(e, i),
            filterChangedCallback: this.filterChangedCallbackFactory(e, i),
            doesRowPassOtherFilter: t => this.doesRowPassOtherFilters(e, t)
          }), s))) && this.destroyFilter(i, "paramsUpdated")
        }) : this.destroyFilter(i, "paramsUpdated")
      }
      setColumnFilterWrapper(e, t) {
        const i = e.getColId();
        this.allColumnFilters.set(i, t), this.allColumnListeners.set(i, this.addManagedListener(e, Le.EVENT_COL_DEF_CHANGED, () => this.checkDestroyFilter(i)))
      }
      areFilterCompsDifferent(e, t) {
        if (!t || !e) return !0;
        const {
          componentClass: i
        } = e, {
          componentClass: r
        } = t;
        return !(i === r || (null == i ? void 0 : i.render) && (null == r ? void 0 : r.render) && i.render === r.render)
      }
      getAdvancedFilterModel() {
        return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null
      }
      setAdvancedFilterModel(e) {
        this.isAdvancedFilterEnabled() && (this.dataTypeService.isPendingInference() ? this.advancedFilterModelUpdateQueue.push(e) : (this.advancedFilterService.setModel(null != e ? e : null), this.onFilterChanged({
          source: "advancedFilter"
        })))
      }
      showAdvancedFilterBuilder(e) {
        this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder(e, !0)
      }
      updateAdvancedFilterColumns() {
        this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({
          source: "advancedFilter"
        })
      }
      hasFloatingFilters() {
        if (this.isAdvancedFilterEnabled()) return !1;
        return this.columnModel.getAllGridColumns().some(e => e.getColDef().floatingFilter)
      }
      getFilterInstance(e, t) {
        if (this.isAdvancedFilterEnabled()) return void this.warnAdvancedFilters();
        const i = this.getFilterInstanceImpl(e, e => {
          if (!t) return;
          const i = Xo(e);
          t(i)
        });
        return Xo(i)
      }
      getColumnFilterInstance(e) {
        return new Promise(t => {
          this.getFilterInstance(e, e => {
            t(e)
          })
        })
      }
      getFilterInstanceImpl(e, t) {
        const i = this.columnModel.getPrimaryColumn(e);
        if (!i) return;
        const r = this.getFilterComponent(i, "NO_UI"),
          s = r && r.resolveNow(null, e => e);
        return s ? setTimeout(t, 0, s) : r && r.then(e => {
          t(e)
        }), s
      }
      warnAdvancedFilters() {
        z("Column Filter API methods have been disabled as Advanced Filters are enabled.")
      }
      setupAdvancedFilterHeaderComp(e) {
        var t;
        null == (t = this.advancedFilterService) || t.getCtrl().setupHeaderComp(e)
      }
      getHeaderRowCount() {
        return this.isAdvancedFilterHeaderActive() ? 1 : 0
      }
      getHeaderHeight() {
        return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0
      }
      processFilterModelUpdateQueue() {
        this.filterModelUpdateQueue.forEach(({
          model: e,
          source: t
        }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({
          key: e,
          model: t,
          resolve: i
        }) => {
          this.setColumnFilterModel(e, t).then(() => i())
        }), this.columnFilterModelUpdateQueue = [], this.advancedFilterModelUpdateQueue.forEach(e => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = []
      }
      getColumnFilterModel(e) {
        const t = this.getFilterWrapper(e);
        return t ? this.getModelFromFilterWrapper(t) : null
      }
      setColumnFilterModel(e, t) {
        if (this.isAdvancedFilterEnabled()) return this.warnAdvancedFilters(), Promise.resolve();
        if (this.dataTypeService.isPendingInference()) {
          let i = () => {};
          const r = new Promise(e => {
            i = e
          });
          return this.columnFilterModelUpdateQueue.push({
            key: e,
            model: t,
            resolve: i
          }), r
        }
        const i = this.columnModel.getPrimaryColumn(e),
          r = i ? this.getOrCreateFilterWrapper(i, "NO_UI") : null;
        return r ? (s = this.setModelOnFilterWrapper(r.filterPromise, t), new Promise(e => {
          s.then(t => e(t))
        })) : Promise.resolve();
        var s
      }
      getFilterWrapper(e) {
        var t;
        const i = this.columnModel.getPrimaryColumn(e);
        return i && null != (t = this.cachedFilter(i)) ? t : null
      }
      destroy() {
        super.destroy(), this.allColumnFilters.forEach(e => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear()
      }
    };
    C([fe("valueService")], jo.prototype, "valueService", 2), C([fe("columnModel")], jo.prototype, "columnModel", 2), C([fe("rowModel")], jo.prototype, "rowModel", 2), C([fe("userComponentFactory")], jo.prototype, "userComponentFactory", 2), C([fe("rowRenderer")], jo.prototype, "rowRenderer", 2), C([fe("dataTypeService")], jo.prototype, "dataTypeService", 2), C([fe("quickFilterService")], jo.prototype, "quickFilterService", 2), C([Te("advancedFilterService")], jo.prototype, "advancedFilterService", 2), C([pe], jo.prototype, "init", 1), jo = C([ge("filterManager")], jo);
    var Jo = class extends _s {
      constructor(e, t) {
        super('<div class="ag-filter"></div>'), this.column = e, this.source = t, this.filterWrapper = null
      }
      postConstruct() {
        this.createFilter(!0), this.addManagedListener(this.eventService, Et.EVENT_FILTER_DESTROYED, this.onFilterDestroyed.bind(this))
      }
      hasFilter() {
        return !!this.filterWrapper
      }
      getFilter() {
        var e, t;
        return null != (t = null == (e = this.filterWrapper) ? void 0 : e.filterPromise) ? t : null
      }
      afterInit() {
        var e, t, i;
        return null != (i = null == (t = null == (e = this.filterWrapper) ? void 0 : e.filterPromise) ? void 0 : t.then(() => {})) ? i : Rs.resolve()
      }
      afterGuiAttached(e) {
        var t, i;
        null == (i = null == (t = this.filterWrapper) ? void 0 : t.filterPromise) || i.then(t => {
          var i;
          null == (i = null == t ? void 0 : t.afterGuiAttached) || i.call(t, e)
        })
      }
      afterGuiDetached() {
        var e, t;
        null == (t = null == (e = this.filterWrapper) ? void 0 : e.filterPromise) || t.then(e => {
          var t;
          null == (t = null == e ? void 0 : e.afterGuiDetached) || t.call(e)
        })
      }
      createFilter(e) {
        var t;
        const {
          column: i,
          source: r
        } = this;
        this.filterWrapper = this.filterManager.getOrCreateFilterWrapper(i, r), (null == (t = this.filterWrapper) ? void 0 : t.filterPromise) && this.filterWrapper.filterPromise.then(t => {
          let s = t.getGui();
          if (v(s) || console.warn(`AG Grid: getGui method from filter returned ${s}, it should be a DOM element or an HTML template string.`), "string" == typeof s && (s = _r(s)), this.appendChild(s), e) {
            const e = {
              type: Et.EVENT_FILTER_OPENED,
              column: i,
              source: r,
              eGui: this.getGui()
            };
            this.eventService.dispatchEvent(e)
          }
        })
      }
      onFilterDestroyed(e) {
        "api" !== e.source && "paramsUpdated" !== e.source || e.column.getId() !== this.column.getId() || !this.columnModel.getPrimaryColumn(this.column) || (Nr(this.getGui()), this.createFilter())
      }
      destroy() {
        this.filterWrapper = null, super.destroy()
      }
    };
    C([fe("filterManager")], Jo.prototype, "filterManager", 2), C([fe("columnModel")], Jo.prototype, "columnModel", 2), C([pe], Jo.prototype, "postConstruct", 1);
    var qo = class extends _s {
        constructor(e, t) {
          super(e), this.ctrl = t
        }
        getCtrl() {
          return this.ctrl
        }
      },
      Qo = class e extends qo {
        constructor(t) {
          super(e.TEMPLATE, t)
        }
        postConstruct() {
          const e = this.getGui(),
            t = {
              addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
              addOrRemoveBodyCssClass: (e, t) => this.eFloatingFilterBody.classList.toggle(e, t),
              setButtonWrapperDisplayed: e => ur(this.eButtonWrapper, e),
              setCompDetails: e => this.setCompDetails(e),
              getFloatingFilterComp: () => this.compPromise,
              setWidth: t => e.style.width = t,
              setMenuIcon: e => this.eButtonShowMainFilter.appendChild(e)
            };
          this.ctrl.setComp(t, e, this.eButtonShowMainFilter, this.eFloatingFilterBody)
        }
        setCompDetails(e) {
          if (!e) return this.destroyFloatingFilterComp(), void(this.compPromise = null);
          this.compPromise = e.newAgStackInstance(), this.compPromise.then(e => this.afterCompCreated(e))
        }
        destroyFloatingFilterComp() {
          this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp))
        }
        afterCompCreated(e) {
          e && (this.isAlive() ? (this.destroyFloatingFilterComp(), this.floatingFilterComp = e, this.eFloatingFilterBody.appendChild(e.getGui()), e.afterGuiAttached && e.afterGuiAttached()) : this.destroyBean(e))
        }
      };
    Qo.TEMPLATE = '<div class="ag-header-cell ag-floating-filter" role="gridcell">\n            <div ref="eFloatingFilterBody" role="presentation"></div>\n            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">\n                <button type="button" class="ag-button ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>\n            </div>\n        </div>', C([ys("eFloatingFilterBody")], Qo.prototype, "eFloatingFilterBody", 2), C([ys("eButtonWrapper")], Qo.prototype, "eButtonWrapper", 2), C([ys("eButtonShowMainFilter")], Qo.prototype, "eButtonShowMainFilter", 2), C([pe], Qo.prototype, "postConstruct", 1), C([Ee], Qo.prototype, "destroyFloatingFilterComp", 1);
    var Zo = Qo,
      ea = class extends ct {
        constructor(e) {
          super(), this.view = e
        }
        postConstruct() {
          this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses()
        }
        updateLayoutClasses() {
          const e = this.getDomLayout(),
            t = {
              autoHeight: "autoHeight" === e,
              normal: "normal" === e,
              print: "print" === e
            },
            i = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
          this.view.updateLayoutClasses(i, t)
        }
        getDomLayout() {
          var e;
          const t = null != (e = this.gos.get("domLayout")) ? e : "normal";
          return -1 === ["normal", "print", "autoHeight"].indexOf(t) ? (z(`${t} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : t
        }
      };
    C([pe], ea.prototype, "postConstruct", 1);
    var ta = class extends ct {
      constructor(e) {
        super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = re(() => this.lastScrollSource[1] = null, 500), this.resetLastVScrollDebounced = re(() => this.lastScrollSource[0] = null, 500)
      }
      postConstruct() {
        this.enableRtl = this.gos.get("enableRtl"), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.ctrlsService.whenReady(e => {
          this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener()
        })
      }
      addScrollListener() {
        const {
          fakeHScrollComp: e,
          fakeVScrollComp: t
        } = this.ctrlsService.getParams();
        this.addManagedListener(this.centerRowsCtrl.getViewportElement(), "scroll", this.onHScroll.bind(this)), e.onScrollCallback(this.onFakeHScroll.bind(this));
        const i = this.gos.get("debounceVerticalScrollbar"),
          r = i ? re(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this),
          s = i ? re(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
        this.addManagedListener(this.eBodyViewport, "scroll", r), t.onScrollCallback(s)
      }
      onDisplayedColumnsWidthChanged() {
        this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter()
      }
      horizontallyScrollHeaderCenterAndFloatingCenter(e) {
        if (null == this.centerRowsCtrl) return;
        void 0 === e && (e = this.centerRowsCtrl.getCenterViewportScrollLeft());
        const t = this.enableRtl ? e : -e,
          {
            topCenter: i,
            stickyTopCenter: r,
            stickyBottomCenter: s,
            centerHeader: n,
            bottomCenter: o,
            fakeHScrollComp: a
          } = this.ctrlsService.getParams();
        n.setHorizontalScroll(-t), o.setContainerTranslateX(t), i.setContainerTranslateX(t), r.setContainerTranslateX(t), s.setContainerTranslateX(t);
        const l = this.centerRowsCtrl.getViewportElement(),
          c = 0 === this.lastScrollSource[1];
        e = Math.abs(e), c ? a.setScrollPosition(e) : vr(l, e, this.enableRtl)
      }
      isControllingScroll(e, t) {
        return null == this.lastScrollSource[t] ? (this.lastScrollSource[t] = e, !0) : this.lastScrollSource[t] === e
      }
      onFakeHScroll() {
        this.isControllingScroll(1, 1) && this.onHScrollCommon(1)
      }
      onHScroll() {
        this.isControllingScroll(0, 1) && this.onHScrollCommon(0)
      }
      onHScrollCommon(e) {
        const t = this.centerRowsCtrl.getViewportElement(),
          {
            scrollLeft: i
          } = t;
        if (this.shouldBlockScrollUpdate(1, i, !0)) return;
        let r;
        r = 0 === e ? Ar(t, this.enableRtl) : this.ctrlsService.get("fakeHScrollComp").getScrollPosition(), this.doHorizontalScroll(Math.round(r)), this.resetLastHScrollDebounced()
      }
      onFakeVScroll() {
        this.isControllingScroll(1, 0) && this.onVScrollCommon(1)
      }
      onVScroll() {
        this.isControllingScroll(0, 0) && this.onVScrollCommon(0)
      }
      onVScrollCommon(e) {
        let t;
        t = 0 === e ? this.eBodyViewport.scrollTop : this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), this.shouldBlockScrollUpdate(0, t, !0) || (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, 0 === e ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced())
      }
      doHorizontalScroll(e) {
        const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
        this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(1), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0))
      }
      fireScrollEvent(e) {
        const t = {
          type: Et.EVENT_BODY_SCROLL,
          direction: 1 === e ? "horizontal" : "vertical",
          left: this.scrollLeft,
          top: this.scrollTop
        };
        this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
          const e = T(f({}, t), {
            type: Et.EVENT_BODY_SCROLL_END
          });
          this.eventService.dispatchEvent(e)
        }, 100)
      }
      shouldBlockScrollUpdate(e, t, i = !1) {
        return !(i && !Gi()) && (0 === e ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t))
      }
      shouldBlockVerticalScroll(e) {
        const t = fr(this.eBodyViewport),
          {
            scrollHeight: i
          } = this.eBodyViewport;
        return e < 0 || e + t > i
      }
      shouldBlockHorizontalScroll(e) {
        const t = this.centerRowsCtrl.getCenterWidth(),
          {
            scrollWidth: i
          } = this.centerRowsCtrl.getViewportElement();
        if (this.enableRtl && Rr()) {
          if (e > 0) return !0
        } else if (e < 0) return !0;
        return Math.abs(e) + t > i
      }
      redrawRowsAfterScroll() {
        this.fireScrollEvent(0)
      }
      checkScrollLeft() {
        this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScrollCommon(0)
      }
      scrollGridIfNeeded() {
        const e = this.scrollTop != this.nextScrollTop;
        return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e
      }
      setHorizontalScrollPosition(e, t = !1) {
        const i = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
        !t && this.shouldBlockScrollUpdate(1, e) && (e = this.enableRtl && Rr() ? e > 0 ? 0 : i : Math.min(Math.max(e, 0), i)), vr(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e)
      }
      setVerticalScrollPosition(e) {
        this.eBodyViewport.scrollTop = e
      }
      getVScrollPosition() {
        this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight;
        return {
          top: this.lastScrollTop,
          bottom: this.lastScrollTop + this.lastOffsetHeight
        }
      }
      getApproximateVScollPosition() {
        return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
          top: this.scrollTop,
          bottom: this.scrollTop + this.lastOffsetHeight
        } : this.getVScrollPosition()
      }
      getHScrollPosition() {
        return this.centerRowsCtrl.getHScrollPosition()
      }
      isHorizontalScrollShowing() {
        return this.centerRowsCtrl.isHorizontalScrollShowing()
      }
      scrollHorizontally(e) {
        const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
        return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t
      }
      scrollToTop() {
        this.eBodyViewport.scrollTop = 0
      }
      ensureNodeVisible(e, t = null) {
        const i = this.rowModel.getRowCount();
        let r = -1;
        for (let t = 0; t < i; t++) {
          const i = this.rowModel.getRow(t);
          if ("function" == typeof e) {
            if (i && e(i)) {
              r = t;
              break
            }
          } else if (e === i || e === i.data) {
            r = t;
            break
          }
        }
        r >= 0 && this.ensureIndexVisible(r, t)
      }
      ensureIndexVisible(e, t) {
        if (this.gos.isDomLayout("print")) return;
        const i = this.paginationProxy.getRowCount();
        if ("number" != typeof e || e < 0 || e >= i) return void console.warn("AG Grid: Invalid row index for ensureIndexVisible: " + e);
        const r = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
        this.getFrameworkOverrides().wrapIncoming(() => {
          r || this.paginationProxy.goToPageWithIndex(e);
          const i = this.ctrlsService.getGridBodyCtrl(),
            s = i.getStickyTopHeight(),
            n = i.getStickyBottomHeight(),
            o = this.paginationProxy.getRow(e);
          let a;
          do {
            const e = o.rowTop,
              i = o.rowHeight,
              r = this.paginationProxy.getPixelOffset(),
              l = o.rowTop - r,
              c = l + o.rowHeight,
              h = this.getVScrollPosition(),
              u = this.heightScaler.getDivStretchOffset(),
              d = h.top + u,
              p = h.bottom + u,
              E = p - d,
              g = this.heightScaler.getScrollPositionForPixel(l),
              f = this.heightScaler.getScrollPositionForPixel(c - E),
              T = Math.min((g + f) / 2, l);
            let m = null;
            "top" === t ? m = g : "bottom" === t ? m = f : "middle" === t ? m = T : d + s > l ? m = g - s : p - n < c && (m = f + n), null !== m && (this.setVerticalScrollPosition(m), this.rowRenderer.redraw({
              afterScroll: !0
            })), a = e !== o.rowTop || i !== o.rowHeight
          } while (a);
          this.animationFrameService.flushAllFrames()
        })
      }
      ensureColumnVisible(e, t = "auto") {
        const i = this.columnModel.getGridColumn(e);
        if (!i) return;
        if (i.isPinned()) return;
        if (!this.columnModel.isColumnDisplayed(i)) return;
        const r = this.getPositionedHorizontalScroll(i, t);
        this.getFrameworkOverrides().wrapIncoming(() => {
          null !== r && this.centerRowsCtrl.setCenterViewportScrollLeft(r), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames()
        })
      }
      setScrollPosition(e, t) {
        this.getFrameworkOverrides().wrapIncoming(() => {
          this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({
            afterScroll: !0
          }), this.animationFrameService.flushAllFrames()
        })
      }
      getPositionedHorizontalScroll(e, t) {
        const {
          columnBeforeStart: i,
          columnAfterEnd: r
        } = this.isColumnOutsideViewport(e), s = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), n = this.centerRowsCtrl.getCenterWidth(), o = this.enableRtl;
        let a = (o ? i : r) || s,
          l = o ? r : i;
        "auto" !== t && (a = "start" === t, l = "end" === t);
        const c = "middle" === t;
        if (a || l || c) {
          const {
            colLeft: t,
            colMiddle: i,
            colRight: r
          } = this.getColumnBounds(e);
          return c ? i - n / 2 : a ? o ? r : t : o ? t - n : r - n
        }
        return null
      }
      isColumnOutsideViewport(e) {
        const {
          start: t,
          end: i
        } = this.getViewportBounds(), {
          colLeft: r,
          colRight: s
        } = this.getColumnBounds(e), n = this.enableRtl;
        return {
          columnBeforeStart: n ? t > s : i < s,
          columnAfterEnd: n ? i < r : t > r
        }
      }
      getColumnBounds(e) {
        const t = this.enableRtl,
          i = this.columnModel.getBodyContainerWidth(),
          r = e.getActualWidth(),
          s = e.getLeft(),
          n = t ? -1 : 1,
          o = t ? i - s : s;
        return {
          colLeft: o,
          colMiddle: o + r / 2 * n,
          colRight: o + r * n
        }
      }
      getViewportBounds() {
        const e = this.centerRowsCtrl.getCenterWidth(),
          t = this.centerRowsCtrl.getCenterViewportScrollLeft();
        return {
          start: t,
          end: e + t,
          width: e
        }
      }
    };
    C([fe("ctrlsService")], ta.prototype, "ctrlsService", 2), C([fe("animationFrameService")], ta.prototype, "animationFrameService", 2), C([fe("paginationProxy")], ta.prototype, "paginationProxy", 2), C([fe("rowModel")], ta.prototype, "rowModel", 2), C([fe("rowContainerHeightService")], ta.prototype, "heightScaler", 2), C([fe("rowRenderer")], ta.prototype, "rowRenderer", 2), C([fe("columnModel")], ta.prototype, "columnModel", 2), C([pe], ta.prototype, "postConstruct", 1);
    var ia = "ag-force-vertical-scroll",
      ra = class extends ct {
        constructor() {
          super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0
        }
        getScrollFeature() {
          return this.bodyScrollFeature
        }
        getBodyViewportElement() {
          return this.eBodyViewport
        }
        setComp(e, t, i, r, s, n, o) {
          this.comp = e, this.eGridBody = t, this.eBodyViewport = i, this.eTop = r, this.eBottom = s, this.eStickyTop = n, this.eStickyBottom = o, this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener("enableCellTextSelection", e => this.setCellTextSelection(e.currentValue)), this.createManagedBean(new ea(this.comp)), this.bodyScrollFeature = this.createManagedBean(new ta(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([r, i, s, n, o]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.filterManager.setupAdvancedFilterHeaderComp(r), this.ctrlsService.register("gridBodyCtrl", this)
        }
        getComp() {
          return this.comp
        }
        addEventListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this))
        }
        addFocusListeners(e) {
          e.forEach(e => {
            this.addManagedListener(e, "focusin", t => {
              const {
                target: i
              } = t, r = Er(i, "ag-root", e);
              e.classList.toggle("ag-has-focus", !r)
            }), this.addManagedListener(e, "focusout", t => {
              const {
                target: i,
                relatedTarget: r
              } = t, s = e.contains(r), n = Er(r, "ag-root", e);
              Er(i, "ag-root", e) || s && !n || e.classList.remove("ag-has-focus")
            })
          })
        }
        setColumnMovingCss(e) {
          this.comp.setColumnMovingCss("ag-column-moving", e)
        }
        setCellTextSelection(e = !1) {
          this.comp.setCellSelectableCss("ag-selectable", e)
        }
        onScrollVisibilityChanged() {
          const e = this.scrollVisibleService.isVerticalScrollShowing();
          this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
          const t = `calc(100% + ${(e&&this.gos.getScrollbarWidth()||0)+(Ki()?16:0)}px)`;
          this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(t))
        }
        onGridColumnsChanged() {
          const e = this.columnModel.getAllGridColumns();
          this.comp.setColumnCount(e.length)
        }
        disableBrowserDragging() {
          this.addManagedListener(this.eGridBody, "dragstart", e => {
            if (e.target instanceof HTMLImageElement) return e.preventDefault(), !1
          })
        }
        addStopEditingWhenGridLosesFocus() {
          if (!this.gos.get("stopEditingWhenCellsLoseFocus")) return;
          const e = e => {
              const i = e.relatedTarget;
              if (null === Hi(i)) return void this.rowRenderer.stopEditing();
              let r = t.some(e => e.contains(i)) && this.mouseEventService.isElementInThisGrid(i);
              if (!r) {
                const e = this.popupService;
                r = e.getActivePopups().some(e => e.contains(i)) || e.isElementWithinCustomPopup(i)
              }
              r || this.rowRenderer.stopEditing()
            },
            t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
          t.forEach(t => this.addManagedListener(t, "focusout", e))
        }
        updateRowCount() {
          const e = this.headerNavigationService.getHeaderRowCount() + this.filterManager.getHeaderRowCount(),
            t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1,
            i = -1 === t ? -1 : e + t;
          this.comp.setRowCount(i)
        }
        registerBodyViewportResizeListener(e) {
          this.comp.registerBodyViewportResizeListener(e)
        }
        setVerticalScrollPaddingVisible(e) {
          const t = e ? "scroll" : "hidden";
          this.comp.setPinnedTopBottomOverflowY(t)
        }
        isVerticalScrollShowing() {
          const e = this.gos.get("alwaysShowVerticalScroll"),
            t = e ? ia : null,
            i = this.gos.isDomLayout("normal");
          return this.comp.setAlwaysVerticalScrollClass(t, e), e || i && Mr(this.eBodyViewport)
        }
        setupRowAnimationCssClass() {
          const e = () => {
            const e = this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching(),
              t = e ? "ag-row-animation" : "ag-row-no-animation";
            this.comp.setRowAnimationCssOnBodyViewport(t, e)
          };
          e(), this.addManagedListener(this.eventService, Et.EVENT_HEIGHT_SCALE_CHANGED, e), this.addManagedPropertyListener("animateRows", e)
        }
        getGridBodyElement() {
          return this.eGridBody
        }
        addBodyViewportListener() {
          const e = this.onBodyViewportContextMenu.bind(this);
          this.addManagedListener(this.eBodyViewport, "contextmenu", e), this.mockContextMenuForIPad(e), this.addManagedListener(this.eBodyViewport, "wheel", this.onBodyViewportWheel.bind(this)), this.addManagedListener(this.eStickyTop, "wheel", this.onStickyWheel.bind(this)), this.addManagedListener(this.eStickyBottom, "wheel", this.onStickyWheel.bind(this)), this.addFullWidthContainerWheelListener()
        }
        addFullWidthContainerWheelListener() {
          const e = this.eBodyViewport.querySelector(".ag-full-width-container"),
            t = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
          e && t && this.addManagedListener(e, "wheel", e => this.onFullWidthContainerWheel(e, t))
        }
        onFullWidthContainerWheel(e, t) {
          !e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e) || (e.preventDefault(), t.scrollBy({
            left: e.deltaX
          }))
        }
        onBodyViewportContextMenu(e, t, i) {
          if (!e && !i) return;
          if (this.gos.get("preventDefaultOnContextMenu")) {
            (e || i).preventDefault()
          }
          const {
            target: r
          } = e || t;
          r !== this.eBodyViewport && r !== this.ctrlsService.get("center").getViewportElement() || this.menuService.showContextMenu({
            mouseEvent: e,
            touchEvent: i,
            value: null,
            anchorToElement: this.eGridBody
          })
        }
        mockContextMenuForIPad(e) {
          if (!Gi()) return;
          const t = new In(this.eBodyViewport);
          this.addManagedListener(t, In.EVENT_LONG_TAP, t => {
            e(void 0, t.touchStart, t.touchEvent)
          }), this.addDestroyFunc(() => t.destroy())
        }
        onBodyViewportWheel(e) {
          this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault()
        }
        onStickyWheel(e) {
          e.preventDefault(), e.offsetY && this.scrollVertically(e.deltaY)
        }
        getGui() {
          return this.eGridBody
        }
        scrollVertically(e) {
          const t = this.eBodyViewport.scrollTop;
          return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t
        }
        addRowDragListener() {
          this.rowDragFeature = this.createManagedBean(new Vo(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature)
        }
        getRowDragFeature() {
          return this.rowDragFeature
        }
        onPinnedRowDataChanged() {
          this.setFloatingHeights()
        }
        setFloatingHeights() {
          const {
            pinnedRowModel: e
          } = this;
          let t = e.getPinnedTopTotalHeight(),
            i = e.getPinnedBottomTotalHeight();
          this.comp.setTopHeight(t), this.comp.setBottomHeight(i), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(i ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom()
        }
        setStickyTopHeight(e = 0) {
          this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e
        }
        getStickyTopHeight() {
          return this.stickyTopHeight
        }
        setStickyBottomHeight(e = 0) {
          this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e
        }
        getStickyBottomHeight() {
          return this.stickyBottomHeight
        }
        setStickyWidth(e) {
          if (e) {
            const e = this.gos.getScrollbarWidth();
            this.comp.setStickyTopWidth(`calc(100% - ${e}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${e}px)`)
          } else this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%")
        }
        onHeaderHeightChanged() {
          this.setStickyTopOffsetTop()
        }
        setStickyTopOffsetTop() {
          const e = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + this.filterManager.getHeaderHeight(),
            t = this.pinnedRowModel.getPinnedTopTotalHeight();
          let i = 0;
          e > 0 && (i += e), t > 0 && (i += t), i > 0 && (i += 1), this.comp.setStickyTopTop(`${i}px`)
        }
        setStickyBottomOffsetBottom() {
          const e = this.pinnedRowModel.getPinnedBottomTotalHeight() + (this.scrollVisibleService.isHorizontalScrollShowing() && this.gos.getScrollbarWidth() || 0);
          this.comp.setStickyBottomBottom(`${e}px`)
        }
        sizeColumnsToFit(e, t) {
          const i = this.isVerticalScrollShowing() ? this.gos.getScrollbarWidth() : 0,
            r = Tr(this.eGridBody) - i;
          r > 0 ? this.columnModel.sizeColumnsToFit(r, "sizeColumnsToFit", !1, e) : void 0 === t ? window.setTimeout(() => {
            this.sizeColumnsToFit(e, 100)
          }, 0) : 100 === t ? window.setTimeout(() => {
            this.sizeColumnsToFit(e, 500)
          }, 100) : 500 === t ? window.setTimeout(() => {
            this.sizeColumnsToFit(e, -1)
          }, 500) : console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?")
        }
        addScrollEventListener(e) {
          this.eBodyViewport.addEventListener("scroll", e, {
            passive: !0
          })
        }
        removeScrollEventListener(e) {
          this.eBodyViewport.removeEventListener("scroll", e)
        }
      };
    C([fe("animationFrameService")], ra.prototype, "animationFrameService", 2), C([fe("rowContainerHeightService")], ra.prototype, "rowContainerHeightService", 2), C([fe("ctrlsService")], ra.prototype, "ctrlsService", 2), C([fe("columnModel")], ra.prototype, "columnModel", 2), C([fe("scrollVisibleService")], ra.prototype, "scrollVisibleService", 2), C([fe("menuService")], ra.prototype, "menuService", 2), C([fe("headerNavigationService")], ra.prototype, "headerNavigationService", 2), C([fe("dragAndDropService")], ra.prototype, "dragAndDropService", 2), C([fe("pinnedRowModel")], ra.prototype, "pinnedRowModel", 2), C([fe("rowRenderer")], ra.prototype, "rowRenderer", 2), C([fe("popupService")], ra.prototype, "popupService", 2), C([fe("mouseEventService")], ra.prototype, "mouseEventService", 2), C([fe("rowModel")], ra.prototype, "rowModel", 2), C([fe("filterManager")], ra.prototype, "filterManager", 2);
    var sa = "ag-cell-range-selected",
      na = class {
        constructor(e, t) {
          this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t
        }
        setComp(e, t) {
          this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged()
        }
        onRangeSelectionChanged() {
          this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(sa, 0 !== this.rangeCount), this.cellComp.addOrRemoveCssClass(`${sa}-1`, 1 === this.rangeCount), this.cellComp.addOrRemoveCssClass(`${sa}-2`, 2 === this.rangeCount), this.cellComp.addOrRemoveCssClass(`${sa}-3`, 3 === this.rangeCount), this.cellComp.addOrRemoveCssClass(`${sa}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass("ag-cell-range-chart", this.hasChartRange), Ci(this.eGui, this.rangeCount > 0 || void 0), this.cellComp.addOrRemoveCssClass("ag-cell-range-single-cell", this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle())
        }
        updateRangeBorders() {
          const e = this.getRangeBorders(),
            t = this.isSingleCell(),
            i = !t && e.top,
            r = !t && e.right,
            s = !t && e.bottom,
            n = !t && e.left;
          this.cellComp.addOrRemoveCssClass("ag-cell-range-top", i), this.cellComp.addOrRemoveCssClass("ag-cell-range-right", r), this.cellComp.addOrRemoveCssClass("ag-cell-range-bottom", s), this.cellComp.addOrRemoveCssClass("ag-cell-range-left", n)
        }
        isSingleCell() {
          const {
            rangeService: e
          } = this.beans;
          return 1 === this.rangeCount && !!e && !e.isMoreThanOneCell()
        }
        getHasChartRange() {
          const {
            rangeService: e
          } = this.beans;
          if (!this.rangeCount || !e) return !1;
          const t = e.getCellRanges();
          return t.length > 0 && t.every(e => Xe([1, 0], e.type))
        }
        updateRangeBordersIfRangeCount() {
          this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle())
        }
        getRangeBorders() {
          const e = this.beans.gos.get("enableRtl");
          let t = !1,
            i = !1,
            r = !1,
            s = !1;
          const n = this.cellCtrl.getCellPosition().column,
            o = this.beans.columnModel;
          let a, l;
          e ? (a = o.getDisplayedColAfter(n), l = o.getDisplayedColBefore(n)) : (a = o.getDisplayedColBefore(n), l = o.getDisplayedColAfter(n));
          const c = this.rangeService.getCellRanges().filter(e => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), e));
          a || (s = !0), l || (i = !0);
          for (let e = 0; e < c.length && !(t && i && r && s); e++) {
            const n = c[e],
              o = this.rangeService.getRangeStartRow(n),
              h = this.rangeService.getRangeEndRow(n);
            !t && this.beans.rowPositionUtils.sameRow(o, this.cellCtrl.getCellPosition()) && (t = !0), !r && this.beans.rowPositionUtils.sameRow(h, this.cellCtrl.getCellPosition()) && (r = !0), !s && a && n.columns.indexOf(a) < 0 && (s = !0), !i && l && n.columns.indexOf(l) < 0 && (i = !0)
          }
          return {
            top: t,
            right: i,
            bottom: r,
            left: s
          }
        }
        refreshHandle() {
          if (this.beans.context.isDestroyed()) return;
          const e = this.shouldHaveSelectionHandle();
          this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass("ag-cell-range-handle", !!this.selectionHandle)
        }
        shouldHaveSelectionHandle() {
          const e = this.beans.gos,
            t = this.rangeService.getCellRanges(),
            i = t.length;
          if (this.rangeCount < 1 || i < 1) return !1;
          const r = Me(t),
            s = this.cellCtrl.getCellPosition(),
            n = e.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle(),
            o = e.get("enableRangeHandle");
          let a = 1 === i && !this.cellCtrl.isEditing() && (n || o);
          if (this.hasChartRange) {
            const e = 1 === t[0].type && this.rangeService.isCellInSpecificRange(s, t[0]);
            this.cellComp.addOrRemoveCssClass("ag-cell-range-chart-category", e), a = 0 === r.type
          }
          return a && null != r.endRow && this.rangeService.isContiguousRange(r) && this.rangeService.isBottomRightCell(r, s)
        }
        addSelectionHandle() {
          const e = this.beans.gos,
            t = Me(this.rangeService.getCellRanges()).type,
            i = e.get("enableFillHandle") && N(t) ? 0 : 1;
          this.selectionHandle && this.selectionHandle.getType() !== i && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(i)), this.selectionHandle.refresh(this.cellCtrl)
        }
        destroy() {
          this.beans.context.destroyBean(this.selectionHandle)
        }
      },
      oa = class extends ct {
        constructor(e, t) {
          super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode()
        }
        setupRowSpan() {
          this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListener(this.beans.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded())
        }
        setComp(e) {
          this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan()
        }
        onNewColumnsLoaded() {
          const e = this.column.getRowSpan(this.rowNode);
          this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0))
        }
        onDisplayColumnsChanged() {
          const e = this.getColSpanningList();
          Fe(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged())
        }
        setupColSpan() {
          null != this.column.getColDef().colSpan && (this.colsSpanning = this.getColSpanningList(), this.addManagedListener(this.beans.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)), this.addManagedListener(this.beans.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this)))
        }
        onWidthChanged() {
          if (!this.eGui) return;
          const e = this.getCellWidth();
          this.eGui.style.width = `${e}px`
        }
        getCellWidth() {
          return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth()
        }
        getColSpanningList() {
          const e = this.column.getColSpan(this.rowNode),
            t = [];
          if (1 === e) t.push(this.column);
          else {
            let i = this.column;
            const r = this.column.getPinned();
            for (let s = 0; i && s < e && (t.push(i), i = this.beans.columnModel.getDisplayedColAfter(i), i && !N(i)) && r === i.getPinned(); s++);
          }
          return t
        }
        onLeftChanged() {
          if (!this.eGui) return;
          const e = this.modifyLeftForPrintLayout(this.getCellLeft());
          this.eGui.style.left = e + "px"
        }
        getCellLeft() {
          let e;
          return e = this.beans.gos.get("enableRtl") && this.colsSpanning ? Me(this.colsSpanning) : this.column, e.getLeft()
        }
        modifyLeftForPrintLayout(e) {
          if (!this.cellCtrl.isPrintLayout() || "left" === this.column.getPinned()) return e;
          const t = this.beans.columnModel.getDisplayedColumnsLeftWidth();
          if ("right" === this.column.getPinned()) {
            return t + this.beans.columnModel.getBodyContainerWidth() + (e || 0)
          }
          return t + (e || 0)
        }
        applyRowSpan(e) {
          if (1 === this.rowSpan && !e) return;
          const t = this.beans.gos.getRowHeightAsNumber() * this.rowSpan;
          this.eGui.style.height = `${t}px`, this.eGui.style.zIndex = "1"
        }
        destroy() {
          super.destroy()
        }
      },
      aa = class extends ct {
        constructor(e, t) {
          super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode()
        }
        setComp(e) {
          this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef()
        }
        applyCellClassRules() {
          const e = this.column.getColDef(),
            {
              cellClassRules: t
            } = e,
            i = this.beans.gos.addGridCommonParams({
              value: this.cellCtrl.getValue(),
              data: this.rowNode.data,
              node: this.rowNode,
              colDef: e,
              column: this.column,
              rowIndex: this.rowNode.rowIndex
            });
          this.beans.stylingService.processClassRules(t === this.cellClassRules ? void 0 : this.cellClassRules, t, i, e => this.cellComp.addOrRemoveCssClass(e, !0), e => this.cellComp.addOrRemoveCssClass(e, !1)), this.cellClassRules = t
        }
        applyUserStyles() {
          const e = this.column.getColDef();
          if (!e.cellStyle) return;
          let t;
          if ("function" == typeof e.cellStyle) {
            const i = this.beans.gos.addGridCommonParams({
              column: this.column,
              value: this.cellCtrl.getValue(),
              colDef: e,
              data: this.rowNode.data,
              node: this.rowNode,
              rowIndex: this.rowNode.rowIndex
            });
            t = (0, e.cellStyle)(i)
          } else t = e.cellStyle;
          t && this.cellComp.setUserStyles(t)
        }
        applyClassesFromColDef() {
          const e = this.column.getColDef(),
            t = this.beans.gos.addGridCommonParams({
              value: this.cellCtrl.getValue(),
              data: this.rowNode.data,
              node: this.rowNode,
              column: this.column,
              colDef: e,
              rowIndex: this.rowNode.rowIndex
            });
          this.staticClasses.length && this.staticClasses.forEach(e => this.cellComp.addOrRemoveCssClass(e, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach(e => this.cellComp.addOrRemoveCssClass(e, !0))
        }
        destroy() {
          super.destroy()
        }
      },
      la = class {
        postConstruct() {
          this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.gos.isRowModelType("serverSide") && (this.serverSideRowModel = this.rowModel)
        }
      };
    C([fe("resizeObserverService")], la.prototype, "resizeObserverService", 2), C([fe("paginationProxy")], la.prototype, "paginationProxy", 2), C([fe("context")], la.prototype, "context", 2), C([fe("gridOptionsService")], la.prototype, "gos", 2), C([fe("environment")], la.prototype, "environment", 2), C([fe("rowRenderer")], la.prototype, "rowRenderer", 2), C([fe("valueService")], la.prototype, "valueService", 2), C([fe("eventService")], la.prototype, "eventService", 2), C([fe("columnModel")], la.prototype, "columnModel", 2), C([fe("headerNavigationService")], la.prototype, "headerNavigationService", 2), C([fe("navigationService")], la.prototype, "navigationService", 2), C([fe("columnAnimationService")], la.prototype, "columnAnimationService", 2), C([fe("focusService")], la.prototype, "focusService", 2), C([fe("popupService")], la.prototype, "popupService", 2), C([fe("stylingService")], la.prototype, "stylingService", 2), C([fe("columnHoverService")], la.prototype, "columnHoverService", 2), C([fe("userComponentFactory")], la.prototype, "userComponentFactory", 2), C([fe("userComponentRegistry")], la.prototype, "userComponentRegistry", 2), C([fe("animationFrameService")], la.prototype, "animationFrameService", 2), C([fe("dragService")], la.prototype, "dragService", 2), C([fe("dragAndDropService")], la.prototype, "dragAndDropService", 2), C([fe("sortController")], la.prototype, "sortController", 2), C([fe("filterManager")], la.prototype, "filterManager", 2), C([fe("rowContainerHeightService")], la.prototype, "rowContainerHeightService", 2), C([fe("frameworkOverrides")], la.prototype, "frameworkOverrides", 2), C([fe("cellPositionUtils")], la.prototype, "cellPositionUtils", 2), C([fe("rowPositionUtils")], la.prototype, "rowPositionUtils", 2), C([fe("selectionService")], la.prototype, "selectionService", 2), C([fe("rowCssClassCalculator")], la.prototype, "rowCssClassCalculator", 2), C([fe("rowModel")], la.prototype, "rowModel", 2), C([fe("ctrlsService")], la.prototype, "ctrlsService", 2), C([fe("ctrlsFactory")], la.prototype, "ctrlsFactory", 2), C([fe("agStackComponentsRegistry")], la.prototype, "agStackComponentsRegistry", 2), C([fe("valueCache")], la.prototype, "valueCache", 2), C([fe("rowNodeEventThrottle")], la.prototype, "rowNodeEventThrottle", 2), C([fe("localeService")], la.prototype, "localeService", 2), C([fe("syncService")], la.prototype, "syncService", 2), C([fe("ariaAnnouncementService")], la.prototype, "ariaAnnouncementService", 2), C([Te("rangeService")], la.prototype, "rangeService", 2), C([Te("selectionHandleFactory")], la.prototype, "selectionHandleFactory", 2), C([pe], la.prototype, "postConstruct", 1), la = C([ge("beans")], la);
    var ca = class extends la {
        constructor(e, t, i) {
          super(), this.cellCtrl = e, this.beans = t, this.column = i
        }
        onMouseEvent(e, t) {
          if (!tt(t)) switch (e) {
            case "click":
              this.onCellClicked(t);
              break;
            case "mousedown":
            case "touchstart":
              this.onMouseDown(t);
              break;
            case "dblclick":
              this.onCellDoubleClicked(t);
              break;
            case "mouseout":
              this.onMouseOut(t);
              break;
            case "mouseover":
              this.onMouseOver(t)
          }
        }
        onCellClicked(e) {
          if (this.isDoubleClickOnIPad()) return this.onCellDoubleClicked(e), void e.preventDefault();
          const {
            eventService: t,
            rangeService: i,
            gos: r
          } = this.beans, s = e.ctrlKey || e.metaKey;
          i && s && i.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && i.intersectLastRange(!0);
          const n = this.cellCtrl.createEvent(e, Et.EVENT_CELL_CLICKED);
          t.dispatchEvent(n);
          const o = this.column.getColDef();
          o.onCellClicked && window.setTimeout(() => {
            this.beans.frameworkOverrides.wrapOutgoing(() => {
              o.onCellClicked(n)
            })
          }, 0);
          !((r.get("singleClickEdit") || o.singleClickEdit) && !r.get("suppressClickEdit")) || e.shiftKey && 0 != (null == i ? void 0 : i.getCellRanges().length) || this.cellCtrl.startRowOrCellEdit()
        }
        isDoubleClickOnIPad() {
          if (!Gi() || it("dblclick")) return !1;
          const e = (new Date).getTime(),
            t = e - this.lastIPadMouseClickEvent < 200;
          return this.lastIPadMouseClickEvent = e, t
        }
        onCellDoubleClicked(e) {
          const t = this.column.getColDef(),
            i = this.cellCtrl.createEvent(e, Et.EVENT_CELL_DOUBLE_CLICKED);
          this.beans.eventService.dispatchEvent(i), "function" == typeof t.onCellDoubleClicked && window.setTimeout(() => {
            this.beans.frameworkOverrides.wrapOutgoing(() => {
              t.onCellDoubleClicked(i)
            })
          }, 0);
          !this.beans.gos.get("singleClickEdit") && !this.beans.gos.get("suppressClickEdit") && this.cellCtrl.startRowOrCellEdit(null, e)
        }
        onMouseDown(e) {
          const {
            ctrlKey: t,
            metaKey: i,
            shiftKey: r
          } = e, s = e.target, {
            cellCtrl: n,
            beans: o
          } = this, {
            eventService: a,
            rangeService: l,
            focusService: c
          } = o;
          if (this.isRightClickInExistingRange(e)) return;
          const h = l && 0 != l.getCellRanges().length;
          if (!r || !h) {
            const e = Pi() && !n.isEditing() && !hr(s);
            n.focusCell(e)
          }
          if (r && h && !c.isCellFocused(n.getCellPosition())) {
            e.preventDefault();
            const t = c.getFocusedCell();
            if (t) {
              const {
                column: e,
                rowIndex: i,
                rowPinned: r
              } = t, s = o.rowRenderer.getRowByPosition({
                rowIndex: i,
                rowPinned: r
              }), n = null == s ? void 0 : s.getCellCtrl(e);
              (null == n ? void 0 : n.isEditing()) && n.stopEditing(), c.setFocusedCell({
                column: e,
                rowIndex: i,
                rowPinned: r,
                forceBrowserFocus: !0,
                preventScrollOnBrowserFocus: !0
              })
            }
          }
          if (!this.containsWidget(s)) {
            if (l) {
              const e = this.cellCtrl.getCellPosition();
              if (r) l.extendLatestRangeToCell(e);
              else {
                const r = t || i;
                l.setRangeToCell(e, r)
              }
            }
            a.dispatchEvent(this.cellCtrl.createEvent(e, Et.EVENT_CELL_MOUSE_DOWN))
          }
        }
        isRightClickInExistingRange(e) {
          const {
            rangeService: t
          } = this.beans;
          if (t) {
            const i = t.isCellInAnyRange(this.cellCtrl.getCellPosition()),
              r = 2 === e.button || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
            if (i && r) return !0
          }
          return !1
        }
        containsWidget(e) {
          return Er(e, "ag-selection-checkbox", 3)
        }
        onMouseOut(e) {
          if (this.mouseStayingInsideCell(e)) return;
          const t = this.cellCtrl.createEvent(e, Et.EVENT_CELL_MOUSE_OUT);
          this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.clearMouseOver()
        }
        onMouseOver(e) {
          if (this.mouseStayingInsideCell(e)) return;
          const t = this.cellCtrl.createEvent(e, Et.EVENT_CELL_MOUSE_OVER);
          this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.setMouseOver([this.column])
        }
        mouseStayingInsideCell(e) {
          if (!e.target || !e.relatedTarget) return !1;
          const t = this.cellCtrl.getGui(),
            i = t.contains(e.target),
            r = t.contains(e.relatedTarget);
          return i && r
        }
        destroy() {}
      },
      ha = class extends ct {
        constructor(e, t, i, r, s) {
          super(), this.cellCtrl = e, this.beans = t, this.rowNode = r, this.rowCtrl = s
        }
        setComp(e) {
          this.eGui = e
        }
        onKeyDown(e) {
          const t = e.key;
          switch (t) {
            case ts.ENTER:
              this.onEnterKeyDown(e);
              break;
            case ts.F2:
              this.onF2KeyDown(e);
              break;
            case ts.ESCAPE:
              this.onEscapeKeyDown(e);
              break;
            case ts.TAB:
              this.onTabKeyDown(e);
              break;
            case ts.BACKSPACE:
            case ts.DELETE:
              this.onBackspaceOrDeleteKeyDown(t, e);
              break;
            case ts.DOWN:
            case ts.UP:
            case ts.RIGHT:
            case ts.LEFT:
              this.onNavigationKeyDown(e, t)
          }
        }
        onNavigationKeyDown(e, t) {
          this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault())
        }
        onShiftRangeSelect(e) {
          if (!this.beans.rangeService) return;
          const t = this.beans.rangeService.extendLatestRangeInDirection(e);
          t && this.beans.navigationService.ensureCellVisible(t)
        }
        onTabKeyDown(e) {
          this.beans.navigationService.onTabKeyDown(this.cellCtrl, e)
        }
        onBackspaceOrDeleteKeyDown(e, t) {
          var i;
          const {
            cellCtrl: r,
            beans: s,
            rowNode: n
          } = this, {
            gos: o,
            rangeService: a,
            eventService: l
          } = s;
          if (!r.isEditing()) {
            if (l.dispatchEvent({
                type: Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_START
              }), ds(e, o.get("enableCellEditingOnBackspace"))) {
              if (a && o.get("enableRangeSelection")) a.clearCellRangeCellValues({
                dispatchWrapperEvents: !0,
                wrapperEventSource: "deleteKey"
              });
              else if (r.isCellEditable()) {
                const e = r.getColumn(),
                  t = null != (i = this.beans.valueService.parseValue(e, n, "", n.getValueFromValueService(e))) ? i : null;
                n.setDataValue(e, t, "cellClear")
              }
            } else r.startRowOrCellEdit(e, t);
            l.dispatchEvent({
              type: Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_END
            })
          }
        }
        onEnterKeyDown(e) {
          if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing()) this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
          else if (this.beans.gos.get("enterNavigatesVertically")) {
            const t = e.shiftKey ? ts.UP : ts.DOWN;
            this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1)
          } else this.cellCtrl.startRowOrCellEdit(ts.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault()
        }
        onF2KeyDown(e) {
          this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(ts.F2, e)
        }
        onEscapeKeyDown(e) {
          this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0))
        }
        processCharacter(e) {
          if (e.target !== this.eGui || this.cellCtrl.isEditing()) return;
          const t = e.key;
          " " === t ? this.onSpaceKeyDown(e) : (this.cellCtrl.startRowOrCellEdit(t, e), e.preventDefault())
        }
        onSpaceKeyDown(e) {
          const {
            gos: t
          } = this.beans;
          if (!this.cellCtrl.isEditing() && t.isRowSelection()) {
            const i = this.rowNode.isSelected(),
              r = !i;
            if (r || !t.get("suppressRowDeselection")) {
              const t = this.beans.gos.get("groupSelectsFiltered"),
                s = this.rowNode.setSelectedParams({
                  newValue: r,
                  rangeSelect: e.shiftKey,
                  groupSelectsFiltered: t,
                  event: e,
                  source: "spaceKey"
                });
              void 0 === i && 0 === s && this.rowNode.setSelectedParams({
                newValue: !1,
                rangeSelect: e.shiftKey,
                groupSelectsFiltered: t,
                event: e,
                source: "spaceKey"
              })
            }
          }
          e.preventDefault()
        }
        destroy() {
          super.destroy()
        }
      },
      ua = class extends _s {
        constructor(e, t, i) {
          super('<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'), this.rowNode = e, this.column = t, this.eCell = i
        }
        postConstruct() {
          this.getGui().appendChild(Zr("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", e => {
            e.stopPropagation()
          }), this.addDragSource(), this.checkVisibility()
        }
        addDragSource() {
          this.addGuiEventListener("dragstart", this.onDragStart.bind(this))
        }
        onDragStart(e) {
          const t = this.column.getColDef().dndSourceOnRowDrag;
          e.dataTransfer.setDragImage(this.eCell, 0, 0);
          const i = () => {
            try {
              const t = JSON.stringify(this.rowNode.data);
              e.dataTransfer.setData("application/json", t), e.dataTransfer.setData("text/plain", t)
            } catch (e) {}
          };
          if (t) {
            t(this.gos.addGridCommonParams({
              rowNode: this.rowNode,
              dragEvent: e
            }))
          } else i()
        }
        checkVisibility() {
          const e = this.column.isDndSource(this.rowNode);
          this.setDisplayed(e)
        }
      };
    C([pe], ua.prototype, "postConstruct", 1);
    var da = class {
        static getHeaderClassesFromColDef(e, t, i, r) {
          return N(e) ? [] : this.getColumnClassesFromCollDef(e.headerClass, e, t, i, r)
        }
        static getToolPanelClassesFromColDef(e, t, i, r) {
          return N(e) ? [] : this.getColumnClassesFromCollDef(e.toolPanelClass, e, t, i, r)
        }
        static refreshFirstAndLastStyles(e, t, i) {
          e.addOrRemoveCssClass("ag-column-first", i.isColumnAtEdge(t, "first")), e.addOrRemoveCssClass("ag-column-last", i.isColumnAtEdge(t, "last"))
        }
        static getClassParams(e, t, i, r) {
          return t.addGridCommonParams({
            colDef: e,
            column: i,
            columnGroup: r
          })
        }
        static getColumnClassesFromCollDef(e, t, i, r, s) {
          if (N(e)) return [];
          let n;
          if ("function" == typeof e) {
            n = e(this.getClassParams(t, i, r, s))
          } else n = e;
          return "string" == typeof n ? [n] : Array.isArray(n) ? [...n] : []
        }
      },
      pa = 0,
      Ea = class e extends ct {
        constructor(e, t, i, r) {
          super(), this.cellRangeFeature = null, this.cellPositionFeature = null, this.cellCustomStyleFeature = null, this.tooltipFeature = null, this.cellMouseListenerFeature = null, this.cellKeyboardListenerFeature = null, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.column = e, this.rowNode = t, this.beans = i, this.rowCtrl = r, this.instanceId = e.getId() + "-" + pa++, this.colIdSanitised = Nt(this.column.getId()), i.gos.get("suppressCellFocus") || (this.tabIndex = -1), this.createCellPosition(), this.addFeatures(), this.updateAndFormatValue(!1)
        }
        shouldRestoreFocus() {
          return this.beans.focusService.shouldRestoreFocus(this.cellPosition)
        }
        addFeatures() {
          this.cellPositionFeature = new oa(this, this.beans), this.addDestroyFunc(() => {
            var e;
            null == (e = this.cellPositionFeature) || e.destroy(), this.cellPositionFeature = null
          }), this.cellCustomStyleFeature = new aa(this, this.beans), this.addDestroyFunc(() => {
            var e;
            null == (e = this.cellCustomStyleFeature) || e.destroy(), this.cellCustomStyleFeature = null
          }), this.cellMouseListenerFeature = new ca(this, this.beans, this.column), this.addDestroyFunc(() => {
            var e;
            null == (e = this.cellMouseListenerFeature) || e.destroy(), this.cellMouseListenerFeature = null
          }), this.cellKeyboardListenerFeature = new ha(this, this.beans, this.column, this.rowNode, this.rowCtrl), this.addDestroyFunc(() => {
            var e;
            null == (e = this.cellKeyboardListenerFeature) || e.destroy(), this.cellKeyboardListenerFeature = null
          }), this.column.isTooltipEnabled() && (this.enableTooltipFeature(), this.addDestroyFunc(() => {
            this.disableTooltipFeature()
          }));
          this.beans.rangeService && this.beans.gos.get("enableRangeSelection") && (this.cellRangeFeature = new na(this.beans, this), this.addDestroyFunc(() => {
            var e;
            null == (e = this.cellRangeFeature) || e.destroy(), this.cellRangeFeature = null
          }))
        }
        enableTooltipFeature(e, t) {
          const i = "whenTruncated" === this.beans.gos.get("tooltipShowMode");
          t || !i || this.isCellRenderer() || (t = () => {
            const e = this.getGui(),
              t = 0 === e.children.length ? e : e.querySelector(".ag-cell-value");
            return !t || t.scrollWidth > t.clientWidth
          });
          const r = {
            getColumn: () => this.column,
            getColDef: () => this.column.getColDef(),
            getRowIndex: () => this.cellPosition.rowIndex,
            getRowNode: () => this.rowNode,
            getGui: () => this.getGui(),
            getLocation: () => "cell",
            getTooltipValue: null != e ? () => e : () => {
              const e = this.column.getColDef(),
                t = this.rowNode.data;
              if (e.tooltipField && v(t)) return B(t, e.tooltipField, this.column.isTooltipFieldContainsDots());
              const i = e.tooltipValueGetter;
              return i ? i(this.beans.gos.addGridCommonParams({
                location: "cell",
                colDef: this.column.getColDef(),
                column: this.column,
                rowIndex: this.cellPosition.rowIndex,
                node: this.rowNode,
                data: this.rowNode.data,
                value: this.value,
                valueFormatted: this.valueFormatted
              })) : null
            },
            getValueFormatted: () => this.valueFormatted,
            shouldDisplayTooltip: t
          };
          this.tooltipFeature = new Is(r, this.beans)
        }
        disableTooltipFeature() {
          this.tooltipFeature && (this.tooltipFeature.destroy(), this.tooltipFeature = null)
        }
        setComp(e, t, i, r, s) {
          var n, o, a, l;
          this.cellComp = e, this.eGui = t, this.printLayout = r, this.addDomData(), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(i), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), null == (n = this.cellPositionFeature) || n.setComp(t), null == (o = this.cellCustomStyleFeature) || o.setComp(e), null == (a = this.tooltipFeature) || a.refreshToolTip(), null == (l = this.cellKeyboardListenerFeature) || l.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(e, t), s && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach(e => e()), this.onCellCompAttachedFuncs = [])
        }
        setupAutoHeight(e) {
          if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !e) return;
          const t = e.parentElement,
            i = this.beans.gos.getRowHeightForNode(this.rowNode).height,
            r = s => {
              if (this.editing) return;
              if (!this.isAlive()) return;
              const {
                paddingTop: n,
                paddingBottom: o,
                borderBottomWidth: a,
                borderTopWidth: l
              } = gr(t), c = n + o + a + l, h = e.offsetHeight + c;
              if (s < 5) {
                const t = this.beans.gos.getDocument();
                if (!t || !t.contains(e) || 0 == h) return void window.setTimeout(() => r(s + 1), 0)
              }
              const u = Math.max(h, i);
              this.rowNode.setRowAutoHeight(u, this.column)
            },
            s = () => r(0);
          s();
          const n = this.beans.resizeObserverService.observeResize(e, s);
          this.addDestroyFunc(() => {
            n(), this.rowNode.setRowAutoHeight(void 0, this.column)
          })
        }
        getCellAriaRole() {
          var e;
          return null != (e = this.column.getColDef().cellAriaRole) ? e : "gridcell"
        }
        getInstanceId() {
          return this.instanceId
        }
        getColumnIdSanitised() {
          return this.colIdSanitised
        }
        getTabIndex() {
          return this.tabIndex
        }
        isCellRenderer() {
          const e = this.column.getColDef();
          return null != e.cellRenderer || null != e.cellRendererSelector
        }
        getValueToDisplay() {
          var e;
          return null != (e = this.valueFormatted) ? e : this.value
        }
        showValue(e = !1) {
          var t;
          const i = this.getValueToDisplay();
          let r;
          if (this.rowNode.stub) {
            const e = this.createCellRendererParams();
            r = this.beans.userComponentFactory.getLoadingCellRendererDetails(this.column.getColDef(), e)
          } else if (this.isCellRenderer()) {
            const e = this.createCellRendererParams();
            r = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), e)
          }
          this.cellComp.setRenderDetails(r, i, e), null == (t = this.cellRangeFeature) || t.refreshHandle()
        }
        setupControlComps() {
          const e = this.column.getColDef();
          this.includeSelection = this.isIncludeControl(e.checkboxSelection), this.includeRowDrag = this.isIncludeControl(e.rowDrag), this.includeDndSource = this.isIncludeControl(e.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag)
        }
        isForceWrapper() {
          return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight()
        }
        isIncludeControl(e) {
          return !(null != this.rowNode.rowPinned) && ("function" == typeof e || !0 === e)
        }
        refreshShouldDestroy() {
          const e = this.column.getColDef(),
            t = this.includeSelection != this.isIncludeControl(e.checkboxSelection),
            i = this.includeRowDrag != this.isIncludeControl(e.rowDrag),
            r = this.includeDndSource != this.isIncludeControl(e.dndSource),
            s = this.isAutoHeight != this.column.isAutoHeight();
          return t || i || r || s
        }
        startEditing(e = null, t = !1, i = null) {
          if (!this.isCellEditable() || this.editing) return;
          if (!this.cellComp) return void this.onCellCompAttachedFuncs.push(() => {
            this.startEditing(e, t, i)
          });
          const r = this.createCellEditorParams(e, t),
            s = this.column.getColDef(),
            n = this.beans.userComponentFactory.getCellEditorDetails(s, r);
          this.editCompDetails = n;
          const o = null != (null == n ? void 0 : n.popupFromSelector) ? n.popupFromSelector : !!s.cellEditorPopup,
            a = null != (null == n ? void 0 : n.popupPositionFromSelector) ? n.popupPositionFromSelector : s.cellEditorPopupPosition;
          this.setEditing(!0), this.cellComp.setEditDetails(n, o, a, this.beans.gos.get("reactiveCustomComponents"));
          const l = this.createEvent(i, Et.EVENT_CELL_EDITING_STARTED);
          this.beans.eventService.dispatchEvent(l)
        }
        setEditing(e) {
          var t;
          this.editing !== e && (this.editing = e, null == (t = this.cellRangeFeature) || t.refreshHandle())
        }
        stopRowOrCellEdit(e = !1) {
          "fullRow" === this.beans.gos.get("editType") ? this.rowCtrl.stopEditing(e) : this.stopEditing(e)
        }
        onPopupEditorClosed() {
          this.isEditing() && this.stopEditingAndFocus()
        }
        takeValueFromCellEditor(e) {
          const t = {
            newValueExists: !1
          };
          if (e) return t;
          const i = this.cellComp.getCellEditor();
          if (!i) return t;
          if (i.isCancelAfterEnd && i.isCancelAfterEnd()) return t;
          return {
            newValue: i.getValue(),
            newValueExists: !0
          }
        }
        saveNewValue(e, t) {
          if (t === e) return !1;
          this.suppressRefreshCell = !0;
          const i = this.rowNode.setDataValue(this.column, t, "edit");
          return this.suppressRefreshCell = !1, i
        }
        stopEditing(e = !1) {
          if (!this.editing) return !1;
          const {
            newValue: t,
            newValueExists: i
          } = this.takeValueFromCellEditor(e), r = this.rowNode.getValueFromValueService(this.column);
          let s = !1;
          return i && (s = this.saveNewValue(r, t)), this.setEditing(!1), this.cellComp.setEditDetails(), this.editCompDetails = void 0, this.updateAndFormatValue(!1), this.refreshCell({
            forceRefresh: !0,
            suppressFlash: !0
          }), this.dispatchEditingStoppedEvent(r, t, !e && !!s), s
        }
        dispatchEditingStoppedEvent(e, t, i) {
          const r = T(f({}, this.createEvent(null, Et.EVENT_CELL_EDITING_STOPPED)), {
            oldValue: e,
            newValue: t,
            valueChanged: i
          });
          this.beans.eventService.dispatchEvent(r)
        }
        createCellEditorParams(e, t) {
          return this.beans.gos.addGridCommonParams({
            value: this.rowNode.getValueFromValueService(this.column),
            eventKey: e,
            column: this.column,
            colDef: this.column.getColDef(),
            rowIndex: this.getCellPosition().rowIndex,
            node: this.rowNode,
            data: this.rowNode.data,
            cellStartedEdit: t,
            onKeyDown: this.onKeyDown.bind(this),
            stopEditing: this.stopEditingAndFocus.bind(this),
            eGridCell: this.getGui(),
            parseValue: this.parseValue.bind(this),
            formatValue: this.formatValue.bind(this)
          })
        }
        createCellRendererParams() {
          return this.beans.gos.addGridCommonParams({
            value: this.value,
            valueFormatted: this.valueFormatted,
            getValue: () => this.rowNode.getValueFromValueService(this.column),
            setValue: e => this.beans.valueService.setValue(this.rowNode, this.column, e),
            formatValue: this.formatValue.bind(this),
            data: this.rowNode.data,
            node: this.rowNode,
            pinned: this.column.getPinned(),
            colDef: this.column.getColDef(),
            column: this.column,
            rowIndex: this.getCellPosition().rowIndex,
            refreshCell: this.refreshCell.bind(this),
            eGridCell: this.getGui(),
            eParentOfValue: this.cellComp.getParentOfValue(),
            registerRowDragger: (e, t, i, r) => this.registerRowDragger(e, t, r),
            setTooltip: (e, t) => {
              var i;
              this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(e, t), null == (i = this.tooltipFeature) || i.refreshToolTip()
            }
          })
        }
        parseValue(e) {
          return this.beans.valueService.parseValue(this.column, this.rowNode, e, this.getValue())
        }
        setFocusOutOnEditor() {
          if (!this.editing) return;
          const e = this.cellComp.getCellEditor();
          e && e.focusOut && e.focusOut()
        }
        setFocusInOnEditor() {
          if (!this.editing) return;
          const e = this.cellComp.getCellEditor();
          e && e.focusIn ? e.focusIn() : this.focusCell(!0)
        }
        onCellChanged(e) {
          e.column === this.column && this.refreshCell({})
        }
        refreshOrDestroyCell(e) {
          var t;
          this.refreshShouldDestroy() ? null == (t = this.rowCtrl) || t.recreateCell(this) : this.refreshCell(e)
        }
        refreshCell(e) {
          var t, i, r, s;
          if (this.suppressRefreshCell || this.editing) return;
          const n = this.column.getColDef(),
            o = null != e && !!e.newData,
            a = null != e && !!e.suppressFlash || !!n.suppressCellFlash,
            l = null == n.field && null == n.valueGetter && null == n.showRowGroup,
            c = e && e.forceRefresh || l || o,
            h = !!this.cellComp,
            u = this.updateAndFormatValue(h);
          if (h) {
            if (c || u) {
              this.showValue(o);
              const e = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();
              !a && !e && (this.beans.gos.get("enableCellChangeFlash") || n.enableCellChangeFlash) && this.flashCell(), null == (t = this.cellCustomStyleFeature) || t.applyUserStyles(), null == (i = this.cellCustomStyleFeature) || i.applyClassesFromColDef()
            }
            null == (r = this.tooltipFeature) || r.refreshToolTip(), null == (s = this.cellCustomStyleFeature) || s.applyCellClassRules()
          }
        }
        stopEditingAndFocus(e = !1, t = !1) {
          this.stopRowOrCellEdit(), this.focusCell(!0), e || this.navigateAfterEdit(t)
        }
        navigateAfterEdit(e) {
          if (this.beans.gos.get("enterNavigatesVerticallyAfterEdit")) {
            const t = e ? ts.UP : ts.DOWN;
            this.beans.navigationService.navigateToNextCell(null, t, this.getCellPosition(), !1)
          }
        }
        flashCell(e) {
          var t, i;
          const r = null != (t = null == e ? void 0 : e.flashDuration) ? t : null == e ? void 0 : e.flashDelay,
            s = null != (i = null == e ? void 0 : e.fadeDuration) ? i : null == e ? void 0 : e.fadeDelay;
          this.animateCell("data-changed", r, s)
        }
        animateCell(e, t, i) {
          if (!this.cellComp) return;
          const r = `ag-cell-${e}`,
            s = `ag-cell-${e}-animation`,
            {
              gos: n
            } = this.beans;
          t || (t = n.get("cellFlashDuration")), v(i) || (i = n.get("cellFadeDuration")), this.cellComp.addOrRemoveCssClass(r, !0), this.cellComp.addOrRemoveCssClass(s, !1), this.beans.frameworkOverrides.wrapIncoming(() => {
            window.setTimeout(() => {
              this.isAlive() && (this.cellComp.addOrRemoveCssClass(r, !1), this.cellComp.addOrRemoveCssClass(s, !0), this.eGui.style.transition = `background-color ${i}ms`, window.setTimeout(() => {
                this.isAlive() && (this.cellComp.addOrRemoveCssClass(s, !1), this.eGui.style.transition = "")
              }, i))
            }, t)
          })
        }
        onFlashCells(e) {
          if (!this.cellComp) return;
          const t = this.beans.cellPositionUtils.createId(this.getCellPosition());
          e.cells[t] && this.animateCell("highlight")
        }
        isCellEditable() {
          return this.column.isCellEditable(this.rowNode)
        }
        isSuppressFillHandle() {
          return this.column.isSuppressFillHandle()
        }
        formatValue(e) {
          var t;
          return null != (t = this.callValueFormatter(e)) ? t : e
        }
        callValueFormatter(e) {
          return this.beans.valueService.formatValue(this.column, this.rowNode, e)
        }
        updateAndFormatValue(e) {
          const t = this.value,
            i = this.valueFormatted;
          return this.value = this.rowNode.getValueFromValueService(this.column), this.valueFormatted = this.callValueFormatter(this.value), !e || (!this.valuesAreEqual(t, this.value) || this.valueFormatted != i)
        }
        valuesAreEqual(e, t) {
          const i = this.column.getColDef();
          return i.equals ? i.equals(e, t) : e === t
        }
        getComp() {
          return this.cellComp
        }
        getValue() {
          return this.value
        }
        addDomData() {
          const t = this.getGui();
          this.beans.gos.setDomData(t, e.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(() => this.beans.gos.setDomData(t, e.DOM_DATA_KEY_CELL_CTRL, null))
        }
        createEvent(e, t) {
          return this.beans.gos.addGridCommonParams({
            type: t,
            node: this.rowNode,
            data: this.rowNode.data,
            value: this.value,
            column: this.column,
            colDef: this.column.getColDef(),
            rowPinned: this.rowNode.rowPinned,
            event: e,
            rowIndex: this.rowNode.rowIndex
          })
        }
        processCharacter(e) {
          var t;
          null == (t = this.cellKeyboardListenerFeature) || t.processCharacter(e)
        }
        onKeyDown(e) {
          var t;
          null == (t = this.cellKeyboardListenerFeature) || t.onKeyDown(e)
        }
        onMouseEvent(e, t) {
          var i;
          null == (i = this.cellMouseListenerFeature) || i.onMouseEvent(e, t)
        }
        getGui() {
          return this.eGui
        }
        getColSpanningList() {
          return this.cellPositionFeature.getColSpanningList()
        }
        onLeftChanged() {
          var e;
          this.cellComp && (null == (e = this.cellPositionFeature) || e.onLeftChanged())
        }
        onDisplayedColumnsChanged() {
          this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles())
        }
        refreshFirstAndLastStyles() {
          const {
            cellComp: e,
            column: t,
            beans: i
          } = this;
          da.refreshFirstAndLastStyles(e, t, i.columnModel)
        }
        refreshAriaColIndex() {
          const e = this.beans.columnModel.getAriaColumnIndex(this.column);
          gi(this.getGui(), e)
        }
        isSuppressNavigable() {
          return this.column.isSuppressNavigable(this.rowNode)
        }
        onWidthChanged() {
          var e;
          return null == (e = this.cellPositionFeature) ? void 0 : e.onWidthChanged()
        }
        getColumn() {
          return this.column
        }
        getRowNode() {
          return this.rowNode
        }
        isPrintLayout() {
          return this.printLayout
        }
        getCellPosition() {
          return this.cellPosition
        }
        isEditing() {
          return this.editing
        }
        startRowOrCellEdit(e, t = null) {
          this.cellComp ? "fullRow" === this.beans.gos.get("editType") ? this.rowCtrl.startRowEditing(e, this) : this.startEditing(e, !0, t) : this.onCellCompAttachedFuncs.push(() => {
            this.startRowOrCellEdit(e, t)
          })
        }
        getRowCtrl() {
          return this.rowCtrl
        }
        getRowPosition() {
          return {
            rowIndex: this.cellPosition.rowIndex,
            rowPinned: this.cellPosition.rowPinned
          }
        }
        updateRangeBordersIfRangeCount() {
          this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount()
        }
        onRangeSelectionChanged() {
          this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged()
        }
        isRangeSelectionEnabled() {
          return null != this.cellRangeFeature
        }
        focusCell(e = !1) {
          this.beans.focusService.setFocusedCell({
            rowIndex: this.getCellPosition().rowIndex,
            column: this.column,
            rowPinned: this.rowNode.rowPinned,
            forceBrowserFocus: e
          })
        }
        onRowIndexChanged() {
          this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged()
        }
        onFirstRightPinnedChanged() {
          if (!this.cellComp) return;
          const e = this.column.isFirstRightPinned();
          this.cellComp.addOrRemoveCssClass("ag-cell-first-right-pinned", e)
        }
        onLastLeftPinnedChanged() {
          if (!this.cellComp) return;
          const e = this.column.isLastLeftPinned();
          this.cellComp.addOrRemoveCssClass("ag-cell-last-left-pinned", e)
        }
        onCellFocused(e) {
          if (this.beans.gos.get("suppressCellFocus")) return;
          const t = this.beans.focusService.isCellFocused(this.cellPosition);
          if (!this.cellComp) return void(t && (null == e ? void 0 : e.forceBrowserFocus) && (this.focusEventToRestore = e));
          if (this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass("ag-cell-focus", t), t && e && e.forceBrowserFocus) {
            this.cellComp.getFocusableElement().focus({
              preventScroll: !!e.preventScrollOnBrowserFocus
            })
          }
          const i = "fullRow" === this.beans.gos.get("editType");
          t || i || !this.editing || this.stopRowOrCellEdit(), t && this.rowCtrl.announceDescription()
        }
        createCellPosition() {
          this.cellPosition = {
            rowIndex: this.rowNode.rowIndex,
            rowPinned: A(this.rowNode.rowPinned),
            column: this.column
          }
        }
        applyStaticCssClasses() {
          this.cellComp.addOrRemoveCssClass("ag-cell", !0), this.cellComp.addOrRemoveCssClass("ag-cell-not-inline-editing", !0);
          const e = 1 == this.column.isAutoHeight();
          this.cellComp.addOrRemoveCssClass("ag-cell-auto-height", e), this.cellComp.addOrRemoveCssClass("ag-cell-normal-height", !e)
        }
        onColumnHover() {
          if (!this.cellComp) return;
          if (!this.beans.gos.get("columnHoverHighlight")) return;
          const e = this.beans.columnHoverService.isHovered(this.column);
          this.cellComp.addOrRemoveCssClass("ag-column-hover", e)
        }
        onColDefChanged() {
          if (!this.cellComp) return;
          if (this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing) {
            const e = this.getCellEditor();
            if (null == e ? void 0 : e.refresh) {
              const {
                eventKey: t,
                cellStartedEdit: i
              } = this.editCompDetails.params, r = this.createCellEditorParams(t, i), s = this.column.getColDef(), n = this.beans.userComponentFactory.getCellEditorDetails(s, r);
              e.refresh(n.params)
            }
          } else this.refreshOrDestroyCell({
            forceRefresh: !0,
            suppressFlash: !0
          })
        }
        setWrapText() {
          const e = 1 == this.column.getColDef().wrapText;
          this.cellComp.addOrRemoveCssClass("ag-cell-wrap-text", e)
        }
        dispatchCellContextMenuEvent(e) {
          const t = this.column.getColDef(),
            i = this.createEvent(e, Et.EVENT_CELL_CONTEXT_MENU);
          this.beans.eventService.dispatchEvent(i), t.onCellContextMenu && window.setTimeout(() => {
            this.beans.frameworkOverrides.wrapOutgoing(() => {
              t.onCellContextMenu(i)
            })
          }, 0)
        }
        getCellRenderer() {
          return this.cellComp ? this.cellComp.getCellRenderer() : null
        }
        getCellEditor() {
          return this.cellComp ? this.cellComp.getCellEditor() : null
        }
        destroy() {
          this.onCellCompAttachedFuncs = [], super.destroy()
        }
        createSelectionCheckbox() {
          const e = new Wn;
          return this.beans.context.createBean(e), e.init({
            rowNode: this.rowNode,
            column: this.column
          }), e
        }
        createDndSource() {
          const e = new ua(this.rowNode, this.column, this.eGui);
          return this.beans.context.createBean(e), e
        }
        registerRowDragger(e, t, i) {
          if (this.customRowDragComp) return void this.customRowDragComp.setDragElement(e, t);
          const r = this.createRowDragComp(e, t, i);
          r && (this.customRowDragComp = r, this.addDestroyFunc(() => {
            this.beans.context.destroyBean(r), this.customRowDragComp = null
          }))
        }
        createRowDragComp(e, t, i) {
          const r = this.beans.gos.get("pagination"),
            s = this.beans.gos.get("rowDragManaged"),
            n = this.beans.gos.isRowModelType("clientSide");
          if (s) {
            if (!n) return void z("managed row dragging is only allowed in the Client Side Row Model");
            if (r) return void z("managed row dragging is not possible when doing pagination")
          }
          const o = new Xn(() => this.value, this.rowNode, this.column, e, t, i);
          return this.beans.context.createBean(o), o
        }
      };
    Ea.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
    var ga = Ea,
      fa = 0,
      Ta = class e extends ct {
        constructor(e, t, i, r, s) {
          super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = {
            list: [],
            map: {}
          }, this.leftCellCtrls = {
            list: [],
            map: {}
          }, this.rightCellCtrls = {
            list: [],
            map: {}
          }, this.slideInAnimation = {
            left: !1,
            center: !1,
            right: !1,
            fullWidth: !1
          }, this.fadeInAnimation = {
            left: !1,
            center: !1,
            right: !1,
            fullWidth: !1
          }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKeySanitised = null, this.beans = t, this.gos = t.gos, this.rowNode = e, this.paginationPage = t.paginationProxy.getCurrentPage(), this.useAnimationFrameForCreate = r, this.printLayout = s, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = e.id + "-" + fa++, this.rowId = Nt(e.id), this.initRowBusinessKey(), this.rowFocused = t.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = t.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(i), this.rowStyles = this.processStylesFromGridOptions(), this.isFullWidth() && !this.gos.get("suppressCellFocus") && (this.tabIndex = -1), this.addListeners()
        }
        initRowBusinessKey() {
          this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey()
        }
        updateRowBusinessKey() {
          if ("function" != typeof this.businessKeyForNodeFunc) return;
          const e = this.businessKeyForNodeFunc(this.rowNode);
          this.businessKeySanitised = Nt(e)
        }
        getRowId() {
          return this.rowId
        }
        getRowStyles() {
          return this.rowStyles
        }
        getTabIndex() {
          return this.tabIndex
        }
        isSticky() {
          return this.rowNode.sticky
        }
        getInstanceId() {
          return this.instanceId
        }
        setComp(e, t, i) {
          const r = {
            rowComp: e,
            element: t,
            containerType: i
          };
          this.allRowGuis.push(r), "left" === i ? this.leftGui = r : "right" === i ? this.rightGui = r : "fullWidth" === i ? this.fullWidthGui = r : this.centerGui = r, this.initialiseRowComp(r), "FullWidthLoading" === this.rowType || this.rowNode.rowPinned || this.beans.rowRenderer.dispatchFirstDataRenderedEvent()
        }
        unsetComp(e) {
          switch (this.allRowGuis = this.allRowGuis.filter(t => t.containerType !== e), e) {
            case "left":
              this.leftGui = void 0;
              break;
            case "right":
              this.rightGui = void 0;
              break;
            case "fullWidth":
              this.fullWidthGui = void 0;
              break;
            case "center":
              this.centerGui = void 0
          }
        }
        isCacheable() {
          return "FullWidthDetail" === this.rowType && this.gos.get("keepDetailRows")
        }
        setCached(e) {
          const t = e ? "none" : "";
          this.allRowGuis.forEach(e => e.element.style.display = t)
        }
        initialiseRowComp(t) {
          const i = this.gos;
          this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(!1, t), i.isRowSelection() && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
          const r = t.rowComp;
          this.getInitialRowClasses(t.containerType).forEach(e => r.addOrRemoveCssClass(e, !0)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && ai(t.element, 1 == this.rowNode.expanded), this.setRowCompRowId(r), this.setRowCompRowBusinessKey(r), i.setDomData(t.element, e.DOM_DATA_KEY_ROW_CTRL, this), this.addDestroyFunc(() => i.setDomData(t.element, e.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(this.addHoverFunctionality.bind(this, t.element), this.rowNode.rowIndex, "createTasksP2") : this.addHoverFunctionality(t.element), this.isFullWidth() && this.setupFullWidth(t), i.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
            this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", !0)
          }), this.executeProcessRowPostCreateFunc()
        }
        setRowCompRowBusinessKey(e) {
          null != this.businessKeySanitised && e.setRowBusinessKey(this.businessKeySanitised)
        }
        getBusinessKey() {
          return this.businessKeySanitised
        }
        setRowCompRowId(e) {
          this.rowId = Nt(this.rowNode.id), null != this.rowId && e.setRowId(this.rowId)
        }
        executeSlideAndFadeAnimations(e) {
          const {
            containerType: t
          } = e;
          this.slideInAnimation[t] && (te(() => {
            this.onTopChanged()
          }), this.slideInAnimation[t] = !1);
          this.fadeInAnimation[t] && (te(() => {
            e.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1)
          }), this.fadeInAnimation[t] = !1)
        }
        addRowDraggerToRow(e) {
          if (this.gos.get("enableRangeSelection")) return void z("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
          const t = this.beans.localeService.getLocaleTextFunc(),
            i = new Xn(() => `1 ${t("rowDragRow","row")}`, this.rowNode, void 0, e.element, void 0, !0),
            r = this.createBean(i, this.beans.context);
          this.rowDragComps.push(r)
        }
        setupFullWidth(e) {
          const t = this.getPinnedForContainer(e.containerType);
          if ("FullWidthDetail" == this.rowType && !he.__assertRegistered("@ag-grid-enterprise/master-detail", "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId())) return;
          const i = this.createFullWidthCompDetails(e.element, t);
          e.rowComp.showFullWidth(i)
        }
        isPrintLayout() {
          return this.printLayout
        }
        getFullWidthCellRenderers() {
          var e, t;
          return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map(e => {
            var t;
            return null == (t = null == e ? void 0 : e.rowComp) ? void 0 : t.getFullWidthCellRenderer()
          }) : [null == (t = null == (e = this.fullWidthGui) ? void 0 : e.rowComp) ? void 0 : t.getFullWidthCellRenderer()]
        }
        getCellElement(e) {
          const t = this.getCellCtrl(e);
          return t ? t.getGui() : null
        }
        executeProcessRowPostCreateFunc() {
          const e = this.gos.getCallback("processRowPostCreate");
          if (!e || !this.areAllContainersReady()) return;
          e({
            eRow: this.centerGui.element,
            ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
            ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            addRenderedRowListener: this.addEventListener.bind(this)
          })
        }
        areAllContainersReady() {
          const e = !!this.leftGui || !this.beans.columnModel.isPinningLeft(),
            t = !!this.centerGui,
            i = !!this.rightGui || !this.beans.columnModel.isPinningRight();
          return e && t && i
        }
        setRowType() {
          const e = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow"),
            t = this.rowNode.isFullWidthCell(),
            i = this.gos.get("masterDetail") && this.rowNode.detail,
            r = this.beans.columnModel.isPivotMode(),
            s = !!this.rowNode.group && !this.rowNode.footer && this.gos.isGroupUseEntireRow(r);
          this.rowType = e ? "FullWidthLoading" : i ? "FullWidthDetail" : t ? "FullWidth" : s ? "FullWidthGroup" : "Normal"
        }
        updateColumnLists(e = !1, t = !1) {
          if (this.isFullWidth()) return;
          e || this.gos.get("suppressAnimationFrame") || this.printLayout ? this.updateColumnListsImpl(t) : this.updateColumnListsPending || (this.beans.animationFrameService.createTask(() => {
            this.active && this.updateColumnListsImpl(!0)
          }, this.rowNode.rowIndex, "createTasksP1"), this.updateColumnListsPending = !0)
        }
        createCellCtrls(e, t, i = null) {
          const r = {
              list: [],
              map: {}
            },
            s = (e, t) => {
              r.list.push(t), r.map[e] = t
            };
          return t.forEach(t => {
            const i = t.getInstanceId();
            let r = e.map[i];
            r || (r = new ga(t, this.rowNode, this.beans, this)), s(i, r)
          }), e.list.forEach(e => {
            if (null != r.map[e.getColumn().getInstanceId()]) return;
            this.isCellEligibleToBeRemoved(e, i) ? e.destroy() : s(e.getColumn().getInstanceId(), e)
          }), r
        }
        updateColumnListsImpl(e) {
          this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(e)
        }
        setCellCtrls(e) {
          this.allRowGuis.forEach(t => {
            const i = this.getCellCtrlsForContainer(t.containerType);
            t.rowComp.setCellCtrls(i, e)
          })
        }
        getCellCtrlsForContainer(e) {
          switch (e) {
            case "left":
              return this.leftCellCtrls.list;
            case "right":
              return this.rightCellCtrls.list;
            case "fullWidth":
              return [];
            case "center":
              return this.centerCellCtrls.list;
            default:
              throw new Error(`Unhandled case: ${e}`)
          }
        }
        createAllCellCtrls() {
          const e = this.beans.columnModel;
          if (this.printLayout) this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, e.getAllDisplayedColumns()), this.leftCellCtrls = {
            list: [],
            map: {}
          }, this.rightCellCtrls = {
            list: [],
            map: {}
          };
          else {
            const t = e.getViewportCenterColumnsForRow(this.rowNode);
            this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t);
            const i = e.getDisplayedLeftColumnsForRow(this.rowNode);
            this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
            const r = e.getDisplayedRightColumnsForRow(this.rowNode);
            this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, r, "right")
          }
        }
        isCellEligibleToBeRemoved(e, t) {
          const i = !0;
          if (e.getColumn().getPinned() != t) return i;
          const r = e.isEditing(),
            s = this.beans.focusService.isCellFocused(e.getCellPosition());
          if (r || s) {
            const t = e.getColumn();
            return !(this.beans.columnModel.getAllDisplayedColumns().indexOf(t) >= 0) && i
          }
          return i
        }
        getDomOrder() {
          return this.gos.get("ensureDomOrder") || this.gos.isDomLayout("print")
        }
        listenOnDomOrder(e) {
          const t = () => {
            e.rowComp.setDomOrder(this.getDomOrder())
          };
          this.addManagedPropertyListener("domLayout", t), this.addManagedPropertyListener("ensureDomOrder", t)
        }
        setAnimateFlags(e) {
          if (this.isSticky() || !e) return;
          const t = v(this.rowNode.oldRowTop),
            i = this.beans.columnModel.isPinningLeft(),
            r = this.beans.columnModel.isPinningRight();
          if (t) {
            if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) return void(this.slideInAnimation.fullWidth = !0);
            this.slideInAnimation.center = !0, this.slideInAnimation.left = i, this.slideInAnimation.right = r
          } else {
            if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) return void(this.fadeInAnimation.fullWidth = !0);
            this.fadeInAnimation.center = !0, this.fadeInAnimation.left = i, this.fadeInAnimation.right = r
          }
        }
        isEditing() {
          return this.editingRow
        }
        isFullWidth() {
          return "Normal" !== this.rowType
        }
        refreshFullWidth() {
          const e = (e, t) => !e || e.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(e.element, t).params),
            t = e(this.fullWidthGui, null),
            i = e(this.centerGui, null),
            r = e(this.leftGui, "left"),
            s = e(this.rightGui, "right");
          return t && i && r && s
        }
        addListeners() {
          this.addManagedListener(this.rowNode, Vn.EVENT_HEIGHT_CHANGED, () => this.onRowHeightChanged()), this.addManagedListener(this.rowNode, Vn.EVENT_ROW_SELECTED, () => this.onRowSelected()), this.addManagedListener(this.rowNode, Vn.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_TOP_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this)), this.rowNode.detail && this.addManagedListener(this.rowNode.parent, Vn.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, this.postProcessCss.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_DRAGGING_CHANGED, this.postProcessRowDragging.bind(this)), this.addManagedListener(this.rowNode, Vn.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
          const e = this.beans.eventService;
          this.addManagedListener(e, Et.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this)), this.addManagedListener(e, Et.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(e, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(e, Et.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(e, Et.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this)), this.addManagedListener(e, Et.EVENT_CELL_FOCUS_CLEARED, this.onCellFocusChanged.bind(this)), this.addManagedListener(e, Et.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), this.addManagedListener(e, Et.EVENT_MODEL_UPDATED, this.refreshFirstAndLastRowStyles.bind(this)), this.addManagedListener(e, Et.EVENT_COLUMN_MOVED, this.updateColumnLists.bind(this)), this.addDestroyFunc(() => {
            this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context))
          }), this.addManagedPropertyListeners(["rowDragEntireRow"], () => {
            this.gos.get("rowDragEntireRow") ? this.allRowGuis.forEach(e => {
              this.addRowDraggerToRow(e)
            }) : (this.destroyBeans(this.rowDragComps, this.beans.context), this.rowDragComps = [])
          }), this.addListenersForCellComps()
        }
        addListenersForCellComps() {
          this.addManagedListener(this.rowNode, Vn.EVENT_ROW_INDEX_CHANGED, () => {
            this.getAllCellCtrls().forEach(e => e.onRowIndexChanged())
          }), this.addManagedListener(this.rowNode, Vn.EVENT_CELL_CHANGED, e => {
            this.getAllCellCtrls().forEach(t => t.onCellChanged(e))
          })
        }
        onRowNodeDataChanged(e) {
          if (this.isFullWidth() !== !!this.rowNode.isFullWidthCell()) this.beans.rowRenderer.redrawRow(this.rowNode);
          else {
            if (this.isFullWidth()) {
              return void(this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode))
            }
            this.getAllCellCtrls().forEach(t => t.refreshCell({
              suppressFlash: !e.update,
              newData: !e.update
            })), this.allRowGuis.forEach(e => {
              this.setRowCompRowId(e.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(e.rowComp)
            }), this.onRowSelected(), this.postProcessCss()
          }
        }
        postProcessCss() {
          this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging()
        }
        onRowNodeHighlightChanged() {
          const e = this.rowNode.highlighted;
          this.allRowGuis.forEach(t => {
            const i = 0 === e,
              r = 1 === e;
            t.rowComp.addOrRemoveCssClass("ag-row-highlight-above", i), t.rowComp.addOrRemoveCssClass("ag-row-highlight-below", r)
          })
        }
        postProcessRowDragging() {
          const e = this.rowNode.dragging;
          this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass("ag-row-dragging", e))
        }
        updateExpandedCss() {
          const e = this.rowNode.isExpandable(),
            t = 1 == this.rowNode.expanded;
          this.allRowGuis.forEach(i => {
            i.rowComp.addOrRemoveCssClass("ag-row-group", e), i.rowComp.addOrRemoveCssClass("ag-row-group-expanded", e && t), i.rowComp.addOrRemoveCssClass("ag-row-group-contracted", e && !t), ai(i.element, e && t)
          })
        }
        onDisplayedColumnsChanged() {
          this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights()
        }
        onVirtualColumnsChanged() {
          this.updateColumnLists(!1, !0)
        }
        getRowPosition() {
          return {
            rowPinned: A(this.rowNode.rowPinned),
            rowIndex: this.rowNode.rowIndex
          }
        }
        onKeyboardNavigate(e) {
          const t = this.allRowGuis.find(t => t.element.contains(e.target));
          if (!((t ? t.element : null) === e.target)) return;
          const i = this.rowNode,
            r = this.beans.focusService.getFocusedCell(),
            s = {
              rowIndex: i.rowIndex,
              rowPinned: i.rowPinned,
              column: r && r.column
            };
          this.beans.navigationService.navigateToNextCell(e, e.key, s, !0), e.preventDefault()
        }
        onTabKeyDown(e) {
          if (e.defaultPrevented || tt(e)) return;
          const t = this.allRowGuis.find(t => t.element.contains(e.target)),
            i = t ? t.element : null,
            r = i === e.target;
          let s = null;
          r || (s = this.beans.focusService.findNextFocusableElement(i, !1, e.shiftKey)), (this.isFullWidth() && r || !s) && this.beans.navigationService.onTabKeyDown(this, e)
        }
        getFullWidthElement() {
          return this.fullWidthGui ? this.fullWidthGui.element : null
        }
        getRowYPosition() {
          var e;
          const t = null == (e = this.allRowGuis.find(e => Lr(e.element))) ? void 0 : e.element;
          return t ? t.getBoundingClientRect().top : 0
        }
        onFullWidthRowFocused(e) {
          var t;
          const i = this.rowNode,
            r = !!e && (this.isFullWidth() && e.rowIndex === i.rowIndex && e.rowPinned == i.rowPinned),
            s = this.fullWidthGui ? this.fullWidthGui.element : null == (t = this.centerGui) ? void 0 : t.element;
          s && (s.classList.toggle("ag-full-width-focus", r), r && s.focus({
            preventScroll: !0
          }))
        }
        recreateCell(e) {
          this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, e), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, e), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, e), e.destroy(), this.updateColumnLists()
        }
        removeCellCtrl(e, t) {
          const i = {
            list: [],
            map: {}
          };
          return e.list.forEach(e => {
            e !== t && (i.list.push(e), i.map[e.getColumn().getInstanceId()] = e)
          }), i
        }
        onMouseEvent(e, t) {
          switch (e) {
            case "dblclick":
              this.onRowDblClick(t);
              break;
            case "click":
              this.onRowClick(t);
              break;
            case "touchstart":
            case "mousedown":
              this.onRowMouseDown(t)
          }
        }
        createRowEvent(e, t) {
          return this.gos.addGridCommonParams({
            type: e,
            node: this.rowNode,
            data: this.rowNode.data,
            rowIndex: this.rowNode.rowIndex,
            rowPinned: this.rowNode.rowPinned,
            event: t
          })
        }
        createRowEventWithSource(e, t) {
          const i = this.createRowEvent(e, t);
          return i.source = this, i
        }
        onRowDblClick(e) {
          if (tt(e)) return;
          const t = this.createRowEventWithSource(Et.EVENT_ROW_DOUBLE_CLICKED, e);
          this.beans.eventService.dispatchEvent(t)
        }
        onRowMouseDown(e) {
          if (this.lastMouseDownOnDragger = Er(e.target, "ag-row-drag", 3), !this.isFullWidth()) return;
          const t = this.rowNode,
            i = this.beans.columnModel;
          this.beans.rangeService && this.beans.rangeService.removeAllCellRanges(), this.beans.focusService.setFocusedCell({
            rowIndex: t.rowIndex,
            column: i.getAllDisplayedColumns()[0],
            rowPinned: t.rowPinned,
            forceBrowserFocus: !0
          })
        }
        onRowClick(e) {
          if (tt(e) || this.lastMouseDownOnDragger) return;
          const t = this.createRowEventWithSource(Et.EVENT_ROW_CLICKED, e);
          this.beans.eventService.dispatchEvent(t);
          const i = e.ctrlKey || e.metaKey,
            r = e.shiftKey;
          if (this.gos.get("groupSelectsChildren") && this.rowNode.group || this.isRowSelectionBlocked() || this.gos.get("suppressRowClickSelection")) return;
          const s = this.gos.get("rowMultiSelectWithClick"),
            n = !this.gos.get("suppressRowDeselection"),
            o = "rowClicked";
          if (this.rowNode.isSelected()) s ? this.rowNode.setSelectedParams({
            newValue: !1,
            event: e,
            source: o
          }) : i ? n && this.rowNode.setSelectedParams({
            newValue: !1,
            event: e,
            source: o
          }) : this.rowNode.setSelectedParams({
            newValue: !0,
            clearSelection: !r,
            rangeSelect: r,
            event: e,
            source: o
          });
          else {
            const t = !s && !i;
            this.rowNode.setSelectedParams({
              newValue: !0,
              clearSelection: t,
              rangeSelect: r,
              event: e,
              source: o
            })
          }
        }
        isRowSelectionBlocked() {
          return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection()
        }
        setupDetailRowAutoHeight(e) {
          if ("FullWidthDetail" !== this.rowType) return;
          if (!this.gos.get("detailRowAutoHeight")) return;
          const t = () => {
              const t = e.clientHeight;
              if (null != t && t > 0) {
                const e = () => {
                  this.rowNode.setRowHeight(t), this.beans.clientSideRowModel ? this.beans.clientSideRowModel.onRowHeightChanged() : this.beans.serverSideRowModel && this.beans.serverSideRowModel.onRowHeightChanged()
                };
                window.setTimeout(e, 0)
              }
            },
            i = this.beans.resizeObserverService.observeResize(e, t);
          this.addDestroyFunc(i), t()
        }
        createFullWidthCompDetails(e, t) {
          const i = this.gos.addGridCommonParams({
            fullWidth: !0,
            data: this.rowNode.data,
            node: this.rowNode,
            value: this.rowNode.key,
            valueFormatted: this.rowNode.key,
            rowIndex: this.rowNode.rowIndex,
            eGridCell: e,
            eParentOfValue: e,
            pinned: t,
            addRenderedRowListener: this.addEventListener.bind(this),
            registerRowDragger: (e, t, i, r) => this.addFullWidthRowDragging(e, t, i, r),
            setTooltip: (e, t) => this.refreshRowTooltip(e, t)
          });
          switch (this.rowType) {
            case "FullWidthDetail":
              return this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(i);
            case "FullWidthGroup":
              return this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(i);
            case "FullWidthLoading":
              return this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(i);
            default:
              return this.beans.userComponentFactory.getFullWidthCellRendererDetails(i)
          }
        }
        refreshRowTooltip(e, t) {
          if (!this.fullWidthGui) return;
          const i = {
            getGui: () => this.fullWidthGui.element,
            getTooltipValue: () => e,
            getLocation: () => "fullWidthRow",
            shouldDisplayTooltip: t
          };
          this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new Is(i, this.beans))
        }
        addFullWidthRowDragging(e, t, i = "", r) {
          if (!this.isFullWidth()) return;
          const s = new Xn(() => i, this.rowNode, void 0, e, t, r);
          this.createBean(s, this.beans.context), this.addDestroyFunc(() => {
            this.destroyBean(s, this.beans.context)
          })
        }
        onUiLevelChanged() {
          const e = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
          if (this.rowLevel != e) {
            const t = "ag-row-level-" + e,
              i = "ag-row-level-" + this.rowLevel;
            this.allRowGuis.forEach(e => {
              e.rowComp.addOrRemoveCssClass(t, !0), e.rowComp.addOrRemoveCssClass(i, !1)
            })
          }
          this.rowLevel = e
        }
        isFirstRowOnPage() {
          return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow()
        }
        isLastRowOnPage() {
          return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow()
        }
        refreshFirstAndLastRowStyles() {
          const e = this.isFirstRowOnPage(),
            t = this.isLastRowOnPage();
          this.firstRowOnPage !== e && (this.firstRowOnPage = e, this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass("ag-row-first", e))), this.lastRowOnPage !== t && (this.lastRowOnPage = t, this.allRowGuis.forEach(e => e.rowComp.addOrRemoveCssClass("ag-row-last", t)))
        }
        stopEditing(e = !1) {
          if (this.stoppingRowEdit) return;
          const t = this.getAllCellCtrls(),
            i = this.editingRow;
          this.stoppingRowEdit = !0;
          let r = !1;
          for (const s of t) {
            const t = s.stopEditing(e);
            i && !e && !r && t && (r = !0)
          }
          if (r) {
            const e = this.createRowEvent(Et.EVENT_ROW_VALUE_CHANGED);
            this.beans.eventService.dispatchEvent(e)
          }
          i && this.setEditingRow(!1), this.stoppingRowEdit = !1
        }
        setInlineEditingCss(e) {
          this.allRowGuis.forEach(t => {
            t.rowComp.addOrRemoveCssClass("ag-row-inline-editing", e), t.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !e)
          })
        }
        setEditingRow(e) {
          this.editingRow = e, this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass("ag-row-editing", e));
          const t = e ? this.createRowEvent(Et.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(Et.EVENT_ROW_EDITING_STOPPED);
          this.beans.eventService.dispatchEvent(t)
        }
        startRowEditing(e = null, t = null, i = null) {
          if (this.editingRow) return;
          this.getAllCellCtrls().reduce((r, s) => {
            const n = s === t;
            return n ? s.startEditing(e, n, i) : s.startEditing(null, n, i), !!r || s.isEditing()
          }, !1) && this.setEditingRow(!0)
        }
        getAllCellCtrls() {
          if (0 === this.leftCellCtrls.list.length && 0 === this.rightCellCtrls.list.length) return this.centerCellCtrls.list;
          return [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list]
        }
        postProcessClassesFromGridOptions() {
          const e = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
          e && e.length && e.forEach(e => {
            this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass(e, !0))
          })
        }
        postProcessRowClassRules() {
          this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, e => {
            this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass(e, !0))
          }, e => {
            this.allRowGuis.forEach(t => t.rowComp.addOrRemoveCssClass(e, !1))
          })
        }
        setStylesFromGridOptions(e, t) {
          e && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(t, e => e.rowComp.setUserStyles(this.rowStyles))
        }
        getPinnedForContainer(e) {
          return "left" === e ? "left" : "right" === e ? "right" : null
        }
        getInitialRowClasses(e) {
          const t = this.getPinnedForContainer(e),
            i = {
              rowNode: this.rowNode,
              rowFocused: this.rowFocused,
              fadeRowIn: this.fadeInAnimation[e],
              rowIsEven: this.rowNode.rowIndex % 2 == 0,
              rowLevel: this.rowLevel,
              fullWidthRow: this.isFullWidth(),
              firstRowOnPage: this.isFirstRowOnPage(),
              lastRowOnPage: this.isLastRowOnPage(),
              printLayout: this.printLayout,
              expandable: this.rowNode.isExpandable(),
              pinned: t
            };
          return this.beans.rowCssClassCalculator.getInitialRowClasses(i)
        }
        processStylesFromGridOptions() {
          const e = this.gos.get("rowStyle");
          if (e && "function" == typeof e) return void console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
          const t = this.gos.getCallback("getRowStyle");
          let i;
          if (t) {
            i = t({
              data: this.rowNode.data,
              node: this.rowNode,
              rowIndex: this.rowNode.rowIndex
            })
          }
          return i || e ? Object.assign({}, e, i) : this.emptyStyle
        }
        onRowSelected(e) {
          const t = !!this.rowNode.isSelected();
          this.forEachGui(e, e => {
            e.rowComp.addOrRemoveCssClass("ag-row-selected", t), Ci(e.element, t);
            !e.element.contains(this.beans.gos.getActiveDomElement()) || e !== this.centerGui && e !== this.fullWidthGui || this.announceDescription()
          })
        }
        announceDescription() {
          if (this.isRowSelectionBlocked()) return;
          const e = this.rowNode.isSelected();
          if (e && this.beans.gos.get("suppressRowDeselection")) return;
          const t = this.beans.localeService.getLocaleTextFunc()(e ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${e?"deselect":"select"} this row.`);
          this.beans.ariaAnnouncementService.announceValue(t)
        }
        addHoverFunctionality(e) {
          this.active && (this.addManagedListener(e, "mouseenter", () => this.rowNode.onMouseEnter()), this.addManagedListener(e, "mouseleave", () => this.rowNode.onMouseLeave()), this.addManagedListener(this.rowNode, Vn.EVENT_MOUSE_ENTER, () => {
            this.beans.dragService.isDragging() || this.gos.get("suppressRowHoverHighlight") || (e.classList.add("ag-row-hover"), this.rowNode.setHovered(!0))
          }), this.addManagedListener(this.rowNode, Vn.EVENT_MOUSE_LEAVE, () => {
            e.classList.remove("ag-row-hover"), this.rowNode.setHovered(!1)
          }))
        }
        roundRowTopToBounds(e) {
          const t = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(),
            i = this.applyPaginationOffset(t.top, !0) - 100,
            r = this.applyPaginationOffset(t.bottom, !0) + 100;
          return Math.min(Math.max(i, e), r)
        }
        getFrameworkOverrides() {
          return this.beans.frameworkOverrides
        }
        forEachGui(e, t) {
          e ? t(e) : this.allRowGuis.forEach(t)
        }
        onRowHeightChanged(e) {
          if (null == this.rowNode.rowHeight) return;
          const t = this.rowNode.rowHeight,
            i = this.beans.environment.getDefaultRowHeight(),
            r = this.gos.isGetRowHeightFunction() ? this.gos.getRowHeightForNode(this.rowNode).height : void 0,
            s = r ? Math.min(i, r) - 2 + "px" : void 0;
          this.forEachGui(e, e => {
            e.element.style.height = `${t}px`, s && e.element.style.setProperty("--ag-line-height", s)
          })
        }
        addEventListener(e, t) {
          super.addEventListener(e, t)
        }
        removeEventListener(e, t) {
          super.removeEventListener(e, t)
        }
        destroyFirstPass(e = !1) {
          if (this.active = !1, !e && this.gos.isAnimateRows() && !this.isSticky()) {
            if (null != this.rowNode.rowTop) {
              const e = this.roundRowTopToBounds(this.rowNode.rowTop);
              this.setRowTop(e)
            } else this.allRowGuis.forEach(e => e.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0))
          }
          this.rowNode.setHovered(!1);
          const t = this.createRowEvent(Et.EVENT_VIRTUAL_ROW_REMOVED);
          this.dispatchEvent(t), this.beans.eventService.dispatchEvent(t), super.destroy()
        }
        destroySecondPass() {
          this.allRowGuis.length = 0, this.stopEditing();
          const e = e => (e.list.forEach(e => e.destroy()), {
            list: [],
            map: {}
          });
          this.centerCellCtrls = e(this.centerCellCtrls), this.leftCellCtrls = e(this.leftCellCtrls), this.rightCellCtrls = e(this.rightCellCtrls)
        }
        setFocusedClasses(e) {
          this.forEachGui(e, e => {
            e.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), e.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused)
          })
        }
        onCellFocusChanged() {
          const e = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
          e !== this.rowFocused && (this.rowFocused = e, this.setFocusedClasses()), !e && this.editingRow && this.stopEditing(!1)
        }
        onPaginationChanged() {
          const e = this.beans.paginationProxy.getCurrentPage();
          this.paginationPage !== e && (this.paginationPage = e, this.onTopChanged()), this.refreshFirstAndLastRowStyles()
        }
        onTopChanged() {
          this.setRowTop(this.rowNode.rowTop)
        }
        onPaginationPixelOffsetChanged() {
          this.onTopChanged()
        }
        applyPaginationOffset(e, t = !1) {
          if (this.rowNode.isRowPinned() || this.rowNode.sticky) return e;
          return e + this.beans.paginationProxy.getPixelOffset() * (t ? 1 : -1)
        }
        setRowTop(e) {
          if (!this.printLayout && v(e)) {
            const t = this.applyPaginationOffset(e),
              i = `${this.rowNode.isRowPinned()||this.rowNode.sticky?t:this.beans.rowContainerHeightService.getRealPixelPosition(t)}px`;
            this.setRowTopStyle(i)
          }
        }
        getInitialRowTop(e) {
          return this.suppressRowTransform ? this.getInitialRowTopShared(e) : void 0
        }
        getInitialTransform(e) {
          return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(e)})`
        }
        getInitialRowTopShared(e) {
          if (this.printLayout) return "";
          let t;
          if (this.isSticky()) t = this.rowNode.stickyRowTop;
          else {
            const i = this.slideInAnimation[e] ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop,
              r = this.applyPaginationOffset(i);
            t = this.rowNode.isRowPinned() ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r)
          }
          return t + "px"
        }
        setRowTopStyle(e) {
          this.allRowGuis.forEach(t => this.suppressRowTransform ? t.rowComp.setTop(e) : t.rowComp.setTransform(`translateY(${e})`))
        }
        getRowNode() {
          return this.rowNode
        }
        getCellCtrl(e) {
          let t = null;
          return this.getAllCellCtrls().forEach(i => {
            i.getColumn() == e && (t = i)
          }), null != t || this.getAllCellCtrls().forEach(i => {
            i.getColSpanningList().indexOf(e) >= 0 && (t = i)
          }), t
        }
        onRowIndexChanged() {
          null != this.rowNode.rowIndex && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss())
        }
        getRowIndex() {
          return this.rowNode.getRowIndexString()
        }
        updateRowIndexes(e) {
          const t = this.rowNode.getRowIndexString(),
            i = this.beans.headerNavigationService.getHeaderRowCount() + this.beans.filterManager.getHeaderRowCount(),
            r = this.rowNode.rowIndex % 2 == 0,
            s = i + this.rowNode.rowIndex + 1;
          this.forEachGui(e, e => {
            e.rowComp.setRowIndex(t), e.rowComp.addOrRemoveCssClass("ag-row-even", r), e.rowComp.addOrRemoveCssClass("ag-row-odd", !r), pi(e.element, s)
          })
        }
      };
    Ta.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
    var ma = Ta,
      Ca = class extends ct {
        constructor(e) {
          super(), this.element = e
        }
        postConstruct() {
          this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad()
        }
        addKeyboardListeners() {
          const e = "keydown",
            t = this.processKeyboardEvent.bind(this, e);
          this.addManagedListener(this.element, e, t)
        }
        addMouseListeners() {
          ["dblclick", "contextmenu", "mouseover", "mouseout", "click", it("touchstart") ? "touchstart" : "mousedown"].forEach(e => {
            const t = this.processMouseEvent.bind(this, e);
            this.addManagedListener(this.element, e, t)
          })
        }
        processMouseEvent(e, t) {
          if (!this.mouseEventService.isEventFromThisGrid(t) || tt(t)) return;
          const i = this.getRowForEvent(t),
            r = this.mouseEventService.getRenderedCellForEvent(t);
          "contextmenu" === e ? this.handleContextMenuMouseEvent(t, void 0, i, r) : (r && r.onMouseEvent(e, t), i && i.onMouseEvent(e, t))
        }
        mockContextMenuForIPad() {
          if (!Gi()) return;
          const e = new In(this.element);
          this.addManagedListener(e, In.EVENT_LONG_TAP, e => {
            const t = this.getRowForEvent(e.touchEvent),
              i = this.mouseEventService.getRenderedCellForEvent(e.touchEvent);
            this.handleContextMenuMouseEvent(void 0, e.touchEvent, t, i)
          }), this.addDestroyFunc(() => e.destroy())
        }
        getRowForEvent(e) {
          let t = e.target;
          for (; t;) {
            const e = this.gos.getDomData(t, ma.DOM_DATA_KEY_ROW_CTRL);
            if (e) return e;
            t = t.parentElement
          }
          return null
        }
        handleContextMenuMouseEvent(e, t, i, r) {
          const s = i ? i.getRowNode() : null,
            n = r ? r.getColumn() : null;
          let o = null;
          if (n) {
            const i = e || t;
            r.dispatchCellContextMenuEvent(null != i ? i : null), o = this.valueService.getValue(n, s)
          }
          const a = this.ctrlsService.getGridBodyCtrl(),
            l = r ? r.getGui() : a.getGridBodyElement();
          this.menuService.showContextMenu({
            mouseEvent: e,
            touchEvent: t,
            rowNode: s,
            column: n,
            value: o,
            anchorToElement: l
          })
        }
        getControlsForEventTarget(e) {
          return {
            cellCtrl: rt(this.gos, e, ga.DOM_DATA_KEY_CELL_CTRL),
            rowCtrl: rt(this.gos, e, ma.DOM_DATA_KEY_ROW_CTRL)
          }
        }
        processKeyboardEvent(e, t) {
          const {
            cellCtrl: i,
            rowCtrl: r
          } = this.getControlsForEventTarget(t.target);
          t.defaultPrevented || (i ? this.processCellKeyboardEvent(i, e, t) : r && r.isFullWidth() && this.processFullWidthRowKeyboardEvent(r, e, t))
        }
        processCellKeyboardEvent(e, t, i) {
          const r = e.getRowNode(),
            s = e.getColumn(),
            n = e.isEditing();
          if (!cs(this.gos, i, r, s, n) && "keydown" === t) {
            !n && this.navigationService.handlePageScrollingKey(i) || e.onKeyDown(i), this.doGridOperations(i, e.isEditing()), ls(i) && e.processCharacter(i)
          }
          if ("keydown" === t) {
            const t = e.createEvent(i, Et.EVENT_CELL_KEY_DOWN);
            this.eventService.dispatchEvent(t)
          }
        }
        processFullWidthRowKeyboardEvent(e, t, i) {
          const r = e.getRowNode(),
            s = this.focusService.getFocusedCell(),
            n = s && s.column;
          if (!cs(this.gos, i, r, n, !1)) {
            const r = i.key;
            if ("keydown" === t) switch (r) {
              case ts.PAGE_HOME:
              case ts.PAGE_END:
              case ts.PAGE_UP:
              case ts.PAGE_DOWN:
                this.navigationService.handlePageScrollingKey(i, !0);
                break;
              case ts.UP:
              case ts.DOWN:
                e.onKeyboardNavigate(i);
                break;
              case ts.TAB:
                e.onTabKeyDown(i)
            }
          }
          if ("keydown" === t) {
            const t = e.createRowEvent(Et.EVENT_CELL_KEY_DOWN, i);
            this.eventService.dispatchEvent(t)
          }
        }
        doGridOperations(e, t) {
          if (!e.ctrlKey && !e.metaKey) return;
          if (t) return;
          if (!this.mouseEventService.isEventFromThisGrid(e)) return;
          const i = us(e);
          return i === ts.A ? this.onCtrlAndA(e) : i === ts.C ? this.onCtrlAndC(e) : i === ts.D ? this.onCtrlAndD(e) : i === ts.V ? this.onCtrlAndV(e) : i === ts.X ? this.onCtrlAndX(e) : i === ts.Y ? this.onCtrlAndY() : i === ts.Z ? this.onCtrlAndZ(e) : void 0
        }
        onCtrlAndA(e) {
          const {
            pinnedRowModel: t,
            paginationProxy: i,
            rangeService: r
          } = this;
          if (r && i.isRowsToRender()) {
            const [e, i] = [t.isEmpty("top"), t.isEmpty("bottom")], s = e ? null : "top";
            let n, o;
            i ? (n = null, o = this.paginationProxy.getRowCount() - 1) : (n = "bottom", o = t.getPinnedBottomRowData().length - 1);
            const a = this.columnModel.getAllDisplayedColumns();
            if (I(a)) return;
            r.setCellRange({
              rowStartIndex: 0,
              rowStartPinned: s,
              rowEndIndex: o,
              rowEndPinned: n,
              columnStart: a[0],
              columnEnd: Me(a)
            })
          }
          e.preventDefault()
        }
        onCtrlAndC(e) {
          if (!this.clipboardService || this.gos.get("enableCellTextSelection")) return;
          const {
            cellCtrl: t,
            rowCtrl: i
          } = this.getControlsForEventTarget(e.target);
          (null == t ? void 0 : t.isEditing()) || (null == i ? void 0 : i.isEditing()) || (e.preventDefault(), this.clipboardService.copyToClipboard())
        }
        onCtrlAndX(e) {
          if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) return;
          const {
            cellCtrl: t,
            rowCtrl: i
          } = this.getControlsForEventTarget(e.target);
          (null == t ? void 0 : t.isEditing()) || (null == i ? void 0 : i.isEditing()) || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"))
        }
        onCtrlAndV(e) {
          const {
            cellCtrl: t,
            rowCtrl: i
          } = this.getControlsForEventTarget(e.target);
          (null == t ? void 0 : t.isEditing()) || (null == i ? void 0 : i.isEditing()) || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard()
        }
        onCtrlAndD(e) {
          this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault()
        }
        onCtrlAndZ(e) {
          this.gos.get("undoRedoCellEditing") && (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"))
        }
        onCtrlAndY() {
          this.undoRedoService.redo("ui")
        }
      };
    C([fe("mouseEventService")], Ca.prototype, "mouseEventService", 2), C([fe("valueService")], Ca.prototype, "valueService", 2), C([fe("menuService")], Ca.prototype, "menuService", 2), C([fe("ctrlsService")], Ca.prototype, "ctrlsService", 2), C([fe("navigationService")], Ca.prototype, "navigationService", 2), C([fe("focusService")], Ca.prototype, "focusService", 2), C([fe("undoRedoService")], Ca.prototype, "undoRedoService", 2), C([fe("columnModel")], Ca.prototype, "columnModel", 2), C([fe("paginationProxy")], Ca.prototype, "paginationProxy", 2), C([fe("pinnedRowModel")], Ca.prototype, "pinnedRowModel", 2), C([Te("rangeService")], Ca.prototype, "rangeService", 2), C([Te("clipboardService")], Ca.prototype, "clipboardService", 2), C([pe], Ca.prototype, "postConstruct", 1);
    var Sa = class extends ct {
      constructor(e) {
        super(), this.centerContainerCtrl = e
      }
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize()
        }), this.addManagedListener(this.eventService, Et.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this)), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
          this.checkViewportAndScrolls()
        })
      }
      listenForResize() {
        const e = () => this.onCenterViewportResized();
        this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e)
      }
      onScrollbarWidthChanged() {
        this.checkViewportAndScrolls()
      }
      onCenterViewportResized() {
        if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
          this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
          const e = this.centerContainerCtrl.getCenterWidth();
          e !== this.centerWidth && (this.centerWidth = e, this.columnModel.refreshFlexedColumns({
            viewportWidth: this.centerWidth,
            updateBodyWidths: !0,
            fireResizedEvent: !0
          }))
        } else this.bodyHeight = 0
      }
      keepPinnedColumnsNarrowerThanViewport() {
        const e = Tr(this.gridBodyCtrl.getBodyViewportElement());
        if (e <= 50) return;
        let t = this.getPinnedColumnsOverflowingViewport(e - 50);
        const i = this.gos.getCallback("processUnpinnedColumns");
        if (t.length) {
          if (i) {
            t = i({
              columns: t,
              viewportWidth: e
            })
          }
          this.columnModel.setColumnsPinned(t, null, "viewportSizeFeature")
        }
      }
      getPinnedColumnsOverflowingViewport(e) {
        const t = this.pinnedWidthService.getPinnedRightWidth() + this.pinnedWidthService.getPinnedLeftWidth();
        if (t < e) return [];
        const i = [...this.columnModel.getDisplayedLeftColumns()],
          r = [...this.columnModel.getDisplayedRightColumns()];
        let s = 0,
          n = 0;
        const o = [];
        let a = t - 0 - e;
        for (;
          (n < i.length || s < r.length) && a > 0;) {
          if (s < r.length) {
            const e = r[s++];
            a -= e.getActualWidth(), o.push(e)
          }
          if (n < i.length && a > 0) {
            const e = i[n++];
            a -= e.getActualWidth(), o.push(e)
          }
        }
        return o
      }
      checkViewportAndScrolls() {
        this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft()
      }
      getBodyHeight() {
        return this.bodyHeight
      }
      checkBodyHeight() {
        const e = fr(this.gridBodyCtrl.getBodyViewportElement());
        if (this.bodyHeight !== e) {
          this.bodyHeight = e;
          const t = {
            type: Et.EVENT_BODY_HEIGHT_CHANGED
          };
          this.eventService.dispatchEvent(t)
        }
      }
      updateScrollVisibleService() {
        this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500)
      }
      updateScrollVisibleServiceImpl() {
        const e = {
          horizontalScrollShowing: this.isHorizontalScrollShowing(),
          verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
        };
        this.scrollVisibleService.setScrollsVisible(e)
      }
      isHorizontalScrollShowing() {
        return this.centerContainerCtrl.isHorizontalScrollShowing()
      }
      onHorizontalViewportChanged() {
        const e = this.centerContainerCtrl.getCenterWidth(),
          t = this.centerContainerCtrl.getViewportScrollLeft();
        this.columnModel.setViewportPosition(e, t)
      }
    };
    C([fe("ctrlsService")], Sa.prototype, "ctrlsService", 2), C([fe("pinnedWidthService")], Sa.prototype, "pinnedWidthService", 2), C([fe("columnModel")], Sa.prototype, "columnModel", 2), C([fe("scrollVisibleService")], Sa.prototype, "scrollVisibleService", 2), C([pe], Sa.prototype, "postConstruct", 1);
    var Ra = class extends ct {
      constructor(e) {
        super(), this.element = e
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this))
      }
      onPinnedLeftWidthChanged() {
        const e = this.pinnedWidthService.getPinnedLeftWidth(),
          t = e > 0;
        ur(this.element, t), xr(this.element, e)
      }
      getWidth() {
        return this.pinnedWidthService.getPinnedLeftWidth()
      }
    };
    C([fe("pinnedWidthService")], Ra.prototype, "pinnedWidthService", 2), C([pe], Ra.prototype, "postConstruct", 1);
    var Aa = class extends ct {
      constructor(e) {
        super(), this.element = e
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this))
      }
      onPinnedRightWidthChanged() {
        const e = this.pinnedWidthService.getPinnedRightWidth(),
          t = e > 0;
        ur(this.element, t), xr(this.element, e)
      }
      getWidth() {
        return this.pinnedWidthService.getPinnedRightWidth()
      }
    };
    C([fe("pinnedWidthService")], Aa.prototype, "pinnedWidthService", 2), C([pe], Aa.prototype, "postConstruct", 1);
    var va = class extends ct {
      constructor(e, t) {
        super(), this.eContainer = e, this.eViewport = t
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this))
      }
      onHeightChanged() {
        const e = this.maxDivHeightScaler.getUiContainerHeight(),
          t = null != e ? `${e}px` : "";
        this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t)
      }
    };
    C([fe("rowContainerHeightService")], va.prototype, "maxDivHeightScaler", 2), C([pe], va.prototype, "postConstruct", 1);
    var Na = class extends ct {
      constructor(e) {
        super(), this.eContainer = e
      }
      postConstruct() {
        if (!this.rangeService) return;
        this.params = {
          eElement: this.eContainer,
          onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
          onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
          onDragging: this.rangeService.onDragging.bind(this.rangeService)
        }, this.addManagedPropertyListener("enableRangeSelection", e => {
          e.currentValue ? this.enableFeature() : this.disableFeature()
        }), this.addDestroyFunc(() => this.disableFeature());
        this.gos.get("enableRangeSelection") && this.enableFeature()
      }
      enableFeature() {
        this.dragService.addDragSource(this.params)
      }
      disableFeature() {
        this.dragService.removeDragSource(this.params)
      }
    };
    C([fe("dragService")], Na.prototype, "dragService", 2), C([Te("rangeService")], Na.prototype, "rangeService", 2), C([pe], Na.prototype, "postConstruct", 1);
    var Ia = class extends ct {
      constructor(e, t = !1) {
        super(), this.callback = e, this.addSpacer = t
      }
      postConstruct() {
        const e = this.setWidth.bind(this);
        this.addManagedPropertyListener("domLayout", e), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_LEFT_PINNED_WIDTH_CHANGED, e), this.addSpacer && (this.addManagedListener(this.eventService, Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_SCROLL_VISIBILITY_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_SCROLLBAR_WIDTH_CHANGED, e)), this.setWidth()
      }
      setWidth() {
        const {
          columnModel: e
        } = this, t = this.gos.isDomLayout("print"), i = e.getBodyContainerWidth(), r = e.getDisplayedColumnsLeftWidth(), s = e.getDisplayedColumnsRightWidth();
        let n;
        if (t) n = i + r + s;
        else if (n = i, this.addSpacer) {
          0 === (this.gos.get("enableRtl") ? r : s) && this.scrollVisibleService.isVerticalScrollShowing() && (n += this.gos.getScrollbarWidth())
        }
        this.callback(n)
      }
    };
    C([fe("columnModel")], Ia.prototype, "columnModel", 2), C([fe("scrollVisibleService")], Ia.prototype, "scrollVisibleService", 2), C([pe], Ia.prototype, "postConstruct", 1);
    var Oa = _t([
        ["center", "ag-center-cols-container"],
        ["left", "ag-pinned-left-cols-container"],
        ["right", "ag-pinned-right-cols-container"],
        ["fullWidth", "ag-full-width-container"],
        ["topCenter", "ag-floating-top-container"],
        ["topLeft", "ag-pinned-left-floating-top"],
        ["topRight", "ag-pinned-right-floating-top"],
        ["topFullWidth", "ag-floating-top-full-width-container"],
        ["stickyTopCenter", "ag-sticky-top-container"],
        ["stickyTopLeft", "ag-pinned-left-sticky-top"],
        ["stickyTopRight", "ag-pinned-right-sticky-top"],
        ["stickyTopFullWidth", "ag-sticky-top-full-width-container"],
        ["stickyBottomCenter", "ag-sticky-bottom-container"],
        ["stickyBottomLeft", "ag-pinned-left-sticky-bottom"],
        ["stickyBottomRight", "ag-pinned-right-sticky-bottom"],
        ["stickyBottomFullWidth", "ag-sticky-bottom-full-width-container"],
        ["bottomCenter", "ag-floating-bottom-container"],
        ["bottomLeft", "ag-pinned-left-floating-bottom"],
        ["bottomRight", "ag-pinned-right-floating-bottom"],
        ["bottomFullWidth", "ag-floating-bottom-full-width-container"]
      ]),
      La = _t([
        ["center", "ag-center-cols-viewport"],
        ["topCenter", "ag-floating-top-viewport"],
        ["stickyTopCenter", "ag-sticky-top-viewport"],
        ["bottomCenter", "ag-floating-bottom-viewport"],
        ["stickyBottomCenter", "ag-sticky-bottom-viewport"]
      ]),
      _a = class e extends ct {
        constructor(e) {
          super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = e, this.isFullWithContainer = "topFullWidth" === this.name || "stickyTopFullWidth" === this.name || "stickyBottomFullWidth" === this.name || "bottomFullWidth" === this.name || "fullWidth" === this.name
        }
        static getRowContainerCssClasses(e) {
          return {
            container: Oa.get(e),
            viewport: La.get(e)
          }
        }
        static getPinned(e) {
          switch (e) {
            case "bottomLeft":
            case "topLeft":
            case "stickyTopLeft":
            case "stickyBottomLeft":
            case "left":
              return "left";
            case "bottomRight":
            case "topRight":
            case "stickyTopRight":
            case "stickyBottomRight":
            case "right":
              return "right";
            default:
              return null
          }
        }
        postConstruct() {
          this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => this.viewportSizeFeature = this.createManagedBean(new Sa(this)))
        }
        registerWithCtrlsService() {
          switch (this.name) {
            case "fullWidth":
            case "topFullWidth":
            case "stickyTopFullWidth":
            case "bottomFullWidth":
            case "stickyBottomFullWidth":
              return;
            default:
              this.ctrlsService.register(this.name, this)
          }
        }
        forContainers(e, t) {
          e.indexOf(this.name) >= 0 && t()
        }
        getContainerElement() {
          return this.eContainer
        }
        getViewportSizeFeature() {
          return this.viewportSizeFeature
        }
        setComp(e, t, i) {
          this.comp = e, this.eContainer = t, this.eViewport = i, this.createManagedBean(new Ca(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows();
          const r = ["topCenter", "topLeft", "topRight", "bottomCenter", "bottomLeft", "bottomRight", "center", "left", "right", "stickyTopCenter", "stickyTopLeft", "stickyTopRight", "stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"];
          this.forContainers(["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], () => {
            this.pinnedWidthFeature = this.createManagedBean(new Ra(this.eContainer)), this.addManagedListener(this.eventService, Et.EVENT_LEFT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged())
          }), this.forContainers(["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], () => {
            this.pinnedWidthFeature = this.createManagedBean(new Aa(this.eContainer)), this.addManagedListener(this.eventService, Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged())
          }), this.forContainers(["center", "left", "right", "fullWidth"], () => this.createManagedBean(new va(this.eContainer, "center" === this.name ? i : void 0))), this.forContainers(r, () => this.createManagedBean(new Na(this.eContainer))), this.forContainers(["center", "topCenter", "stickyTopCenter", "bottomCenter", "stickyBottomCenter"], () => this.createManagedBean(new Ia(e => this.comp.setContainerWidth(`${e}px`)))), this.addListeners(), this.registerWithCtrlsService()
        }
        addListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, () => this.onDisplayedColumnsChanged()), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => this.onDisplayedColumnsWidthChanged()), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_ROWS_CHANGED, e => this.onDisplayedRowsChanged(e.afterScroll)), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged()
        }
        listenOnDomOrder() {
          if (["stickyTopCenter", "stickyTopLeft", "stickyTopRight", "stickyTopFullWidth", "stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight", "stickyBottomFullWidth"].indexOf(this.name) >= 0) return void this.comp.setDomOrder(!0);
          const e = () => {
            const e = this.gos.get("ensureDomOrder"),
              t = this.gos.isDomLayout("print");
            this.comp.setDomOrder(e || t)
          };
          this.addManagedPropertyListener("domLayout", e), e()
        }
        stopHScrollOnPinnedRows() {
          this.forContainers(["topCenter", "stickyTopCenter", "bottomCenter", "stickyBottomCenter"], () => {
            this.addManagedListener(this.eViewport, "scroll", () => this.eViewport.scrollLeft = 0)
          })
        }
        onDisplayedColumnsChanged() {
          this.forContainers(["center"], () => this.onHorizontalViewportChanged())
        }
        onDisplayedColumnsWidthChanged() {
          this.forContainers(["center"], () => this.onHorizontalViewportChanged())
        }
        addPreventScrollWhileDragging() {
          const e = e => {
            this.dragService.isDragging() && e.cancelable && e.preventDefault()
          };
          this.eContainer.addEventListener("touchmove", e, {
            passive: !1
          }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e))
        }
        onHorizontalViewportChanged(e = !1) {
          const t = this.getCenterWidth(),
            i = this.getCenterViewportScrollLeft();
          this.columnModel.setViewportPosition(t, i, e)
        }
        getCenterWidth() {
          return Tr(this.eViewport)
        }
        getCenterViewportScrollLeft() {
          return Ar(this.eViewport, this.enableRtl)
        }
        registerViewportResizeListener(e) {
          const t = this.resizeObserverService.observeResize(this.eViewport, e);
          this.addDestroyFunc(() => t())
        }
        isViewportInTheDOMTree() {
          return Or(this.eViewport)
        }
        getViewportScrollLeft() {
          return Ar(this.eViewport, this.enableRtl)
        }
        isHorizontalScrollShowing() {
          return this.gos.get("alwaysShowHorizontalScroll") || br(this.eViewport)
        }
        getViewportElement() {
          return this.eViewport
        }
        setContainerTranslateX(e) {
          this.eContainer.style.transform = `translateX(${e}px)`
        }
        getHScrollPosition() {
          return {
            left: this.eViewport.scrollLeft,
            right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
          }
        }
        setCenterViewportScrollLeft(e) {
          vr(this.eViewport, e, this.enableRtl)
        }
        isContainerVisible() {
          return !e.getPinned(this.name) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0
        }
        onPinnedWidthChanged() {
          const e = this.isContainerVisible();
          this.visible != e && (this.visible = e, this.onDisplayedRowsChanged())
        }
        onDisplayedRowsChanged(e = !1) {
          const t = this.getRowCtrls();
          if (!this.visible || 0 === t.length) return void this.comp.setRowCtrls({
            rowCtrls: this.EMPTY_CTRLS
          });
          const i = this.gos.isDomLayout("print"),
            r = this.gos.get("embedFullWidthRows") || i,
            s = t.filter(e => {
              const t = e.isFullWidth();
              return this.isFullWithContainer ? !r && t : r || !t
            });
          this.comp.setRowCtrls({
            rowCtrls: s,
            useFlushSync: e
          })
        }
        getRowCtrls() {
          switch (this.name) {
            case "topCenter":
            case "topLeft":
            case "topRight":
            case "topFullWidth":
              return this.rowRenderer.getTopRowCtrls();
            case "stickyTopCenter":
            case "stickyTopLeft":
            case "stickyTopRight":
            case "stickyTopFullWidth":
              return this.rowRenderer.getStickyTopRowCtrls();
            case "stickyBottomCenter":
            case "stickyBottomLeft":
            case "stickyBottomRight":
            case "stickyBottomFullWidth":
              return this.rowRenderer.getStickyBottomRowCtrls();
            case "bottomCenter":
            case "bottomLeft":
            case "bottomRight":
            case "bottomFullWidth":
              return this.rowRenderer.getBottomRowCtrls();
            default:
              return this.rowRenderer.getCentreRowCtrls()
          }
        }
      };
    C([fe("dragService")], _a.prototype, "dragService", 2), C([fe("ctrlsService")], _a.prototype, "ctrlsService", 2), C([fe("columnModel")], _a.prototype, "columnModel", 2), C([fe("resizeObserverService")], _a.prototype, "resizeObserverService", 2), C([fe("rowRenderer")], _a.prototype, "rowRenderer", 2), C([pe], _a.prototype, "postConstruct", 1);
    var ya = _a,
      wa = class extends _s {
        constructor() {
          super('<div class="ag-root ag-unselectable" role="treegrid">\n        <ag-header-root ref="gridHeader"></ag-header-root>\n        <div class="ag-floating-top" ref="eTop" role="presentation">\n            <ag-row-container ref="topLeftContainer" name="topLeft"></ag-row-container>\n            <ag-row-container ref="topCenterContainer" name="topCenter"></ag-row-container>\n            <ag-row-container ref="topRightContainer" name="topRight"></ag-row-container>\n            <ag-row-container ref="topFullWidthContainer" name="topFullWidth"></ag-row-container>\n        </div>\n        <div class="ag-body" ref="eBody" role="presentation">\n            <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">\n                <ag-row-container ref="leftContainer" name="left"></ag-row-container>\n                <ag-row-container ref="centerContainer" name="center"></ag-row-container>\n                <ag-row-container ref="rightContainer" name="right"></ag-row-container>\n                <ag-row-container ref="fullWidthContainer" name="fullWidth"></ag-row-container>\n            </div>\n            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>\n        </div>\n        <div class="ag-sticky-top" ref="eStickyTop" role="presentation">\n            <ag-row-container ref="stickyTopLeftContainer" name="stickyTopLeft"></ag-row-container>\n            <ag-row-container ref="stickyTopCenterContainer" name="stickyTopCenter"></ag-row-container>\n            <ag-row-container ref="stickyTopRightContainer" name="stickyTopRight"></ag-row-container>\n            <ag-row-container ref="stickyTopFullWidthContainer" name="stickyTopFullWidth"></ag-row-container>\n        </div>\n        <div class="ag-sticky-bottom" ref="eStickyBottom" role="presentation">\n            <ag-row-container ref="stickyBottomLeftContainer" name="stickyBottomLeft"></ag-row-container>\n            <ag-row-container ref="stickyBottomCenterContainer" name="stickyBottomCenter"></ag-row-container>\n            <ag-row-container ref="stickyBottomRightContainer" name="stickyBottomRight"></ag-row-container>\n            <ag-row-container ref="stickyBottomFullWidthContainer" name="stickyBottomFullWidth"></ag-row-container>\n        </div>\n        <div class="ag-floating-bottom" ref="eBottom" role="presentation">\n            <ag-row-container ref="bottomLeftContainer" name="bottomLeft"></ag-row-container>\n            <ag-row-container ref="bottomCenterContainer" name="bottomCenter"></ag-row-container>\n            <ag-row-container ref="bottomRightContainer" name="bottomRight"></ag-row-container>\n            <ag-row-container ref="bottomFullWidthContainer" name="bottomFullWidth"></ag-row-container>\n        </div>\n        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>\n        <ag-overlay-wrapper></ag-overlay-wrapper>\n    </div>')
        }
        init() {
          const e = (e, t) => {
              const i = `${e}px`;
              t.style.minHeight = i, t.style.height = i
            },
            t = {
              setRowAnimationCssOnBodyViewport: (e, t) => this.setRowAnimationCssOnBodyViewport(e, t),
              setColumnCount: e => Ei(this.getGui(), e),
              setRowCount: e => di(this.getGui(), e),
              setTopHeight: t => e(t, this.eTop),
              setBottomHeight: t => e(t, this.eBottom),
              setTopDisplay: e => this.eTop.style.display = e,
              setBottomDisplay: e => this.eBottom.style.display = e,
              setStickyTopHeight: e => this.eStickyTop.style.height = e,
              setStickyTopTop: e => this.eStickyTop.style.top = e,
              setStickyTopWidth: e => this.eStickyTop.style.width = e,
              setStickyBottomHeight: e => this.eStickyBottom.style.height = e,
              setStickyBottomBottom: e => this.eStickyBottom.style.bottom = e,
              setStickyBottomWidth: e => this.eStickyBottom.style.width = e,
              setColumnMovingCss: (e, t) => this.addOrRemoveCssClass(e, t),
              updateLayoutClasses: (e, t) => {
                [this.eBodyViewport.classList, this.eBody.classList].forEach(e => {
                  e.toggle("ag-layout-auto-height", t.autoHeight), e.toggle("ag-layout-normal", t.normal), e.toggle("ag-layout-print", t.print)
                }), this.addOrRemoveCssClass("ag-layout-auto-height", t.autoHeight), this.addOrRemoveCssClass("ag-layout-normal", t.normal), this.addOrRemoveCssClass("ag-layout-print", t.print)
              },
              setAlwaysVerticalScrollClass: (e, t) => this.eBodyViewport.classList.toggle(ia, t),
              registerBodyViewportResizeListener: e => {
                const t = this.resizeObserverService.observeResize(this.eBodyViewport, e);
                this.addDestroyFunc(() => t())
              },
              setPinnedTopBottomOverflowY: e => this.eTop.style.overflowY = this.eBottom.style.overflowY = e,
              setCellSelectableCss: (e, t) => {
                [this.eTop, this.eBodyViewport, this.eBottom].forEach(i => i.classList.toggle(e, t))
              },
              setBodyViewportWidth: e => this.eBodyViewport.style.width = e
            };
          this.ctrl = this.createManagedBean(new ra), this.ctrl.setComp(t, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop, this.eStickyBottom), (this.rangeService && this.gos.get("enableRangeSelection") || "multiple" === this.gos.get("rowSelection")) && ui(this.getGui(), !0)
        }
        setRowAnimationCssOnBodyViewport(e, t) {
          const i = this.eBodyViewport.classList;
          i.toggle("ag-row-animation", t), i.toggle("ag-row-no-animation", !t)
        }
        getFloatingTopBottom() {
          return [this.eTop, this.eBottom]
        }
      };
    C([fe("resizeObserverService")], wa.prototype, "resizeObserverService", 2), C([Te("rangeService")], wa.prototype, "rangeService", 2), C([ys("eBodyViewport")], wa.prototype, "eBodyViewport", 2), C([ys("eStickyTop")], wa.prototype, "eStickyTop", 2), C([ys("eStickyBottom")], wa.prototype, "eStickyBottom", 2), C([ys("eTop")], wa.prototype, "eTop", 2), C([ys("eBottom")], wa.prototype, "eBottom", 2), C([ys("gridHeader")], wa.prototype, "headerRootComp", 2), C([ys("eBody")], wa.prototype, "eBody", 2), C([pe], wa.prototype, "init", 1);
    var Da = class extends ct {
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this))
      }
      onDisplayedColumnsChanged() {
        this.update()
      }
      onDisplayedColumnsWidthChanged() {
        this.update()
      }
      update() {
        this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
          this.columnAnimationService.executeLaterVMTurn(() => this.updateImpl())
        }) : this.updateImpl()
      }
      updateImpl() {
        const e = this.ctrlsService.get("center");
        if (!e || this.columnAnimationService.isActive()) return;
        const t = {
          horizontalScrollShowing: e.isHorizontalScrollShowing(),
          verticalScrollShowing: this.isVerticalScrollShowing()
        };
        this.setScrollsVisible(t)
      }
      setScrollsVisible(e) {
        if (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) {
          this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing;
          const t = {
            type: Et.EVENT_SCROLL_VISIBILITY_CHANGED
          };
          this.eventService.dispatchEvent(t)
        }
      }
      isHorizontalScrollShowing() {
        return this.horizontalScrollShowing
      }
      isVerticalScrollShowing() {
        return this.verticalScrollShowing
      }
    };
    C([fe("ctrlsService")], Da.prototype, "ctrlsService", 2), C([fe("columnAnimationService")], Da.prototype, "columnAnimationService", 2), C([pe], Da.prototype, "postConstruct", 1), Da = C([ge("scrollVisibleService")], Da);
    var Pa = class extends ct {
      constructor() {
        super(...arguments), this.gridInstanceId = Pa.gridInstanceSequence.next()
      }
      stampTopLevelGridCompWithGridInstance(e) {
        e[Pa.GRID_DOM_KEY] = this.gridInstanceId
      }
      getRenderedCellForEvent(e) {
        return rt(this.gos, e.target, ga.DOM_DATA_KEY_CELL_CTRL)
      }
      isEventFromThisGrid(e) {
        return this.isElementInThisGrid(e.target)
      }
      isElementInThisGrid(e) {
        let t = e;
        for (; t;) {
          const e = t[Pa.GRID_DOM_KEY];
          if (v(e)) {
            return e === this.gridInstanceId
          }
          t = t.parentElement
        }
        return !1
      }
      getCellPositionForEvent(e) {
        const t = this.getRenderedCellForEvent(e);
        return t ? t.getCellPosition() : null
      }
      getNormalisedPosition(e) {
        const t = this.gos.isDomLayout("normal"),
          i = e;
        let r, s;
        if (null != i.clientX || null != i.clientY ? (r = i.clientX, s = i.clientY) : (r = i.x, s = i.y), t) {
          const e = this.ctrlsService.getGridBodyCtrl(),
            t = e.getScrollFeature().getVScrollPosition();
          r += e.getScrollFeature().getHScrollPosition().left, s += t.top
        }
        return {
          x: r,
          y: s
        }
      }
    };
    Pa.gridInstanceSequence = new Ss, Pa.GRID_DOM_KEY = "__ag_grid_instance", C([fe("ctrlsService")], Pa.prototype, "ctrlsService", 2), Pa = C([ge("mouseEventService")], Pa);
    var ba = class extends ct {
      constructor() {
        super(), this.onPageDown = se(this.onPageDown, 100), this.onPageUp = se(this.onPageUp, 100)
      }
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          this.gridBodyCon = e.gridBodyCtrl
        })
      }
      handlePageScrollingKey(e, t = !1) {
        const i = e.key,
          r = e.altKey,
          s = e.ctrlKey || e.metaKey,
          n = !!this.rangeService && e.shiftKey,
          o = this.mouseEventService.getCellPositionForEvent(e);
        let a = !1;
        switch (i) {
          case ts.PAGE_HOME:
          case ts.PAGE_END:
            s || r || (this.onHomeOrEndKey(i), a = !0);
            break;
          case ts.LEFT:
          case ts.RIGHT:
          case ts.UP:
          case ts.DOWN:
            if (!o) return !1;
            !s || r || n || (this.onCtrlUpDownLeftRight(i, o), a = !0);
            break;
          case ts.PAGE_DOWN:
          case ts.PAGE_UP:
            s || r || (a = this.handlePageUpDown(i, o, t))
        }
        return a && e.preventDefault(), a
      }
      handlePageUpDown(e, t, i) {
        return i && (t = this.focusService.getFocusedCell()), !!t && (e === ts.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0)
      }
      navigateTo(e) {
        var t;
        const {
          scrollIndex: i,
          scrollType: r,
          scrollColumn: s,
          focusIndex: n,
          focusColumn: o
        } = e;
        v(s) && !s.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(s), v(i) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(i, r), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(n), this.focusService.setFocusedCell({
          rowIndex: n,
          column: o,
          rowPinned: null,
          forceBrowserFocus: !0
        }), null == (t = this.rangeService) || t.setRangeToCell({
          rowIndex: n,
          rowPinned: null,
          column: o
        })
      }
      onPageDown(e) {
        const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(),
          i = this.getViewportHeight(),
          r = this.paginationProxy.getPixelOffset(),
          s = t.top + i,
          n = this.paginationProxy.getRowIndexAtPixel(s + r);
        this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, n) : this.navigateToNextPage(e, n)
      }
      onPageUp(e) {
        const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(),
          i = this.paginationProxy.getPixelOffset(),
          r = t.top,
          s = this.paginationProxy.getRowIndexAtPixel(r + i);
        this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, s, !0) : this.navigateToNextPage(e, s, !0)
      }
      navigateToNextPage(e, t, i = !1) {
        const r = this.getViewportHeight(),
          s = this.paginationProxy.getPageFirstRow(),
          n = this.paginationProxy.getPageLastRow(),
          o = this.paginationProxy.getPixelOffset(),
          a = this.paginationProxy.getRow(e.rowIndex),
          l = i ? (null == a ? void 0 : a.rowHeight) - r - o : r - o,
          c = (null == a ? void 0 : a.rowTop) + l;
        let h, u = this.paginationProxy.getRowIndexAtPixel(c + o);
        if (u === e.rowIndex) {
          const r = i ? -1 : 1;
          t = u = e.rowIndex + r
        }
        i ? (h = "bottom", u < s && (u = s), t < s && (t = s)) : (h = "top", u > n && (u = n), t > n && (t = n)), this.isRowTallerThanView(u) && (t = u, h = "top"), this.navigateTo({
          scrollIndex: t,
          scrollType: h,
          scrollColumn: null,
          focusIndex: u,
          focusColumn: e.column
        })
      }
      navigateToNextPageWithAutoHeight(e, t, i = !1) {
        this.navigateTo({
          scrollIndex: t,
          scrollType: i ? "bottom" : "top",
          scrollColumn: null,
          focusIndex: t,
          focusColumn: e.column
        }), setTimeout(() => {
          const r = this.getNextFocusIndexForAutoHeight(e, i);
          this.navigateTo({
            scrollIndex: t,
            scrollType: i ? "bottom" : "top",
            scrollColumn: null,
            focusIndex: r,
            focusColumn: e.column,
            isAsync: !0
          })
        }, 50)
      }
      getNextFocusIndexForAutoHeight(e, t = !1) {
        var i;
        const r = t ? -1 : 1,
          s = this.getViewportHeight(),
          n = this.paginationProxy.getPageLastRow();
        let o = 0,
          a = e.rowIndex;
        for (; a >= 0 && a <= n;) {
          const e = this.paginationProxy.getRow(a);
          if (e) {
            const t = null != (i = e.rowHeight) ? i : 0;
            if (o + t > s) break;
            o += t
          }
          a += r
        }
        return Math.max(0, Math.min(a, n))
      }
      getViewportHeight() {
        const {
          gridBodyCtrl: e,
          center: t
        } = this.ctrlsService.getParams(), i = e.getScrollFeature().getVScrollPosition(), r = this.gos.getScrollbarWidth();
        let s = i.bottom - i.top;
        return t.isHorizontalScrollShowing() && (s -= r), s
      }
      isRowTallerThanView(e) {
        const t = this.paginationProxy.getRow(e);
        if (!t) return !1;
        const i = t.rowHeight;
        return "number" == typeof i && i > this.getViewportHeight()
      }
      onCtrlUpDownLeftRight(e, t) {
        const i = this.cellNavigationService.getNextCellToFocus(e, t, !0),
          {
            rowIndex: r,
            column: s
          } = i;
        this.navigateTo({
          scrollIndex: r,
          scrollType: null,
          scrollColumn: s,
          focusIndex: r,
          focusColumn: s
        })
      }
      onHomeOrEndKey(e) {
        const t = e === ts.PAGE_HOME,
          i = this.columnModel.getAllDisplayedColumns(),
          r = t ? i[0] : Me(i),
          s = t ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
        this.navigateTo({
          scrollIndex: s,
          scrollType: null,
          scrollColumn: r,
          focusIndex: s,
          focusColumn: r
        })
      }
      onTabKeyDown(e, t) {
        const i = t.shiftKey,
          r = this.tabToNextCellCommon(e, i, t);
        if (!1 === r)
          if (i) {
            const {
              rowIndex: i,
              rowPinned: r
            } = e.getRowPosition();
            (r ? 0 === i : i === this.paginationProxy.getPageFirstRow()) && (0 === this.gos.get("headerHeight") || this.gos.get("suppressHeaderFocus") ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)))
          } else e instanceof ga && e.focusCell(!0), this.focusService.focusNextGridCoreContainer(i) && t.preventDefault();
        else r && t.preventDefault()
      }
      tabToNextCell(e, t) {
        const i = this.focusService.getFocusedCell();
        if (!i) return !1;
        let r = this.getCellByPosition(i);
        return !!(r || (r = this.rowRenderer.getRowByPosition(i), r && r.isFullWidth())) && !!this.tabToNextCellCommon(r, e, t)
      }
      tabToNextCellCommon(e, t, i) {
        let r, s = e.isEditing();
        if (!s && e instanceof ga) {
          const t = e.getRowCtrl();
          t && (s = t.isEditing())
        }
        return r = s ? "fullRow" === this.gos.get("editType") ? this.moveToNextEditingRow(e, t, i) : this.moveToNextEditingCell(e, t, i) : this.moveToNextCellNotEditing(e, t), null === r ? r : r || !!this.focusService.getFocusedHeader()
      }
      moveToNextEditingCell(e, t, i = null) {
        const r = e.getCellPosition();
        e.getGui().focus(), e.stopEditing();
        const s = this.findNextCellToFocusOn(r, t, !0);
        return !1 === s ? null : null != s && (s.startEditing(null, !0, i), s.focusCell(!1), !0)
      }
      moveToNextEditingRow(e, t, i = null) {
        const r = e.getCellPosition(),
          s = this.findNextCellToFocusOn(r, t, !0);
        if (!1 === s) return null;
        if (null == s) return !1;
        const n = s.getCellPosition(),
          o = this.isCellEditable(r),
          a = this.isCellEditable(n),
          l = n && r.rowIndex === n.rowIndex && r.rowPinned === n.rowPinned;
        if (o && e.setFocusOutOnEditor(), !l) {
          e.getRowCtrl().stopEditing();
          s.getRowCtrl().startRowEditing(void 0, void 0, i)
        }
        return a ? (s.setFocusInOnEditor(), s.focusCell()) : s.focusCell(!0), !0
      }
      moveToNextCellNotEditing(e, t) {
        const i = this.columnModel.getAllDisplayedColumns();
        let r;
        r = e instanceof ma ? T(f({}, e.getRowPosition()), {
          column: t ? i[0] : Me(i)
        }) : e.getCellPosition();
        const s = this.findNextCellToFocusOn(r, t, !1);
        if (!1 === s) return null;
        if (s instanceof ga) s.focusCell(!0);
        else if (s) return this.tryToFocusFullWidthRow(s.getRowPosition(), t);
        return v(s)
      }
      findNextCellToFocusOn(e, t, i) {
        var r;
        let s = e;
        for (;;) {
          e !== s && (e = s), t || (s = this.getLastCellOfColSpan(s)), s = this.cellNavigationService.getNextTabbedCell(s, t);
          const n = this.gos.getCallback("tabToNextCell");
          if (v(n)) {
            const r = n({
              backwards: t,
              editing: i,
              previousCellPosition: e,
              nextCellPosition: s || null
            });
            if (!0 === r || null === r) null === r && z("Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."), s = e;
            else {
              if (!1 === r) return !1;
              r.floating && (z("tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?"), r.rowPinned = r.floating), s = {
                rowIndex: r.rowIndex,
                column: r.column,
                rowPinned: r.rowPinned
              }
            }
          }
          if (!s) return null;
          if (s.rowIndex < 0) {
            const e = this.headerNavigationService.getHeaderRowCount();
            return this.focusService.focusHeaderPosition({
              headerPosition: {
                headerRowIndex: e + s.rowIndex,
                column: s.column
              },
              fromCell: !0
            }), null
          }
          const o = "fullRow" === this.gos.get("editType");
          if (i && !o) {
            if (!this.isCellEditable(s)) continue
          }
          this.ensureCellVisible(s);
          const a = this.getCellByPosition(s);
          if (!a) {
            const e = this.rowRenderer.getRowByPosition(s);
            if (!e || !e.isFullWidth() || i) continue;
            return e
          }
          if (!a.isSuppressNavigable()) return null == (r = this.rangeService) || r.setRangeToCell(s), a
        }
      }
      isCellEditable(e) {
        const t = this.lookupRowNodeForCell(e);
        return !!t && e.column.isCellEditable(t)
      }
      getCellByPosition(e) {
        const t = this.rowRenderer.getRowByPosition(e);
        return t ? t.getCellCtrl(e.column) : null
      }
      lookupRowNodeForCell(e) {
        return "top" === e.rowPinned ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : "bottom" === e.rowPinned ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.paginationProxy.getRow(e.rowIndex)
      }
      navigateToNextCell(e, t, i, r) {
        let s = i,
          n = !1;
        for (; s && (s === i || !this.isValidNavigateCell(s));) this.gos.get("enableRtl") ? t === ts.LEFT && (s = this.getLastCellOfColSpan(s)) : t === ts.RIGHT && (s = this.getLastCellOfColSpan(s)), s = this.cellNavigationService.getNextCellToFocus(t, s), n = N(s);
        if (n && e && e.key === ts.UP && (s = {
            rowIndex: -1,
            rowPinned: null,
            column: i.column
          }), r) {
          const r = this.gos.getCallback("navigateToNextCell");
          if (v(r)) {
            const n = r({
              key: t,
              previousCellPosition: i,
              nextCellPosition: s || null,
              event: e
            });
            v(n) ? (n.floating && (z("tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?"), n.rowPinned = n.floating), s = {
              rowPinned: n.rowPinned,
              rowIndex: n.rowIndex,
              column: n.column
            }) : s = null
          }
        }
        if (!s) return;
        if (s.rowIndex < 0) {
          const t = this.headerNavigationService.getHeaderRowCount();
          return void this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: t + s.rowIndex,
              column: i.column
            },
            event: e || void 0,
            fromCell: !0
          })
        }
        const o = this.getNormalisedPosition(s);
        o ? this.focusPosition(o) : this.tryToFocusFullWidthRow(s)
      }
      getNormalisedPosition(e) {
        this.ensureCellVisible(e);
        const t = this.getCellByPosition(e);
        return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null
      }
      tryToFocusFullWidthRow(e, t = !1) {
        const i = this.columnModel.getAllDisplayedColumns(),
          r = this.rowRenderer.getRowByPosition(e);
        if (!r || !r.isFullWidth()) return !1;
        const s = this.focusService.getFocusedCell(),
          n = {
            rowIndex: e.rowIndex,
            rowPinned: e.rowPinned,
            column: e.column || (t ? Me(i) : i[0])
          };
        this.focusPosition(n);
        const o = null != s && this.rowPositionUtils.before(n, s),
          a = {
            type: Et.EVENT_FULL_WIDTH_ROW_FOCUSED,
            rowIndex: n.rowIndex,
            rowPinned: n.rowPinned,
            column: n.column,
            isFullWidthCell: !0,
            floating: n.rowPinned,
            fromBelow: o
          };
        return this.eventService.dispatchEvent(a), !0
      }
      focusPosition(e) {
        var t;
        this.focusService.setFocusedCell({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0
        }), null == (t = this.rangeService) || t.setRangeToCell(e)
      }
      isValidNavigateCell(e) {
        return !!this.rowPositionUtils.getRowNode(e)
      }
      getLastCellOfColSpan(e) {
        const t = this.getCellByPosition(e);
        if (!t) return e;
        const i = t.getColSpanningList();
        return 1 === i.length ? e : {
          rowIndex: e.rowIndex,
          column: Me(i),
          rowPinned: e.rowPinned
        }
      }
      ensureCellVisible(e) {
        const t = this.gos.isGroupRowsSticky(),
          i = this.rowModel.getRow(e.rowIndex);
        !(t && (null == i ? void 0 : i.sticky)) && N(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column)
      }
    };
    C([fe("mouseEventService")], ba.prototype, "mouseEventService", 2), C([fe("paginationProxy")], ba.prototype, "paginationProxy", 2), C([fe("focusService")], ba.prototype, "focusService", 2), C([fe("columnModel")], ba.prototype, "columnModel", 2), C([fe("rowModel")], ba.prototype, "rowModel", 2), C([fe("ctrlsService")], ba.prototype, "ctrlsService", 2), C([fe("rowRenderer")], ba.prototype, "rowRenderer", 2), C([fe("headerNavigationService")], ba.prototype, "headerNavigationService", 2), C([fe("rowPositionUtils")], ba.prototype, "rowPositionUtils", 2), C([fe("cellNavigationService")], ba.prototype, "cellNavigationService", 2), C([fe("pinnedRowModel")], ba.prototype, "pinnedRowModel", 2), C([Te("rangeService")], ba.prototype, "rangeService", 2), C([pe], ba.prototype, "postConstruct", 1), ba = C([ge("navigationService")], ba);
    var Ma = class e extends Pn {
      constructor(e) {
        super('<div class="ag-popup-editor" tabindex="-1"/>'), this.params = e
      }
      postConstruct() {
        this.gos.setDomData(this.getGui(), e.DOM_KEY_POPUP_EDITOR_WRAPPER, !0), this.addKeyDownListener()
      }
      addKeyDownListener() {
        const e = this.getGui(),
          t = this.params;
        this.addManagedListener(e, "keydown", e => {
          cs(this.gos, e, t.node, t.column, !0) || t.onKeyDown(e)
        })
      }
    };
    Ma.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper", C([pe], Ma.prototype, "postConstruct", 1);
    var Fa = Ma,
      xa = class extends _s {
        constructor(e, t, i, r, s) {
          super(), this.rendererVersion = 0, this.editorVersion = 0, this.beans = e, this.column = t.getColumn(), this.rowNode = t.getRowNode(), this.rowCtrl = t.getRowCtrl(), this.eRow = r, this.cellCtrl = t;
          const n = document.createElement("div");
          n.setAttribute("comp-id", `${this.getCompId()}`), this.setTemplateFromElement(n);
          const o = this.getGui();
          this.forceWrapper = t.isForceWrapper(), this.refreshWrapper(!1);
          const a = (e, t) => {
            null != t && "" != t ? o.setAttribute(e, t) : o.removeAttribute(e)
          };
          Xt(o, t.getCellAriaRole()), a("col-id", t.getColumnIdSanitised());
          const l = t.getTabIndex();
          void 0 !== l && a("tabindex", l.toString());
          const c = {
            addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
            setUserStyles: e => Pr(o, e),
            getFocusableElement: () => this.getFocusableElement(),
            setIncludeSelection: e => this.includeSelection = e,
            setIncludeRowDrag: e => this.includeRowDrag = e,
            setIncludeDndSource: e => this.includeDndSource = e,
            setRenderDetails: (e, t, i) => this.setRenderDetails(e, t, i),
            setEditDetails: (e, t, i) => this.setEditDetails(e, t, i),
            getCellEditor: () => this.cellEditor || null,
            getCellRenderer: () => this.cellRenderer || null,
            getParentOfValue: () => this.getParentOfValue()
          };
          t.setComp(c, this.getGui(), this.eCellWrapper, i, s)
        }
        getParentOfValue() {
          return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui()
        }
        setRenderDetails(e, t, i) {
          if (this.cellEditor && !this.cellEditorPopupWrapper) return;
          this.firstRender = null == this.firstRender;
          const r = this.refreshWrapper(!1);
          if (this.refreshEditStyles(!1), e) {
            !(i || r) && this.refreshCellRenderer(e) || (this.destroyRenderer(), this.createCellRendererInstance(e))
          } else this.destroyRenderer(), this.insertValueWithoutCellRenderer(t)
        }
        setEditDetails(e, t, i) {
          e ? this.createCellEditorInstance(e, t, i) : this.destroyEditor()
        }
        removeControls() {
          this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp)
        }
        refreshWrapper(e) {
          const t = this.includeRowDrag || this.includeDndSource || this.includeSelection,
            i = t || this.forceWrapper,
            r = i && null == this.eCellWrapper;
          if (r) {
            const e = document.createElement("div");
            e.setAttribute("role", "presentation"), e.setAttribute("class", "ag-cell-wrapper"), this.eCellWrapper = e, this.getGui().appendChild(this.eCellWrapper)
          }
          const s = !i && null != this.eCellWrapper;
          s && (Ir(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !i);
          const n = !e && i,
            o = n && null == this.eCellValue;
          if (o) {
            const e = document.createElement("span");
            e.setAttribute("role", "presentation"), e.setAttribute("class", "ag-cell-value"), this.eCellValue = e, this.eCellWrapper.appendChild(this.eCellValue)
          }
          const a = !n && null != this.eCellValue;
          a && (Ir(this.eCellValue), this.eCellValue = void 0);
          const l = r || s || o || a;
          return l && this.removeControls(), e || t && this.addControls(), l
        }
        addControls() {
          this.includeRowDrag && null == this.rowDraggingComp && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && null == this.dndSourceComp && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && null == this.checkboxSelectionComp && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue))
        }
        createCellEditorInstance(e, t, i) {
          const r = this.editorVersion,
            s = e.newAgStackInstance();
          if (!s) return;
          const {
            params: n
          } = e;
          s.then(e => this.afterCellEditorCreated(r, e, n, t, i));
          N(this.cellEditor) && n.cellStartedEdit && this.cellCtrl.focusCell(!0)
        }
        insertValueWithoutCellRenderer(e) {
          const t = this.getParentOfValue();
          Nr(t);
          const i = null != e ? Nt(e, !0) : null;
          null != i && (t.textContent = i)
        }
        destroyEditorAndRenderer() {
          this.destroyRenderer(), this.destroyEditor()
        }
        destroyRenderer() {
          const {
            context: e
          } = this.beans;
          this.cellRenderer = e.destroyBean(this.cellRenderer), Ir(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++
        }
        destroyEditor() {
          const {
            context: e
          } = this.beans;
          this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = e.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = e.destroyBean(this.cellEditorPopupWrapper), Ir(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++
        }
        refreshCellRenderer(e) {
          if (null == this.cellRenderer || null == this.cellRenderer.refresh) return !1;
          if (this.cellRendererClass !== e.componentClass) return !1;
          const t = this.cellRenderer.refresh(e.params);
          return !0 === t || void 0 === t
        }
        createCellRendererInstance(e) {
          const t = !this.beans.gos.get("suppressAnimationFrame"),
            i = this.rendererVersion,
            {
              componentClass: r
            } = e,
            s = () => {
              if (this.rendererVersion !== i || !this.isAlive()) return;
              const t = e.newAgStackInstance(),
                s = this.afterCellRendererCreated.bind(this, i, r);
              t && t.then(s)
            };
          t && this.firstRender ? this.beans.animationFrameService.createTask(s, this.rowNode.rowIndex, "createTasksP2") : s()
        }
        getCtrl() {
          return this.cellCtrl
        }
        getRowCtrl() {
          return this.rowCtrl
        }
        getCellRenderer() {
          return this.cellRenderer
        }
        getCellEditor() {
          return this.cellEditor
        }
        afterCellRendererCreated(e, t, i) {
          if (!this.isAlive() || e !== this.rendererVersion) this.beans.context.destroyBean(i);
          else if (this.cellRenderer = i, this.cellRendererClass = t, this.cellRendererGui = this.cellRenderer.getGui(), null != this.cellRendererGui) {
            const e = this.getParentOfValue();
            Nr(e), e.appendChild(this.cellRendererGui)
          }
        }
        afterCellEditorCreated(e, t, i, r, s) {
          if (e !== this.editorVersion) return void this.beans.context.destroyBean(t);
          if (t.isCancelBeforeStart && t.isCancelBeforeStart()) return this.beans.context.destroyBean(t), void this.cellCtrl.stopEditing(!0);
          if (!t.getGui) return console.warn(`AG Grid: cellEditor for column ${this.column.getId()} is missing getGui() method`), void this.beans.context.destroyBean(t);
          this.cellEditor = t, this.cellEditorGui = t.getGui();
          const n = r || void 0 !== t.isPopup && t.isPopup();
          n ? this.addPopupCellEditor(i, s) : this.addInCellEditor(), this.refreshEditStyles(!0, n), t.afterGuiAttached && t.afterGuiAttached()
        }
        refreshEditStyles(e, t) {
          var i;
          this.addOrRemoveCssClass("ag-cell-inline-editing", e && !t), this.addOrRemoveCssClass("ag-cell-popup-editing", e && !!t), this.addOrRemoveCssClass("ag-cell-not-inline-editing", !e || !!t), null == (i = this.rowCtrl) || i.setInlineEditingCss(e)
        }
        addInCellEditor() {
          const e = this.getGui();
          if (e.contains(this.beans.gos.getActiveDomElement()) && e.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui) {
            this.getParentOfValue().appendChild(this.cellEditorGui)
          }
        }
        addPopupCellEditor(e, t) {
          "fullRow" === this.beans.gos.get("editType") && console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
          const i = this.cellEditor;
          this.cellEditorPopupWrapper = this.beans.context.createBean(new Fa(e));
          const r = this.cellEditorPopupWrapper.getGui();
          this.cellEditorGui && r.appendChild(this.cellEditorGui);
          const s = this.beans.popupService,
            n = this.beans.gos.get("stopEditingWhenCellsLoseFocus"),
            o = null != t ? t : i.getPopupPosition ? i.getPopupPosition() : "over",
            a = this.beans.gos.get("enableRtl"),
            l = {
              ePopup: r,
              column: this.column,
              rowNode: this.rowNode,
              type: "popupCellEditor",
              eventSource: this.getGui(),
              position: o,
              alignSide: a ? "right" : "left",
              keepWithinBounds: !0
            },
            c = s.positionPopupByComponent.bind(s, l),
            h = this.beans.localeService.getLocaleTextFunc(),
            u = s.addPopup({
              modal: n,
              eChild: r,
              closeOnEsc: !0,
              closedCallback: () => {
                this.cellCtrl.onPopupEditorClosed()
              },
              anchorToElement: this.getGui(),
              positionCallback: c,
              ariaLabel: h("ariaLabelCellEditor", "Cell Editor")
            });
          u && (this.hideEditorPopup = u.hideFunc)
        }
        detach() {
          this.eRow.removeChild(this.getGui())
        }
        destroy() {
          this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), super.destroy()
        }
        clearParentOfValue() {
          const e = this.getGui();
          e.contains(this.beans.gos.getActiveDomElement()) && Ui() && e.focus({
            preventScroll: !0
          }), Nr(this.getParentOfValue())
        }
      },
      Ga = class extends _s {
        constructor(e, t, i) {
          super(), this.cellComps = {}, this.beans = t, this.rowCtrl = e;
          const r = document.createElement("div");
          r.setAttribute("comp-id", `${this.getCompId()}`), r.setAttribute("style", this.getInitialStyle(i)), this.setTemplateFromElement(r);
          const s = this.getGui(),
            n = s.style;
          this.domOrder = this.rowCtrl.getDomOrder(), Xt(s, "row");
          const o = this.rowCtrl.getTabIndex();
          null != o && s.setAttribute("tabindex", o.toString());
          const a = {
            setDomOrder: e => this.domOrder = e,
            setCellCtrls: e => this.setCellCtrls(e),
            showFullWidth: e => this.showFullWidth(e),
            getFullWidthCellRenderer: () => this.getFullWidthCellRenderer(),
            addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
            setUserStyles: e => Pr(s, e),
            setTop: e => n.top = e,
            setTransform: e => n.transform = e,
            setRowIndex: e => s.setAttribute("row-index", e),
            setRowId: e => s.setAttribute("row-id", e),
            setRowBusinessKey: e => s.setAttribute("row-business-key", e),
            refreshFullWidth: e => this.refreshFullWidth(e)
          };
          e.setComp(a, this.getGui(), i), this.addDestroyFunc(() => {
            e.unsetComp(i)
          })
        }
        getInitialStyle(e) {
          const t = this.rowCtrl.getInitialTransform(e);
          return t ? `transform: ${t}` : `top: ${this.rowCtrl.getInitialRowTop(e)}`
        }
        showFullWidth(e) {
          const t = e.newAgStackInstance();
          t && t.then(e => {
            if (this.isAlive()) {
              const t = e.getGui();
              this.getGui().appendChild(t), this.rowCtrl.setupDetailRowAutoHeight(t), this.setFullWidthRowComp(e)
            } else this.beans.context.destroyBean(e)
          })
        }
        setCellCtrls(e) {
          const t = Object.assign({}, this.cellComps);
          e.forEach(e => {
            const i = e.getInstanceId();
            null == this.cellComps[i] ? this.newCellComp(e) : t[i] = null
          });
          const i = H(t).filter(e => null != e);
          this.destroyCells(i), this.ensureDomOrder(e)
        }
        ensureDomOrder(e) {
          if (!this.domOrder) return;
          const t = [];
          e.forEach(e => {
            const i = this.cellComps[e.getInstanceId()];
            i && t.push(i.getGui())
          }), wr(this.getGui(), t)
        }
        newCellComp(e) {
          const t = new xa(this.beans, e, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
          this.cellComps[e.getInstanceId()] = t, this.getGui().appendChild(t.getGui())
        }
        destroy() {
          super.destroy(), this.destroyAllCells()
        }
        destroyAllCells() {
          const e = H(this.cellComps).filter(e => null != e);
          this.destroyCells(e)
        }
        setFullWidthRowComp(e) {
          this.fullWidthCellRenderer && console.error("AG Grid - should not be setting fullWidthRowComponent twice"), this.fullWidthCellRenderer = e, this.addDestroyFunc(() => {
            this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer)
          })
        }
        getFullWidthCellRenderer() {
          return this.fullWidthCellRenderer
        }
        destroyCells(e) {
          e.forEach(e => {
            if (!e) return;
            const t = e.getCtrl().getInstanceId();
            this.cellComps[t] === e && (e.detach(), e.destroy(), this.cellComps[t] = null)
          })
        }
        refreshFullWidth(e) {
          const {
            fullWidthCellRenderer: t
          } = this;
          if (!t || !t.refresh) return !1;
          const i = e();
          return t.refresh(i)
        }
      };
    var Ua = class extends _s {
      constructor() {
        super(function() {
          const e = _s.elementGettingCreated.getAttribute("name"),
            t = ya.getRowContainerCssClasses(e);
          let i;
          return i = "center" === e || "topCenter" === e || "stickyTopCenter" === e || "bottomCenter" === e || "stickyBottomCenter" === e ? `<div class="${t.viewport}" ref="eViewport" role="presentation">\n                <div class="${t.container}" ref="eContainer"></div>\n            </div>` : `<div class="${t.container}" ref="eContainer"></div>`, i
        }()), this.rowComps = {}, this.name = _s.elementGettingCreated.getAttribute("name"), this.type = function(e) {
          switch (e) {
            case "center":
            case "topCenter":
            case "stickyTopCenter":
            case "bottomCenter":
            case "stickyBottomCenter":
              return "center";
            case "left":
            case "topLeft":
            case "stickyTopLeft":
            case "bottomLeft":
            case "stickyBottomLeft":
              return "left";
            case "right":
            case "topRight":
            case "stickyTopRight":
            case "bottomRight":
            case "stickyBottomRight":
              return "right";
            case "fullWidth":
            case "topFullWidth":
            case "stickyTopFullWidth":
            case "bottomFullWidth":
            case "stickyBottomFullWidth":
              return "fullWidth";
            default:
              throw Error("Invalid Row Container Type")
          }
        }(this.name)
      }
      postConstruct() {
        const e = {
          setViewportHeight: e => this.eViewport.style.height = e,
          setRowCtrls: ({
            rowCtrls: e
          }) => this.setRowCtrls(e),
          setDomOrder: e => {
            this.domOrder = e
          },
          setContainerWidth: e => this.eContainer.style.width = e
        };
        this.createManagedBean(new ya(this.name)).setComp(e, this.eContainer, this.eViewport)
      }
      preDestroy() {
        this.setRowCtrls([])
      }
      setRowCtrls(e) {
        const t = f({}, this.rowComps);
        this.rowComps = {}, this.lastPlacedElement = null;
        e.forEach(e => {
          const i = e.getInstanceId(),
            r = t[i];
          if (r) this.rowComps[i] = r, delete t[i], this.ensureDomOrder(r.getGui());
          else {
            if (!e.getRowNode().displayed) return;
            const t = new Ga(e, this.beans, this.type);
            this.rowComps[i] = t, this.appendRow(t.getGui())
          }
        }), H(t).forEach(e => {
          this.eContainer.removeChild(e.getGui()), e.destroy()
        }), Xt(this.eContainer, "rowgroup")
      }
      appendRow(e) {
        this.domOrder ? Dr(this.eContainer, e, this.lastPlacedElement) : this.eContainer.appendChild(e), this.lastPlacedElement = e
      }
      ensureDomOrder(e) {
        this.domOrder && (yr(this.eContainer, e, this.lastPlacedElement), this.lastPlacedElement = e)
      }
    };
    C([fe("beans")], Ua.prototype, "beans", 2), C([ys("eViewport")], Ua.prototype, "eViewport", 2), C([ys("eContainer")], Ua.prototype, "eContainer", 2), C([pe], Ua.prototype, "postConstruct", 1), C([Ee], Ua.prototype, "preDestroy", 1);
    var Ha = class {
      constructor(e) {
        this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e
      }
      onDragEnter(e) {
        if (this.clearColumnsList(), this.gos.get("functionsReadOnly")) return;
        const t = e.dragItem.columns;
        t && t.forEach(e => {
          e.isPrimary() && (e.isAnyFunctionActive() || (e.isAllowValue() ? this.columnsToAggregate.push(e) : e.isAllowRowGroup() ? this.columnsToGroup.push(e) : e.isAllowPivot() && this.columnsToPivot.push(e)))
        })
      }
      getIconName() {
        return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? Kn.ICON_PINNED : Kn.ICON_MOVE : null
      }
      onDragLeave(e) {
        this.clearColumnsList()
      }
      clearColumnsList() {
        this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0
      }
      onDragging(e) {}
      onDragStop(e) {
        this.columnsToAggregate.length > 0 && this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop")
      }
    };
    C([fe("columnModel")], Ha.prototype, "columnModel", 2), C([fe("gridOptionsService")], Ha.prototype, "gos", 2);
    var ka = class {
        static attemptMoveColumns(e) {
          const {
            isFromHeader: t,
            hDirection: i,
            xPosition: r,
            fromEnter: s,
            fakeEvent: n,
            pinned: o,
            gos: a,
            columnModel: l
          } = e, c = 0 === i, h = 1 === i;
          let {
            allMovingColumns: u
          } = e;
          if (t) {
            let e = [];
            u.forEach(t => {
              var i;
              let r = null,
                s = t.getParent();
              for (; null != s && 1 === s.getDisplayedLeafColumns().length;) r = s, s = s.getParent();
              if (null != r) {
                (!!(null == (i = r.getColGroupDef()) ? void 0 : i.marryChildren) ? r.getProvidedColumnGroup().getLeafColumns() : r.getLeafColumns()).forEach(t => {
                  e.includes(t) || e.push(t)
                })
              } else e.includes(t) || e.push(t)
            }), u = e
          }
          const d = u.slice();
          l.sortColumnsLikeGridColumns(d);
          const p = this.calculateValidMoves({
              movingCols: d,
              draggingRight: h,
              xPosition: r,
              pinned: o,
              gos: a,
              columnModel: l
            }),
            E = this.calculateOldIndex(d, l);
          if (0 === p.length) return;
          const g = p[0];
          let f = null !== E && !s;
          if (t && (f = null !== E), f && !n) {
            if (c && g >= E) return;
            if (h && g <= E) return
          }
          const T = l.getAllDisplayedColumns();
          let m = [],
            C = null;
          for (let e = 0; e < p.length; e++) {
            const t = p[e],
              i = l.getProposedColumnOrder(d, t);
            if (!l.doesOrderPassRules(i)) continue;
            const r = i.filter(e => T.includes(e));
            if (null === C) C = r;
            else if (!Fe(r, C)) break;
            const s = this.groupFragCount(i);
            m.push({
              move: t,
              fragCount: s
            })
          }
          return 0 !== m.length ? (m.sort((e, t) => e.fragCount - t.fragCount), this.moveColumns(u, m[0].move, "uiColumnMoved", !1, l)) : void 0
        }
        static moveColumns(e, t, i, r, s) {
          return s.moveColumns(e, t, i, r), r ? null : {
            columns: e,
            toIndex: t
          }
        }
        static calculateOldIndex(e, t) {
          const i = t.getAllGridColumns(),
            r = Ge(e.map(e => i.indexOf(e))),
            s = r[0];
          return Me(r) - s !== r.length - 1 ? null : s
        }
        static groupFragCount(e) {
          function t(e) {
            let t = [],
              i = e.getOriginalParent();
            for (; null != i;) t.push(i), i = i.getOriginalParent();
            return t
          }
          let i = 0;
          for (let r = 0; r < e.length - 1; r++) {
            let s = t(e[r]),
              n = t(e[r + 1]);
            [s, n] = s.length > n.length ? [s, n] : [n, s], s.forEach(e => {
              -1 === n.indexOf(e) && i++
            })
          }
          return i
        }
        static getDisplayedColumns(e, t) {
          switch (t) {
            case "left":
              return e.getDisplayedLeftColumns();
            case "right":
              return e.getDisplayedRightColumns();
            default:
              return e.getDisplayedCenterColumns()
          }
        }
        static calculateValidMoves(e) {
          const {
            movingCols: t,
            draggingRight: i,
            xPosition: r,
            pinned: s,
            gos: n,
            columnModel: o
          } = e;
          if (n.get("suppressMovableColumns") || t.some(e => e.getColDef().suppressMovable)) return [];
          const a = this.getDisplayedColumns(o, s),
            l = o.getAllGridColumns(),
            c = a.filter(e => Xe(t, e)),
            h = a.filter(e => !Xe(t, e)),
            u = l.filter(e => !Xe(t, e));
          let d, p = 0,
            E = r;
          if (i) {
            let e = 0;
            c.forEach(t => e += t.getActualWidth()), E -= e
          }
          if (E > 0) {
            for (let e = 0; e < h.length; e++) {
              if (E -= h[e].getActualWidth(), E < 0) break;
              p++
            }
            i && p++
          }
          if (p > 0) {
            const e = h[p - 1];
            d = u.indexOf(e) + 1
          } else d = u.indexOf(h[0]), -1 === d && (d = 0);
          const g = [d],
            f = (e, t) => e - t;
          if (i) {
            let e = d + 1;
            const t = l.length - 1;
            for (; e <= t;) g.push(e), e++;
            g.sort(f)
          } else {
            let e = d;
            const t = l.length - 1;
            let i = l[e];
            for (; e <= t && a.indexOf(i) < 0;) e++, g.push(e), i = l[e];
            e = d - 1;
            const r = 0;
            for (; e >= r;) g.push(e), e--;
            g.sort(f).reverse()
          }
          return g
        }
        static normaliseX(e, t, i, r, s) {
          const n = s.getHeaderRowContainerCtrl(t).getViewport();
          if (i && (e -= n.getBoundingClientRect().left), r.get("enableRtl")) {
            e = n.clientWidth - e
          }
          return null == t && (e += s.get("center").getCenterViewportScrollLeft()), e
        }
      },
      Ba = class {
        constructor(e) {
          this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !v(e)
        }
        init() {
          this.ctrlsService.whenReady(e => {
            this.gridBodyCon = e.gridBodyCtrl
          })
        }
        getIconName() {
          return this.pinned ? Kn.ICON_PINNED : Kn.ICON_MOVE
        }
        onDragEnter(e) {
          const t = e.dragItem.columns;
          if (0 === e.dragSource.type) this.setColumnsVisible(t, !0, "uiColumnDragged");
          else {
            const i = e.dragItem.visibleState,
              r = (t || []).filter(e => i[e.getId()]);
            this.setColumnsVisible(r, !0, "uiColumnDragged")
          }
          this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0, !0)
        }
        onDragLeave() {
          this.ensureIntervalCleared(), this.lastMovedInfo = null
        }
        setColumnsVisible(e, t, i) {
          if (e) {
            const r = e.filter(e => !e.getColDef().lockVisible);
            this.columnModel.setColumnsVisible(r, t, i)
          }
        }
        setColumnsPinned(e, t, i) {
          if (e) {
            const r = e.filter(e => !e.getColDef().lockPinned);
            this.columnModel.setColumnsPinned(r, t, i)
          }
        }
        onDragStop() {
          this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null
        }
        checkCenterForScrolling(e) {
          if (this.isCenterContainer) {
            const t = this.ctrlsService.get("center"),
              i = t.getCenterViewportScrollLeft(),
              r = i + t.getCenterWidth();
            this.gos.get("enableRtl") ? (this.needToMoveRight = e < i + 50, this.needToMoveLeft = e > r - 50) : (this.needToMoveLeft = e < i + 50, this.needToMoveRight = e > r - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared()
          }
        }
        onDragging(e = this.lastDraggingEvent, t = !1, i = !1, r = !1) {
          var s;
          if (r) {
            if (this.lastMovedInfo) {
              const {
                columns: e,
                toIndex: t
              } = this.lastMovedInfo;
              ka.moveColumns(e, t, "uiColumnMoved", !0, this.columnModel)
            }
            return
          }
          if (this.lastDraggingEvent = e, N(e.hDirection)) return;
          const n = ka.normaliseX(e.x, this.pinned, !1, this.gos, this.ctrlsService);
          t || this.checkCenterForScrolling(n);
          const o = this.normaliseDirection(e.hDirection),
            a = e.dragSource.type,
            l = (null == (s = e.dragSource.getDragItem().columns) ? void 0 : s.filter(e => !e.getColDef().lockPinned || e.getPinned() == this.pinned)) || [],
            c = ka.attemptMoveColumns({
              allMovingColumns: l,
              isFromHeader: 1 === a,
              hDirection: o,
              xPosition: n,
              pinned: this.pinned,
              fromEnter: t,
              fakeEvent: i,
              gos: this.gos,
              columnModel: this.columnModel
            });
          c && (this.lastMovedInfo = c)
        }
        normaliseDirection(e) {
          if (!this.gos.get("enableRtl")) return e;
          switch (e) {
            case 0:
              return 1;
            case 1:
              return 0;
            default:
              console.error(`AG Grid: Unknown direction ${e}`)
          }
        }
        ensureIntervalStarted() {
          this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.needToMoveLeft ? this.dragAndDropService.setGhostIcon(Kn.ICON_LEFT, !0) : this.dragAndDropService.setGhostIcon(Kn.ICON_RIGHT, !0))
        }
        ensureIntervalCleared() {
          this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon(Kn.ICON_MOVE))
        }
        moveInterval() {
          let e;
          this.intervalCount++, e = 10 + 5 * this.intervalCount, e > 100 && (e = 100);
          let t = null;
          const i = this.gridBodyCon.getScrollFeature();
          if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), 0 !== t) this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
          else {
            this.failedMoveAttempts++;
            const e = this.lastDraggingEvent.dragItem.columns.filter(e => !e.getColDef().lockPinned);
            if (e.length > 0 && (this.dragAndDropService.setGhostIcon(Kn.ICON_PINNED), this.failedMoveAttempts > 7)) {
              const t = this.needToMoveLeft ? "left" : "right";
              this.setColumnsPinned(e, t, "uiColumnDragged"), this.dragAndDropService.nudge()
            }
          }
        }
      };
    C([fe("columnModel")], Ba.prototype, "columnModel", 2), C([fe("dragAndDropService")], Ba.prototype, "dragAndDropService", 2), C([fe("gridOptionsService")], Ba.prototype, "gos", 2), C([fe("ctrlsService")], Ba.prototype, "ctrlsService", 2), C([pe], Ba.prototype, "init", 1);
    var Va = class extends ct {
      constructor(e, t) {
        super(), this.pinned = e, this.eContainer = t
      }
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          switch (this.pinned) {
            case "left":
              this.eSecondaryContainers = [
                [e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()],
                [e.bottomLeft.getContainerElement()],
                [e.topLeft.getContainerElement()]
              ];
              break;
            case "right":
              this.eSecondaryContainers = [
                [e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()],
                [e.bottomRight.getContainerElement()],
                [e.topRight.getContainerElement()]
              ];
              break;
            default:
              this.eSecondaryContainers = [
                [e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()],
                [e.bottomCenter.getViewportElement()],
                [e.topCenter.getViewportElement()]
              ]
          }
        })
      }
      isInterestedIn(e) {
        return 1 === e || 0 === e && this.gos.get("allowDragFromColumnsToolPanel")
      }
      getSecondaryContainers() {
        return this.eSecondaryContainers
      }
      getContainer() {
        return this.eContainer
      }
      init() {
        this.moveColumnFeature = this.createManagedBean(new Ba(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new Ha(this.pinned)), this.dragAndDropService.addDropTarget(this)
      }
      getIconName() {
        return this.currentDropListener.getIconName()
      }
      isDropColumnInPivotMode(e) {
        return this.columnModel.isPivotMode() && 0 === e.dragSource.type
      }
      onDragEnter(e) {
        this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e)
      }
      onDragLeave(e) {
        this.currentDropListener.onDragLeave(e)
      }
      onDragging(e) {
        this.currentDropListener.onDragging(e)
      }
      onDragStop(e) {
        this.currentDropListener.onDragStop(e)
      }
    };
    C([fe("dragAndDropService")], Va.prototype, "dragAndDropService", 2), C([fe("columnModel")], Va.prototype, "columnModel", 2), C([fe("ctrlsService")], Va.prototype, "ctrlsService", 2), C([pe], Va.prototype, "postConstruct", 1), C([pe], Va.prototype, "init", 1);
    var Wa = class e extends qo {
      constructor(t) {
        super(e.TEMPLATE, t), this.headerCompVersion = 0, this.column = t.getColumnGroupChild(), this.pinned = t.getPinned()
      }
      postConstruct() {
        const e = this.getGui();
        var t, i;
        t = "col-id", null != (i = this.column.getColId()) && "" != i ? e.setAttribute(t, i) : e.removeAttribute(t);
        const r = {
          setWidth: t => e.style.width = t,
          addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
          setAriaSort: t => t ? Ti(e, t) : mi(e),
          setUserCompDetails: e => this.setUserCompDetails(e),
          getUserCompInstance: () => this.headerComp
        };
        this.ctrl.setComp(r, this.getGui(), this.eResize, this.eHeaderCompWrapper);
        const s = this.ctrl.getSelectAllGui();
        this.eResize.insertAdjacentElement("afterend", s)
      }
      destroyHeaderComp() {
        this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0)
      }
      setUserCompDetails(e) {
        this.headerCompVersion++;
        const t = this.headerCompVersion;
        e.newAgStackInstance().then(e => this.afterCompCreated(t, e))
      }
      afterCompCreated(e, t) {
        e == this.headerCompVersion && this.isAlive() ? (this.destroyHeaderComp(), this.headerComp = t, this.headerCompGui = t.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui())) : this.destroyBean(t)
      }
    };
    Wa.TEMPLATE = '<div class="ag-header-cell" role="columnheader">\n            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>\n            <div ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>\n        </div>', C([ys("eResize")], Wa.prototype, "eResize", 2), C([ys("eHeaderCompWrapper")], Wa.prototype, "eHeaderCompWrapper", 2), C([pe], Wa.prototype, "postConstruct", 1), C([Ee], Wa.prototype, "destroyHeaderComp", 1);
    var Ya = Wa,
      Ka = class e extends qo {
        constructor(t) {
          super(e.TEMPLATE, t)
        }
        postConstruct() {
          const e = this.getGui();
          e.setAttribute("col-id", this.ctrl.getColId());
          const t = {
            addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
            setResizableDisplayed: e => ur(this.eResize, e),
            setWidth: t => e.style.width = t,
            setAriaExpanded: t => {
              return i = "aria-expanded", null != (r = t) ? e.setAttribute(i, r) : e.removeAttribute(i);
              var i, r
            },
            setUserCompDetails: e => this.setUserCompDetails(e),
            getUserCompInstance: () => this.headerGroupComp
          };
          this.ctrl.setComp(t, e, this.eResize)
        }
        setUserCompDetails(e) {
          e.newAgStackInstance().then(e => this.afterHeaderCompCreated(e))
        }
        afterHeaderCompCreated(e) {
          const t = () => this.destroyBean(e);
          if (!this.isAlive()) return void t();
          const i = this.getGui(),
            r = e.getGui();
          i.appendChild(r), this.addDestroyFunc(t), this.headerGroupComp = e, this.ctrl.setDragSource(i)
        }
      };
    Ka.TEMPLATE = '<div class="ag-header-group-cell" role="columnheader">\n            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>\n        </div>', C([ys("eResize")], Ka.prototype, "eResize", 2), C([pe], Ka.prototype, "postConstruct", 1);
    var Xa = Ka,
      za = class extends _s {
        constructor(e) {
          super(), this.headerComps = {}, this.ctrl = e, this.setTemplate(`<div class="${this.ctrl.getHeaderRowClass()}" role="row"></div>`)
        }
        init() {
          pi(this.getGui(), this.ctrl.getAriaRowIndex());
          const e = {
            setHeight: e => this.getGui().style.height = e,
            setTop: e => this.getGui().style.top = e,
            setHeaderCtrls: (e, t) => this.setHeaderCtrls(e, t),
            setWidth: e => this.getGui().style.width = e
          };
          this.ctrl.setComp(e)
        }
        destroyHeaderCtrls() {
          this.setHeaderCtrls([], !1)
        }
        setHeaderCtrls(e, t) {
          if (!this.isAlive()) return;
          const i = this.headerComps;
          if (this.headerComps = {}, e.forEach(e => {
              const t = e.getInstanceId();
              let r = i[t];
              delete i[t], null == r && (r = this.createHeaderComp(e), this.getGui().appendChild(r.getGui())), this.headerComps[t] = r
            }), x(i, (e, t) => {
              this.getGui().removeChild(t.getGui()), this.destroyBean(t)
            }), t) {
            const e = H(this.headerComps);
            e.sort((e, t) => e.getCtrl().getColumnGroupChild().getLeft() - t.getCtrl().getColumnGroupChild().getLeft());
            const t = e.map(e => e.getGui());
            wr(this.getGui(), t)
          }
        }
        createHeaderComp(e) {
          let t;
          switch (this.ctrl.getType()) {
            case "group":
              t = new Xa(e);
              break;
            case "filter":
              t = new Zo(e);
              break;
            default:
              t = new Ya(e)
          }
          return this.createBean(t), t.setParentComponent(this), t
        }
      };
    C([pe], za.prototype, "init", 1), C([Ee], za.prototype, "destroyHeaderCtrls", 1);
    var $a = 0,
      ja = class e extends ct {
        constructor(e, t, i) {
          super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = e, this.parentRowCtrl = i, this.beans = t, this.instanceId = e.getUniqueId() + "-" + $a++
        }
        postConstruct() {
          this.addManagedPropertyListeners(["suppressHeaderFocus"], () => this.refreshTabIndex())
        }
        shouldStopEventPropagation(e) {
          const {
            headerRowIndex: t,
            column: i
          } = this.focusService.getFocusedHeader();
          return hs(this.gos, e, t, i)
        }
        getWrapperHasFocus() {
          return this.gos.getActiveDomElement() === this.eGui
        }
        setGui(e) {
          this.eGui = e, this.addDomData(), this.addManagedListener(this.beans.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.onDisplayedColumnsChanged(), this.refreshTabIndex()
        }
        onDisplayedColumnsChanged() {
          this.comp && this.column && (this.refreshFirstAndLastStyles(), this.refreshAriaColIndex())
        }
        refreshFirstAndLastStyles() {
          const {
            comp: e,
            column: t,
            beans: i
          } = this;
          da.refreshFirstAndLastStyles(e, t, i.columnModel)
        }
        refreshAriaColIndex() {
          const {
            beans: e,
            column: t
          } = this, i = e.columnModel.getAriaColumnIndex(t);
          gi(this.eGui, i)
        }
        addResizeAndMoveKeyboardListeners() {
          this.resizeFeature && (this.addManagedListener(this.eGui, "keydown", this.onGuiKeyDown.bind(this)), this.addManagedListener(this.eGui, "keyup", this.onGuiKeyUp.bind(this)))
        }
        refreshTabIndex() {
          this.gos.get("suppressHeaderFocus") ? this.eGui.removeAttribute("tabindex") : this.eGui.setAttribute("tabindex", "-1")
        }
        onGuiKeyDown(e) {
          var t;
          const i = this.gos.getActiveDomElement(),
            r = e.key === ts.LEFT || e.key === ts.RIGHT;
          if (this.isResizing && (e.preventDefault(), e.stopImmediatePropagation()), i !== this.eGui || !e.shiftKey && !e.altKey) return;
          if ((this.isResizing || r) && (e.preventDefault(), e.stopImmediatePropagation()), !r) return;
          const s = e.key === ts.LEFT !== this.gos.get("enableRtl"),
            n = Yn[s ? "Left" : "Right"];
          if (e.altKey) {
            this.isResizing = !0, this.resizeMultiplier += 1;
            const i = this.getViewportAdjustedResizeDiff(e);
            this.resizeHeader(i, e.shiftKey), null == (t = this.resizeFeature) || t.toggleColumnResizing(!0)
          } else this.moveHeader(n)
        }
        getViewportAdjustedResizeDiff(e) {
          let t = this.getResizeDiff(e);
          if (this.column.getPinned()) {
            const e = this.pinnedWidthService.getPinnedLeftWidth(),
              i = this.pinnedWidthService.getPinnedRightWidth(),
              r = Tr(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
            if (e + i + t > r) {
              if (!(r > e + i)) return 0;
              t = r - e - i
            }
          }
          return t
        }
        getResizeDiff(e) {
          let t = e.key === ts.LEFT !== this.gos.get("enableRtl");
          const i = this.column.getPinned(),
            r = this.gos.get("enableRtl");
          return i && r !== ("right" === i) && (t = !t), (t ? -1 : 1) * this.resizeMultiplier
        }
        onGuiKeyUp() {
          this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = setTimeout(() => {
            var e;
            null == (e = this.resizeFeature) || e.toggleColumnResizing(!1)
          }, 150))
        }
        handleKeyDown(e) {
          const t = this.getWrapperHasFocus();
          switch (e.key) {
            case ts.PAGE_DOWN:
            case ts.PAGE_UP:
            case ts.PAGE_HOME:
            case ts.PAGE_END:
              t && e.preventDefault()
          }
        }
        addDomData() {
          const t = e.DOM_DATA_KEY_HEADER_CTRL;
          this.gos.setDomData(this.eGui, t, this), this.addDestroyFunc(() => this.gos.setDomData(this.eGui, t, null))
        }
        getGui() {
          return this.eGui
        }
        focus(e) {
          return !!this.eGui && (this.lastFocusEvent = e || null, this.eGui.focus(), !0)
        }
        getRowIndex() {
          return this.parentRowCtrl.getRowIndex()
        }
        getParentRowCtrl() {
          return this.parentRowCtrl
        }
        getPinned() {
          return this.parentRowCtrl.getPinned()
        }
        getInstanceId() {
          return this.instanceId
        }
        getColumnGroupChild() {
          return this.columnGroupChild
        }
        removeDragSource() {
          this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null)
        }
        handleContextMenuMouseEvent(e, t, i) {
          const r = null != e ? e : t;
          this.gos.get("preventDefaultOnContextMenu") && r.preventDefault();
          const s = i instanceof Le ? i : void 0;
          this.menuService.isHeaderContextMenuEnabled(s) && this.menuService.showHeaderContextMenu(s, e, t), this.dispatchColumnMouseEvent(Et.EVENT_COLUMN_HEADER_CONTEXT_MENU, i)
        }
        dispatchColumnMouseEvent(e, t) {
          const i = {
            type: e,
            column: t
          };
          this.eventService.dispatchEvent(i)
        }
        destroy() {
          super.destroy(), this.removeDragSource(), this.comp = null, this.column = null, this.resizeFeature = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null, this.eGui = null
        }
      };
    ja.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl", C([fe("pinnedWidthService")], ja.prototype, "pinnedWidthService", 2), C([fe("focusService")], ja.prototype, "focusService", 2), C([fe("userComponentFactory")], ja.prototype, "userComponentFactory", 2), C([fe("ctrlsService")], ja.prototype, "ctrlsService", 2), C([fe("dragAndDropService")], ja.prototype, "dragAndDropService", 2), C([fe("menuService")], ja.prototype, "menuService", 2), C([pe], ja.prototype, "postConstruct", 1);
    var Ja = ja,
      qa = class extends ct {
        constructor(e, t, i, r) {
          super(), this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = r, this.beans = i
        }
        setColsSpanning(e) {
          this.colsSpanning = e, this.onLeftChanged()
        }
        getColumnOrGroup() {
          return this.beans.gos.get("enableRtl") && this.colsSpanning ? Me(this.colsSpanning) : this.columnOrGroup
        }
        postConstruct() {
          this.addManagedListener(this.columnOrGroup, Le.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this)), this.setLeftFirstTime(), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onLeftChanged.bind(this))
        }
        setLeftFirstTime() {
          const e = this.beans.gos.get("suppressColumnMoveAnimation"),
            t = v(this.columnOrGroup.getOldLeft());
          this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged()
        }
        animateInLeft() {
          const e = this.getColumnOrGroup(),
            t = e.getLeft(),
            i = e.getOldLeft(),
            r = this.modifyLeftForPrintLayout(e, i),
            s = this.modifyLeftForPrintLayout(e, t);
          this.setLeft(r), this.actualLeft = s, this.beans.columnAnimationService.executeNextVMTurn(() => {
            this.actualLeft === s && this.setLeft(s)
          })
        }
        onLeftChanged() {
          const e = this.getColumnOrGroup(),
            t = e.getLeft();
          this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft)
        }
        modifyLeftForPrintLayout(e, t) {
          if (!this.beans.gos.isDomLayout("print")) return t;
          if ("left" === e.getPinned()) return t;
          const i = this.beans.columnModel.getDisplayedColumnsLeftWidth();
          if ("right" === e.getPinned()) {
            return i + this.beans.columnModel.getBodyContainerWidth() + t
          }
          return i + t
        }
        setLeft(e) {
          let t;
          if (v(e) && (this.eCell.style.left = `${e}px`), this.columnOrGroup instanceof Le) t = this.columnOrGroup;
          else {
            const e = this.columnOrGroup.getLeafColumns();
            if (!e.length) return;
            e.length > 1 && fi(this.ariaEl, e.length), t = e[0]
          }
        }
      };
    C([pe], qa.prototype, "postConstruct", 1);
    var Qa = class extends ct {
      constructor(e, t) {
        super(), this.columns = e, this.element = t
      }
      postConstruct() {
        this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners()
      }
      addMouseHoverListeners() {
        this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this)), this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this))
      }
      onMouseOut() {
        this.columnHoverService.clearMouseOver()
      }
      onMouseOver() {
        this.columnHoverService.setMouseOver(this.columns)
      }
    };
    C([fe("columnHoverService")], Qa.prototype, "columnHoverService", 2), C([pe], Qa.prototype, "postConstruct", 1);
    var Za = class extends Ja {
        constructor(e, t, i) {
          super(e, t, i), this.iconCreated = !1, this.column = e
        }
        setComp(e, t, i, r) {
          this.comp = e, this.eButtonShowMainFilter = i, this.eFloatingFilterBody = r, this.setGui(t), this.setupActive(), this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this)), this.setupFilterChangedListener(), this.addManagedListener(this.column, Le.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this))
        }
        resizeHeader() {}
        moveHeader() {}
        setupActive() {
          const e = this.column.getColDef(),
            t = !!e.filter,
            i = !!e.floatingFilter;
          this.active = t && i
        }
        setupUi() {
          if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated) return;
          const e = Zr("filter", this.gos, this.column);
          e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e))
        }
        setupFocus() {
          this.createManagedBean(new xs(this.eGui, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this)
          }))
        }
        setupAria() {
          const e = this.localeService.getLocaleTextFunc();
          qt(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"))
        }
        onTabKeyDown(e) {
          if (this.gos.getActiveDomElement() === this.eGui) return;
          const t = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
          if (t) return this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), void t.focus();
          const i = this.findNextColumnWithFloatingFilter(e.shiftKey);
          i && this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: this.getParentRowCtrl().getRowIndex(),
              column: i
            },
            event: e
          }) && e.preventDefault()
        }
        findNextColumnWithFloatingFilter(e) {
          const t = this.beans.columnModel;
          let i = this.column;
          do {
            if (i = e ? t.getDisplayedColBefore(i) : t.getDisplayedColAfter(i), !i) break
          } while (!i.getColDef().filter || !i.getColDef().floatingFilter);
          return i
        }
        handleKeyDown(e) {
          super.handleKeyDown(e);
          const t = this.getWrapperHasFocus();
          switch (e.key) {
            case ts.UP:
            case ts.DOWN:
              t || e.preventDefault();
            case ts.LEFT:
            case ts.RIGHT:
              if (t) return;
              e.stopPropagation();
            case ts.ENTER:
              t && this.focusService.focusInto(this.eGui) && e.preventDefault();
              break;
            case ts.ESCAPE:
              t || this.eGui.focus()
          }
        }
        onFocusIn(e) {
          if (this.eGui.contains(e.relatedTarget)) return;
          const t = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"),
            i = !!e.relatedTarget && Er(e.relatedTarget, "ag-floating-filter");
          if (t && i && e.target === this.eGui) {
            const e = this.lastFocusEvent,
              t = !(!e || e.key !== ts.TAB);
            if (e && t) {
              const t = e.shiftKey;
              this.focusService.focusInto(this.eGui, t)
            }
          }
          const r = this.getRowIndex();
          this.beans.focusService.setFocusedHeader(r, this.column)
        }
        setupHover() {
          this.createManagedBean(new Qa([this.column], this.eGui));
          const e = () => {
            if (!this.gos.get("columnHoverHighlight")) return;
            const e = this.beans.columnHoverService.isHovered(this.column);
            this.comp.addOrRemoveCssClass("ag-column-hover", e)
          };
          this.addManagedListener(this.eventService, Et.EVENT_COLUMN_HOVER_CHANGED, e), e()
        }
        setupLeft() {
          const e = new qa(this.column, this.eGui, this.beans);
          this.createManagedBean(e)
        }
        setupFilterButton() {
          this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled()
        }
        setupUserComp() {
          if (!this.active) return;
          const e = this.beans.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
          e && this.setCompDetails(e)
        }
        setCompDetails(e) {
          this.userCompDetails = e, this.comp.setCompDetails(e)
        }
        showParentFilter() {
          const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
          this.menuService.showFilterMenu({
            column: this.column,
            buttonElement: e,
            containerType: "floatingFilter",
            positionBy: "button"
          })
        }
        setupSyncWithFilter() {
          if (!this.active) return;
          const {
            filterManager: e
          } = this.beans, t = t => {
            if ("filterDestroyed" === (null == t ? void 0 : t.source) && this.context.isDestroyed()) return;
            const i = this.comp.getFloatingFilterComp();
            i && i.then(i => {
              var r;
              if (i) {
                const s = e.getCurrentFloatingFilterParentModel(this.column);
                i.onParentModelChanged(s, t ? this.gos.addGridCommonParams({
                  columns: null != (r = t.columns) ? r : [],
                  type: Et.EVENT_FILTER_CHANGED,
                  source: "api" === t.source ? "api" : "columnFilter"
                }) : null)
              }
            })
          };
          this.destroySyncListener = this.addManagedListener(this.column, Le.EVENT_FILTER_CHANGED, t), e.isFilterActive(this.column) && t(null)
        }
        setupWidth() {
          const e = () => {
            const e = `${this.column.getActualWidth()}px`;
            this.comp.setWidth(e)
          };
          this.addManagedListener(this.column, Le.EVENT_WIDTH_CHANGED, e), e()
        }
        setupFilterChangedListener() {
          this.active && (this.destroyFilterChangedListener = this.addManagedListener(this.column, Le.EVENT_FILTER_CHANGED, this.updateFilterButton.bind(this)), this.updateFilterButton())
        }
        updateFilterButton() {
          if (!this.suppressFilterButton && this.comp) {
            const e = this.beans.filterManager.isFilterAllowed(this.column);
            this.comp.setButtonWrapperDisplayed(e), this.highlightFilterButtonWhenActive && e && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive())
          }
        }
        onColDefChanged() {
          var e, t;
          const i = this.active;
          this.setupActive();
          const r = !i && this.active;
          i && !this.active && (null == (e = this.destroySyncListener) || e.call(this), null == (t = this.destroyFilterChangedListener) || t.call(this));
          const s = this.active ? this.beans.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null,
            n = this.comp.getFloatingFilterComp();
          n && s ? n.then(e => {
            var t;
            !e || this.beans.filterManager.areFilterCompsDifferent(null != (t = this.userCompDetails) ? t : null, s) ? this.updateCompDetails(s, r) : this.updateFloatingFilterParams(s)
          }) : this.updateCompDetails(s, r)
        }
        updateCompDetails(e, t) {
          this.isAlive() && (this.setCompDetails(e), this.setupFilterButton(), this.setupUi(), t && (this.setupSyncWithFilter(), this.setupFilterChangedListener()))
        }
        updateFloatingFilterParams(e) {
          var t;
          if (!e) return;
          const i = e.params;
          null == (t = this.comp.getFloatingFilterComp()) || t.then(e => {
            let t = !1;
            if ((null == e ? void 0 : e.refresh) && "function" == typeof e.refresh) {
              null !== e.refresh(i) && (t = !0)
            }
            if (!t && (null == e ? void 0 : e.onParamsUpdated) && "function" == typeof e.onParamsUpdated) {
              null !== e.onParamsUpdated(i) && z("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.")
            }
          })
        }
        destroy() {
          super.destroy(), this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.destroySyncListener = null, this.destroyFilterChangedListener = null
        }
      },
      el = class extends ct {
        constructor(e, t, i, r, s) {
          super(), this.pinned = e, this.column = t, this.eResize = i, this.comp = r, this.ctrl = s
        }
        postConstruct() {
          const e = [];
          let t, i;
          const r = () => {
              if (ur(this.eResize, t), !t) return;
              const r = this.horizontalResizeService.addResizeBar({
                eResizeBar: this.eResize,
                onResizeStart: this.onResizeStart.bind(this),
                onResizing: this.onResizing.bind(this, !1),
                onResizeEnd: this.onResizing.bind(this, !0)
              });
              if (e.push(r), i) {
                const t = this.gos.get("skipHeaderOnAutoSize"),
                  i = () => {
                    this.columnModel.autoSizeColumn(this.column, "uiColumnResized", t)
                  };
                this.eResize.addEventListener("dblclick", i);
                const r = new In(this.eResize);
                r.addEventListener(In.EVENT_DOUBLE_TAP, i), e.push(() => {
                  this.eResize.removeEventListener("dblclick", i), r.removeEventListener(In.EVENT_DOUBLE_TAP, i), r.destroy()
                })
              }
            },
            s = () => {
              e.forEach(e => e()), e.length = 0
            },
            n = () => {
              const e = this.column.isResizable(),
                n = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
              (e !== t || n !== i) && (t = e, i = n, s(), r())
            };
          n(), this.addDestroyFunc(s), this.ctrl.addRefreshFunction(n)
        }
        onResizing(e, t) {
          const {
            column: i,
            lastResizeAmount: r,
            resizeStartWidth: s
          } = this, n = this.normaliseResizeAmount(t), o = [{
            key: i,
            newWidth: s + n
          }];
          if (this.column.getPinned()) {
            if (this.pinnedWidthService.getPinnedLeftWidth() + this.pinnedWidthService.getPinnedRightWidth() + (n - r) > Tr(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50) return
          }
          this.lastResizeAmount = n, this.columnModel.setColumnWidths(o, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1)
        }
        onResizeStart(e) {
          this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0)
        }
        toggleColumnResizing(e) {
          this.comp.addOrRemoveCssClass("ag-column-resizing", e)
        }
        normaliseResizeAmount(e) {
          let t = e;
          const i = "left" !== this.pinned,
            r = "right" === this.pinned;
          return this.gos.get("enableRtl") ? i && (t *= -1) : r && (t *= -1), t
        }
      };
    C([fe("horizontalResizeService")], el.prototype, "horizontalResizeService", 2), C([fe("pinnedWidthService")], el.prototype, "pinnedWidthService", 2), C([fe("ctrlsService")], el.prototype, "ctrlsService", 2), C([fe("columnModel")], el.prototype, "columnModel", 2), C([pe], el.prototype, "postConstruct", 1);
    var tl = class extends ct {
      constructor(e) {
        super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e
      }
      onSpaceKeyDown(e) {
        const t = this.cbSelectAll;
        t.isDisplayed() && !t.getGui().contains(this.gos.getActiveDomElement()) && (e.preventDefault(), t.setValue(!t.getValue()))
      }
      getCheckboxGui() {
        return this.cbSelectAll.getGui()
      }
      setComp(e) {
        this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new Js), this.cbSelectAll.addCssClass("ag-header-select-all"), Xt(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_PAGINATION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this)), this.addManagedListener(this.cbSelectAll, Et.EVENT_FIELD_VALUE_CHANGED, this.onCbSelectAll.bind(this)), ni(this.cbSelectAll.getGui(), !0), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel()
      }
      onNewColumnsLoaded() {
        this.showOrHideSelectAll()
      }
      onDisplayedColumnsChanged() {
        this.isAlive() && this.showOrHideSelectAll()
      }
      showOrHideSelectAll() {
        this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, {
          skipAriaHidden: !0
        }), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel()
      }
      onModelChanged() {
        this.cbSelectAllVisible && this.updateStateOfCheckbox()
      }
      onSelectionChanged() {
        this.cbSelectAllVisible && this.updateStateOfCheckbox()
      }
      updateStateOfCheckbox() {
        if (this.processingEventFromCheckbox) return;
        this.processingEventFromCheckbox = !0;
        const e = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
        this.cbSelectAll.setValue(e);
        const t = this.selectionService.hasNodesToSelect(this.isFilteredOnly(), this.isCurrentPageOnly());
        this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1
      }
      refreshSelectAllLabel() {
        const e = this.localeService.getLocaleTextFunc(),
          t = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"),
          i = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
        this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${i} (${t})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(`${i} (${t})`), this.headerCellCtrl.announceAriaDescription()
      }
      checkSelectionType(e) {
        return !("multiple" !== this.gos.get("rowSelection")) || (console.warn(`AG Grid: ${e} is only available if using 'multiple' rowSelection.`), !1)
      }
      checkRightRowModelType(e) {
        const t = this.rowModel.getType();
        return !("clientSide" !== t && "serverSide" !== t) || (console.warn(`AG Grid: ${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`), !1)
      }
      onCbSelectAll() {
        if (this.processingEventFromCheckbox) return;
        if (!this.cbSelectAllVisible) return;
        const e = this.cbSelectAll.getValue(),
          t = this.isFilteredOnly(),
          i = this.isCurrentPageOnly();
        let r = "uiSelectAll";
        i ? r = "uiSelectAllCurrentPage" : t && (r = "uiSelectAllFiltered");
        const s = {
          source: r,
          justFiltered: t,
          justCurrentPage: i
        };
        e ? this.selectionService.selectAllRowNodes(s) : this.selectionService.deselectAllRowNodes(s)
      }
      isCheckboxSelection() {
        let e = this.column.getColDef().headerCheckboxSelection;
        if ("function" == typeof e) {
          e = e(this.gos.addGridCommonParams({
            column: this.column,
            colDef: this.column.getColDef()
          }))
        }
        return !!e && (this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection"))
      }
      isFilteredOnly() {
        return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly
      }
      isCurrentPageOnly() {
        return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly
      }
    };
    C([fe("rowModel")], tl.prototype, "rowModel", 2), C([fe("selectionService")], tl.prototype, "selectionService", 2);
    var il = class extends Ja {
        constructor(e, t, i) {
          super(e, t, i), this.refreshFunctions = [], this.userHeaderClasses = new Set, this.ariaDescriptionProperties = new Map, this.column = e
        }
        setComp(e, t, i, r) {
          this.comp = e, this.setGui(t), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight(r), this.addColumnHoverListener(), this.setupFilterClass(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.refreshAria(), this.resizeFeature = this.createManagedBean(new el(this.getPinned(), this.column, i, e, this)), this.createManagedBean(new Qa([this.column], t)), this.createManagedBean(new qa(this.column, t, this.beans)), this.createManagedBean(new xs(t, {
            shouldStopEventPropagation: e => this.shouldStopEventPropagation(e),
            onTabKeyDown: () => null,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
            onFocusOut: this.onFocusOut.bind(this)
          })), this.addResizeAndMoveKeyboardListeners(), this.addManagedPropertyListeners(["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"], this.refresh.bind(this)), this.addManagedListener(this.column, Le.EVENT_COL_DEF_CHANGED, this.refresh.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this))
        }
        resizeHeader(e, t) {
          var i, r;
          if (!this.column.isResizable()) return;
          const s = this.column.getActualWidth(),
            n = null != (i = this.column.getMinWidth()) ? i : 0,
            o = null != (r = this.column.getMaxWidth()) ? r : Number.MAX_SAFE_INTEGER,
            a = Math.min(Math.max(s + e, n), o);
          this.beans.columnModel.setColumnWidths([{
            key: this.column,
            newWidth: a
          }], t, !0, "uiColumnResized")
        }
        moveHeader(e) {
          const {
            eGui: t,
            column: i,
            gos: r,
            ctrlsService: s
          } = this, n = this.getPinned(), o = t.getBoundingClientRect().left, a = i.getActualWidth(), l = 0 === e !== r.get("enableRtl"), c = ka.normaliseX(l ? o - 20 : o + a + 20, n, !0, r, s);
          ka.attemptMoveColumns({
            allMovingColumns: [i],
            isFromHeader: !0,
            hDirection: e,
            xPosition: c,
            pinned: n,
            fromEnter: !1,
            fakeEvent: !1,
            gos: r,
            columnModel: this.beans.columnModel
          }), s.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(i, "auto")
        }
        setupUserComp() {
          const e = this.lookupUserCompDetails();
          this.setCompDetails(e)
        }
        setCompDetails(e) {
          this.userCompDetails = e, this.comp.setUserCompDetails(e)
        }
        lookupUserCompDetails() {
          const e = this.createParams(),
            t = this.column.getColDef();
          return this.userComponentFactory.getHeaderCompDetails(t, e)
        }
        createParams() {
          return this.gos.addGridCommonParams({
            column: this.column,
            displayName: this.displayName,
            enableSorting: this.column.isSortable(),
            enableMenu: this.menuEnabled,
            enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
            enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
            showColumnMenu: e => {
              this.menuService.showColumnMenu({
                column: this.column,
                buttonElement: e,
                positionBy: "button"
              })
            },
            showColumnMenuAfterMouseClick: e => {
              this.menuService.showColumnMenu({
                column: this.column,
                mouseEvent: e,
                positionBy: "mouse"
              })
            },
            showFilter: e => {
              this.menuService.showFilterMenu({
                column: this.column,
                buttonElement: e,
                containerType: "columnFilter",
                positionBy: "button"
              })
            },
            progressSort: e => {
              this.beans.sortController.progressSort(this.column, !!e, "uiColumnSorted")
            },
            setSort: (e, t) => {
              this.beans.sortController.setSortForColumn(this.column, e, !!t, "uiColumnSorted")
            },
            eGridHeader: this.getGui(),
            setTooltip: (e, t) => {
              this.setupTooltip(e, t)
            }
          })
        }
        setupSelectAll() {
          this.selectAllFeature = this.createManagedBean(new tl(this.column)), this.selectAllFeature.setComp(this)
        }
        getSelectAllGui() {
          return this.selectAllFeature.getCheckboxGui()
        }
        handleKeyDown(e) {
          super.handleKeyDown(e), e.key === ts.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === ts.ENTER && this.onEnterKeyDown(e), e.key === ts.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1)
        }
        onEnterKeyDown(e) {
          if (e.ctrlKey || e.metaKey) this.showMenuOnKeyPress(e, !0);
          else if (this.sortable) {
            const t = e.shiftKey;
            this.beans.sortController.progressSort(this.column, t, "uiColumnSorted")
          }
        }
        showMenuOnKeyPress(e, t) {
          const i = this.comp.getUserCompInstance();
          i && i instanceof yn && i.onMenuKeyboardShortcut(t) && e.preventDefault()
        }
        onFocusIn(e) {
          if (!this.getGui().contains(e.relatedTarget)) {
            const e = this.getRowIndex();
            this.focusService.setFocusedHeader(e, this.column), this.announceAriaDescription()
          }
          this.focusService.isKeyboardMode() && this.setActiveHeader(!0)
        }
        onFocusOut(e) {
          this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1)
        }
        setupTooltip(e, t) {
          this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
          const i = "whenTruncated" === this.gos.get("tooltipShowMode"),
            r = this.eGui,
            s = this.column.getColDef();
          t || !i || s.headerComponent || (t = () => {
            const e = r.querySelector(".ag-header-cell-text");
            return !e || e.scrollWidth > e.clientWidth
          });
          const n = {
              getColumn: () => this.column,
              getColDef: () => this.column.getColDef(),
              getGui: () => r,
              getLocation: () => "header",
              getTooltipValue: () => {
                if (null != e) return e;
                return this.column.getColDef().headerTooltip
              },
              shouldDisplayTooltip: t
            },
            o = this.createManagedBean(new Is(n));
          this.refreshFunctions.push(() => o.refreshToolTip())
        }
        setupClassesFromColDef() {
          const e = () => {
            const e = this.column.getColDef(),
              t = da.getHeaderClassesFromColDef(e, this.gos, this.column, null),
              i = this.userHeaderClasses;
            this.userHeaderClasses = new Set(t), t.forEach(e => {
              i.has(e) ? i.delete(e) : this.comp.addOrRemoveCssClass(e, !0)
            }), i.forEach(e => this.comp.addOrRemoveCssClass(e, !1))
          };
          this.refreshFunctions.push(e), e()
        }
        setDragSource(e) {
          if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable) return;
          const {
            column: t,
            beans: i,
            displayName: r,
            dragAndDropService: s,
            gos: n
          } = this, {
            columnModel: o
          } = i;
          let a = !this.gos.get("suppressDragLeaveHidesColumns");
          const l = this.dragSource = {
            type: 1,
            eElement: e,
            getDefaultIconName: () => a ? Kn.ICON_HIDE : Kn.ICON_NOT_ALLOWED,
            getDragItem: () => this.createDragItem(t),
            dragItemName: r,
            onDragStarted: () => {
              a = !n.get("suppressDragLeaveHidesColumns"), t.setMoving(!0, "uiColumnMoved")
            },
            onDragStopped: () => t.setMoving(!1, "uiColumnMoved"),
            onGridEnter: e => {
              var t;
              if (a) {
                const i = (null == (t = null == e ? void 0 : e.columns) ? void 0 : t.filter(e => !e.getColDef().lockVisible)) || [];
                o.setColumnsVisible(i, !0, "uiColumnMoved")
              }
            },
            onGridExit: e => {
              var t;
              if (a) {
                const i = (null == (t = null == e ? void 0 : e.columns) ? void 0 : t.filter(e => !e.getColDef().lockVisible)) || [];
                o.setColumnsVisible(i, !1, "uiColumnMoved")
              }
            }
          };
          s.addDragSource(l, !0)
        }
        createDragItem(e) {
          const t = {};
          return t[e.getId()] = e.isVisible(), {
            columns: [e],
            visibleState: t
          }
        }
        updateState() {
          this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable()
        }
        addRefreshFunction(e) {
          this.refreshFunctions.push(e)
        }
        refresh() {
          this.updateState(), this.refreshHeaderComp(), this.refreshAria(), this.refreshFunctions.forEach(e => e())
        }
        refreshHeaderComp() {
          const e = this.lookupUserCompDetails();
          !!(null != this.comp.getUserCompInstance() && this.userCompDetails.componentClass == e.componentClass) && this.attemptHeaderCompRefresh(e.params) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e)
        }
        attemptHeaderCompRefresh(e) {
          const t = this.comp.getUserCompInstance();
          if (!t) return !1;
          if (!t.refresh) return !1;
          return t.refresh(e)
        }
        calculateDisplayName() {
          return this.beans.columnModel.getDisplayNameForColumn(this.column, "header", !0)
        }
        checkDisplayName() {
          this.displayName !== this.calculateDisplayName() && this.refresh()
        }
        workOutDraggable() {
          const e = this.column.getColDef();
          return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot
        }
        onColumnRowGroupChanged() {
          this.checkDisplayName()
        }
        onColumnPivotChanged() {
          this.checkDisplayName()
        }
        onColumnValueChanged() {
          this.checkDisplayName()
        }
        setupWidth() {
          const e = () => {
            const e = this.column.getActualWidth();
            this.comp.setWidth(`${e}px`)
          };
          this.addManagedListener(this.column, Le.EVENT_WIDTH_CHANGED, e), e()
        }
        setupMovingCss() {
          const e = () => {
            this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving())
          };
          this.addManagedListener(this.column, Le.EVENT_MOVING_CHANGED, e), e()
        }
        setupMenuClass() {
          const e = () => {
            this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible())
          };
          this.addManagedListener(this.column, Le.EVENT_MENU_VISIBLE_CHANGED, e), e()
        }
        setupSortableClass() {
          const e = () => {
            this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable)
          };
          e(), this.addRefreshFunction(e), this.addManagedListener(this.eventService, Le.EVENT_SORT_CHANGED, this.refreshAriaSort.bind(this))
        }
        setupFilterClass() {
          const e = () => {
            const e = this.column.isFilterActive();
            this.comp.addOrRemoveCssClass("ag-header-cell-filtered", e), this.refreshAria()
          };
          this.addManagedListener(this.column, Le.EVENT_FILTER_ACTIVE_CHANGED, e), e()
        }
        setupWrapTextClass() {
          const e = () => {
            const e = !!this.column.getColDef().wrapHeaderText;
            this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", e)
          };
          e(), this.addRefreshFunction(e)
        }
        onDisplayedColumnsChanged() {
          super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged()
        }
        onHeaderHeightChanged() {
          this.refreshSpanHeaderHeight()
        }
        refreshSpanHeaderHeight() {
          const {
            eGui: e,
            column: t,
            comp: i,
            beans: r
          } = this;
          if (!t.isSpanHeaderHeight()) return e.style.removeProperty("top"), e.style.removeProperty("height"), i.addOrRemoveCssClass("ag-header-span-height", !1), void i.addOrRemoveCssClass("ag-header-span-total", !1);
          const {
            numberOfParents: s,
            isSpanningTotal: n
          } = this.column.getColumnGroupPaddingInfo();
          i.addOrRemoveCssClass("ag-header-span-height", s > 0);
          const {
            columnModel: o
          } = r, a = o.getColumnHeaderRowHeight();
          if (0 === s) return i.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), void e.style.setProperty("height", `${a}px`);
          i.addOrRemoveCssClass("ag-header-span-total", n);
          const l = s * (o.isPivotMode() ? o.getPivotGroupHeaderHeight() : o.getGroupHeaderHeight());
          e.style.setProperty("top", -l + "px"), e.style.setProperty("height", `${a+l}px`)
        }
        setupAutoHeight(e) {
          const {
            columnModel: t,
            resizeObserverService: i
          } = this.beans, r = i => {
            if (!this.isAlive()) return;
            const {
              paddingTop: s,
              paddingBottom: n,
              borderBottomWidth: o,
              borderTopWidth: a
            } = gr(this.getGui()), l = s + n + o + a, c = e.offsetHeight + l;
            if (i < 5) {
              const t = this.beans.gos.getDocument();
              if (!t || !t.contains(e) || 0 == c) return void window.setTimeout(() => r(i + 1), 0)
            }
            t.setColumnHeaderHeight(this.column, c)
          };
          let s, n = !1;
          const o = () => {
              const e = this.column.isAutoHeaderHeight();
              e && !n && a(), !e && n && l()
            },
            a = () => {
              n = !0, r(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), s = i.observeResize(e, () => r(0))
            },
            l = () => {
              n = !1, s && s(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), s = void 0
            };
          o(), this.addDestroyFunc(() => l()), this.addManagedListener(this.column, Le.EVENT_WIDTH_CHANGED, () => n && r(0)), this.addManagedListener(this.eventService, Le.EVENT_SORT_CHANGED, () => {
            n && window.setTimeout(() => r(0))
          }), this.addRefreshFunction(o)
        }
        refreshAriaSort() {
          if (this.sortable) {
            const e = this.localeService.getLocaleTextFunc(),
              t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
            this.comp.setAriaSort(zt(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"))
          } else this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null)
        }
        refreshAriaMenu() {
          if (this.menuEnabled) {
            const e = this.localeService.getLocaleTextFunc();
            this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"))
          } else this.setAriaDescriptionProperty("menu", null)
        }
        refreshAriaFilterButton() {
          if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
            const e = this.localeService.getLocaleTextFunc();
            this.setAriaDescriptionProperty("filterButton", e("ariaFilterColumn", "Press CTRL ENTER to open filter"))
          } else this.setAriaDescriptionProperty("filterButton", null)
        }
        refreshAriaFiltered() {
          const e = this.localeService.getLocaleTextFunc();
          this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null)
        }
        setAriaDescriptionProperty(e, t) {
          null != t ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e)
        }
        announceAriaDescription() {
          if (!this.eGui.contains(this.beans.gos.getActiveDomElement())) return;
          const e = Array.from(this.ariaDescriptionProperties.keys()).sort((e, t) => "filter" === e ? -1 : t.charCodeAt(0) - e.charCodeAt(0)).map(e => this.ariaDescriptionProperties.get(e)).join(". ");
          this.beans.ariaAnnouncementService.announceValue(e)
        }
        refreshAria() {
          this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered()
        }
        addColumnHoverListener() {
          const e = () => {
            if (!this.gos.get("columnHoverHighlight")) return;
            const e = this.beans.columnHoverService.isHovered(this.column);
            this.comp.addOrRemoveCssClass("ag-column-hover", e)
          };
          this.addManagedListener(this.eventService, Et.EVENT_COLUMN_HOVER_CHANGED, e), e()
        }
        getColId() {
          return this.column.getColId()
        }
        addActiveHeaderMouseListeners() {
          const e = e => this.handleMouseOverChange("mouseenter" === e.type);
          this.addManagedListener(this.getGui(), "mouseenter", e), this.addManagedListener(this.getGui(), "mouseleave", e), this.addManagedListener(this.getGui(), "click", () => this.dispatchColumnMouseEvent(Et.EVENT_COLUMN_HEADER_CLICKED, this.column)), this.addManagedListener(this.getGui(), "contextmenu", e => this.handleContextMenuMouseEvent(e, void 0, this.column))
        }
        handleMouseOverChange(e) {
          this.setActiveHeader(e);
          const t = {
            type: e ? Et.EVENT_COLUMN_HEADER_MOUSE_OVER : Et.EVENT_COLUMN_HEADER_MOUSE_LEAVE,
            column: this.column
          };
          this.eventService.dispatchEvent(t)
        }
        setActiveHeader(e) {
          this.comp.addOrRemoveCssClass("ag-header-active", e)
        }
        getAnchorElementForMenu(e) {
          const t = this.comp.getUserCompInstance();
          return t instanceof yn ? t.getAnchorElementForMenu(e) : this.getGui()
        }
        destroy() {
          super.destroy(), this.refreshFunctions = null, this.selectAllFeature = null, this.dragSourceElement = null, this.userCompDetails = null, this.userHeaderClasses = null, this.ariaDescriptionProperties = null
        }
      },
      rl = class extends ct {
        constructor(e, t, i, r) {
          super(), this.eResize = t, this.comp = e, this.pinned = i, this.columnGroup = r
        }
        postConstruct() {
          if (!this.columnGroup.isResizable()) return void this.comp.setResizableDisplayed(!1);
          const e = this.horizontalResizeService.addResizeBar({
            eResizeBar: this.eResize,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this, !1),
            onResizeEnd: this.onResizing.bind(this, !0)
          });
          if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
            const e = this.gos.get("skipHeaderOnAutoSize");
            this.eResize.addEventListener("dblclick", () => {
              const t = [];
              this.columnGroup.getDisplayedLeafColumns().forEach(e => {
                e.getColDef().suppressAutoSize || t.push(e.getColId())
              }), t.length > 0 && this.columnModel.autoSizeColumns({
                columns: t,
                skipHeader: e,
                stopAtGroup: this.columnGroup,
                source: "uiColumnResized"
              }), this.resizeLeafColumnsToFit("uiColumnResized")
            })
          }
        }
        onResizeStart(e) {
          const t = this.getInitialValues(e);
          this.storeLocalValues(t), this.toggleColumnResizing(!0)
        }
        onResizing(e, t, i = "uiColumnResized") {
          const r = this.normaliseDragChange(t),
            s = this.resizeStartWidth + r;
          this.resizeColumnsFromLocalValues(s, i, e)
        }
        getInitialValues(e) {
          const t = this.getColumnsToResize(),
            i = this.getInitialSizeOfColumns(t),
            r = {
              columnsToResize: t,
              resizeStartWidth: i,
              resizeRatios: this.getSizeRatiosOfColumns(t, i)
            };
          let s = null;
          if (e && (s = this.columnModel.getDisplayedGroupAtDirection(this.columnGroup, "After")), s) {
            const e = s.getDisplayedLeafColumns(),
              t = r.groupAfterColumns = e.filter(e => e.isResizable()),
              i = r.groupAfterStartWidth = this.getInitialSizeOfColumns(t);
            r.groupAfterRatios = this.getSizeRatiosOfColumns(t, i)
          } else r.groupAfterColumns = void 0, r.groupAfterStartWidth = void 0, r.groupAfterRatios = void 0;
          return r
        }
        storeLocalValues(e) {
          const {
            columnsToResize: t,
            resizeStartWidth: i,
            resizeRatios: r,
            groupAfterColumns: s,
            groupAfterStartWidth: n,
            groupAfterRatios: o
          } = e;
          this.resizeCols = t, this.resizeStartWidth = i, this.resizeRatios = r, this.resizeTakeFromCols = s, this.resizeTakeFromStartWidth = n, this.resizeTakeFromRatios = o
        }
        clearLocalValues() {
          this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0
        }
        resizeLeafColumnsToFit(e) {
          const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup),
            i = this.getInitialValues();
          t > i.resizeStartWidth && this.resizeColumns(i, t, e, !0)
        }
        resizeColumnsFromLocalValues(e, t, i = !0) {
          var r, s, n;
          if (!this.resizeCols || !this.resizeRatios) return;
          const o = {
            columnsToResize: this.resizeCols,
            resizeStartWidth: this.resizeStartWidth,
            resizeRatios: this.resizeRatios,
            groupAfterColumns: null != (r = this.resizeTakeFromCols) ? r : void 0,
            groupAfterStartWidth: null != (s = this.resizeTakeFromStartWidth) ? s : void 0,
            groupAfterRatios: null != (n = this.resizeTakeFromRatios) ? n : void 0
          };
          this.resizeColumns(o, e, t, i)
        }
        resizeColumns(e, t, i, r = !0) {
          const {
            columnsToResize: s,
            resizeStartWidth: n,
            resizeRatios: o,
            groupAfterColumns: a,
            groupAfterStartWidth: l,
            groupAfterRatios: c
          } = e, h = [];
          if (h.push({
              columns: s,
              ratios: o,
              width: t
            }), a) {
            const e = t - n;
            h.push({
              columns: a,
              ratios: c,
              width: l - e
            })
          }
          this.columnModel.resizeColumnSets({
            resizeSets: h,
            finished: r,
            source: i
          }), r && this.toggleColumnResizing(!1)
        }
        toggleColumnResizing(e) {
          this.comp.addOrRemoveCssClass("ag-column-resizing", e)
        }
        getColumnsToResize() {
          return this.columnGroup.getDisplayedLeafColumns().filter(e => e.isResizable())
        }
        getInitialSizeOfColumns(e) {
          return e.reduce((e, t) => e + t.getActualWidth(), 0)
        }
        getSizeRatiosOfColumns(e, t) {
          return e.map(e => e.getActualWidth() / t)
        }
        normaliseDragChange(e) {
          let t = e;
          return this.gos.get("enableRtl") ? "left" !== this.pinned && (t *= -1) : "right" === this.pinned && (t *= -1), t
        }
        destroy() {
          super.destroy(), this.clearLocalValues()
        }
      };
    C([fe("horizontalResizeService")], rl.prototype, "horizontalResizeService", 2), C([fe("autoWidthCalculator")], rl.prototype, "autoWidthCalculator", 2), C([fe("columnModel")], rl.prototype, "columnModel", 2), C([pe], rl.prototype, "postConstruct", 1);
    var sl = class extends ct {
      constructor(e, t) {
        super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e
      }
      postConstruct() {
        this.addListenersToChildrenColumns(), this.addManagedListener(this.columnGroup, pt.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this)), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this))
      }
      addListenersToChildrenColumns() {
        this.removeListenersOnChildrenColumns();
        const e = this.onWidthChanged.bind(this);
        this.columnGroup.getLeafColumns().forEach(t => {
          t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
            t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e)
          })
        })
      }
      removeListenersOnChildrenColumns() {
        this.removeChildListenersFuncs.forEach(e => e()), this.removeChildListenersFuncs = []
      }
      onDisplayedChildrenChanged() {
        this.addListenersToChildrenColumns(), this.onWidthChanged()
      }
      onWidthChanged() {
        const e = this.columnGroup.getActualWidth();
        this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", 0 === e)
      }
    };
    C([pe], sl.prototype, "postConstruct", 1);
    var nl = class extends Ja {
        constructor(e, t, i) {
          super(e, t, i), this.onSuppressColMoveChange = () => {
            if (!this.isAlive() || this.isSuppressMoving()) this.removeDragSource();
            else if (!this.dragSource) {
              const e = this.getGui();
              this.setDragSource(e)
            }
          }, this.column = e
        }
        setComp(e, t, i) {
          this.comp = e, this.setGui(t), this.displayName = this.beans.columnModel.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.addDestroyFunc(() => {
            this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature))
          }), this.setupUserComp(), this.addHeaderMouseListeners();
          const r = this.getParentRowCtrl().getPinned(),
            s = this.column.getProvidedColumnGroup().getLeafColumns();
          this.createManagedBean(new Qa(s, t)), this.createManagedBean(new qa(this.column, t, this.beans)), this.createManagedBean(new sl(e, this.column)), this.resizeFeature = this.createManagedBean(new rl(e, i, r, this.column)), this.createManagedBean(new xs(t, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: () => {},
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this)
          })), this.addManagedPropertyListener(Et.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED, this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners()
        }
        resizeHeader(e, t) {
          if (!this.resizeFeature) return;
          const i = this.resizeFeature.getInitialValues(t);
          this.resizeFeature.resizeColumns(i, i.resizeStartWidth + e, "uiColumnResized", !0)
        }
        moveHeader(e) {
          const {
            beans: t,
            eGui: i,
            column: r,
            gos: s,
            ctrlsService: n
          } = this, o = s.get("enableRtl"), a = 0 === e, l = this.getPinned(), c = i.getBoundingClientRect(), h = c.left, u = c.width, d = ka.normaliseX(a !== o ? h - 20 : h + u + 20, l, !0, s, n), p = r.getGroupId(), E = this.focusService.getFocusedHeader();
          ka.attemptMoveColumns({
            allMovingColumns: this.column.getLeafColumns(),
            isFromHeader: !0,
            hDirection: e,
            xPosition: d,
            pinned: l,
            fromEnter: !1,
            fakeEvent: !1,
            gos: s,
            columnModel: t.columnModel
          });
          const g = r.getDisplayedLeafColumns(),
            f = a ? g[0] : Me(g);
          this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(f, "auto"), !this.isAlive() && E && this.restoreFocus(p, r, E)
        }
        restoreFocus(e, t, i) {
          const r = t.getLeafColumns();
          if (!r.length) return;
          const s = r[0].getParent();
          if (!s) return;
          const n = this.findGroupWidthId(s, e);
          n && this.focusService.focusHeaderPosition({
            headerPosition: T(f({}, i), {
              column: n
            })
          })
        }
        findGroupWidthId(e, t) {
          for (; e;) {
            if (e.getGroupId() === t) return e;
            e = e.getParent()
          }
          return null
        }
        resizeLeafColumnsToFit(e) {
          this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e)
        }
        setupUserComp() {
          const e = this.gos.addGridCommonParams({
              displayName: this.displayName,
              columnGroup: this.column,
              setExpanded: e => {
                this.beans.columnModel.setColumnGroupOpened(this.column.getProvidedColumnGroup(), e, "gridInitializing")
              },
              setTooltip: (e, t) => {
                this.setupTooltip(e, t)
              }
            }),
            t = this.userComponentFactory.getHeaderGroupCompDetails(e);
          this.comp.setUserCompDetails(t)
        }
        addHeaderMouseListeners() {
          const e = e => this.handleMouseOverChange("mouseenter" === e.type);
          this.addManagedListener(this.getGui(), "mouseenter", e), this.addManagedListener(this.getGui(), "mouseleave", e), this.addManagedListener(this.getGui(), "click", () => this.dispatchColumnMouseEvent(Et.EVENT_COLUMN_HEADER_CLICKED, this.column.getProvidedColumnGroup())), this.addManagedListener(this.getGui(), "contextmenu", e => this.handleContextMenuMouseEvent(e, void 0, this.column.getProvidedColumnGroup()))
        }
        handleMouseOverChange(e) {
          const t = {
            type: e ? Et.EVENT_COLUMN_HEADER_MOUSE_OVER : Et.EVENT_COLUMN_HEADER_MOUSE_LEAVE,
            column: this.column.getProvidedColumnGroup()
          };
          this.eventService.dispatchEvent(t)
        }
        setupTooltip(e, t) {
          this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
          const i = this.column.getColGroupDef(),
            r = "whenTruncated" === this.gos.get("tooltipShowMode"),
            s = this.eGui;
          t || !r || (null == i ? void 0 : i.headerGroupComponent) || (t = () => {
            const e = s.querySelector(".ag-header-group-text");
            return !e || e.scrollWidth > e.clientWidth
          });
          const n = {
            getColumn: () => this.column,
            getGui: () => s,
            getLocation: () => "headerGroup",
            getTooltipValue: () => null != e ? e : i && i.headerTooltip,
            shouldDisplayTooltip: t
          };
          i && (n.getColDef = () => i), this.createBean(new Is(n))
        }
        setupExpandable() {
          const e = this.column.getProvidedColumnGroup();
          this.refreshExpanded(), this.addManagedListener(e, ye.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this)), this.addManagedListener(e, ye.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this))
        }
        refreshExpanded() {
          const e = this.column;
          this.expandable = e.isExpandable();
          const t = e.isExpanded();
          this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0)
        }
        getColId() {
          return this.column.getUniqueId()
        }
        addClasses() {
          const e = this.column.getColGroupDef(),
            t = da.getHeaderClassesFromColDef(e, this.gos, null, this.column);
          if (this.column.isPadding()) {
            t.push("ag-header-group-cell-no-group");
            this.column.getLeafColumns().every(e => e.isSpanHeaderHeight()) && t.push("ag-header-span-height")
          } else t.push("ag-header-group-cell-with-group");
          t.forEach(e => this.comp.addOrRemoveCssClass(e, !0))
        }
        setupMovingCss() {
          const e = this.column.getProvidedColumnGroup().getLeafColumns(),
            t = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
          e.forEach(e => {
            this.addManagedListener(e, Le.EVENT_MOVING_CHANGED, t)
          }), t()
        }
        onFocusIn(e) {
          if (!this.eGui.contains(e.relatedTarget)) {
            const e = this.getRowIndex();
            this.beans.focusService.setFocusedHeader(e, this.column)
          }
        }
        handleKeyDown(e) {
          super.handleKeyDown(e);
          const t = this.getWrapperHasFocus();
          if (this.expandable && t && e.key === ts.ENTER) {
            const e = this.column,
              t = !e.isExpanded();
            this.beans.columnModel.setColumnGroupOpened(e.getProvidedColumnGroup(), t, "uiColumnExpanded")
          }
        }
        setDragSource(e) {
          if (!this.isAlive() || this.isSuppressMoving()) return;
          if (this.removeDragSource(), !e) return;
          const {
            beans: t,
            column: i,
            displayName: r,
            gos: s,
            dragAndDropService: n
          } = this, {
            columnModel: o
          } = t, a = i.getProvidedColumnGroup().getLeafColumns();
          let l = !s.get("suppressDragLeaveHidesColumns");
          const c = this.dragSource = {
            type: 1,
            eElement: e,
            getDefaultIconName: () => l ? Kn.ICON_HIDE : Kn.ICON_NOT_ALLOWED,
            dragItemName: r,
            getDragItem: () => this.getDragItemForGroup(i),
            onDragStarted: () => {
              l = !s.get("suppressDragLeaveHidesColumns"), a.forEach(e => e.setMoving(!0, "uiColumnDragged"))
            },
            onDragStopped: () => a.forEach(e => e.setMoving(!1, "uiColumnDragged")),
            onGridEnter: e => {
              var t;
              if (l) {
                const i = (null == (t = null == e ? void 0 : e.columns) ? void 0 : t.filter(e => !e.getColDef().lockVisible)) || [];
                o.setColumnsVisible(i, !0, "uiColumnMoved")
              }
            },
            onGridExit: e => {
              var t;
              if (l) {
                const i = (null == (t = null == e ? void 0 : e.columns) ? void 0 : t.filter(e => !e.getColDef().lockVisible)) || [];
                o.setColumnsVisible(i, !1, "uiColumnMoved")
              }
            }
          };
          n.addDragSource(c, !0)
        }
        getDragItemForGroup(e) {
          const t = e.getProvidedColumnGroup().getLeafColumns(),
            i = {};
          t.forEach(e => i[e.getId()] = e.isVisible());
          const r = [];
          return this.beans.columnModel.getAllDisplayedColumns().forEach(e => {
            t.indexOf(e) >= 0 && (r.push(e), ke(t, e))
          }), t.forEach(e => r.push(e)), {
            columns: r,
            visibleState: i
          }
        }
        isSuppressMoving() {
          let e = !1;
          this.column.getLeafColumns().forEach(t => {
            (t.getColDef().suppressMovable || t.getColDef().lockPosition) && (e = !0)
          });
          return e || this.gos.get("suppressMovableColumns")
        }
      },
      ol = 0,
      al = class extends ct {
        constructor(e, t, i) {
          super(), this.instanceId = ol++, this.rowIndex = e, this.pinned = t, this.type = i;
          const r = "group" == i ? "ag-header-row-column-group" : "filter" == i ? "ag-header-row-column-filter" : "ag-header-row-column";
          this.headerRowClass = `ag-header-row ${r}`
        }
        postConstruct() {
          this.isPrintLayout = this.gos.isDomLayout("print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder")
        }
        getInstanceId() {
          return this.instanceId
        }
        setComp(e, t = !0) {
          this.comp = e, t && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners()
        }
        getHeaderRowClass() {
          return this.headerRowClass
        }
        getAriaRowIndex() {
          return this.rowIndex + 1
        }
        addEventListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_VIRTUAL_COLUMNS_CHANGED, e => this.onVirtualColumnsChanged(e.afterScroll)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_GRID_STYLES_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), this.addManagedPropertyListener("ensureDomOrder", e => this.isEnsureDomOrder = e.currentValue), this.addManagedPropertyListener("headerHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("groupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotGroupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("floatingFiltersHeight", this.onRowHeightChanged.bind(this))
        }
        getHeaderCellCtrl(e) {
          if (this.headerCellCtrls) return P(this.headerCellCtrls).find(t => t.getColumnGroupChild() === e)
        }
        onDisplayedColumnsChanged() {
          this.isPrintLayout = this.gos.isDomLayout("print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged()
        }
        getType() {
          return this.type
        }
        onColumnResized() {
          this.setWidth()
        }
        setWidth() {
          const e = this.getWidthForRow();
          this.comp.setWidth(`${e}px`)
        }
        getWidthForRow() {
          const {
            columnModel: e
          } = this.beans;
          if (this.isPrintLayout) {
            return null != this.pinned ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null)
          }
          return e.getContainerWidth(this.pinned)
        }
        onRowHeightChanged() {
          var {
            topOffset: e,
            rowHeight: t
          } = this.getTopAndHeight();
          this.comp.setTop(e + "px"), this.comp.setHeight(t + "px")
        }
        getTopAndHeight() {
          const {
            columnModel: e,
            filterManager: t
          } = this.beans;
          let i = e.getHeaderRowCount();
          const r = [];
          let s = 0;
          t.hasFloatingFilters() && (i++, s = 1);
          const n = e.getColumnGroupHeaderRowHeight(),
            o = e.getColumnHeaderRowHeight(),
            a = i - (1 + s);
          for (let e = 0; e < a; e++) r.push(n);
          r.push(o);
          for (let t = 0; t < s; t++) r.push(e.getFloatingFiltersHeight());
          let l = 0;
          for (let e = 0; e < this.rowIndex; e++) l += r[e];
          return {
            topOffset: l,
            rowHeight: r[this.rowIndex]
          }
        }
        getPinned() {
          return this.pinned
        }
        getRowIndex() {
          return this.rowIndex
        }
        onVirtualColumnsChanged(e = !1) {
          const t = this.getHeaderCtrls(),
            i = this.isEnsureDomOrder || this.isPrintLayout;
          this.comp.setHeaderCtrls(t, i, e)
        }
        getHeaderCtrls() {
          const e = this.headerCellCtrls;
          this.headerCellCtrls = new Map;
          const t = this.getColumnsInViewport();
          for (const i of t) this.recycleAndCreateHeaderCtrls(i, e);
          const i = e => {
            const {
              focusService: t,
              columnModel: i
            } = this.beans;
            if (!t.isHeaderWrapperFocused(e)) return !1;
            return i.isDisplayed(e.getColumnGroupChild())
          };
          if (e)
            for (const [t, r] of e) {
              i(r) ? this.headerCellCtrls.set(t, r) : this.destroyBean(r)
            }
          return Array.from(this.headerCellCtrls.values())
        }
        recycleAndCreateHeaderCtrls(e, t) {
          if (!this.headerCellCtrls) return;
          if (e.isEmptyGroup()) return;
          const i = e.getUniqueId();
          let r;
          t && (r = t.get(i), t.delete(i));
          if (r && r.getColumnGroupChild() != e && (this.destroyBean(r), r = void 0), null == r) switch (this.type) {
            case "filter":
              r = this.createBean(new Za(e, this.beans, this));
              break;
            case "group":
              r = this.createBean(new nl(e, this.beans, this));
              break;
            default:
              r = this.createBean(new il(e, this.beans, this))
          }
          this.headerCellCtrls.set(i, r)
        }
        getColumnsInViewport() {
          return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout()
        }
        getColumnsInViewportPrintLayout() {
          if (null != this.pinned) return [];
          let e = [];
          const t = this.getActualDepth(),
            {
              columnModel: i
            } = this.beans;
          return ["left", null, "right"].forEach(r => {
            const s = i.getVirtualHeaderGroupRow(r, t);
            e = e.concat(s)
          }), e
        }
        getActualDepth() {
          return "filter" == this.type ? this.rowIndex - 1 : this.rowIndex
        }
        getColumnsInViewportNormalLayout() {
          return this.beans.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth())
        }
        focusHeader(e, t) {
          if (!this.headerCellCtrls) return !1;
          const i = Array.from(this.headerCellCtrls.values()).find(t => t.getColumnGroupChild() == e);
          return !!i && i.focus(t)
        }
        destroy() {
          this.headerCellCtrls && this.headerCellCtrls.forEach(e => {
            this.destroyBean(e)
          }), this.headerCellCtrls = void 0, super.destroy()
        }
      };
    C([fe("beans")], al.prototype, "beans", 2), C([pe], al.prototype, "postConstruct", 1);
    var ll = class extends ct {
      constructor(e) {
        super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e
      }
      setComp(e, t) {
        this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport), this.addManagedListener(this.eventService, Et.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh()
      }
      setupDragAndDrop(e) {
        const t = new Va(this.pinned, e);
        this.createManagedBean(t)
      }
      refresh(e = !1) {
        const t = new Ss,
          i = this.focusService.getFocusHeaderToUseAfterRefresh();
        (() => {
          const e = this.columnModel.getHeaderRowCount() - 1;
          this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
          for (let i = 0; i < e; i++) {
            const e = this.createBean(new al(t.next(), this.pinned, "group"));
            this.groupsRowCtrls.push(e)
          }
        })(), (() => {
          const i = t.next(),
            r = !(this.hidden || null != this.columnsRowCtrl && e && this.columnsRowCtrl.getRowIndex() === i);
          (r || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), r && (this.columnsRowCtrl = this.createBean(new al(i, this.pinned, "column")))
        })(), (() => {
          this.includeFloatingFilter = this.filterManager.hasFloatingFilters() && !this.hidden;
          const i = () => {
            this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)
          };
          if (!this.includeFloatingFilter) return void i();
          const r = t.next();
          if (this.filtersRowCtrl) {
            const t = this.filtersRowCtrl.getRowIndex() !== r;
            e && !t || i()
          }
          this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new al(r, this.pinned, "filter")))
        })();
        const r = this.getAllCtrls();
        this.comp.setCtrls(r), this.restoreFocusOnHeader(i)
      }
      restoreFocusOnHeader(e) {
        null != e && e.column.getPinned() == this.pinned && this.focusService.focusHeaderPosition({
          headerPosition: e
        })
      }
      getAllCtrls() {
        const e = [...this.groupsRowCtrls];
        return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e
      }
      onGridColumnsChanged() {
        this.refresh(!0)
      }
      onDisplayedColumnsChanged() {
        const e = this.filterManager.hasFloatingFilters() && !this.hidden;
        this.includeFloatingFilter !== e && this.refresh(!0)
      }
      setupCenterWidth() {
        null == this.pinned && this.createManagedBean(new Ia(e => this.comp.setCenterWidth(`${e}px`), !0))
      }
      setHorizontalScroll(e) {
        this.comp.setViewportScrollLeft(e)
      }
      setupPinnedWidth() {
        if (null == this.pinned) return;
        const e = "left" === this.pinned,
          t = "right" === this.pinned;
        this.hidden = !0;
        const i = () => {
          const i = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
          if (null == i) return;
          const r = 0 == i,
            s = this.hidden !== r,
            n = this.gos.get("enableRtl"),
            o = this.gos.getScrollbarWidth(),
            a = this.scrollVisibleService.isVerticalScrollShowing() && (n && e || !n && t) ? i + o : i;
          this.comp.setPinnedContainerWidth(`${a}px`), this.comp.setDisplayed(!r), s && (this.hidden = r, this.refresh())
        };
        this.addManagedListener(this.eventService, Et.EVENT_LEFT_PINNED_WIDTH_CHANGED, i), this.addManagedListener(this.eventService, Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED, i), this.addManagedListener(this.eventService, Et.EVENT_SCROLL_VISIBILITY_CHANGED, i), this.addManagedListener(this.eventService, Et.EVENT_SCROLLBAR_WIDTH_CHANGED, i)
      }
      getHeaderCtrlForColumn(e) {
        if (e instanceof Le) {
          if (!this.columnsRowCtrl) return;
          return this.columnsRowCtrl.getHeaderCellCtrl(e)
        }
        if (0 !== this.groupsRowCtrls.length)
          for (let t = 0; t < this.groupsRowCtrls.length; t++) {
            const i = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
            if (i) return i
          }
      }
      getHtmlElementForColumnHeader(e) {
        const t = this.getHeaderCtrlForColumn(e);
        return t ? t.getGui() : null
      }
      getRowType(e) {
        const t = this.getAllCtrls()[e];
        return t ? t.getType() : void 0
      }
      focusHeader(e, t, i) {
        const r = this.getAllCtrls()[e];
        return !!r && r.focusHeader(t, i)
      }
      getViewport() {
        return this.eViewport
      }
      getRowCount() {
        return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0)
      }
      destroy() {
        this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy()
      }
    };
    C([fe("ctrlsService")], ll.prototype, "ctrlsService", 2), C([fe("scrollVisibleService")], ll.prototype, "scrollVisibleService", 2), C([fe("pinnedWidthService")], ll.prototype, "pinnedWidthService", 2), C([fe("columnModel")], ll.prototype, "columnModel", 2), C([fe("focusService")], ll.prototype, "focusService", 2), C([fe("filterManager")], ll.prototype, "filterManager", 2);
    var cl = class e extends _s {
      constructor(e) {
        super(), this.headerRowComps = {}, this.rowCompsList = [], this.pinned = e
      }
      init() {
        this.selectAndSetTemplate();
        const e = {
          setDisplayed: e => this.setDisplayed(e),
          setCtrls: e => this.setCtrls(e),
          setCenterWidth: e => this.eCenterContainer.style.width = e,
          setViewportScrollLeft: e => this.getGui().scrollLeft = e,
          setPinnedContainerWidth: e => {
            const t = this.getGui();
            t.style.width = e, t.style.maxWidth = e, t.style.minWidth = e
          }
        };
        this.createManagedBean(new ll(this.pinned)).setComp(e, this.getGui())
      }
      selectAndSetTemplate() {
        const t = "left" == this.pinned,
          i = "right" == this.pinned,
          r = t ? e.PINNED_LEFT_TEMPLATE : i ? e.PINNED_RIGHT_TEMPLATE : e.CENTER_TEMPLATE;
        this.setTemplate(r), this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui()
      }
      destroyRowComps() {
        this.setCtrls([])
      }
      destroyRowComp(e) {
        this.destroyBean(e), this.eRowContainer.removeChild(e.getGui())
      }
      setCtrls(e) {
        const t = this.headerRowComps;
        let i;
        this.headerRowComps = {}, this.rowCompsList = [];
        const r = e => {
          const t = e.getGui();
          t.parentElement != this.eRowContainer && this.eRowContainer.appendChild(t), i && yr(this.eRowContainer, t, i), i = t
        };
        e.forEach(e => {
          const i = e.getInstanceId(),
            s = t[i];
          delete t[i];
          const n = s || this.createBean(new za(e));
          this.headerRowComps[i] = n, this.rowCompsList.push(n), r(n)
        }), H(t).forEach(e => this.destroyRowComp(e))
      }
    };
    cl.PINNED_LEFT_TEMPLATE = '<div class="ag-pinned-left-header" role="rowgroup"></div>', cl.PINNED_RIGHT_TEMPLATE = '<div class="ag-pinned-right-header" role="rowgroup"></div>', cl.CENTER_TEMPLATE = '<div class="ag-header-viewport" role="presentation">\n            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>\n        </div>', C([ys("eCenterContainer")], cl.prototype, "eCenterContainer", 2), C([pe], cl.prototype, "init", 1), C([Ee], cl.prototype, "destroyRowComps", 1);
    var hl = cl,
      ul = class extends ct {
        constructor() {
          super(...arguments), this.currentHeaderRowWithoutSpan = -1
        }
        postConstruct() {
          this.ctrlsService.whenReady(e => {
            this.gridBodyCon = e.gridBodyCtrl
          });
          const e = this.gos.getDocument();
          this.addManagedListener(e, "mousedown", () => this.setCurrentHeaderRowWithoutSpan(-1))
        }
        getHeaderRowCount() {
          const e = this.ctrlsService.getHeaderRowContainerCtrl();
          return e ? e.getRowCount() : 0
        }
        navigateVertically(e, t, i) {
          if (t || (t = this.focusService.getFocusedHeader()), !t) return !1;
          const {
            headerRowIndex: r,
            column: s
          } = t, n = this.getHeaderRowCount(), o = 0 === e;
          let {
            headerRowIndex: a,
            column: l,
            headerRowIndexWithoutSpan: c
          } = o ? this.headerPositionUtils.getColumnVisibleParent(s, r) : this.headerPositionUtils.getColumnVisibleChild(s, r), h = !1;
          return a < 0 && (a = 0, l = s, h = !0), a >= n ? (a = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : void 0 !== c && (this.currentHeaderRowWithoutSpan = c), !(!h && !l) && this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: a,
              column: l
            },
            allowUserOverride: !0,
            event: i
          })
        }
        setCurrentHeaderRowWithoutSpan(e) {
          this.currentHeaderRowWithoutSpan = e
        }
        navigateHorizontally(e, t = !1, i) {
          const r = this.focusService.getFocusedHeader(),
            s = 2 === e,
            n = this.gos.get("enableRtl");
          let o, a;
          if (-1 !== this.currentHeaderRowWithoutSpan ? r.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = r.headerRowIndex, s !== n ? (a = "Before", o = this.headerPositionUtils.findHeader(r, a)) : (a = "After", o = this.headerPositionUtils.findHeader(r, a)), o || !t) return this.focusService.focusHeaderPosition({
            headerPosition: o,
            direction: a,
            fromTab: t,
            allowUserOverride: !0,
            event: i
          });
          if (t) {
            const e = this.gos.getCallback("tabToNextHeader");
            if (e) return this.focusService.focusHeaderPositionFromUserFunc({
              userFunc: e,
              headerPosition: o,
              direction: a
            })
          }
          return this.focusNextHeaderRow(r, a, i)
        }
        focusNextHeaderRow(e, t, i) {
          const r = e.headerRowIndex;
          let s, n = null;
          if ("Before" === t ? r > 0 && (s = r - 1, this.currentHeaderRowWithoutSpan -= 1, n = this.headerPositionUtils.findColAtEdgeForHeaderRow(s, "end")) : (s = r + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), n = this.headerPositionUtils.findColAtEdgeForHeaderRow(s, "start")), !n) return !1;
          const {
            column: o,
            headerRowIndex: a
          } = this.headerPositionUtils.getHeaderIndexToFocus(n.column, null == n ? void 0 : n.headerRowIndex);
          return this.focusService.focusHeaderPosition({
            headerPosition: {
              column: o,
              headerRowIndex: a
            },
            direction: t,
            fromTab: !0,
            allowUserOverride: !0,
            event: i
          })
        }
        scrollToColumn(e, t = "After") {
          if (e.getPinned()) return;
          let i;
          if (e instanceof pt) {
            const r = e.getDisplayedLeafColumns();
            i = "Before" === t ? Me(r) : r[0]
          } else i = e;
          this.gridBodyCon.getScrollFeature().ensureColumnVisible(i)
        }
      };
    C([fe("focusService")], ul.prototype, "focusService", 2), C([fe("headerPositionUtils")], ul.prototype, "headerPositionUtils", 2), C([fe("ctrlsService")], ul.prototype, "ctrlsService", 2), C([pe], ul.prototype, "postConstruct", 1), ul = C([ge("headerNavigationService")], ul);
    var dl = class extends ct {
      setComp(e, t, i) {
        this.comp = e, this.eGui = t, this.createManagedBean(new xs(i, {
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusOut: this.onFocusOut.bind(this)
        })), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.onPivotModeChanged(), this.setupHeaderHeight();
        const r = this.onHeaderContextMenu.bind(this);
        this.addManagedListener(this.eGui, "contextmenu", r), this.mockContextMenuForIPad(r), this.ctrlsService.register("gridHeaderCtrl", this)
      }
      setupHeaderHeight() {
        const e = this.setHeaderHeight.bind(this);
        e(), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("pivotHeaderHeight", e), this.addManagedPropertyListener("groupHeaderHeight", e), this.addManagedPropertyListener("pivotGroupHeaderHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_GRID_STYLES_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, e)
      }
      getHeaderHeight() {
        return this.headerHeight
      }
      setHeaderHeight() {
        const {
          columnModel: e
        } = this;
        let t, i = 0,
          r = e.getHeaderRowCount();
        this.filterManager.hasFloatingFilters() && (r++, i = 1);
        const s = this.columnModel.getColumnGroupHeaderRowHeight(),
          n = this.columnModel.getColumnHeaderRowHeight(),
          o = r - (1 + i);
        if (t = i * e.getFloatingFiltersHeight(), t += o * s, t += n, this.headerHeight === t) return;
        this.headerHeight = t;
        const a = `${t+1}px`;
        this.comp.setHeightAndMinHeight(a), this.eventService.dispatchEvent({
          type: Et.EVENT_HEADER_HEIGHT_CHANGED
        })
      }
      onPivotModeChanged() {
        const e = this.columnModel.isPivotMode();
        this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e)
      }
      onDisplayedColumnsChanged() {
        const e = this.columnModel.getAllDisplayedColumns().some(e => e.isSpanHeaderHeight());
        this.comp.addOrRemoveCssClass("ag-header-allow-overflow", e)
      }
      onTabKeyDown(e) {
        const t = this.gos.get("enableRtl"),
          i = e.shiftKey !== t ? 2 : 3;
        (this.headerNavigationService.navigateHorizontally(i, !0, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) && e.preventDefault()
      }
      handleKeyDown(e) {
        let t = null;
        switch (e.key) {
          case ts.LEFT:
            t = 2;
          case ts.RIGHT:
            v(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, !1, e);
            break;
          case ts.UP:
            t = 0;
          case ts.DOWN:
            v(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
            break;
          default:
            return
        }
      }
      onFocusOut(e) {
        const {
          relatedTarget: t
        } = e;
        !t && this.eGui.contains(this.gos.getActiveDomElement()) || this.eGui.contains(t) || this.focusService.clearFocusedHeader()
      }
      onHeaderContextMenu(e, t, i) {
        if (!e && !i || !this.menuService.isHeaderContextMenuEnabled()) return;
        const {
          target: r
        } = null != e ? e : t;
        r !== this.eGui && r !== this.ctrlsService.getHeaderRowContainerCtrl().getViewport() || this.menuService.showHeaderContextMenu(void 0, e, i)
      }
      mockContextMenuForIPad(e) {
        if (!Gi()) return;
        const t = new In(this.eGui);
        this.addManagedListener(t, In.EVENT_LONG_TAP, t => {
          e(void 0, t.touchStart, t.touchEvent)
        }), this.addDestroyFunc(() => t.destroy())
      }
    };
    C([fe("headerNavigationService")], dl.prototype, "headerNavigationService", 2), C([fe("focusService")], dl.prototype, "focusService", 2), C([fe("columnModel")], dl.prototype, "columnModel", 2), C([fe("ctrlsService")], dl.prototype, "ctrlsService", 2), C([fe("filterManager")], dl.prototype, "filterManager", 2), C([fe("menuService")], dl.prototype, "menuService", 2);
    var pl = class e extends _s {
      constructor() {
        super(e.TEMPLATE)
      }
      postConstruct() {
        const e = {
          addOrRemoveCssClass: (e, t) => this.addOrRemoveCssClass(e, t),
          setHeightAndMinHeight: e => {
            this.getGui().style.height = e, this.getGui().style.minHeight = e
          }
        };
        this.createManagedBean(new dl).setComp(e, this.getGui(), this.getFocusableElement());
        const t = e => {
          this.createManagedBean(e), this.appendChild(e)
        };
        t(new hl("left")), t(new hl(null)), t(new hl("right"))
      }
    };
    pl.TEMPLATE = '<div class="ag-header" role="presentation"/>', C([pe], pl.prototype, "postConstruct", 1);
    var El = pl,
      gl = class extends ct {
        addResizeBar(e) {
          const t = {
            dragStartPixels: e.dragStartPixels || 0,
            eElement: e.eResizeBar,
            onDragStart: this.onDragStart.bind(this, e),
            onDragStop: this.onDragStop.bind(this, e),
            onDragging: this.onDragging.bind(this, e),
            includeTouch: !0,
            stopPropagationForTouch: !0
          };
          this.dragService.addDragSource(t);
          return () => this.dragService.removeDragSource(t)
        }
        onDragStart(e, t) {
          this.dragStartX = t.clientX, this.setResizeIcons();
          const i = t instanceof MouseEvent && !0 === t.shiftKey;
          e.onResizeStart(i)
        }
        setResizeIcons() {
          const e = this.ctrlsService.get("gridCtrl");
          e.setResizeCursor(!0), e.disableUserSelect(!0)
        }
        onDragStop(e, t) {
          e.onResizeEnd(this.resizeAmount), this.resetIcons()
        }
        resetIcons() {
          const e = this.ctrlsService.get("gridCtrl");
          e.setResizeCursor(!1), e.disableUserSelect(!1)
        }
        onDragging(e, t) {
          this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount)
        }
      };
    C([fe("dragService")], gl.prototype, "dragService", 2), C([fe("ctrlsService")], gl.prototype, "ctrlsService", 2), gl = C([ge("horizontalResizeService")], gl);
    var fl = class extends ct {
      hideActiveMenu() {
        this.hidePopup && this.hidePopup()
      }
      showMenuAfterMouseEvent(e, t, i) {
        this.showPopup(e, r => {
          this.popupService.positionPopupUnderMouseEvent({
            column: e,
            type: i,
            mouseEvent: t,
            ePopup: r
          })
        }, i, t.target, this.menuService.isLegacyMenuEnabled())
      }
      showMenuAfterButtonClick(e, t, i) {
        let r = -1,
          s = "left";
        const n = this.menuService.isLegacyMenuEnabled();
        !n && this.gos.get("enableRtl") && (r = 1, s = "right");
        let o = n ? void 0 : 4 * r,
          a = n ? void 0 : 4;
        this.showPopup(e, r => {
          this.popupService.positionPopupByComponent({
            type: i,
            eventSource: t,
            ePopup: r,
            nudgeX: o,
            nudgeY: a,
            alignSide: s,
            keepWithinBounds: !0,
            position: "under",
            column: e
          })
        }, i, t, n)
      }
      showPopup(e, t, i, r, s) {
        const n = e ? this.createBean(new Jo(e, "COLUMN_MENU")) : void 0;
        if (this.activeMenu = n, !(null == n ? void 0 : n.hasFilter()) || !e) throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
        const o = document.createElement("div");
        let a;
        Xt(o, "presentation"), o.classList.add("ag-menu"), s || o.classList.add("ag-filter-menu"), this.tabListener = this.addManagedListener(o, "keydown", e => this.trapFocusWithin(e, o)), o.appendChild(null == n ? void 0 : n.getGui());
        const l = this.menuService.isColumnMenuAnchoringEnabled() ? null != r ? r : this.ctrlsService.getGridBodyCtrl().getGui() : void 0,
          c = this.localeService.getLocaleTextFunc(),
          h = s && "columnFilter" !== i ? c("ariaLabelColumnMenu", "Column Menu") : c("ariaLabelColumnFilter", "Column Filter"),
          u = this.popupService.addPopup({
            modal: !0,
            eChild: o,
            closeOnEsc: !0,
            closedCallback: t => {
              e.setMenuVisible(!1, "contextMenu");
              const s = t instanceof KeyboardEvent;
              if (this.tabListener && (this.tabListener = this.tabListener()), s && r && Lr(r)) {
                const e = this.focusService.findTabbableParent(r);
                e && e.focus()
              }
              null == n || n.afterGuiDetached(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, i, e)
            },
            positionCallback: () => t(o),
            anchorToElement: l,
            ariaLabel: h
          });
        u && (this.hidePopup = a = u.hideFunc), n.afterInit().then(() => {
          t(o), n.afterGuiAttached({
            container: i,
            hidePopup: a
          })
        }), e.setMenuVisible(!0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, i, e)
      }
      trapFocusWithin(e, t) {
        e.key !== ts.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey))
      }
      dispatchVisibleChangedEvent(e, t, i) {
        const r = {
          type: Et.EVENT_COLUMN_MENU_VISIBLE_CHANGED,
          visible: e,
          switchingTab: !1,
          key: t,
          column: null != i ? i : null
        };
        this.eventService.dispatchEvent(r)
      }
      isMenuEnabled(e) {
        var t;
        return e.isFilterAllowed() && (null != (t = e.getColDef().menuTabs) ? t : ["filterMenuTab"]).includes("filterMenuTab")
      }
      showMenuAfterContextMenuEvent() {}
      destroy() {
        this.destroyBean(this.activeMenu), super.destroy()
      }
    };
    C([fe("filterManager")], fl.prototype, "filterManager", 2), C([fe("popupService")], fl.prototype, "popupService", 2), C([fe("focusService")], fl.prototype, "focusService", 2), C([fe("ctrlsService")], fl.prototype, "ctrlsService", 2), C([fe("menuService")], fl.prototype, "menuService", 2), fl = C([ge("filterMenuFactory")], fl);
    var Tl = class extends ct {
      constructor(e) {
        super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1;
        const {
          comp: t,
          eTopGuard: i,
          eBottomGuard: r,
          focusTrapActive: s,
          forceFocusOutWhenTabGuardsAreEmpty: n,
          focusInnerElement: o,
          onFocusIn: a,
          onFocusOut: l,
          shouldStopEventPropagation: c,
          onTabKeyDown: h,
          handleKeyDown: u,
          eFocusableElement: d
        } = e;
        this.comp = t, this.eTopGuard = i, this.eBottomGuard = r, this.providedFocusInnerElement = o, this.eFocusableElement = d, this.focusTrapActive = !!s, this.forceFocusOutWhenTabGuardsAreEmpty = !!n, this.providedFocusIn = a, this.providedFocusOut = l, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = h, this.providedHandleKeyDown = u
      }
      postConstruct() {
        this.createManagedBean(new xs(this.eFocusableElement, {
          shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
          onTabKeyDown: e => this.onTabKeyDown(e),
          handleKeyDown: e => this.handleKeyDown(e),
          onFocusIn: e => this.onFocusIn(e),
          onFocusOut: e => this.onFocusOut(e)
        })), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(e => this.addManagedListener(e, "focus", this.onFocus.bind(this)))
      }
      handleKeyDown(e) {
        this.providedHandleKeyDown && this.providedHandleKeyDown(e)
      }
      tabGuardsAreActive() {
        return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex")
      }
      shouldStopEventPropagation() {
        return !!this.providedShouldStopEventPropagation && this.providedShouldStopEventPropagation()
      }
      activateTabGuards() {
        if (this.forcingFocusOut) return;
        const e = this.gos.get("tabIndex");
        this.comp.setTabIndex(e.toString())
      }
      deactivateTabGuards() {
        this.comp.setTabIndex()
      }
      onFocus(e) {
        if (this.skipTabGuardFocus) return void(this.skipTabGuardFocus = !1);
        if (this.forceFocusOutWhenTabGuardsAreEmpty) {
          if (0 === this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length) return void this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard)
        }
        const t = e.target === this.eBottomGuard;
        this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t)
      }
      findNextElementOutsideAndFocus(e) {
        const t = this.gos.getDocument(),
          i = this.focusService.findFocusableElements(t.body, null, !0),
          r = i.indexOf(e ? this.eTopGuard : this.eBottomGuard);
        if (-1 === r) return;
        let s, n;
        e ? (s = 0, n = r) : (s = r + 1, n = i.length);
        const o = i.slice(s, n),
          a = this.gos.get("tabIndex");
        o.sort((e, t) => {
          const i = parseInt(e.getAttribute("tabindex") || "0"),
            r = parseInt(t.getAttribute("tabindex") || "0");
          return r === a ? 1 : i === a ? -1 : 0 === i ? 1 : 0 === r ? -1 : i - r
        }), o[e ? o.length - 1 : 0].focus()
      }
      onFocusIn(e) {
        this.focusTrapActive || (this.providedFocusIn && this.providedFocusIn(e), this.deactivateTabGuards())
      }
      onFocusOut(e) {
        this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards())
      }
      onTabKeyDown(e) {
        if (this.providedOnTabKeyDown) return void this.providedOnTabKeyDown(e);
        if (this.focusTrapActive) return;
        if (e.defaultPrevented) return;
        const t = this.tabGuardsAreActive();
        t && this.deactivateTabGuards();
        const i = this.getNextFocusableElement(e.shiftKey);
        t && setTimeout(() => this.activateTabGuards(), 0), i && (i.focus(), e.preventDefault())
      }
      focusInnerElement(e = !1) {
        const t = this.focusService.findFocusableElements(this.eFocusableElement);
        this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({
          preventScroll: !0
        })
      }
      getNextFocusableElement(e) {
        return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e)
      }
      forceFocusOutOfContainer(e = !1) {
        if (this.forcingFocusOut) return;
        const t = e ? this.eTopGuard : this.eBottomGuard;
        this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
          this.forcingFocusOut = !1, this.activateTabGuards()
        })
      }
      isTabGuard(e) {
        return e === this.eTopGuard || e === this.eBottomGuard
      }
    };
    C([fe("focusService")], Tl.prototype, "focusService", 2), C([pe], Tl.prototype, "postConstruct", 1);
    var ml = class extends _s {
        initialiseTabGuard(e) {
          this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.getFocusableElement();
          const t = [this.eTopGuard, this.eBottomGuard],
            i = {
              setTabIndex: e => {
                t.forEach(t => null != e ? t.setAttribute("tabindex", e) : t.removeAttribute("tabindex"))
              }
            };
          this.addTabGuards(this.eTopGuard, this.eBottomGuard), this.tabGuardCtrl = this.createManagedBean(new Tl({
            comp: i,
            focusTrapActive: !!e.focusTrapActive,
            eTopGuard: this.eTopGuard,
            eBottomGuard: this.eBottomGuard,
            eFocusableElement: this.eFocusableElement,
            onFocusIn: e.onFocusIn,
            onFocusOut: e.onFocusOut,
            focusInnerElement: e.focusInnerElement,
            handleKeyDown: e.handleKeyDown,
            onTabKeyDown: e.onTabKeyDown,
            shouldStopEventPropagation: e.shouldStopEventPropagation,
            forceFocusOutWhenTabGuardsAreEmpty: e.forceFocusOutWhenTabGuardsAreEmpty
          }))
        }
        createTabGuard(e) {
          const t = document.createElement("div"),
            i = "top" === e ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
          return t.classList.add("ag-tab-guard", i), Xt(t, "presentation"), t
        }
        addTabGuards(e, t) {
          this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t)
        }
        removeAllChildrenExceptTabGuards() {
          const e = [this.eTopGuard, this.eBottomGuard];
          Nr(this.getFocusableElement()), this.addTabGuards(...e)
        }
        forceFocusOutOfContainer(e = !1) {
          this.tabGuardCtrl.forceFocusOutOfContainer(e)
        }
        appendChild(e, t) {
          kr(e) || (e = e.getGui());
          const {
            eBottomGuard: i
          } = this;
          i ? i.insertAdjacentElement("beforebegin", e) : super.appendChild(e, t)
        }
      },
      Cl = class e extends ml {
        constructor(t) {
          super(e.getTemplate(t.cssClass)), this.items = [], this.tabbedItemScrollMap = new Map, this.params = t
        }
        postConstruct() {
          this.setupHeader(), this.params.items && this.params.items.forEach(e => this.addItem(e)), this.initialiseTabGuard({
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            focusInnerElement: this.focusInnerElement.bind(this),
            focusTrapActive: !0
          }), this.addDestroyFunc(() => {
            var e, t, i;
            return null == (i = null == (t = null == (e = this.activeItem) ? void 0 : e.tabbedItem) ? void 0 : t.afterDetachedCallback) ? void 0 : i.call(t)
          })
        }
        static getTemplate(e) {
          return `<div class="ag-tabs ${e}">\n            <div ref="eHeader"></div>\n            <div ref="eBody" role="presentation" class="ag-tabs-body ${e?`${e}-body`:""}"></div>\n        </div>`
        }
        setupHeader() {
          const {
            enableCloseButton: e,
            cssClass: t
          } = this.params, i = (e, i) => {
            e.classList.add(`ag-tabs-${i}`), t && e.classList.add(`${t}-${i}`)
          };
          e ? (this.setupCloseButton(i), this.eTabHeader = this.gos.getDocument().createElement("div"), i(this.eHeader, "header-wrapper"), Xt(this.eHeader, "presentation"), this.eHeader.appendChild(this.eTabHeader)) : this.eTabHeader = this.eHeader, Xt(this.eTabHeader, "tablist"), i(this.eTabHeader, "header")
        }
        setupCloseButton(e) {
          const t = this.gos.getDocument(),
            i = t.createElement("button");
          e(i, "close-button");
          const r = Zr("close", this.gos, void 0, !0);
          qt(i, this.params.closeButtonAriaLabel), i.appendChild(r), this.addManagedListener(i, "click", () => {
            var e, t;
            return null == (t = (e = this.params).onCloseClicked) ? void 0 : t.call(e)
          });
          const s = t.createElement("div");
          e(s, "close-button-wrapper"), Xt(s, "presentation"), s.appendChild(i), this.eHeader.appendChild(s), this.eCloseButton = i
        }
        handleKeyDown(e) {
          switch (e.key) {
            case ts.RIGHT:
            case ts.LEFT:
              if (!this.eTabHeader.contains(this.gos.getActiveDomElement())) return;
              const t = e.key === ts.RIGHT,
                i = this.gos.get("enableRtl"),
                r = this.items.indexOf(this.activeItem),
                s = t !== i ? Math.min(r + 1, this.items.length - 1) : Math.max(r - 1, 0);
              if (r === s) return;
              e.preventDefault();
              const n = this.items[s];
              this.showItemWrapper(n), n.eHeaderButton.focus();
              break;
            case ts.UP:
            case ts.DOWN:
              e.stopPropagation()
          }
        }
        onTabKeyDown(e) {
          var t, i, r, s;
          if (e.defaultPrevented) return;
          const {
            focusService: n,
            eHeader: o,
            eBody: a,
            activeItem: l,
            params: c
          } = this, {
            suppressTrapFocus: h,
            enableCloseButton: u
          } = c, d = this.gos.getActiveDomElement(), p = e.target, E = e.shiftKey;
          if (o.contains(d)) return e.preventDefault(), void(u && E && !(null == (t = this.eCloseButton) ? void 0 : t.contains(d)) ? null == (i = this.eCloseButton) || i.focus() : h && E ? null == (r = this.focusService.findFocusableElementBeforeTabGuard(this.gos.getDocument().body, p)) || r.focus() : this.focusBody(e.shiftKey));
          let g = null;
          if (n.isTargetUnderManagedComponent(a, p) && (E && (g = this.focusService.findFocusableElementBeforeTabGuard(a, p)), g || h || (g = l.eHeaderButton)), !g && a.contains(d) && (g = n.findNextFocusableElement(a, !1, E), !g)) return e.preventDefault(), void(h && !E ? this.forceFocusOutOfContainer(E) : u && !E ? null == (s = this.eCloseButton) || s.focus() : this.focusHeader());
          g && (e.preventDefault(), g.focus())
        }
        focusInnerElement(e) {
          e ? this.focusHeader() : this.focusBody(!0)
        }
        focusHeader(e) {
          this.activeItem.eHeaderButton.focus({
            preventScroll: e
          })
        }
        focusBody(e) {
          this.focusService.focusInto(this.eBody, e)
        }
        setAfterAttachedParams(e) {
          this.afterAttachedParams = e
        }
        showFirstItem() {
          this.items.length > 0 && this.showItemWrapper(this.items[0])
        }
        addItem(e) {
          const t = document.createElement("span");
          Xt(t, "tab"), t.setAttribute("tabindex", "-1"), t.appendChild(e.title), t.classList.add("ag-tab"), this.eTabHeader.appendChild(t), qt(t, e.titleLabel);
          const i = {
            tabbedItem: e,
            eHeaderButton: t
          };
          this.items.push(i), t.addEventListener("click", this.showItemWrapper.bind(this, i))
        }
        showItem(e) {
          const t = this.items.find(t => t.tabbedItem === e);
          t && this.showItemWrapper(t)
        }
        showItemWrapper(e) {
          var t, i, r, s, n, o;
          const {
            tabbedItem: a,
            eHeaderButton: l
          } = e;
          null == (i = (t = this.params).onItemClicked) || i.call(t, {
            item: a
          }), this.activeItem !== e ? (this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), Nr(this.eBody), a.bodyPromise.then(e => {
            this.eBody.appendChild(e);
            const t = !this.focusService.isKeyboardMode();
            if (this.params.suppressFocusBodyOnOpen || this.focusService.focusInto(this.eBody, !1, t), a.afterAttachedCallback && a.afterAttachedCallback(this.afterAttachedParams), this.params.keepScrollPosition) {
              const t = a.getScrollableContainer && a.getScrollableContainer() || e;
              this.lastScrollListener = this.addManagedListener(t, "scroll", () => {
                this.tabbedItemScrollMap.set(a.name, t.scrollTop)
              });
              const i = this.tabbedItemScrollMap.get(a.name);
              void 0 !== i && setTimeout(() => {
                t.scrollTop = i
              }, 0)
            }
          }), this.activeItem && (this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), null == (o = (n = this.activeItem.tabbedItem).afterDetachedCallback) || o.call(n)), l.classList.add("ag-tab-selected"), this.activeItem = e) : null == (s = (r = this.params).onActiveItemClicked) || s.call(r)
        }
      };
    C([fe("focusService")], Cl.prototype, "focusService", 2), C([ys("eHeader")], Cl.prototype, "eHeader", 2), C([ys("eBody")], Cl.prototype, "eBody", 2), C([pe], Cl.prototype, "postConstruct", 1);
    var Sl = class extends ct {
      constructor() {
        super(...arguments), this.polyfillFunctions = []
      }
      observeResize(e, t) {
        const i = this.gos.getWindow(),
          r = () => {
            var i, r;
            let s = null != (i = null == e ? void 0 : e.clientWidth) ? i : 0,
              n = null != (r = null == e ? void 0 : e.clientHeight) ? r : 0,
              o = !0;
            const a = () => {
              var i, r;
              if (o) {
                const o = null != (i = null == e ? void 0 : e.clientWidth) ? i : 0,
                  l = null != (r = null == e ? void 0 : e.clientHeight) ? r : 0;
                (o !== s || l !== n) && (s = o, n = l, t()), this.doNextPolyfillTurn(a)
              }
            };
            return a(), () => o = !1
          },
          s = this.gos.get("suppressBrowserResizeObserver");
        return !!i.ResizeObserver && !s ? (() => {
          const r = new i.ResizeObserver(t);
          return r.observe(e), () => r.disconnect()
        })() : this.getFrameworkOverrides().wrapIncoming(() => r(), "resize-observer")
      }
      doNextPolyfillTurn(e) {
        this.polyfillFunctions.push(e), this.schedulePolyfill()
      }
      schedulePolyfill() {
        if (this.polyfillScheduled) return;
        this.polyfillScheduled = !0, window.setTimeout(() => {
          const e = this.polyfillFunctions;
          this.polyfillScheduled = !1, this.polyfillFunctions = [], e.forEach(e => e())
        }, 50)
      }
    };
    Sl = C([ge("resizeObserverService")], Sl);
    var Rl = class extends ct {
      constructor() {
        super(...arguments), this.createTasksP1 = {
          list: [],
          sorted: !1
        }, this.createTasksP2 = {
          list: [],
          sorted: !1
        }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = new Set
      }
      setScrollTop(e) {
        const t = this.gos.get("pagination");
        if (this.scrollGoingDown = e >= this.lastScrollTop, t && 0 === e) {
          const e = this.paginationProxy.getCurrentPage();
          e !== this.lastPage && (this.lastPage = e, this.scrollGoingDown = !0)
        }
        this.lastScrollTop = e
      }
      init() {
        this.useAnimationFrame = !this.gos.get("suppressAnimationFrame")
      }
      isOn() {
        return this.useAnimationFrame
      }
      verifyAnimationFrameOn(e) {
        !1 === this.useAnimationFrame && console.warn(`AG Grid: AnimationFrameService.${e} called but animation frames are off`)
      }
      createTask(e, t, i) {
        this.verifyAnimationFrameOn(i);
        const r = {
          task: e,
          index: t,
          createOrder: ++this.taskCount
        };
        this.addTaskToList(this[i], r), this.schedule()
      }
      cancelTask(e) {
        this.cancelledTasks.add(e)
      }
      addTaskToList(e, t) {
        e.list.push(t), e.sorted = !1
      }
      sortTaskList(e) {
        if (e.sorted) return;
        const t = this.scrollGoingDown ? 1 : -1;
        e.list.sort((e, i) => e.index !== i.index ? t * (i.index - e.index) : i.createOrder - e.createOrder), e.sorted = !0
      }
      addDestroyTask(e) {
        this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule()
      }
      executeFrame(e) {
        this.verifyAnimationFrameOn("executeFrame");
        const t = this.createTasksP1,
          i = t.list,
          r = this.createTasksP2,
          s = r.list,
          n = this.destroyTasks,
          o = (new Date).getTime();
        let a = (new Date).getTime() - o;
        const l = e <= 0,
          c = this.ctrlsService.getGridBodyCtrl();
        for (; l || a < e;) {
          if (!c.getScrollFeature().scrollGridIfNeeded()) {
            let e;
            if (i.length) this.sortTaskList(t), e = i.pop().task;
            else if (s.length) this.sortTaskList(r), e = s.pop().task;
            else {
              if (!n.length) {
                this.cancelledTasks.clear();
                break
              }
              e = n.pop()
            }
            this.cancelledTasks.has(e) || e()
          }
          a = (new Date).getTime() - o
        }
        i.length || s.length || n.length ? this.requestFrame() : this.stopTicking()
      }
      stopTicking() {
        this.ticking = !1
      }
      flushAllFrames() {
        this.useAnimationFrame && this.executeFrame(-1)
      }
      schedule() {
        this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()))
      }
      requestFrame() {
        const e = this.executeFrame.bind(this, 60);
        this.requestAnimationFrame(e)
      }
      requestAnimationFrame(e) {
        const t = this.gos.getWindow();
        t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0)
      }
      isQueueEmpty() {
        return !this.ticking
      }
      debounce(e) {
        let t = !1;
        return () => {
          this.isOn() ? t || (t = !0, this.addDestroyTask(() => {
            t = !1, e()
          })) : window.setTimeout(e, 0)
        }
      }
    };
    C([fe("ctrlsService")], Rl.prototype, "ctrlsService", 2), C([fe("paginationProxy")], Rl.prototype, "paginationProxy", 2), C([pe], Rl.prototype, "init", 1), Rl = C([ge("animationFrameService")], Rl);
    var Al = class extends ct {
      postConstruct() {
        this.isClientSideRowModel = "clientSide" === this.rowModel.getType()
      }
      expandRows(e) {
        if (!this.isClientSideRowModel) return;
        const t = new Set(e);
        this.rowModel.forEachNode(e => {
          e.id && t.has(e.id) && (e.expanded = !0)
        }), this.onGroupExpandedOrCollapsed()
      }
      getExpandedRows() {
        const e = [];
        return this.rowModel.forEachNode(({
          expanded: t,
          id: i
        }) => {
          t && i && e.push(i)
        }), e
      }
      expandAll(e) {
        this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e)
      }
      setRowNodeExpanded(e, t, i, r) {
        e && (i && e.parent && -1 !== e.parent.level && this.setRowNodeExpanded(e.parent, t, i, r), e.setExpanded(t, void 0, r))
      }
      onGroupExpandedOrCollapsed() {
        this.isClientSideRowModel && this.rowModel.refreshModel({
          step: "map"
        })
      }
    };
    C([fe("rowModel")], Al.prototype, "rowModel", 2), C([pe], Al.prototype, "postConstruct", 1), Al = C([ge("expansionService")], Al);
    var vl = class extends ct {
      postConstruct() {
        var e;
        this.activeMenuFactory = null != (e = this.enterpriseMenuFactory) ? e : this.filterMenuFactory
      }
      showColumnMenu(e) {
        this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu")
      }
      showFilterMenu(e) {
        const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
        this.showColumnMenuCommon(t, e, e.containerType, !0)
      }
      showHeaderContextMenu(e, t, i) {
        this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, i)
      }
      getContextMenuPosition(e, t) {
        const i = this.getRowCtrl(e),
          r = this.getCellGui(i, t);
        if (!r) return i ? {
          x: 0,
          y: i.getRowYPosition()
        } : {
          x: 0,
          y: 0
        };
        const s = r.getBoundingClientRect();
        return {
          x: s.x + s.width / 2,
          y: s.y + s.height / 2
        }
      }
      showContextMenu(e) {
        var t, i, r;
        const {
          column: s,
          rowNode: n
        } = e;
        let {
          anchorToElement: o,
          value: a
        } = e;
        n && s && null == a && (a = n.getValueFromValueService(s)), null == o && (o = this.getContextMenuAnchorElement(n, s)), null == (r = this.contextMenuFactory) || r.onContextMenu(null != (t = e.mouseEvent) ? t : null, null != (i = e.touchEvent) ? i : null, null != n ? n : null, null != s ? s : null, a, o)
      }
      showColumnChooser(e) {
        var t;
        null == (t = this.columnChooserFactory) || t.showColumnChooser(e)
      }
      hidePopupMenu() {
        var e;
        null == (e = this.contextMenuFactory) || e.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu()
      }
      hideColumnChooser() {
        var e;
        null == (e = this.columnChooserFactory) || e.hideActiveColumnChooser()
      }
      isColumnMenuInHeaderEnabled(e) {
        const {
          suppressMenu: t,
          suppressHeaderMenuButton: i
        } = e.getColDef();
        return !(null != i ? i : t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory)
      }
      isFilterMenuInHeaderEnabled(e) {
        return !e.getColDef().suppressHeaderFilterButton && this.filterManager.isFilterAllowed(e)
      }
      isHeaderContextMenuEnabled(e) {
        return !(null == e ? void 0 : e.getColDef().suppressHeaderContextMenu) && "new" === this.getColumnMenuType()
      }
      isHeaderMenuButtonAlwaysShowEnabled() {
        return this.isSuppressMenuHide()
      }
      isHeaderMenuButtonEnabled() {
        const e = !this.isSuppressMenuHide();
        return !(Gi() && e)
      }
      isHeaderFilterButtonEnabled(e) {
        return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e)
      }
      isFilterMenuItemEnabled(e) {
        return this.filterManager.isFilterAllowed(e) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e)
      }
      isColumnMenuAnchoringEnabled() {
        return !this.isLegacyMenuEnabled()
      }
      areAdditionalColumnMenuItemsEnabled() {
        return "new" === this.getColumnMenuType()
      }
      isLegacyMenuEnabled() {
        return "legacy" === this.getColumnMenuType()
      }
      isFloatingFilterButtonEnabled(e) {
        var t;
        const i = e.getColDef(),
          r = null == (t = i.floatingFilterComponentParams) ? void 0 : t.suppressFilterButton;
        return null != r && z("As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."), null == i.suppressFloatingFilterButton ? !r : !i.suppressFloatingFilterButton
      }
      getColumnMenuType() {
        var e;
        return null != (e = this.gos.get("columnMenu")) ? e : "legacy"
      }
      isFloatingFilterButtonDisplayed(e) {
        return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e)
      }
      isSuppressMenuHide() {
        const e = this.gos.get("suppressMenuHide");
        return this.isLegacyMenuEnabled() ? e : !this.gos.exists("suppressMenuHide") || e
      }
      showColumnMenuCommon(e, t, i, r) {
        const {
          column: s,
          positionBy: n
        } = t;
        if ("button" === n) {
          const {
            buttonElement: n
          } = t;
          e.showMenuAfterButtonClick(s, n, i, r)
        } else if ("mouse" === n) {
          const {
            mouseEvent: n
          } = t;
          e.showMenuAfterMouseEvent(s, n, i, r)
        } else s && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(s, "auto"), this.animationFrameService.requestAnimationFrame(() => {
          const t = this.ctrlsService.getHeaderRowContainerCtrl(s.getPinned()).getHeaderCtrlForColumn(s);
          e.showMenuAfterButtonClick(s, t.getAnchorElementForMenu(r), i, !0)
        }))
      }
      getRowCtrl(e) {
        const {
          rowIndex: t,
          rowPinned: i
        } = e || {};
        if (null != t) return this.rowRenderer.getRowByPosition({
          rowIndex: t,
          rowPinned: i
        }) || void 0
      }
      getCellGui(e, t) {
        if (!e || !t) return;
        const i = e.getCellCtrl(t);
        return (null == i ? void 0 : i.getGui()) || void 0
      }
      getContextMenuAnchorElement(e, t) {
        const i = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(),
          r = this.getRowCtrl(e);
        if (!r) return i;
        const s = this.getCellGui(r, t);
        return s || (r.isFullWidth() ? r.getFullWidthElement() : i)
      }
    };
    C([fe("filterMenuFactory")], vl.prototype, "filterMenuFactory", 2), C([fe("ctrlsService")], vl.prototype, "ctrlsService", 2), C([fe("animationFrameService")], vl.prototype, "animationFrameService", 2), C([fe("filterManager")], vl.prototype, "filterManager", 2), C([fe("rowRenderer")], vl.prototype, "rowRenderer", 2), C([Te("columnChooserFactory")], vl.prototype, "columnChooserFactory", 2), C([Te("contextMenuFactory")], vl.prototype, "contextMenuFactory", 2), C([Te("enterpriseMenuFactory")], vl.prototype, "enterpriseMenuFactory", 2), C([pe], vl.prototype, "postConstruct", 1), vl = C([ge("menuService")], vl);
    var Nl = class extends ct {
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          this.centerRowContainerCtrl = e.center
        })
      }
      getPreferredWidthForColumn(e, t) {
        const i = this.getHeaderCellForColumn(e);
        if (!i) return -1;
        const r = this.rowRenderer.getAllCellsForColumn(e);
        return t || r.push(i), this.addElementsToContainerAndGetWidth(r)
      }
      getPreferredWidthForColumnGroup(e) {
        const t = this.getHeaderCellForColumn(e);
        return t ? this.addElementsToContainerAndGetWidth([t]) : -1
      }
      addElementsToContainerAndGetWidth(e) {
        const t = document.createElement("form");
        t.style.position = "fixed";
        const i = this.centerRowContainerCtrl.getContainerElement();
        e.forEach(e => this.cloneItemIntoDummy(e, t)), i.appendChild(t);
        const r = t.offsetWidth;
        i.removeChild(t);
        return r + this.getAutoSizePadding()
      }
      getAutoSizePadding() {
        return this.gos.get("autoSizePadding")
      }
      getHeaderCellForColumn(e) {
        let t = null;
        return this.ctrlsService.getHeaderRowContainerCtrls().forEach(i => {
          const r = i.getHtmlElementForColumnHeader(e);
          null != r && (t = r)
        }), t
      }
      cloneItemIntoDummy(e, t) {
        const i = e.cloneNode(!0);
        i.style.width = "", i.style.position = "static", i.style.left = "";
        const r = document.createElement("div"),
          s = r.classList;
        ["ag-header-cell", "ag-header-group-cell"].some(e => i.classList.contains(e)) ? (s.add("ag-header", "ag-header-row"), r.style.position = "static") : s.add("ag-row");
        let n = e.parentElement;
        for (; n;) {
          if (["ag-header-row", "ag-row"].some(e => n.classList.contains(e))) {
            for (let e = 0; e < n.classList.length; e++) {
              const t = n.classList[e];
              "ag-row-position-absolute" != t && s.add(t)
            }
            break
          }
          n = n.parentElement
        }
        r.appendChild(i), t.appendChild(r)
      }
    };
    C([fe("rowRenderer")], Nl.prototype, "rowRenderer", 2), C([fe("ctrlsService")], Nl.prototype, "ctrlsService", 2), C([fe("rowCssClassCalculator")], Nl.prototype, "rowCssClassCalculator", 2), C([pe], Nl.prototype, "postConstruct", 1), Nl = C([ge("autoWidthCalculator")], Nl);
    var Il = class extends ct {
      constructor(e, t) {
        super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.topContainerHeight = 0, this.bottomContainerHeight = 0
      }
      postConstruct() {
        this.isClientSide = "clientSide" === this.rowModel.getType(), this.ctrlsService.whenReady(e => {
          this.gridBodyCtrl = e.gridBodyCtrl
        })
      }
      getStickyTopRowCtrls() {
        return this.stickyTopRowCtrls
      }
      getStickyBottomRowCtrls() {
        return this.stickyBottomRowCtrls
      }
      getLastPixelOfGroup(e) {
        return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e)
      }
      getFirstPixelOfGroup(e) {
        return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0
      }
      getServerSideLastPixelOfGroup(e) {
        var t, i, r, s;
        if (this.isClientSide) throw new Error("This func should only be called in server side row model.");
        if (e.isExpandable() || e.footer) {
          if (e.master) return e.detailNode.rowTop + e.detailNode.rowHeight;
          if (!e.sibling || 1 === Math.abs(e.sibling.rowIndex - e.rowIndex)) {
            let n = null == (t = e.childStore) ? void 0 : t.getStoreBounds();
            return e.footer && (n = null == (i = e.sibling.childStore) ? void 0 : i.getStoreBounds()), (null != (r = null == n ? void 0 : n.heightPx) ? r : 0) + (null != (s = null == n ? void 0 : n.topPx) ? s : 0)
          }
          return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight
        }
        return Number.MAX_SAFE_INTEGER
      }
      getClientSideLastPixelOfGroup(e) {
        if (!this.isClientSide) throw new Error("This func should only be called in client side row model.");
        if (e.isExpandable() || e.footer) {
          const t = e.footer && 0 === e.rowIndex,
            i = !e.sibling || 1 === Math.abs(e.sibling.rowIndex - e.rowIndex);
          if (t || i) {
            let t = e.footer ? e.sibling : e;
            for (; t.isExpandable() && t.expanded;)
              if (t.master) t = t.detailNode;
              else if (t.childrenAfterSort) {
              if (0 === t.childrenAfterSort.length) break;
              t = Me(t.childrenAfterSort)
            }
            return t.rowTop + t.rowHeight
          }
          return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight
        }
        return Number.MAX_SAFE_INTEGER
      }
      updateStickyRows(e) {
        const t = "top" === e;
        let i = 0;
        if (!this.canRowsBeSticky()) return this.refreshNodesAndContainerHeight(e, new Set, i);
        const r = t ? this.rowRenderer.getFirstVisibleVerticalPixel() : this.rowRenderer.getLastVisibleVerticalPixel(),
          s = new Set,
          n = e => {
            if (s.add(e), t) {
              const t = this.getLastPixelOfGroup(e),
                s = r + i + e.rowHeight;
              e.stickyRowTop = t < s ? i + (t - s) : i
            } else {
              const t = this.getFirstPixelOfGroup(e),
                s = r - (i + e.rowHeight);
              e.stickyRowTop = t > s ? i - (t - s) : i
            }
            i = 0, s.forEach(e => {
              const t = e.stickyRowTop + e.rowHeight;
              i < t && (i = t)
            })
          },
          o = this.areFooterRowsStickySuppressed(),
          a = this.gos.get("suppressGroupRowsSticky"),
          l = e => {
            if (!e.displayed) return !1;
            if (e.footer) {
              if (!0 === o) return !1;
              if ("grand" === o && -1 === e.level) return !1;
              if ("group" === o && e.level > -1) return !1;
              return !s.has(e)
            }
            if (e.isExpandable()) {
              if (!0 === a) return !1;
              return !s.has(e) && e.expanded
            }
            return !1
          };
        for (let e = 0; e < 100; e++) {
          let e = r + i;
          t || (e = r - i);
          const s = this.rowModel.getRowIndexAtPixel(e),
            o = this.rowModel.getRow(s);
          if (null == o) break;
          const a = this.getStickyAncestors(o).find(e => (t ? e.rowIndex < s : e.rowIndex > s) && l(e));
          if (a) {
            n(a);
            continue
          }
          if (!(t ? o.rowTop < e : o.rowTop + o.rowHeight > e) || !l(o)) break;
          n(o)
        }
        return t || s.forEach(e => {
          e.stickyRowTop = i - (e.stickyRowTop + e.rowHeight)
        }), this.refreshNodesAndContainerHeight(e, s, i)
      }
      areFooterRowsStickySuppressed() {
        const e = this.gos.get("suppressStickyTotalRow");
        if (!0 === e) return !0;
        const t = !!this.gos.get("groupIncludeFooter") || "group" === e,
          i = !!this.gos.get("groupIncludeTotalFooter") || "grand" === e;
        return !(!t || !i) || (i ? "grand" : !!t && "group")
      }
      canRowsBeSticky() {
        const e = this.gos.isGroupRowsSticky(),
          t = this.areFooterRowsStickySuppressed(),
          i = this.gos.get("suppressGroupRowsSticky");
        return e && (!t || !i)
      }
      getStickyAncestors(e) {
        const t = [];
        let i = e.footer ? e.sibling : e.parent;
        for (; i;) i.sibling && t.push(i.sibling), t.push(i), i = i.parent;
        return t.reverse()
      }
      checkStickyRows() {
        const e = this.updateStickyRows("top"),
          t = this.updateStickyRows("bottom");
        return e || t
      }
      destroyStickyCtrls() {
        this.refreshNodesAndContainerHeight("top", new Set, 0), this.refreshNodesAndContainerHeight("bottom", new Set, 0)
      }
      refreshStickyNode(e) {
        const t = new Set;
        if (this.stickyTopRowCtrls.some(t => t.getRowNode() === e)) {
          for (let i = 0; i < this.stickyTopRowCtrls.length; i++) {
            const r = this.stickyTopRowCtrls[i].getRowNode();
            r !== e && t.add(r)
          }
          this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows()
        } else {
          for (let i = 0; i < this.stickyBottomRowCtrls.length; i++) {
            const r = this.stickyBottomRowCtrls[i].getRowNode();
            r !== e && t.add(r)
          }
          this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows()
        }
      }
      refreshNodesAndContainerHeight(e, t, i) {
        const r = "top" === e,
          s = r ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls,
          n = {},
          o = [];
        for (let e = 0; e < s.length; e++) {
          const i = s[e].getRowNode();
          !t.has(i) ? (n[i.id] = s[e], i.sticky = !1) : o.push(s[e])
        }
        const a = new Set;
        for (let e = 0; e < o.length; e++) a.add(o[e].getRowNode());
        const l = [];
        t.forEach(e => {
          a.has(e) || (e.sticky = !0, l.push(this.createRowCon(e, !1, !1)))
        });
        let c = !!l.length || o.length !== s.length;
        r ? this.topContainerHeight !== i && (this.topContainerHeight = i, this.gridBodyCtrl.setStickyTopHeight(i), c = !0) : this.bottomContainerHeight !== i && (this.bottomContainerHeight = i, this.gridBodyCtrl.setStickyBottomHeight(i), c = !0), this.destroyRowCtrls(n, !1);
        const h = [...o, ...l];
        return h.sort((e, t) => t.getRowNode().rowIndex - e.getRowNode().rowIndex), r || h.reverse(), h.forEach(e => e.setRowTop(e.getRowNode().stickyRowTop)), !!c && (r ? this.stickyTopRowCtrls = h : this.stickyBottomRowCtrls = h, !0)
      }
    };
    C([fe("rowModel")], Il.prototype, "rowModel", 2), C([fe("rowRenderer")], Il.prototype, "rowRenderer", 2), C([fe("ctrlsService")], Il.prototype, "ctrlsService", 2), C([pe], Il.prototype, "postConstruct", 1);
    var Ol = class extends ct {
      constructor() {
        super(...arguments), this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
          const e = () => {
              this.getAllCellCtrls().forEach(e => e.onRangeSelectionChanged())
            },
            t = () => {
              this.getAllCellCtrls().forEach(e => e.updateRangeBordersIfRangeCount())
            },
            i = () => {
              this.eventService.addEventListener(Et.EVENT_RANGE_SELECTION_CHANGED, e), this.eventService.addEventListener(Et.EVENT_COLUMN_MOVED, t), this.eventService.addEventListener(Et.EVENT_COLUMN_PINNED, t), this.eventService.addEventListener(Et.EVENT_COLUMN_VISIBLE, t)
            },
            r = () => {
              this.eventService.removeEventListener(Et.EVENT_RANGE_SELECTION_CHANGED, e), this.eventService.removeEventListener(Et.EVENT_COLUMN_MOVED, t), this.eventService.removeEventListener(Et.EVENT_COLUMN_PINNED, t), this.eventService.removeEventListener(Et.EVENT_COLUMN_VISIBLE, t)
            };
          this.addDestroyFunc(() => r()), this.addManagedPropertyListener("enableRangeSelection", e => {
            e.currentValue ? i() : r()
          });
          this.gos.get("enableRangeSelection") && i()
        }
      }
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          this.gridBodyCtrl = e.gridBodyCtrl, this.initialise()
        })
      }
      initialise() {
        if (this.addManagedListener(this.eventService, Et.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL, this.onBodyScroll.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_BODY_HEIGHT_CHANGED, this.redraw.bind(this)), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListeners(["suppressCellFocus", "getBusinessKeyForNode", "fullWidthCellRenderer", "fullWidthCellRendererParams", "rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules", "suppressStickyTotalRow", "groupRowRenderer", "groupRowRendererParams", "loadingCellRenderer", "loadingCellRendererParams", "detailCellRenderer", "detailCellRendererParams", "enableRangeSelection", "enableCellTextSelection"], () => this.redrawRows()), this.gos.isGroupRowsSticky()) {
          const e = this.rowModel.getType();
          "clientSide" !== e && "serverSide" !== e || (this.stickyRowFeature = this.createManagedBean(new Il(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this))))
        }
        this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gos.isDomLayout("print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate()
      }
      initialiseCache() {
        if (this.gos.get("keepDetailRows")) {
          const e = this.getKeepDetailRowsCount(),
            t = null != e ? e : 3;
          this.cachedRowCtrls = new Ll(t)
        }
      }
      getKeepDetailRowsCount() {
        return this.gos.get("keepDetailRowsCount")
      }
      getStickyTopRowCtrls() {
        return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : []
      }
      getStickyBottomRowCtrls() {
        return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : []
      }
      updateAllRowCtrls() {
        const e = H(this.rowCtrlsByRowIndex),
          t = H(this.zombieRowCtrls),
          i = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
        t.length > 0 || i.length > 0 ? this.allRowCtrls = [...e, ...t, ...i] : this.allRowCtrls = e
      }
      onCellFocusChanged(e) {
        this.getAllCellCtrls().forEach(t => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach(t => t.onFullWidthRowFocused(e))
      }
      registerCellEventListeners() {
        this.addManagedListener(this.eventService, Et.EVENT_CELL_FOCUSED, e => {
          this.onCellFocusChanged(e)
        }), this.addManagedListener(this.eventService, Et.EVENT_CELL_FOCUS_CLEARED, () => {
          this.onCellFocusChanged()
        }), this.addManagedListener(this.eventService, Et.EVENT_FLASH_CELLS, e => {
          this.getAllCellCtrls().forEach(t => t.onFlashCells(e))
        }), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_HOVER_CHANGED, () => {
          this.getAllCellCtrls().forEach(e => e.onColumnHover())
        }), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, () => {
          this.getAllCellCtrls().forEach(e => e.onDisplayedColumnsChanged())
        }), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {
          this.printLayout && this.getAllCellCtrls().forEach(e => e.onLeftChanged())
        }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedListener(this.eventService, Et.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this)), this.addDestroyFunc(this.removeGridColumnListeners.bind(this))
      }
      removeGridColumnListeners() {
        this.destroyFuncsForColumnListeners.forEach(e => e()), this.destroyFuncsForColumnListeners.length = 0
      }
      refreshListenersToColumnsForCellComps() {
        this.removeGridColumnListeners();
        this.columnModel.getAllGridColumns().forEach(e => {
          const t = t => {
              this.getAllCellCtrls().forEach(i => {
                i.getColumn() === e && t(i)
              })
            },
            i = () => {
              t(e => e.onLeftChanged())
            },
            r = () => {
              t(e => e.onWidthChanged())
            },
            s = () => {
              t(e => e.onFirstRightPinnedChanged())
            },
            n = () => {
              t(e => e.onLastLeftPinnedChanged())
            },
            o = () => {
              t(e => e.onColDefChanged())
            };
          e.addEventListener("leftChanged", i), e.addEventListener("widthChanged", r), e.addEventListener("firstRightPinnedChanged", s), e.addEventListener("lastLeftPinnedChanged", n), e.addEventListener("colDefChanged", o), this.destroyFuncsForColumnListeners.push(() => {
            e.removeEventListener("leftChanged", i), e.removeEventListener("widthChanged", r), e.removeEventListener("firstRightPinnedChanged", s), e.removeEventListener("lastLeftPinnedChanged", n), e.removeEventListener("colDefChanged", o)
          })
        })
      }
      onDomLayoutChanged() {
        const e = this.gos.isDomLayout("print"),
          t = e || this.gos.get("embedFullWidthRows"),
          i = t !== this.embedFullWidthRows || this.printLayout !== e;
        this.printLayout = e, this.embedFullWidthRows = t, i && this.redrawAfterModelUpdate({
          domLayoutChanged: !0
        })
      }
      datasourceChanged() {
        this.firstRenderedRow = 0, this.lastRenderedRow = -1;
        const e = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(e)
      }
      onPageLoaded(e) {
        const t = {
          recycleRows: e.keepRenderedRows,
          animate: e.animate,
          newData: e.newData,
          newPage: e.newPage,
          onlyBody: !0
        };
        this.redrawAfterModelUpdate(t)
      }
      getAllCellsForColumn(e) {
        const t = [];
        return this.getAllRowCtrls().forEach(i => {
          const r = i.getCellElement(e);
          r && t.push(r)
        }), t
      }
      refreshFloatingRowComps() {
        this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData())
      }
      getTopRowCtrls() {
        return this.topRowCtrls
      }
      getCentreRowCtrls() {
        return this.allRowCtrls
      }
      getBottomRowCtrls() {
        return this.bottomRowCtrls
      }
      refreshFloatingRows(e, t) {
        e.forEach(e => {
          e.destroyFirstPass(), e.destroySecondPass()
        }), e.length = 0, t && t.forEach(t => {
          const i = new ma(t, this.beans, !1, !1, this.printLayout);
          e.push(i)
        })
      }
      onPinnedRowDataChanged() {
        this.redrawAfterModelUpdate({
          recycleRows: !0
        })
      }
      redrawRow(e, t = !1) {
        var i;
        if (e.sticky) this.stickyRowFeature.refreshStickyNode(e);
        else {
          if (null == (i = this.cachedRowCtrls) ? void 0 : i.has(e)) return void this.cachedRowCtrls.removeRow(e); {
            const t = t => {
              const i = t[e.rowIndex];
              i && i.getRowNode() === e && (i.destroyFirstPass(), i.destroySecondPass(), t[e.rowIndex] = this.createRowCon(e, !1, !1))
            };
            switch (e.rowPinned) {
              case "top":
                t(this.topRowCtrls);
                break;
              case "bottom":
                t(this.bottomRowCtrls);
                break;
              default:
                t(this.rowCtrlsByRowIndex), this.updateAllRowCtrls()
            }
          }
        }
        t || this.dispatchDisplayedRowsChanged(!1)
      }
      redrawRows(e) {
        if (null != e) return null == e || e.forEach(e => this.redrawRow(e, !0)), void this.dispatchDisplayedRowsChanged(!1);
        this.redrawAfterModelUpdate()
      }
      getCellToRestoreFocusToAfterRefresh(e) {
        const t = (null == e ? void 0 : e.suppressKeepFocus) ? null : this.focusService.getFocusCellToUseAfterRefresh();
        if (null == t) return null;
        const i = this.gos.getActiveDomElement(),
          r = this.gos.getDomData(i, ga.DOM_DATA_KEY_CELL_CTRL),
          s = this.gos.getDomData(i, ma.DOM_DATA_KEY_ROW_CTRL);
        return r || s ? t : null
      }
      redrawAfterModelUpdate(e = {}) {
        this.getLockOnRefresh();
        const t = this.getCellToRestoreFocusToAfterRefresh(e);
        this.updateContainerHeights(), this.scrollToTopIfNewData(e);
        const i = !e.domLayoutChanged && !!e.recycleRows,
          r = e.animate && this.gos.isAnimateRows(),
          s = i ? this.getRowsToRecycle() : null;
        i || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature && this.stickyRowFeature.checkStickyRows(), this.recycleRows(s, r), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), null != t && this.restoreFocusedCell(t), this.releaseLockOnRefresh()
      }
      scrollToTopIfNewData(e) {
        const t = e.newData || e.newPage,
          i = this.gos.get("suppressScrollOnNewData");
        t && !i && this.gridBodyCtrl.getScrollFeature().scrollToTop()
      }
      updateContainerHeights() {
        if (this.printLayout) return void this.rowContainerHeightService.setModelHeight(null);
        let e = this.paginationProxy.getCurrentPageHeight();
        0 === e && (e = 1), this.rowContainerHeightService.setModelHeight(e)
      }
      getLockOnRefresh() {
        if (this.refreshInProgress) throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
        this.refreshInProgress = !0
      }
      releaseLockOnRefresh() {
        this.refreshInProgress = !1
      }
      isRefreshInProgress() {
        return this.refreshInProgress
      }
      restoreFocusedCell(e) {
        e && (this.focusService.setRestoreFocusedCell(e), this.onCellFocusChanged(this.beans.gos.addGridCommonParams({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          type: "mock"
        })))
      }
      stopEditing(e = !1) {
        this.getAllRowCtrls().forEach(t => {
          t.stopEditing(e)
        })
      }
      getAllCellCtrls() {
        const e = [],
          t = this.getAllRowCtrls(),
          i = t.length;
        for (let r = 0; r < i; r++) {
          const i = t[r].getAllCellCtrls(),
            s = i.length;
          for (let t = 0; t < s; t++) e.push(i[t])
        }
        return e
      }
      getAllRowCtrls() {
        const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [],
          t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [],
          i = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
        for (const e in this.rowCtrlsByRowIndex) i.push(this.rowCtrlsByRowIndex[e]);
        return i
      }
      addRenderedRowListener(e, t, i) {
        const r = this.rowCtrlsByRowIndex[t];
        r && r.addEventListener(e, i)
      }
      flashCells(e = {}) {
        this.getCellCtrls(e.rowNodes, e.columns).forEach(t => t.flashCell(e))
      }
      refreshCells(e = {}) {
        const t = {
          forceRefresh: e.force,
          newData: !1,
          suppressFlash: e.suppressFlash
        };
        this.getCellCtrls(e.rowNodes, e.columns).forEach(e => e.refreshOrDestroyCell(t)), e.rowNodes && (this.getRowCtrls(e.rowNodes).forEach(e => {
          if (!e.isFullWidth()) return;
          e.refreshFullWidth() || this.redrawRow(e.getRowNode(), !0)
        }), this.dispatchDisplayedRowsChanged(!1))
      }
      getCellRendererInstances(e) {
        var t;
        const i = this.getCellCtrls(e.rowNodes, e.columns).map(e => e.getCellRenderer()).filter(e => null != e);
        if (null == (t = e.columns) ? void 0 : t.length) return i;
        const r = [],
          s = this.mapRowNodes(e.rowNodes);
        return this.getAllRowCtrls().forEach(e => {
          if (s && !this.isRowInMap(e.getRowNode(), s)) return;
          if (!e.isFullWidth()) return;
          const t = e.getFullWidthCellRenderers();
          for (let e = 0; e < t.length; e++) {
            const i = t[e];
            null != i && r.push(i)
          }
        }), [...r, ...i]
      }
      getCellEditorInstances(e) {
        const t = [];
        return this.getCellCtrls(e.rowNodes, e.columns).forEach(e => {
          const i = e.getCellEditor();
          i && t.push(i)
        }), t
      }
      getEditingCells() {
        const e = [];
        return this.getAllCellCtrls().forEach(t => {
          if (t.isEditing()) {
            const i = t.getCellPosition();
            e.push(i)
          }
        }), e
      }
      mapRowNodes(e) {
        if (!e) return;
        const t = {
          top: {},
          bottom: {},
          normal: {}
        };
        return e.forEach(e => {
          const i = e.id;
          switch (e.rowPinned) {
            case "top":
              t.top[i] = e;
              break;
            case "bottom":
              t.bottom[i] = e;
              break;
            default:
              t.normal[i] = e
          }
        }), t
      }
      isRowInMap(e, t) {
        const i = e.id;
        switch (e.rowPinned) {
          case "top":
            return null != t.top[i];
          case "bottom":
            return null != t.bottom[i];
          default:
            return null != t.normal[i]
        }
      }
      getRowCtrls(e) {
        const t = this.mapRowNodes(e),
          i = this.getAllRowCtrls();
        return e && t ? i.filter(e => {
          const i = e.getRowNode();
          return this.isRowInMap(i, t)
        }) : i
      }
      getCellCtrls(e, t) {
        let i;
        v(t) && (i = {}, t.forEach(e => {
          const t = this.columnModel.getGridColumn(e);
          v(t) && (i[t.getId()] = !0)
        }));
        const r = [];
        return this.getRowCtrls(e).forEach(e => {
          e.getAllCellCtrls().forEach(e => {
            const t = e.getColumn().getId();
            i && !i[t] || r.push(e)
          })
        }), r
      }
      destroy() {
        this.removeAllRowComps(), super.destroy()
      }
      removeAllRowComps() {
        const e = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls()
      }
      getRowsToRecycle() {
        const e = [];
        x(this.rowCtrlsByRowIndex, (t, i) => {
          null == i.getRowNode().id && e.push(t)
        }), this.removeRowCtrls(e);
        const t = {};
        return x(this.rowCtrlsByRowIndex, (e, i) => {
          const r = i.getRowNode();
          t[r.id] = i
        }), this.rowCtrlsByRowIndex = {}, t
      }
      removeRowCtrls(e, t = !1) {
        e.forEach(e => {
          const i = this.rowCtrlsByRowIndex[e];
          i && (i.destroyFirstPass(t), i.destroySecondPass()), delete this.rowCtrlsByRowIndex[e]
        })
      }
      onBodyScroll(e) {
        "vertical" === e.direction && this.redraw({
          afterScroll: !0
        })
      }
      redraw(e = {}) {
        const {
          afterScroll: t
        } = e;
        let i;
        this.stickyRowFeature && Ui() && (i = this.getCellToRestoreFocusToAfterRefresh() || void 0);
        const r = this.firstRenderedRow,
          s = this.lastRenderedRow;
        this.workOutFirstAndLastRowsToRender();
        let n = !1;
        this.stickyRowFeature && (n = this.stickyRowFeature.checkStickyRows());
        const o = this.firstRenderedRow !== r || this.lastRenderedRow !== s;
        if ((!t || n || o) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !n), null != i)) {
          const e = this.getCellToRestoreFocusToAfterRefresh();
          null != i && null == e && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(i))
        }
      }
      removeRowCompsNotToDraw(e, t) {
        const i = {};
        e.forEach(e => i[e] = !0);
        const r = Object.keys(this.rowCtrlsByRowIndex).filter(e => !i[e]);
        this.removeRowCtrls(r, t)
      }
      calculateIndexesToDraw(e) {
        let t = ji(this.firstRenderedRow, this.lastRenderedRow);
        const i = (e, i) => {
          const r = i.getRowNode().rowIndex;
          null != r && (r < this.firstRenderedRow || r > this.lastRenderedRow) && this.doNotUnVirtualiseRow(i) && t.push(r)
        };
        x(this.rowCtrlsByRowIndex, i), x(e, i), t.sort((e, t) => e - t);
        const r = [];
        for (let e = 0; e < t.length; e++) {
          const i = t[e],
            s = this.paginationProxy.getRow(i);
          s && !s.sticky && r.push(i)
        }
        return r
      }
      recycleRows(e, t = !1, i = !1) {
        const r = this.calculateIndexesToDraw(e);
        (this.printLayout || i) && (t = !1), this.removeRowCompsNotToDraw(r, !t);
        const s = [];
        if (r.forEach(r => {
            const n = this.createOrUpdateRowCtrl(r, e, t, i);
            v(n) && s.push(n)
          }), e) {
          i && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
            this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged()
          }) : this.destroyRowCtrls(e, t)
        }
        this.updateAllRowCtrls()
      }
      dispatchDisplayedRowsChanged(e = !1) {
        const t = {
          type: Et.EVENT_DISPLAYED_ROWS_CHANGED,
          afterScroll: e
        };
        this.eventService.dispatchEvent(t)
      }
      onDisplayedColumnsChanged() {
        const e = this.columnModel.isPinningLeft(),
          t = this.columnModel.isPinningRight();
        (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows())
      }
      redrawFullWidthEmbeddedRows() {
        const e = [];
        this.getFullWidthRowCtrls().forEach(t => {
          const i = t.getRowNode().rowIndex;
          e.push(i.toString())
        }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({
          afterScroll: !0
        })
      }
      getFullWidthRowCtrls(e) {
        const t = this.mapRowNodes(e);
        return this.getAllRowCtrls().filter(e => {
          if (!e.isFullWidth()) return !1;
          const i = e.getRowNode();
          return !(null != t && !this.isRowInMap(i, t))
        })
      }
      createOrUpdateRowCtrl(e, t, i, r) {
        let s, n = this.rowCtrlsByRowIndex[e];
        n || (s = this.paginationProxy.getRow(e), v(s) && v(t) && t[s.id] && s.alreadyRendered && (n = t[s.id], t[s.id] = null));
        if (!n) {
          if (s || (s = this.paginationProxy.getRow(e)), !v(s)) return;
          n = this.createRowCon(s, i, r)
        }
        return s && (s.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = n, n
      }
      destroyRowCtrls(e, t) {
        const i = [];
        x(e, (e, r) => {
          r && (this.cachedRowCtrls && r.isCacheable() ? this.cachedRowCtrls.addRow(r) : (r.destroyFirstPass(!t), t ? (this.zombieRowCtrls[r.getInstanceId()] = r, i.push(() => {
            r.destroySecondPass(), delete this.zombieRowCtrls[r.getInstanceId()]
          })) : r.destroySecondPass()))
        }), t && (i.push(() => {
          this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged()
        }), Q(i))
      }
      getRowBuffer() {
        return this.gos.get("rowBuffer")
      }
      getRowBufferInPixels() {
        return this.getRowBuffer() * this.gos.getRowHeightAsNumber()
      }
      workOutFirstAndLastRowsToRender() {
        let e, t;
        if (this.rowContainerHeightService.updateOffset(), this.paginationProxy.isRowsToRender())
          if (this.printLayout) this.environment.refreshRowHeightVariable(), e = this.paginationProxy.getPageFirstRow(), t = this.paginationProxy.getPageLastRow();
          else {
            const i = this.getRowBufferInPixels(),
              r = this.ctrlsService.getGridBodyCtrl(),
              s = this.gos.get("suppressRowVirtualisation");
            let n, o, a = !1;
            do {
              const e = this.paginationProxy.getPixelOffset(),
                {
                  pageFirstPixel: t,
                  pageLastPixel: l
                } = this.paginationProxy.getCurrentPagePixelRange(),
                c = this.rowContainerHeightService.getDivStretchOffset(),
                h = r.getScrollFeature().getVScrollPosition(),
                u = h.top,
                d = h.bottom;
              s ? (n = t + c, o = l + c) : (n = Math.max(u + e - i, t) + c, o = Math.min(d + e + i, l) + c), this.firstVisibleVPixel = Math.max(u + e, t) + c, this.lastVisibleVPixel = Math.min(d + e, l) + c, a = this.ensureAllRowsInRangeHaveHeightsCalculated(n, o)
            } while (a);
            let l = this.paginationProxy.getRowIndexAtPixel(n),
              c = this.paginationProxy.getRowIndexAtPixel(o);
            const h = this.paginationProxy.getPageFirstRow(),
              u = this.paginationProxy.getPageLastRow();
            l < h && (l = h), c > u && (c = u), e = l, t = c
          }
        else e = 0, t = -1;
        const i = this.gos.isDomLayout("normal"),
          r = this.gos.get("suppressMaxRenderedRowRestriction"),
          s = Math.max(this.getRowBuffer(), 500);
        i && !r && t - e > s && (t = e + s);
        const n = e !== this.firstRenderedRow,
          o = t !== this.lastRenderedRow;
        if (n || o) {
          this.firstRenderedRow = e, this.lastRenderedRow = t;
          const i = {
            type: Et.EVENT_VIEWPORT_CHANGED,
            firstRow: e,
            lastRow: t
          };
          this.eventService.dispatchEvent(i)
        }
      }
      dispatchFirstDataRenderedEvent() {
        if (this.dataFirstRenderedFired) return;
        this.dataFirstRenderedFired = !0;
        const e = {
          type: Et.EVENT_FIRST_DATA_RENDERED,
          firstRow: this.firstRenderedRow,
          lastRow: this.lastRenderedRow
        };
        window.requestAnimationFrame(() => {
          this.beans.eventService.dispatchEvent(e)
        })
      }
      ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
        const i = this.paginationProxy.ensureRowHeightsValid(e, t, -1, -1);
        return i && this.updateContainerHeights(), i
      }
      getFirstVisibleVerticalPixel() {
        return this.firstVisibleVPixel
      }
      getLastVisibleVerticalPixel() {
        return this.lastVisibleVPixel
      }
      getFirstVirtualRenderedRow() {
        return this.firstRenderedRow
      }
      getLastVirtualRenderedRow() {
        return this.lastRenderedRow
      }
      doNotUnVirtualiseRow(e) {
        const t = !1,
          i = e.getRowNode(),
          r = this.focusService.isRowNodeFocused(i),
          s = e.isEditing(),
          n = i.detail;
        if (!(r || s || n)) return t;
        return !!this.paginationProxy.isRowPresent(i) || t
      }
      createRowCon(e, t, i) {
        const r = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
        if (r) return r;
        const s = this.gos.get("suppressAnimationFrame"),
          n = i && !s && !this.printLayout;
        return new ma(e, this.beans, t, n, this.printLayout)
      }
      getRenderedNodes() {
        const e = this.rowCtrlsByRowIndex;
        return Object.values(e).map(e => e.getRowNode())
      }
      getRowByPosition(e) {
        let t;
        const {
          rowIndex: i
        } = e;
        switch (e.rowPinned) {
          case "top":
            t = this.topRowCtrls[i];
            break;
          case "bottom":
            t = this.bottomRowCtrls[i];
            break;
          default:
            t = this.rowCtrlsByRowIndex[i], t || (t = this.getStickyTopRowCtrls().find(e => e.getRowNode().rowIndex === i) || null, t || (t = this.getStickyBottomRowCtrls().find(e => e.getRowNode().rowIndex === i) || null))
        }
        return t
      }
      isRangeInRenderedViewport(e, t) {
        if (null == e || null == t) return !1;
        const i = e > this.lastRenderedRow;
        return !(t < this.firstRenderedRow) && !i
      }
    };
    C([fe("animationFrameService")], Ol.prototype, "animationFrameService", 2), C([fe("paginationProxy")], Ol.prototype, "paginationProxy", 2), C([fe("columnModel")], Ol.prototype, "columnModel", 2), C([fe("pinnedRowModel")], Ol.prototype, "pinnedRowModel", 2), C([fe("rowModel")], Ol.prototype, "rowModel", 2), C([fe("focusService")], Ol.prototype, "focusService", 2), C([fe("beans")], Ol.prototype, "beans", 2), C([fe("rowContainerHeightService")], Ol.prototype, "rowContainerHeightService", 2), C([fe("ctrlsService")], Ol.prototype, "ctrlsService", 2), C([pe], Ol.prototype, "postConstruct", 1), Ol = C([ge("rowRenderer")], Ol);
    var Ll = class {
        constructor(e) {
          this.entriesMap = {}, this.entriesList = [], this.maxCount = e
        }
        addRow(e) {
          if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
            const e = this.entriesList[0];
            e.destroyFirstPass(), e.destroySecondPass(), this.removeFromCache(e)
          }
        }
        getRow(e) {
          if (null == e || null == e.id) return null;
          const t = this.entriesMap[e.id];
          if (!t) return null;
          this.removeFromCache(t), t.setCached(!1);
          return t.getRowNode() != e ? null : t
        }
        has(e) {
          return null != this.entriesMap[e.id]
        }
        removeRow(e) {
          const t = e.id,
            i = this.entriesMap[t];
          delete this.entriesMap[t], ke(this.entriesList, i)
        }
        removeFromCache(e) {
          const t = e.getRowNode().id;
          delete this.entriesMap[t], ke(this.entriesList, e)
        }
        getEntries() {
          return this.entriesList
        }
      },
      _l = class extends ct {
        init() {
          this.setPinnedTopRowData(), this.setPinnedBottomRowData(), this.addManagedPropertyListener("pinnedTopRowData", () => this.setPinnedTopRowData()), this.addManagedPropertyListener("pinnedBottomRowData", () => this.setPinnedBottomRowData())
        }
        isEmpty(e) {
          return I("top" === e ? this.pinnedTopRows : this.pinnedBottomRows)
        }
        isRowsToRender(e) {
          return !this.isEmpty(e)
        }
        getRowAtPixel(e, t) {
          const i = "top" === t ? this.pinnedTopRows : this.pinnedBottomRows;
          if (I(i)) return 0;
          for (let t = 0; t < i.length; t++) {
            const r = i[t];
            if (r.rowTop + r.rowHeight - 1 >= e) return t
          }
          return i.length - 1
        }
        setPinnedTopRowData() {
          const e = this.gos.get("pinnedTopRowData");
          this.pinnedTopRows = this.createNodesFromData(e, !0);
          const t = {
            type: Et.EVENT_PINNED_ROW_DATA_CHANGED
          };
          this.eventService.dispatchEvent(t)
        }
        setPinnedBottomRowData() {
          const e = this.gos.get("pinnedBottomRowData");
          this.pinnedBottomRows = this.createNodesFromData(e, !1);
          const t = {
            type: Et.EVENT_PINNED_ROW_DATA_CHANGED
          };
          this.eventService.dispatchEvent(t)
        }
        createNodesFromData(e, t) {
          const i = [];
          if (e) {
            let r = 0;
            e.forEach((e, s) => {
              const n = new Vn(this.beans);
              n.data = e;
              const o = t ? Vn.ID_PREFIX_TOP_PINNED : Vn.ID_PREFIX_BOTTOM_PINNED;
              n.id = o + s, n.rowPinned = t ? "top" : "bottom", n.setRowTop(r), n.setRowHeight(this.gos.getRowHeightForNode(n).height), n.setRowIndex(s), r += n.rowHeight, i.push(n)
            })
          }
          return i
        }
        getPinnedTopRowData() {
          return this.pinnedTopRows
        }
        getPinnedBottomRowData() {
          return this.pinnedBottomRows
        }
        getPinnedTopTotalHeight() {
          return this.getTotalHeight(this.pinnedTopRows)
        }
        getPinnedTopRowCount() {
          return this.pinnedTopRows ? this.pinnedTopRows.length : 0
        }
        getPinnedBottomRowCount() {
          return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0
        }
        getPinnedTopRow(e) {
          return this.pinnedTopRows[e]
        }
        getPinnedBottomRow(e) {
          return this.pinnedBottomRows[e]
        }
        forEachPinnedTopRow(e) {
          I(this.pinnedTopRows) || this.pinnedTopRows.forEach(e)
        }
        forEachPinnedBottomRow(e) {
          I(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(e)
        }
        getPinnedBottomTotalHeight() {
          return this.getTotalHeight(this.pinnedBottomRows)
        }
        getTotalHeight(e) {
          if (!e || 0 === e.length) return 0;
          const t = Me(e);
          return t.rowTop + t.rowHeight
        }
      };
    C([fe("beans")], _l.prototype, "beans", 2), C([pe], _l.prototype, "init", 1), _l = C([ge("pinnedRowModel")], _l);
    var yl = class {
        constructor(e, t) {
          this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
            rowNode: t,
            children: null
          }, this.mapToItems[t.id] = this.pathRoot
        }
        setInactive() {
          this.active = !1
        }
        isActive() {
          return this.active
        }
        depthFirstSearchChangedPath(e, t) {
          if (e.children)
            for (let i = 0; i < e.children.length; i++) this.depthFirstSearchChangedPath(e.children[i], t);
          t(e.rowNode)
        }
        depthFirstSearchEverything(e, t, i) {
          if (e.childrenAfterGroup)
            for (let r = 0; r < e.childrenAfterGroup.length; r++) {
              const s = e.childrenAfterGroup[r];
              s.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[r], t, i) : i && t(s)
            }
          t(e)
        }
        forEachChangedNodeDepthFirst(e, t = !1, i = !1) {
          this.active && !i ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t)
        }
        executeFromRootNode(e) {
          e(this.pathRoot.rowNode)
        }
        createPathItems(e) {
          let t = e,
            i = 0;
          for (; !this.mapToItems[t.id];) {
            const e = {
              rowNode: t,
              children: null
            };
            this.mapToItems[t.id] = e, i++, t = t.parent
          }
          return i
        }
        populateColumnsMap(e, t) {
          if (!this.keepingColumns || !t) return;
          let i = e;
          for (; i;) this.nodeIdsToColumns[i.id] || (this.nodeIdsToColumns[i.id] = {}), t.forEach(e => this.nodeIdsToColumns[i.id][e.getId()] = !0), i = i.parent
        }
        linkPathItems(e, t) {
          let i = e;
          for (let e = 0; e < t; e++) {
            const e = this.mapToItems[i.id],
              t = this.mapToItems[i.parent.id];
            t.children || (t.children = []), t.children.push(e), i = i.parent
          }
        }
        addParentNode(e, t) {
          if (!e || e.isRowPinned()) return;
          const i = this.createPathItems(e);
          this.linkPathItems(e, i), this.populateColumnsMap(e, t)
        }
        canSkip(e) {
          return this.active && !this.mapToItems[e.id]
        }
        getValueColumnsForNode(e, t) {
          if (!this.keepingColumns) return t;
          const i = this.nodeIdsToColumns[e.id];
          return t.filter(e => i[e.getId()])
        }
        getNotValueColumnsForNode(e, t) {
          if (!this.keepingColumns) return null;
          const i = this.nodeIdsToColumns[e.id];
          return t.filter(e => !i[e.getId()])
        }
      },
      wl = class e extends ct {
        constructor(t) {
          super(), this.state = e.STATE_WAITING_TO_LOAD, this.version = 0, this.id = t
        }
        getId() {
          return this.id
        }
        load() {
          this.state = e.STATE_LOADING, this.loadFromDatasource()
        }
        getVersion() {
          return this.version
        }
        setStateWaitingToLoad() {
          this.version++, this.state = e.STATE_WAITING_TO_LOAD
        }
        getState() {
          return this.state
        }
        pageLoadFailed(t) {
          this.isRequestMostRecentAndLive(t) && (this.state = e.STATE_FAILED, this.processServerFail()), this.dispatchLoadCompleted(!1)
        }
        success(e, t) {
          this.successCommon(e, t)
        }
        pageLoaded(e, t, i) {
          this.successCommon(e, {
            rowData: t,
            rowCount: i
          })
        }
        isRequestMostRecentAndLive(e) {
          const t = e === this.version,
            i = this.isAlive();
          return t && i
        }
        successCommon(t, i) {
          this.dispatchLoadCompleted();
          this.isRequestMostRecentAndLive(t) && (this.state = e.STATE_LOADED, this.processServerResult(i))
        }
        dispatchLoadCompleted(t = !0) {
          const i = {
            type: e.EVENT_LOAD_COMPLETE,
            success: t,
            block: this
          };
          this.dispatchEvent(i)
        }
      };
    wl.EVENT_LOAD_COMPLETE = "loadComplete", wl.STATE_WAITING_TO_LOAD = "needsLoading", wl.STATE_LOADING = "loading", wl.STATE_LOADED = "loaded", wl.STATE_FAILED = "failed";
    var Dl = wl,
      Pl = class extends ct {
        constructor() {
          super(...arguments), this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0
        }
        postConstruct() {
          this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
          const e = this.gos.get("blockLoadDebounceMillis");
          e && e > 0 && (this.checkBlockToLoadDebounce = Cs.debounce(this.performCheckBlocksToLoad.bind(this), e))
        }
        setBeans(e) {
          this.logger = e.create("RowNodeBlockLoader")
        }
        getMaxConcurrentDatasourceRequests() {
          const e = this.gos.get("maxConcurrentDatasourceRequests");
          return null == e ? 2 : e <= 0 ? void 0 : e
        }
        addBlock(e) {
          this.blocks.push(e), e.addEventListener(Dl.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this)), this.checkBlockToLoad()
        }
        removeBlock(e) {
          Cs.removeFromArray(this.blocks, e)
        }
        destroy() {
          super.destroy(), this.active = !1
        }
        loadComplete() {
          this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchEvent({
            type: Pl.BLOCK_LOADED_EVENT
          }), 0 == this.activeBlockLoadsCount && this.dispatchEvent({
            type: Pl.BLOCK_LOADER_FINISHED_EVENT
          })
        }
        checkBlockToLoad() {
          this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad()
        }
        performCheckBlocksToLoad() {
          if (!this.active) return;
          if (this.printCacheStatus(), null != this.maxConcurrentRequests && this.activeBlockLoadsCount >= this.maxConcurrentRequests) return void this.logger.log("checkBlockToLoad: max loads exceeded");
          const e = this.getAvailableLoadingCount(),
            t = this.blocks.filter(e => e.getState() === Dl.STATE_WAITING_TO_LOAD).slice(0, e);
          this.registerLoads(t.length), t.forEach(e => e.load()), this.printCacheStatus()
        }
        getBlockState() {
          if (this.gos.isRowModelType("serverSide")) {
            return this.rowModel.getBlockStates()
          }
          const e = {};
          return this.blocks.forEach(t => {
            const {
              id: i,
              state: r
            } = t.getBlockStateJson();
            e[i] = r
          }), e
        }
        printCacheStatus() {
          this.logger.isLogging() && this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`)
        }
        isLoading() {
          return this.activeBlockLoadsCount > 0
        }
        registerLoads(e) {
          this.activeBlockLoadsCount += e
        }
        getAvailableLoadingCount() {
          return void 0 !== this.maxConcurrentRequests ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0
        }
      };
    Pl.BLOCK_LOADED_EVENT = "blockLoaded", Pl.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished", C([fe("rowModel")], Pl.prototype, "rowModel", 2), C([pe], Pl.prototype, "postConstruct", 1), C([S(0, Ce("loggerFactory"))], Pl.prototype, "setBeans", 1), Pl = C([ge("rowNodeBlockLoader")], Pl);
    var bl = class extends ct {
      constructor() {
        super(...arguments), this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.pixelOffset = 0, this.masterRowCount = 0
      }
      postConstruct() {
        this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedListener(this.eventService, Et.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this)), this.onModelUpdated()
      }
      ensureRowHeightsValid(e, t, i, r) {
        const s = this.rowModel.ensureRowHeightsValid(e, t, this.getPageFirstRow(), this.getPageLastRow());
        return s && this.calculatePages(), s
      }
      isPaginateChildRows() {
        return !(!this.gos.get("groupRemoveSingleChildren") && !this.gos.get("groupRemoveLowestSingleChildren")) || this.gos.get("paginateChildRows")
      }
      onModelUpdated(e) {
        this.calculatePages();
        const t = {
          type: Et.EVENT_PAGINATION_CHANGED,
          animate: !!e && e.animate,
          newData: !!e && e.newData,
          newPage: !!e && e.newPage,
          newPageSize: !!e && e.newPageSize,
          keepRenderedRows: !!e && e.keepRenderedRows
        };
        this.eventService.dispatchEvent(t)
      }
      onPaginationGridOptionChanged() {
        this.active = this.gos.get("pagination"), this.calculatePages();
        const e = {
          type: Et.EVENT_PAGINATION_CHANGED,
          animate: !1,
          newData: !1,
          newPage: !1,
          newPageSize: !1,
          keepRenderedRows: !0
        };
        this.eventService.dispatchEvent(e)
      }
      onPageSizeGridOptionChanged() {
        this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions")
      }
      goToPage(e) {
        if (!this.active || this.currentPage === e || "number" != typeof this.currentPage) return;
        this.currentPage = e, this.calculatePages();
        const t = {
          type: Et.EVENT_PAGINATION_CHANGED,
          animate: !1,
          newData: !1,
          newPage: !0,
          newPageSize: !1,
          keepRenderedRows: !1
        };
        this.eventService.dispatchEvent(t)
      }
      getPixelOffset() {
        return this.pixelOffset
      }
      getRow(e) {
        return this.rowModel.getRow(e)
      }
      getRowNode(e) {
        return this.rowModel.getRowNode(e)
      }
      getRowIndexAtPixel(e) {
        return this.rowModel.getRowIndexAtPixel(e)
      }
      getCurrentPageHeight() {
        return N(this.topRowBounds) || N(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0)
      }
      getCurrentPagePixelRange() {
        return {
          pageFirstPixel: this.topRowBounds ? this.topRowBounds.rowTop : 0,
          pageLastPixel: this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0
        }
      }
      isRowPresent(e) {
        if (!this.rowModel.isRowPresent(e)) return !1;
        return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex
      }
      isEmpty() {
        return this.rowModel.isEmpty()
      }
      isRowsToRender() {
        return this.rowModel.isRowsToRender()
      }
      forEachNode(e) {
        return this.rowModel.forEachNode(e)
      }
      forEachNodeOnPage(e) {
        const t = this.getPageFirstRow(),
          i = this.getPageLastRow();
        for (let r = t; r <= i; r++) {
          const t = this.getRow(r);
          t && e(t)
        }
      }
      getType() {
        return this.rowModel.getType()
      }
      getRowBounds(e) {
        const t = this.rowModel.getRowBounds(e);
        return t.rowIndex = e, t
      }
      getPageFirstRow() {
        return this.topRowBounds ? this.topRowBounds.rowIndex : -1
      }
      getPageLastRow() {
        return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1
      }
      getRowCount() {
        return this.rowModel.getRowCount()
      }
      getPageForIndex(e) {
        return Math.floor(e / this.pageSize)
      }
      goToPageWithIndex(e) {
        if (!this.active) return;
        const t = this.getPageForIndex(e);
        this.goToPage(t)
      }
      isRowInPage(e) {
        if (!this.active) return !0;
        return this.getPageForIndex(e.rowIndex) === this.currentPage
      }
      isLastPageFound() {
        return this.rowModel.isLastRowIndexKnown()
      }
      getCurrentPage() {
        return this.currentPage
      }
      goToNextPage() {
        this.goToPage(this.currentPage + 1)
      }
      goToPreviousPage() {
        this.goToPage(this.currentPage - 1)
      }
      goToFirstPage() {
        this.goToPage(0)
      }
      goToLastPage() {
        const e = this.rowModel.getRowCount(),
          t = Math.floor(e / this.pageSize);
        this.goToPage(t)
      }
      getPageSize() {
        return this.pageSize
      }
      getTotalPages() {
        return this.totalPages
      }
      setPage(e) {
        this.currentPage = e
      }
      get pageSize() {
        return v(this.pageSizeAutoCalculated) ? this.pageSizeAutoCalculated : v(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : v(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : v(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize
      }
      unsetAutoCalculatedPageSize() {
        if (void 0 === this.pageSizeAutoCalculated) return;
        const e = this.pageSizeAutoCalculated;
        if (this.pageSizeAutoCalculated = void 0, this.pageSize === e) return;
        this.calculatePages();
        const t = {
          type: Et.EVENT_PAGINATION_CHANGED,
          animate: !1,
          newData: !1,
          newPage: !1,
          newPageSize: !0,
          keepRenderedRows: !1
        };
        this.eventService.dispatchEvent(t)
      }
      setPageSize(e, t) {
        const i = this.pageSize;
        switch (t) {
          case "autoCalculated":
            this.pageSizeAutoCalculated = e;
            break;
          case "pageSizeSelector":
            this.pageSizeFromPageSizeSelector = e, 0 !== this.currentPage && this.goToFirstPage();
            break;
          case "initialState":
            this.pageSizeFromInitialState = e;
            break;
          case "gridOptions":
            this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, 0 !== this.currentPage && this.goToFirstPage()
        }
        if (i !== this.pageSize) {
          this.calculatePages();
          const e = {
            type: Et.EVENT_PAGINATION_CHANGED,
            animate: !1,
            newData: !1,
            newPage: !1,
            newPageSize: !0,
            keepRenderedRows: !0
          };
          this.eventService.dispatchEvent(e)
        }
      }
      calculatePages() {
        this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex), this.topRowBounds && (this.topRowBounds.rowIndex = this.topDisplayedRowIndex), this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex), this.setPixelOffset(v(this.topRowBounds) ? this.topRowBounds.rowTop : 0)
      }
      setPixelOffset(e) {
        this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({
          type: Et.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED
        }))
      }
      setZeroRows() {
        this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0
      }
      adjustCurrentPageIfInvalid() {
        this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0)
      }
      calculatePagesMasterRowsOnly() {
        if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) return void this.setZeroRows();
        const e = this.masterRowCount - 1;
        this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
        const t = this.pageSize * this.currentPage;
        let i = this.pageSize * (this.currentPage + 1) - 1;
        if (i > e && (i = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), i === e) this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
        else {
          const e = this.rowModel.getTopLevelRowDisplayedIndex(i + 1);
          this.bottomDisplayedRowIndex = e - 1
        }
      }
      getMasterRowCount() {
        return this.masterRowCount
      }
      calculatePagesAllRows() {
        if (this.masterRowCount = this.rowModel.getRowCount(), 0 === this.masterRowCount) return void this.setZeroRows();
        const e = this.masterRowCount - 1;
        this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e)
      }
      calculatedPagesNotActive() {
        this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1
      }
    };
    C([fe("rowModel")], bl.prototype, "rowModel", 2), C([pe], bl.prototype, "postConstruct", 1), bl = C([ge("paginationProxy")], bl);
    var Ml = class extends ct {
      processAllCellClasses(e, t, i, r) {
        this.processClassRules(void 0, e.cellClassRules, t, i, r), this.processStaticCellClasses(e, t, i)
      }
      processClassRules(e, t, i, r, s) {
        if (null == t && null == e) return;
        const n = {},
          o = {},
          a = (e, t) => {
            e.split(" ").forEach(e => {
              "" != e.trim() && t(e)
            })
          };
        if (t) {
          const e = Object.keys(t);
          for (let r = 0; r < e.length; r++) {
            const s = e[r],
              l = t[s];
            let c;
            "string" == typeof l ? c = this.expressionService.evaluate(l, i) : "function" == typeof l && (c = l(i)), a(s, e => {
              c ? n[e] = !0 : o[e] = !0
            })
          }
        }
        e && s && Object.keys(e).forEach(e => a(e, e => {
          n[e] || (o[e] = !0)
        })), s && Object.keys(o).forEach(s), Object.keys(n).forEach(r)
      }
      getStaticCellClasses(e, t) {
        const {
          cellClass: i
        } = e;
        if (!i) return [];
        let r;
        if ("function" == typeof i) {
          r = i(t)
        } else r = i;
        return "string" == typeof r && (r = [r]), r || []
      }
      processStaticCellClasses(e, t, i) {
        this.getStaticCellClasses(e, t).forEach(e => {
          i(e)
        })
      }
    };
    C([fe("expressionService")], Ml.prototype, "expressionService", 2), Ml = C([ge("stylingService")], Ml);
    var Fl = class extends Js {
        constructor(e) {
          super(e, "ag-toggle-button")
        }
        setValue(e, t) {
          return super.setValue(e, t), this.addOrRemoveCssClass("ag-selected", this.getValue()), this
        }
      },
      xl = class extends js {
        constructor(e) {
          super(e, "ag-text-area", null, "textarea")
        }
        setValue(e, t) {
          const i = super.setValue(e, t);
          return this.eInput.value = e, i
        }
        setCols(e) {
          return this.eInput.cols = e, this
        }
        setRows(e) {
          return this.eInput.rows = e, this
        }
      },
      Gl = class extends hn {
        constructor(e) {
          super(e, "ag-date-field", "date")
        }
        postConstruct() {
          super.postConstruct(), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
          const e = Pi();
          this.addManagedListener(this.eInput, "mousedown", () => {
            this.isDisabled() || e || this.eInput.focus()
          }), this.eInput.step = "any"
        }
        onWheel(e) {
          this.gos.getActiveDomElement() === this.eInput && e.preventDefault()
        }
        setMin(e) {
          var t;
          const i = e instanceof Date ? null != (t = tr(null != e ? e : null, !1)) ? t : void 0 : e;
          return this.min === i || (this.min = i, Wr(this.eInput, "min", i)), this
        }
        setMax(e) {
          var t;
          const i = e instanceof Date ? null != (t = tr(null != e ? e : null, !1)) ? t : void 0 : e;
          return this.max === i || (this.max = i, Wr(this.eInput, "max", i)), this
        }
        setStep(e) {
          return this.step === e || (this.step = e, Wr(this.eInput, "step", e)), this
        }
        getDate() {
          var e;
          if (this.eInput.validity.valid) return null != (e = sr(this.getValue())) ? e : void 0
        }
        setDate(e, t) {
          this.setValue(tr(null != e ? e : null, !1), t)
        }
      },
      Ul = class extends js {
        constructor(e) {
          super(e, "ag-range-field", "range")
        }
        postConstruct() {
          super.postConstruct();
          const {
            min: e,
            max: t,
            step: i
          } = this.config;
          null != e && this.setMinValue(e), null != t && this.setMaxValue(t), this.setStep(i || 1)
        }
        addInputListeners() {
          this.addManagedListener(this.eInput, "input", e => {
            const t = e.target.value;
            this.setValue(t)
          })
        }
        setMinValue(e) {
          return this.min = e, this.eInput.setAttribute("min", e.toString()), this
        }
        setMaxValue(e) {
          return this.max = e, this.eInput.setAttribute("max", e.toString()), this
        }
        setStep(e) {
          return this.eInput.setAttribute("step", e.toString()), this
        }
        setValue(e, t) {
          null != this.min && (e = Math.max(parseFloat(e), this.min).toString()), null != this.max && (e = Math.min(parseFloat(e), this.max).toString());
          const i = super.setValue(e, t);
          return this.eInput.value = e, i
        }
      },
      Hl = class extends _s {
        constructor(e, t) {
          super('<div class="ag-rich-select-row" role="presentation"></div>'), this.params = e, this.wrapperEl = t
        }
        postConstruct() {
          this.addManagedListener(this.getGui(), "click", this.onClick.bind(this))
        }
        setState(e) {
          let t = "";
          this.params.valueFormatter && (t = this.params.valueFormatter(e));
          this.populateWithRenderer(e, t) || this.populateWithoutRenderer(e, t), this.value = e
        }
        highlightString(e) {
          const {
            parsedValue: t
          } = this;
          if (this.params.cellRenderer || !v(t)) return;
          let i = v(e);
          if (i) {
            const r = null == t ? void 0 : t.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
            if (r >= 0) {
              const i = r + e.length,
                s = Nt(t.slice(0, r), !0),
                n = Nt(t.slice(r, i), !0),
                o = Nt(t.slice(i));
              this.renderValueWithoutRenderer(`${s}<span class="ag-rich-select-row-text-highlight">${n}</span>${o}`)
            } else i = !1
          }
          i || this.renderValueWithoutRenderer(t)
        }
        updateHighlighted(e) {
          var t;
          const i = this.getGui(),
            r = `ag-rich-select-row-${this.getCompId()}`;
          if (null == (t = i.parentElement) || t.setAttribute("id", r), e) {
            oi(this.getParentComponent().getAriaElement(), r), this.wrapperEl.setAttribute("data-active-option", r)
          }
          Ci(i.parentElement, e), this.addOrRemoveCssClass("ag-rich-select-row-selected", e)
        }
        populateWithoutRenderer(e, t) {
          const i = this.gos.getDocument(),
            r = this.getGui(),
            s = i.createElement("span");
          s.style.overflow = "hidden", s.style.textOverflow = "ellipsis";
          const n = Nt(v(t) ? t : e, !0);
          this.parsedValue = v(n) ? n : null, r.appendChild(s), this.renderValueWithoutRenderer(n), this.setTooltip({
            newTooltipText: this.parsedValue,
            shouldDisplayTooltip: () => s.scrollWidth > s.clientWidth
          })
        }
        renderValueWithoutRenderer(e) {
          const t = this.getGui().querySelector("span");
          t && (t.innerHTML = v(e) ? e : "&nbsp;")
        }
        populateWithRenderer(e, t) {
          let i, r;
          return this.params.cellRenderer && (r = this.userComponentFactory.getCellRendererDetails(this.params, {
            value: e,
            valueFormatted: t,
            setTooltip: (e, t) => {
              this.setTooltip({
                newTooltipText: e,
                shouldDisplayTooltip: t
              })
            }
          })), r && (i = r.newAgStackInstance()), i && Kr(i, this.getGui()), !!i && (i.then(e => {
            this.addDestroyFunc(() => {
              this.getContext().destroyBean(e)
            })
          }), !0)
        }
        onClick() {
          const e = this.getParentComponent(),
            t = {
              type: Et.EVENT_FIELD_PICKER_VALUE_SELECTED,
              fromEnterKey: !1,
              value: this.value
            };
          null == e || e.dispatchEvent(t)
        }
      };
    C([fe("userComponentFactory")], Hl.prototype, "userComponentFactory", 2), C([pe], Hl.prototype, "postConstruct", 1);
    var kl = class e extends ml {
      constructor(t) {
        super(e.getTemplate((null == t ? void 0 : t.cssIdentifier) || "default")), this.renderedRows = new Map, this.rowHeight = 20, this.pageSize = -1, this.isScrolling = !1, this.isHeightFromTheme = !0;
        const {
          cssIdentifier: i = "default",
          ariaRole: r = "listbox",
          listName: s
        } = t || {};
        this.cssIdentifier = i, this.ariaRole = r, this.listName = s
      }
      postConstruct() {
        this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
          onFocusIn: e => this.onFocusIn(e),
          onFocusOut: e => this.onFocusOut(e),
          focusInnerElement: e => this.focusInnerElement(e),
          onTabKeyDown: e => this.onTabKeyDown(e),
          handleKeyDown: e => this.handleKeyDown(e)
        }), this.setAriaProperties(), this.addManagedListener(this.eventService, Et.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanged.bind(this))
      }
      onGridStylesChanged() {
        this.rowHeight = this.getItemHeight(), this.refresh()
      }
      setAriaProperties() {
        const e = this.localeService.getLocaleTextFunc()("ariaDefaultListName", this.listName || "List"),
          t = this.eContainer;
        Xt(t, this.ariaRole), qt(t, e)
      }
      addResizeObserver() {
        const e = this.resizeObserverService.observeResize(this.getGui(), () => this.animationFrameService.requestAnimationFrame(() => this.drawVirtualRows()));
        this.addDestroyFunc(e)
      }
      focusInnerElement(e) {
        this.focusRow(e ? this.model.getRowCount() - 1 : 0)
      }
      onFocusIn(e) {
        const t = e.target;
        t.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = jt(t) - 1)
      }
      onFocusOut(e) {
        this.getFocusableElement().contains(e.relatedTarget) || (this.lastFocusedRowIndex = null)
      }
      handleKeyDown(e) {
        switch (e.key) {
          case ts.UP:
          case ts.DOWN:
            this.navigate(e.key === ts.UP) && e.preventDefault();
            break;
          case ts.PAGE_HOME:
          case ts.PAGE_END:
          case ts.PAGE_UP:
          case ts.PAGE_DOWN:
            null !== this.navigateToPage(e.key) && e.preventDefault()
        }
      }
      onTabKeyDown(e) {
        this.navigate(e.shiftKey) ? e.preventDefault() : (et(e), this.forceFocusOutOfContainer(e.shiftKey))
      }
      navigate(e) {
        if (null == this.lastFocusedRowIndex) return !1;
        const t = this.lastFocusedRowIndex + (e ? -1 : 1);
        return !(t < 0 || t >= this.model.getRowCount()) && (this.focusRow(t), !0)
      }
      navigateToPage(e, t = "focused") {
        let i = !1;
        "focused" === t && (t = this.getLastFocusedRow(), i = !0);
        const r = this.model.getRowCount() - 1;
        let s = -1;
        return e === ts.PAGE_HOME ? s = 0 : e === ts.PAGE_END ? s = r : e === ts.PAGE_DOWN ? s = Math.min(t + this.pageSize, r) : e === ts.PAGE_UP && (s = Math.max(t - this.pageSize, 0)), -1 === s ? null : (i ? this.focusRow(s) : this.ensureIndexVisible(s), s)
      }
      getLastFocusedRow() {
        return this.lastFocusedRowIndex
      }
      focusRow(e) {
        this.isScrolling || (this.isScrolling = !0, this.ensureIndexVisible(e), this.animationFrameService.requestAnimationFrame(() => {
          if (this.isScrolling = !1, !this.isAlive()) return;
          const t = this.renderedRows.get(e);
          t && t.eDiv.focus()
        }))
      }
      getComponentAt(e) {
        const t = this.renderedRows.get(e);
        return t && t.rowComponent
      }
      forEachRenderedRow(e) {
        this.renderedRows.forEach((t, i) => e(t.rowComponent, i))
      }
      static getTemplate(e) {
        return `<div class="ag-virtual-list-viewport ag-${e}-virtual-list-viewport" role="presentation">\n                <div class="ag-virtual-list-container ag-${e}-virtual-list-container" ref="eContainer"></div>\n            </div>`
      }
      getItemHeight() {
        return this.isHeightFromTheme ? this.environment.getListItemHeight() : this.rowHeight
      }
      ensureIndexVisible(e, t = !0) {
        const i = this.model.getRowCount();
        if ("number" != typeof e || e < 0 || e >= i) return console.warn("AG Grid: invalid row index for ensureIndexVisible: " + e), !1;
        const r = e * this.rowHeight,
          s = r + this.rowHeight,
          n = this.getGui(),
          o = n.scrollTop,
          a = n.offsetHeight,
          l = o + a,
          c = t ? 0 : this.rowHeight,
          h = l < s - c;
        if (o > r + c) return n.scrollTop = r, !0;
        if (h) {
          const e = s - a;
          return n.scrollTop = e, !0
        }
        return !1
      }
      setComponentCreator(e) {
        this.componentCreator = e
      }
      setComponentUpdater(e) {
        this.componentUpdater = e
      }
      getRowHeight() {
        return this.rowHeight
      }
      getScrollTop() {
        return this.getGui().scrollTop
      }
      setRowHeight(e) {
        this.isHeightFromTheme = !1, this.rowHeight = e, this.refresh()
      }
      refresh(e) {
        if (null == this.model || !this.isAlive()) return;
        const t = this.model.getRowCount();
        this.eContainer.style.height = t * this.rowHeight + "px", ne(() => this.eContainer.clientHeight >= t * this.rowHeight, () => {
          this.isAlive() && (this.canSoftRefresh(e) ? this.drawVirtualRows(!0) : (this.clearVirtualRows(), this.drawVirtualRows()))
        })
      }
      canSoftRefresh(e) {
        return !!(e && this.renderedRows.size && "function" == typeof this.model.areRowsEqual && this.componentUpdater)
      }
      clearVirtualRows() {
        this.renderedRows.forEach((e, t) => this.removeRow(t))
      }
      drawVirtualRows(e) {
        if (!this.isAlive() || !this.model) return;
        const t = this.getGui(),
          i = t.scrollTop,
          r = i + t.offsetHeight,
          s = Math.floor(i / this.rowHeight),
          n = Math.floor(r / this.rowHeight);
        this.pageSize = Math.floor((r - i) / this.rowHeight), this.ensureRowsRendered(s, n, e)
      }
      ensureRowsRendered(e, t, i) {
        this.renderedRows.forEach((i, r) => {
          (r < e || r > t) && r !== this.lastFocusedRowIndex && this.removeRow(r)
        }), i && this.refreshRows();
        for (let i = e; i <= t; i++) this.renderedRows.has(i) || i < this.model.getRowCount() && this.insertRow(i)
      }
      insertRow(e) {
        const t = this.model.getRow(e),
          i = document.createElement("div");
        i.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`), Xt(i, "tree" === this.ariaRole ? "treeitem" : "option"), ci(i, this.model.getRowCount()), hi(i, e + 1), i.setAttribute("tabindex", "-1"), i.style.height = `${this.rowHeight}px`, i.style.top = this.rowHeight * e + "px";
        const r = this.componentCreator(t, i);
        r.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = e), i.appendChild(r.getGui()), this.renderedRows.has(e - 1) ? this.renderedRows.get(e - 1).eDiv.insertAdjacentElement("afterend", i) : this.renderedRows.has(e + 1) ? this.renderedRows.get(e + 1).eDiv.insertAdjacentElement("beforebegin", i) : this.eContainer.appendChild(i), this.renderedRows.set(e, {
          rowComponent: r,
          eDiv: i,
          value: t
        })
      }
      removeRow(e) {
        const t = this.renderedRows.get(e);
        this.eContainer.removeChild(t.eDiv), this.destroyBean(t.rowComponent), this.renderedRows.delete(e)
      }
      refreshRows() {
        const e = this.model.getRowCount();
        this.renderedRows.forEach((t, i) => {
          var r, s;
          if (i >= e) this.removeRow(i);
          else {
            const e = this.model.getRow(i);
            (null == (s = (r = this.model).areRowsEqual) ? void 0 : s.call(r, t.value, e)) ? this.componentUpdater(e, t.rowComponent): this.removeRow(i)
          }
        })
      }
      addScrollListener() {
        this.addGuiEventListener("scroll", () => this.drawVirtualRows(), {
          passive: !0
        })
      }
      setModel(e) {
        this.model = e
      }
      getAriaElement() {
        return this.eContainer
      }
      destroy() {
        this.isAlive() && (this.clearVirtualRows(), super.destroy())
      }
    };
    C([fe("resizeObserverService")], kl.prototype, "resizeObserverService", 2), C([fe("animationFrameService")], kl.prototype, "animationFrameService", 2), C([ys("eContainer")], kl.prototype, "eContainer", 2), C([pe], kl.prototype, "postConstruct", 1);
    var Bl = kl,
      Vl = class extends Ys {
        constructor(e) {
          var t, i;
          super(T(f({
            pickerAriaLabelKey: "ariaLabelRichSelectField",
            pickerAriaLabelValue: "Rich Select Field",
            pickerType: "ag-list",
            className: "ag-rich-select",
            pickerIcon: "smallDown",
            ariaRole: "combobox",
            template: null != (t = null == e ? void 0 : e.template) ? t : '\n    <div class="ag-picker-field" role="presentation">\n        <div ref="eLabel"></div>\n            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-rich-select-value ag-picker-collapsed">\n            <div ref="eDisplayField" class="ag-picker-field-display"></div>\n            <ag-input-text-field ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>\n            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>\n        </div>\n    </div>',
            modalPicker: !1
          }, e), {
            maxPickerHeight: null != (i = null == e ? void 0 : e.maxPickerHeight) ? i : "calc(var(--ag-row-height) * 6.5)"
          })), this.searchString = "", this.highlightedItem = -1, this.lastRowHovered = -1, this.searchStringCreator = null;
          const {
            cellRowHeight: r,
            value: s,
            valueList: n,
            searchStringCreator: o
          } = e || {};
          null != r && (this.cellRowHeight = r), void 0 !== s && (this.value = s), null != n && (this.values = n), o && (this.searchStringCreator = o)
        }
        postConstruct() {
          super.postConstruct(), this.createLoadingElement(), this.createListComponent();
          const {
            allowTyping: e,
            placeholder: t
          } = this.config;
          e ? (this.eInput.setAutoComplete(!1).setInputPlaceholder(t), this.eDisplayField.classList.add("ag-hidden")) : this.eInput.setDisplayed(!1), this.eWrapper.tabIndex = this.gos.get("tabIndex");
          const {
            searchDebounceDelay: i = 300
          } = this.config;
          this.clearSearchString = re(this.clearSearchString, i), this.renderSelectedValue(), e && (this.eInput.onValueChange(e => this.searchTextFromString(e)), this.addManagedListener(this.eWrapper, "focus", this.onWrapperFocus.bind(this))), this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this))
        }
        createLoadingElement() {
          const e = this.gos.getDocument(),
            t = this.localeService.getLocaleTextFunc(),
            i = e.createElement("div");
          i.classList.add("ag-loading-text"), i.innerText = t("loadingOoo", "Loading..."), this.eLoading = i
        }
        createListComponent() {
          this.listComponent = this.createBean(new Bl({
            cssIdentifier: "rich-select"
          })), this.listComponent.setComponentCreator(this.createRowComponent.bind(this));
          this.listComponent.setComponentUpdater((e, t) => {}), this.listComponent.setParentComponent(this), this.addManagedListener(this.listComponent, Et.EVENT_FIELD_PICKER_VALUE_SELECTED, e => {
            this.onListValueSelected(e.value, e.fromEnterKey)
          });
          const {
            cellRowHeight: e
          } = this;
          e && this.listComponent.setRowHeight(e);
          const t = this.listComponent.getGui(),
            i = this.listComponent.getAriaElement();
          this.addManagedListener(t, "mousemove", this.onPickerMouseMove.bind(this)), this.addManagedListener(t, "mousedown", e => e.preventDefault()), t.classList.add("ag-rich-select-list");
          const r = `ag-rich-select-list-${this.listComponent.getCompId()}`;
          i.setAttribute("id", r);
          qt(i, this.localeService.getLocaleTextFunc()(this.config.pickerAriaLabelKey, this.config.pickerAriaLabelValue)), Ri(this.eWrapper, i)
        }
        renderSelectedValue() {
          const {
            value: e,
            eDisplayField: t,
            config: i
          } = this, {
            allowTyping: r,
            initialInputValue: s
          } = this.config, n = this.config.valueFormatter ? this.config.valueFormatter(e) : e;
          if (r) return void this.eInput.setValue(null != s ? s : n);
          let o, a;
          if (i.cellRenderer && (o = this.userComponentFactory.getCellRendererDetails(this.config, {
              value: e,
              valueFormatted: n
            })), o && (a = o.newAgStackInstance()), a) Nr(t), Kr(a, t), a.then(e => {
            this.addDestroyFunc(() => this.getContext().destroyBean(e))
          });
          else {
            if (v(this.value)) t.innerText = n, t.classList.remove("ag-display-as-placeholder");
            else {
              const {
                placeholder: e
              } = i;
              v(e) ? (t.innerHTML = `${Nt(e)}`, t.classList.add("ag-display-as-placeholder")) : Nr(t)
            }
            this.setTooltip({
              newTooltipText: null != n ? n : null,
              shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
            })
          }
        }
        getCurrentValueIndex() {
          const {
            currentList: e,
            value: t
          } = this;
          if (null == t || !e) return -1;
          for (let i = 0; i < e.length; i++)
            if (e[i] === t) return i;
          return -1
        }
        highlightFilterMatch() {
          var e;
          null == (e = this.listComponent) || e.forEachRenderedRow((e, t) => {
            e.highlightString(this.searchString)
          })
        }
        highlightSelectedValue(e) {
          var t;
          null == e && (e = this.getCurrentValueIndex()), this.highlightedItem = e, null == (t = this.listComponent) || t.forEachRenderedRow((t, i) => {
            const r = -1 !== e && this.highlightedItem === i;
            t.updateHighlighted(r)
          })
        }
        setRowHeight(e) {
          e !== this.cellRowHeight && (this.cellRowHeight = e), this.listComponent && this.listComponent.setRowHeight(e)
        }
        createPickerComponent() {
          const {
            values: e
          } = this;
          return e && this.setValueList({
            valueList: e
          }), this.listComponent
        }
        setSearchStringCreator(e) {
          this.searchStringCreator = e
        }
        setValueList(e) {
          const {
            valueList: t,
            refresh: i
          } = e;
          this.listComponent && this.currentList !== t && (this.currentList = t, this.listComponent.setModel({
            getRowCount: () => t.length,
            getRow: e => t[e],
            areRowsEqual: (e, t) => e === t
          }), i && (this.values ? this.listComponent.refresh(!0) : (this.values = t, this.isPickerDisplayed && this.showCurrentValueInPicker())))
        }
        showPicker() {
          super.showPicker(), this.showCurrentValueInPicker(), this.displayOrHidePicker()
        }
        showCurrentValueInPicker() {
          var e, t;
          if (!this.listComponent) return;
          if (!this.currentList) return void(this.isPickerDisplayed && this.eLoading && this.listComponent.appendChild(this.eLoading));
          (null == (e = this.eLoading) ? void 0 : e.offsetParent) && (null == (t = this.eLoading.parentElement) || t.removeChild(this.eLoading));
          const i = this.getCurrentValueIndex(); - 1 !== i ? (this.listComponent.refresh(), this.listComponent.ensureIndexVisible(i), this.listComponent.refresh(!0), this.highlightSelectedValue(i)) : this.listComponent.refresh()
        }
        beforeHidePicker() {
          this.highlightedItem = -1, super.beforeHidePicker()
        }
        onWrapperFocus() {
          if (!this.eInput) return;
          const e = this.eInput.getFocusableElement();
          e.focus(), e.select()
        }
        onWrapperFocusOut(e) {
          this.eWrapper.contains(e.relatedTarget) || this.hidePicker()
        }
        buildSearchStringFromKeyboardEvent(e) {
          let {
            key: t
          } = e;
          if (t === ts.BACKSPACE) this.searchString = this.searchString.slice(0, -1), t = "";
          else if (!ls(e)) return;
          e.preventDefault(), this.searchTextFromCharacter(t)
        }
        searchTextFromCharacter(e) {
          this.searchString += e, this.runSearch(), this.clearSearchString()
        }
        searchTextFromString(e) {
          null == e && (e = ""), this.searchString = e, this.runSearch()
        }
        buildSearchStrings(e) {
          const {
            valueFormatter: t = e => e
          } = this.config;
          let i;
          return "number" == typeof e[0] || "string" == typeof e[0] ? i = e.map(e => t(e)) : "object" == typeof e[0] && this.searchStringCreator && (i = this.searchStringCreator(e)), i
        }
        getSuggestionsAndFilteredValues(e, t) {
          let i = [],
            r = [];
          if (!e.length) return {
            suggestions: i,
            filteredValues: r
          };
          const {
            searchType: s = "fuzzy",
            filterList: n
          } = this.config;
          if ("fuzzy" === s) {
            const e = $r(this.searchString, t, !0);
            i = e.values;
            const s = e.indices;
            if (n && s.length)
              for (let e = 0; e < s.length; e++) r.push(this.values[s[e]])
          } else i = t.filter((e, t) => {
            const i = e.toLocaleLowerCase(),
              o = this.searchString.toLocaleLowerCase(),
              a = "match" === s ? i.startsWith(o) : -1 !== i.indexOf(o);
            return n && a && r.push(this.values[t]), a
          });
          return {
            suggestions: i,
            filteredValues: r
          }
        }
        filterListModel(e) {
          const {
            filterList: t
          } = this.config;
          t && (this.setValueList({
            valueList: e,
            refresh: !0
          }), this.alignPickerToComponent())
        }
        runSearch() {
          var e, t;
          const {
            values: i
          } = this, r = this.buildSearchStrings(i);
          if (!r) return void this.highlightSelectedValue(-1);
          const {
            suggestions: s,
            filteredValues: n
          } = this.getSuggestionsAndFilteredValues(this.searchString, r), {
            filterList: o,
            highlightMatch: a,
            searchType: l = "fuzzy"
          } = this.config, c = n.length, h = !(!o || "" === this.searchString);
          if (this.filterListModel(h ? n : i), s.length) {
            const e = h ? 0 : r.indexOf(s[0]);
            this.selectListItem(e)
          } else if (this.highlightSelectedValue(-1), !h || c) null == (e = this.listComponent) || e.ensureIndexVisible(0);
          else if (h) {
            this.getAriaElement().removeAttribute("data-active-option");
            const e = null == (t = this.listComponent) ? void 0 : t.getAriaElement();
            e && oi(e, null)
          }
          a && "fuzzy" !== l && this.highlightFilterMatch(), this.displayOrHidePicker()
        }
        displayOrHidePicker() {
          var e;
          const t = null == (e = this.listComponent) ? void 0 : e.getGui(),
            i = !!this.currentList && 0 === this.currentList.length;
          null == t || t.classList.toggle("ag-hidden", i)
        }
        clearSearchString() {
          this.searchString = ""
        }
        selectListItem(e, t) {
          if (!this.isPickerDisplayed || !this.currentList || !this.listComponent || e < 0 || e >= this.currentList.length) return;
          this.listComponent.ensureIndexVisible(e, !t) && !t && this.listComponent.refresh(!0), this.highlightSelectedValue(e)
        }
        setValue(e, t, i) {
          const r = this.currentList ? this.currentList.indexOf(e) : -1;
          return -1 === r ? this : (this.value = e, i || this.selectListItem(r), this.renderSelectedValue(), super.setValue(e, t))
        }
        createRowComponent(e) {
          const t = new Hl(this.config, this.eWrapper);
          t.setParentComponent(this.listComponent), this.getContext().createBean(t), t.setState(e);
          const {
            highlightMatch: i,
            searchType: r = "fuzzy"
          } = this.config;
          return i && "fuzzy" !== r && t.highlightString(this.searchString), t
        }
        getRowForMouseEvent(e) {
          const {
            listComponent: t
          } = this;
          if (!t) return -1;
          const i = (null == t ? void 0 : t.getGui()).getBoundingClientRect(),
            r = t.getScrollTop(),
            s = e.clientY - i.top + r;
          return Math.floor(s / t.getRowHeight())
        }
        onPickerMouseMove(e) {
          if (!this.listComponent) return;
          const t = this.getRowForMouseEvent(e); - 1 !== t && t != this.lastRowHovered && (this.lastRowHovered = t, this.selectListItem(t, !0))
        }
        onNavigationKeyDown(e, t) {
          e.preventDefault();
          const i = t === ts.DOWN;
          if (!this.isPickerDisplayed && i) return void this.showPicker();
          const r = this.highlightedItem,
            s = -1 === r ? 0 : r + (i ? 1 : -1);
          this.selectListItem(s)
        }
        onPageNavigation(e) {
          var t;
          if (!this.isPickerDisplayed) return;
          const i = null == (t = this.listComponent) ? void 0 : t.navigateToPage(e, this.highlightedItem);
          null != i && this.animationFrameService.requestAnimationFrame(() => {
            if (!this.isAlive()) return null;
            this.highlightSelectedValue(i)
          })
        }
        onEnterKeyDown(e) {
          this.isPickerDisplayed && (e.preventDefault(), this.currentList && this.onListValueSelected(this.currentList[this.highlightedItem], !0))
        }
        onTabKeyDown() {
          this.isPickerDisplayed && this.currentList && this.setValue(this.currentList[this.highlightedItem], !1, !0)
        }
        onListValueSelected(e, t) {
          this.setValue(e, !1, !0), this.dispatchPickerEvent(e, t), this.hidePicker()
        }
        dispatchPickerEvent(e, t) {
          const i = {
            type: Et.EVENT_FIELD_PICKER_VALUE_SELECTED,
            fromEnterKey: t,
            value: e
          };
          this.dispatchEvent(i)
        }
        getFocusableElement() {
          const {
            allowTyping: e
          } = this.config;
          return e ? this.eInput.getFocusableElement() : super.getFocusableElement()
        }
        onKeyDown(e) {
          const t = e.key,
            {
              allowTyping: i
            } = this.config;
          switch (t) {
            case ts.LEFT:
            case ts.RIGHT:
              i || e.preventDefault();
              break;
            case ts.PAGE_HOME:
            case ts.PAGE_END:
              if (i) {
                e.preventDefault();
                const i = this.eInput.getInputElement(),
                  r = t === ts.PAGE_HOME ? 0 : i.value.length;
                i.setSelectionRange(r, r);
                break
              }
              case ts.PAGE_UP:
              case ts.PAGE_DOWN:
                e.preventDefault(), this.onPageNavigation(t);
                break;
              case ts.DOWN:
              case ts.UP:
                this.onNavigationKeyDown(e, t);
                break;
              case ts.ESCAPE:
                this.isPickerDisplayed && (Lr(this.listComponent.getGui()) && (e.preventDefault(), et(e)), this.hidePicker());
                break;
              case ts.ENTER:
                this.onEnterKeyDown(e);
                break;
              case ts.TAB:
                this.onTabKeyDown();
                break;
              default:
                i || this.buildSearchStringFromKeyboardEvent(e)
          }
        }
        destroy() {
          this.listComponent && (this.destroyBean(this.listComponent), this.listComponent = void 0), this.eLoading = void 0, super.destroy()
        }
      };
    C([fe("userComponentFactory")], Vl.prototype, "userComponentFactory", 2), C([fe("animationFrameService")], Vl.prototype, "animationFrameService", 2), C([ys("eInput")], Vl.prototype, "eInput", 2);
    var Wl = class e extends Vs {
      constructor(t) {
        super(t, e.TEMPLATE), this.labelAlignment = "top"
      }
      init() {
        this.eSlider.addCssClass("ag-slider-field");
        const {
          minValue: e,
          maxValue: t,
          textFieldWidth: i,
          step: r,
          value: s,
          onValueChange: n
        } = this.config;
        null != e && this.setMinValue(e), null != t && this.setMaxValue(t), null != i && this.setTextFieldWidth(i), null != r && this.setStep(r), null != s && this.setValue(s), null != n && this.onValueChange(n)
      }
      onValueChange(e) {
        const t = Et.EVENT_FIELD_VALUE_CHANGED;
        return this.addManagedListener(this.eText, t, () => {
          const t = parseFloat(this.eText.getValue());
          this.eSlider.setValue(t.toString(), !0), e(t || 0)
        }), this.addManagedListener(this.eSlider, t, () => {
          const t = this.eSlider.getValue();
          this.eText.setValue(t, !0), e(parseFloat(t))
        }), this
      }
      setSliderWidth(e) {
        return this.eSlider.setWidth(e), this
      }
      setTextFieldWidth(e) {
        return this.eText.setWidth(e), this
      }
      setMinValue(e) {
        return this.eSlider.setMinValue(e), this.eText.setMin(e), this
      }
      setMaxValue(e) {
        return this.eSlider.setMaxValue(e), this.eText.setMax(e), this
      }
      getValue() {
        return this.eText.getValue()
      }
      setValue(e, t) {
        return this.getValue() === e || (this.eText.setValue(e, !0), this.eSlider.setValue(e, !0), t || this.dispatchEvent({
          type: Et.EVENT_FIELD_VALUE_CHANGED
        })), this
      }
      setStep(e) {
        return this.eSlider.setStep(e), this.eText.setStep(e), this
      }
    };
    Wl.TEMPLATE = '<div class="ag-slider">\n            <label ref="eLabel"></label>\n            <div class="ag-wrapper ag-slider-wrapper">\n                <ag-input-range ref="eSlider"></ag-input-range>\n                <ag-input-number-field ref="eText"></ag-input-number-field>\n            </div>\n        </div>', C([ys("eLabel")], Wl.prototype, "eLabel", 2), C([ys("eSlider")], Wl.prototype, "eSlider", 2), C([ys("eText")], Wl.prototype, "eText", 2), C([pe], Wl.prototype, "init", 1);
    var Yl = Wl,
      Kl = class e extends _s {
        constructor(t = {}) {
          super(e.getTemplate(t)), this.params = t, this.suppressEnabledCheckbox = !0, this.suppressToggleExpandOnEnableChange = !1;
          const {
            enabled: i,
            items: r,
            suppressEnabledCheckbox: s,
            expanded: n,
            suppressToggleExpandOnEnableChange: o,
            useToggle: a
          } = t;
          this.cssIdentifier = t.cssIdentifier || "default", this.enabled = null == i || i, this.items = r || [], this.useToggle = null != a && a, this.alignItems = t.alignItems || "center", this.expanded = null == n || n, null != s && (this.suppressEnabledCheckbox = s), null != o && (this.suppressToggleExpandOnEnableChange = o)
        }
        static getTemplate(e) {
          const t = e.cssIdentifier || "default";
          return `\n            <div class="ag-group ag-${t}-group" role="presentation">\n                <div ref="eToolbar" class="ag-group-toolbar ag-${t}-group-toolbar">\n                    <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>\n                </div>\n                <div ref="eContainer" class="ag-group-container ag-group-container-${e.direction||"vertical"} ag-${t}-group-container"></div>\n            </div>\n        `
        }
        postConstruct() {
          if (this.setupTitleBar(), this.items.length) {
            const e = this.items;
            this.items = [], this.addItems(e)
          }
          const e = this.localeService.getLocaleTextFunc();
          this.cbGroupEnabled.setLabel(e("enabled", "Enabled")), this.enabled && this.setEnabled(this.enabled, void 0, !0), this.setAlignItems(this.alignItems);
          const {
            onEnableChange: t,
            suppressOpenCloseIcons: i
          } = this.params;
          this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(null != i && i), this.refreshChildDisplay(), ur(this.eContainer, this.expanded), this.cbGroupEnabled.onValueChange(e => {
            this.setEnabled(e, !0, this.suppressToggleExpandOnEnableChange), this.dispatchEnableChangeEvent(e)
          }), null != t && this.onEnableChange(t)
        }
        refreshChildDisplay() {
          var e;
          ur(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), null == (e = this.eTitleBar) || e.refreshOnExpand(this.expanded)
        }
        isExpanded() {
          return this.expanded
        }
        setAlignItems(e) {
          this.alignItems !== e && this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`), this.alignItems = e;
          const t = `ag-group-item-alignment-${this.alignItems}`;
          return this.addCssClass(t), this
        }
        toggleGroupExpand(t) {
          var i;
          let r = !1;
          if ((null == (i = this.eTitleBar) ? void 0 : i.isSuppressCollapse()) && !this.useToggle) t = !0, r = !0;
          else if (t = null != t ? t : !this.expanded, this.expanded === t) return this;
          return this.expanded = t, this.refreshChildDisplay(), ur(this.eContainer, t), r || this.dispatchEvent({
            type: t ? e.EVENT_EXPANDED : e.EVENT_COLLAPSED
          }), this
        }
        addItems(e) {
          e.forEach(e => this.addItem(e))
        }
        prependItem(e) {
          this.insertItem(e, !0)
        }
        addItem(e) {
          this.insertItem(e, !1)
        }
        insertItem(e, t) {
          const i = this.eContainer,
            r = e instanceof _s ? e.getGui() : e;
          r.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`), t ? (i.insertAdjacentElement("afterbegin", r), this.items.unshift(r)) : (i.appendChild(r), this.items.push(r))
        }
        hideItem(e, t) {
          ur(this.items[t], !e)
        }
        getItemIndex(e) {
          const t = e instanceof _s ? e.getGui() : e;
          return this.items.indexOf(t)
        }
        setTitle(e) {
          var t;
          return null == (t = this.eTitleBar) || t.setTitle(e), this
        }
        addTitleBarWidget(e) {
          var t;
          return null == (t = this.eTitleBar) || t.addWidget(e), this
        }
        addCssClassToTitleBar(e) {
          var t;
          null == (t = this.eTitleBar) || t.addCssClass(e)
        }
        dispatchEnableChangeEvent(t) {
          const i = {
            type: e.EVENT_ENABLE_CHANGE,
            enabled: t
          };
          this.dispatchEvent(i)
        }
        setEnabled(e, t, i) {
          var r;
          return this.enabled = e, this.refreshDisabledStyles(), i || this.toggleGroupExpand(e), t || (this.cbGroupEnabled.setValue(e), null == (r = this.eToggle) || r.setValue(e)), this
        }
        isEnabled() {
          return this.enabled
        }
        onEnableChange(t) {
          return this.addManagedListener(this, e.EVENT_ENABLE_CHANGE, e => t(e.enabled)), this
        }
        hideEnabledCheckbox(e) {
          return this.suppressEnabledCheckbox = e, this.refreshChildDisplay(), this.refreshDisabledStyles(), this
        }
        hideOpenCloseIcons(e) {
          var t;
          return null == (t = this.eTitleBar) || t.hideOpenCloseIcons(e), this
        }
        refreshDisabledStyles() {
          var e;
          const t = !this.enabled;
          this.eContainer.classList.toggle("ag-disabled", t), null == (e = this.eTitleBar) || e.refreshDisabledStyles(this.suppressEnabledCheckbox && t), this.eContainer.classList.toggle("ag-disabled-group-container", t)
        }
        setupTitleBar() {
          const e = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
          this.eToolbar.insertAdjacentElement("beforebegin", e.getGui())
        }
        createDefaultTitleBar() {
          const e = this.createManagedBean(new jl(this.params));
          return this.eTitleBar = e, e.refreshOnExpand(this.expanded), this.addManagedListener(e, jl.EVENT_EXPAND_CHANGED, e => this.toggleGroupExpand(e.expanded)), e
        }
        createToggleTitleBar() {
          var e;
          const t = this.createManagedBean(new Fl({
            value: this.enabled,
            label: this.params.title,
            labelAlignment: "left",
            labelWidth: "flex",
            onValueChange: e => {
              this.setEnabled(e, !0), this.dispatchEnableChangeEvent(e)
            }
          }));
          return t.addCssClass("ag-group-title-bar"), t.addCssClass(`ag-${null!=(e=this.params.cssIdentifier)?e:"default"}-group-title-bar ag-unselectable`), this.eToggle = t, this.toggleGroupExpand(this.enabled), t
        }
      };
    Kl.EVENT_EXPANDED = "expanded", Kl.EVENT_COLLAPSED = "collapsed", Kl.EVENT_ENABLE_CHANGE = "enableChange", C([ys("eToolbar")], Kl.prototype, "eToolbar", 2), C([ys("cbGroupEnabled")], Kl.prototype, "cbGroupEnabled", 2), C([ys("eContainer")], Kl.prototype, "eContainer", 2), C([pe], Kl.prototype, "postConstruct", 1);
    var Xl = Kl,
      zl = "ag-disabled-group-title-bar",
      $l = class e extends _s {
        constructor(t = {}) {
          super(e.getTemplate(t)), this.suppressOpenCloseIcons = !1;
          const {
            title: i,
            suppressOpenCloseIcons: r
          } = t;
          i && i.length > 0 && (this.title = i), null != r && (this.suppressOpenCloseIcons = r)
        }
        static getTemplate(e) {
          var t;
          const i = null != (t = e.cssIdentifier) ? t : "default";
          return `\n            <div class="ag-group-title-bar ag-${i}-group-title-bar ag-unselectable" role="button">\n                <span class="ag-group-title-bar-icon ag-${i}-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>\n                <span class="ag-group-title-bar-icon ag-${i}-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>\n                <span ref="eTitle" class="ag-group-title ag-${i}-group-title"></span>\n            </div>\n        `
        }
        postConstruct() {
          this.setTitle(this.title), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract()
        }
        setupExpandContract() {
          this.eGroupClosedIcon.appendChild(Qr("columnSelectClosed", this.gos, null)), this.eGroupOpenedIcon.appendChild(Qr("columnSelectOpen", this.gos, null)), this.addManagedListener(this.getGui(), "click", () => this.dispatchExpandChanged()), this.addManagedListener(this.getGui(), "keydown", e => {
            switch (e.key) {
              case ts.ENTER:
              case ts.SPACE:
                e.preventDefault(), this.dispatchExpandChanged();
                break;
              case ts.RIGHT:
              case ts.LEFT:
                e.preventDefault(), this.dispatchExpandChanged(e.key === ts.RIGHT)
            }
          })
        }
        refreshOnExpand(e) {
          this.refreshAriaStatus(e), this.refreshOpenCloseIcons(e)
        }
        refreshAriaStatus(e) {
          this.suppressOpenCloseIcons || ai(this.getGui(), e)
        }
        refreshOpenCloseIcons(e) {
          const t = !this.suppressOpenCloseIcons;
          ur(this.eGroupOpenedIcon, t && e), ur(this.eGroupClosedIcon, t && !e)
        }
        isSuppressCollapse() {
          return this.suppressOpenCloseIcons
        }
        dispatchExpandChanged(t) {
          const i = {
            type: e.EVENT_EXPAND_CHANGED,
            expanded: t
          };
          this.dispatchEvent(i)
        }
        setTitle(e) {
          const t = this.getGui(),
            i = !!e && e.length > 0;
          e = i ? e : void 0, this.eTitle.textContent = null != e ? e : "", ur(t, i), e !== this.title && (this.title = e);
          const r = t.classList.contains(zl);
          return this.refreshDisabledStyles(r), this
        }
        addWidget(e) {
          return this.getGui().appendChild(e), this
        }
        hideOpenCloseIcons(e) {
          return this.suppressOpenCloseIcons = e, e && this.dispatchExpandChanged(!0), this
        }
        refreshDisabledStyles(e) {
          const t = this.getGui();
          e ? (t.classList.add(zl), t.removeAttribute("tabindex")) : (t.classList.remove(zl), "string" == typeof this.title ? t.setAttribute("tabindex", "0") : t.removeAttribute("tabindex"))
        }
      };
    $l.EVENT_EXPAND_CHANGED = "expandedChanged", C([ys("eGroupOpenedIcon")], $l.prototype, "eGroupOpenedIcon", 2), C([ys("eGroupClosedIcon")], $l.prototype, "eGroupClosedIcon", 2), C([ys("eTitle")], $l.prototype, "eTitle", 2), C([pe], $l.prototype, "postConstruct", 1);
    var jl = $l,
      Jl = class extends ml {
        constructor(e = 0, t) {
          super('<div class="ag-menu-list" role="tree"></div>'), this.level = e, this.menuItems = [], this.params = null != t ? t : {
            column: null,
            node: null,
            value: null
          }
        }
        postConstruct() {
          this.initialiseTabGuard({
            onTabKeyDown: e => this.onTabKeyDown(e),
            handleKeyDown: e => this.handleKeyDown(e),
            onFocusIn: e => this.handleFocusIn(e),
            onFocusOut: e => this.handleFocusOut(e)
          })
        }
        onTabKeyDown(e) {
          const t = this.getParentComponent(),
            i = t && t.getGui();
          i && i.classList.contains("ag-focus-managed") || e.preventDefault(), e.shiftKey && this.closeIfIsChild(e)
        }
        handleKeyDown(e) {
          switch (e.key) {
            case ts.UP:
            case ts.RIGHT:
            case ts.DOWN:
            case ts.LEFT:
              e.preventDefault(), this.handleNavKey(e.key);
              break;
            case ts.ESCAPE:
              this.closeIfIsChild() && et(e)
          }
        }
        handleFocusIn(e) {
          var t, i;
          const r = e.relatedTarget;
          (this.tabGuardCtrl.isTabGuard(r) || !this.getGui().contains(r) && !(null == (i = null == (t = this.activeMenuItem) ? void 0 : t.getSubMenuGui()) ? void 0 : i.contains(r))) && (this.activeMenuItem ? this.activeMenuItem.activate() : this.activateFirstItem())
        }
        handleFocusOut(e) {
          var t;
          const i = e.relatedTarget;
          !this.activeMenuItem || this.getGui().contains(i) || (null == (t = this.activeMenuItem.getSubMenuGui()) ? void 0 : t.contains(i)) || this.activeMenuItem.isSubMenuOpening() || this.activeMenuItem.deactivate()
        }
        clearActiveItem() {
          this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null)
        }
        addMenuItems(e) {
          null != e && Rs.all(e.map(e => "separator" === e ? Rs.resolve({
            eGui: this.createSeparator()
          }) : "string" == typeof e ? (console.warn(`AG Grid: unrecognised menu item ${e}`), Rs.resolve({
            eGui: null
          })) : this.addItem(e))).then(e => {
            e.forEach(e => {
              (null == e ? void 0 : e.eGui) && (this.appendChild(e.eGui), e.comp && this.menuItems.push(e.comp))
            })
          })
        }
        addItem(e) {
          const t = this.createManagedBean(new Zl);
          return t.init({
            menuItemDef: e,
            isAnotherSubMenuOpen: () => this.menuItems.some(e => e.isSubMenuOpen()),
            level: this.level,
            contextParams: this.params
          }).then(() => (t.setParentComponent(this), this.addManagedListener(t, Zl.EVENT_CLOSE_MENU, e => {
            this.dispatchEvent(e)
          }), this.addManagedListener(t, Zl.EVENT_MENU_ITEM_ACTIVATED, e => {
            this.activeMenuItem && this.activeMenuItem !== e.menuItem && this.activeMenuItem.deactivate(), this.activeMenuItem = e.menuItem
          }), {
            comp: t,
            eGui: t.getGui()
          }))
        }
        activateFirstItem() {
          const e = this.menuItems.filter(e => !e.isDisabled())[0];
          e && e.activate()
        }
        createSeparator() {
          return _r('\n            <div class="ag-menu-separator" aria-hidden="true">\n                <div class="ag-menu-separator-part"></div>\n                <div class="ag-menu-separator-part"></div>\n                <div class="ag-menu-separator-part"></div>\n                <div class="ag-menu-separator-part"></div>\n            </div>')
        }
        handleNavKey(e) {
          switch (e) {
            case ts.UP:
            case ts.DOWN:
              const t = this.findNextItem(e === ts.UP);
              return void(t && t !== this.activeMenuItem && t.activate())
          }
          e === (this.gos.get("enableRtl") ? ts.RIGHT : ts.LEFT) ? this.closeIfIsChild() : this.openChild()
        }
        closeIfIsChild(e) {
          const t = this.getParentComponent();
          return !!(t && t instanceof Zl) && (e && e.preventDefault(), t.closeSubMenu(), t.getGui().focus(), !0)
        }
        openChild() {
          this.activeMenuItem && this.activeMenuItem.openSubMenu(!0)
        }
        findNextItem(e) {
          const t = this.menuItems.filter(e => !e.isDisabled());
          if (!t.length) return;
          if (!this.activeMenuItem) return e ? Me(t) : t[0];
          let i;
          e && t.reverse();
          let r = !1;
          for (let e = 0; e < t.length; e++) {
            const s = t[e];
            if (r) {
              i = s;
              break
            }
            s === this.activeMenuItem && (r = !0)
          }
          return r && !i ? t[0] : i || this.activeMenuItem
        }
        destroy() {
          this.clearActiveItem(), super.destroy()
        }
      };
    C([fe("focusService")], Jl.prototype, "focusService", 2), C([pe], Jl.prototype, "postConstruct", 1);
    var ql = class extends ml {
      constructor(e) {
        super(), this.wrappedComponent = e, this.setTemplateFromElement(e.getGui())
      }
      postConstruct() {
        this.initialiseTabGuard({
          onTabKeyDown: e => this.onTabKeyDown(e),
          handleKeyDown: e => this.handleKeyDown(e)
        })
      }
      handleKeyDown(e) {
        e.key === ts.ESCAPE && this.closePanel()
      }
      onTabKeyDown(e) {
        e.defaultPrevented || (this.closePanel(), e.preventDefault())
      }
      closePanel() {
        const e = this.parentComponent;
        e.closeSubMenu(), setTimeout(() => e.getGui().focus(), 0)
      }
    };
    C([pe], ql.prototype, "postConstruct", 1);
    var Ql = class e extends ct {
      constructor() {
        super(...arguments), this.isActive = !1, this.subMenuIsOpen = !1, this.subMenuIsOpening = !1, this.suppressRootStyles = !0, this.suppressAria = !0, this.suppressFocus = !0
      }
      init(e) {
        var t, i;
        const {
          menuItemDef: r,
          isAnotherSubMenuOpen: s,
          level: n,
          childComponent: o,
          contextParams: a
        } = e;
        this.params = e.menuItemDef, this.level = n, this.isAnotherSubMenuOpen = s, this.childComponent = o, this.contextParams = a, this.cssClassPrefix = null != (i = null == (t = this.params.menuItemParams) ? void 0 : t.cssClassPrefix) ? i : "ag-menu-option";
        return this.userComponentFactory.getMenuItemCompDetails(this.params, T(f({}, r), {
          level: n,
          isAnotherSubMenuOpen: s,
          openSubMenu: e => this.openSubMenu(e),
          closeSubMenu: () => this.closeSubMenu(),
          closeMenu: e => this.closeMenu(e),
          updateTooltip: (e, t) => this.refreshTooltip(e, t),
          onItemActivated: () => this.onItemActivated()
        })).newAgStackInstance().then(e => {
          var t;
          this.menuItemComp = e;
          const i = null == (t = e.configureDefaults) ? void 0 : t.call(e);
          i && this.configureDefaults(!0 === i ? void 0 : i)
        })
      }
      addListeners(e, t) {
        (null == t ? void 0 : t.suppressClick) || this.addManagedListener(e, "click", e => this.onItemSelected(e)), (null == t ? void 0 : t.suppressKeyboardSelect) || this.addManagedListener(e, "keydown", e => {
          e.key !== ts.ENTER && e.key !== ts.SPACE || (e.preventDefault(), this.onItemSelected(e))
        }), (null == t ? void 0 : t.suppressMouseDown) || this.addManagedListener(e, "mousedown", e => {
          e.stopPropagation(), e.preventDefault()
        }), (null == t ? void 0 : t.suppressMouseOver) || (this.addManagedListener(e, "mouseenter", () => this.onMouseEnter()), this.addManagedListener(e, "mouseleave", () => this.onMouseLeave()))
      }
      isDisabled() {
        return !!this.params.disabled
      }
      openSubMenu(t = !1) {
        var i, r;
        if (this.closeSubMenu(), !this.params.subMenu) return;
        this.subMenuIsOpening = !0;
        const s = _r('<div class="ag-menu" role="presentation"></div>');
        let n;
        this.eSubMenuGui = s;
        let o = () => {
          this.subMenuIsOpening = !1
        };
        if (this.childComponent) {
          const e = this.createBean(new ql(this.childComponent));
          e.setParentComponent(this);
          const t = e.getGui(),
            i = "mouseenter",
            r = () => this.cancelDeactivate();
          t.addEventListener(i, r), n = () => t.removeEventListener(i, r), s.appendChild(t), this.childComponent.afterGuiAttached && (o = () => {
            this.childComponent.afterGuiAttached(), this.subMenuIsOpening = !1
          })
        } else if (this.params.subMenu) {
          const i = this.createBean(new Jl(this.level + 1, this.contextParams));
          i.setParentComponent(this), i.addMenuItems(this.params.subMenu), s.appendChild(i.getGui()), this.addManagedListener(i, e.EVENT_CLOSE_MENU, e => this.dispatchEvent(e)), i.addGuiEventListener("mouseenter", () => this.cancelDeactivate()), n = () => this.destroyBean(i), t && (o = () => {
            i.activateFirstItem(), this.subMenuIsOpening = !1
          })
        }
        const a = this.popupService.positionPopupForMenu.bind(this.popupService, {
            eventSource: this.eGui,
            ePopup: s
          }),
          l = this.localeService.getLocaleTextFunc(),
          c = this.popupService.addPopup({
            modal: !0,
            eChild: s,
            positionCallback: a,
            anchorToElement: this.eGui,
            ariaLabel: l("ariaLabelSubMenu", "SubMenu"),
            afterGuiAttached: o
          });
        this.subMenuIsOpen = !0, this.setAriaExpanded(!0), this.hideSubMenu = () => {
          var e, t;
          c && c.hideFunc(), this.subMenuIsOpen = !1, this.setAriaExpanded(!1), n(), null == (t = (e = this.menuItemComp).setExpanded) || t.call(e, !1), this.eSubMenuGui = void 0
        }, null == (r = (i = this.menuItemComp).setExpanded) || r.call(i, !0)
      }
      setAriaExpanded(e) {
        this.suppressAria || ai(this.eGui, e)
      }
      closeSubMenu() {
        this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, this.setAriaExpanded(!1))
      }
      isSubMenuOpen() {
        return this.subMenuIsOpen
      }
      isSubMenuOpening() {
        return this.subMenuIsOpening
      }
      activate(e) {
        var t, i;
        this.cancelActivate(), this.params.disabled || (this.isActive = !0, this.suppressRootStyles || this.eGui.classList.add(`${this.cssClassPrefix}-active`), null == (i = (t = this.menuItemComp).setActive) || i.call(t, !0), this.suppressFocus || this.eGui.focus({
          preventScroll: !0
        }), e && this.params.subMenu && window.setTimeout(() => {
          this.isAlive() && this.isActive && this.openSubMenu()
        }, 300), this.onItemActivated())
      }
      deactivate() {
        var e, t;
        this.cancelDeactivate(), this.suppressRootStyles || this.eGui.classList.remove(`${this.cssClassPrefix}-active`), null == (t = (e = this.menuItemComp).setActive) || t.call(e, !1), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu()
      }
      getGui() {
        return this.menuItemComp.getGui()
      }
      getParentComponent() {
        return this.parentComponent
      }
      setParentComponent(e) {
        this.parentComponent = e
      }
      getSubMenuGui() {
        return this.eSubMenuGui
      }
      onItemSelected(e) {
        var t, i;
        null == (i = (t = this.menuItemComp).select) || i.call(t), this.params.action ? this.getFrameworkOverrides().wrapOutgoing(() => this.params.action(this.gos.addGridCommonParams(f({}, this.contextParams)))) : this.openSubMenu(e && "keydown" === e.type), this.params.subMenu && !this.params.action || this.params.suppressCloseOnSelect || this.closeMenu(e)
      }
      closeMenu(t) {
        const i = {
          type: e.EVENT_CLOSE_MENU
        };
        t && (t instanceof MouseEvent ? i.mouseEvent = t : i.keyboardEvent = t), this.dispatchEvent(i)
      }
      onItemActivated() {
        const t = {
          type: e.EVENT_MENU_ITEM_ACTIVATED,
          menuItem: this
        };
        this.dispatchEvent(t)
      }
      cancelActivate() {
        this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0)
      }
      cancelDeactivate() {
        this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0)
      }
      onMouseEnter() {
        this.cancelDeactivate(), this.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(() => this.activate(!0), e.ACTIVATION_DELAY) : this.activate(!0)
      }
      onMouseLeave() {
        this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), e.ACTIVATION_DELAY) : this.deactivate()
      }
      configureDefaults(e) {
        var t, i, r;
        if (!this.menuItemComp) return void setTimeout(() => this.configureDefaults(e));
        let s = this.menuItemComp.getGui();
        const n = null == (i = (t = this.menuItemComp).getRootElement) ? void 0 : i.call(t);
        n && ((null == e ? void 0 : e.suppressRootStyles) || s.classList.add("ag-menu-option-custom"), s = n), this.eGui = s, this.suppressRootStyles = !!(null == e ? void 0 : e.suppressRootStyles), this.suppressRootStyles || (s.classList.add(this.cssClassPrefix), null == (r = this.params.cssClasses) || r.forEach(e => s.classList.add(e)), this.params.disabled && s.classList.add(`${this.cssClassPrefix}-disabled`)), (null == e ? void 0 : e.suppressTooltip) || this.refreshTooltip(this.params.tooltip), this.suppressAria = !!(null == e ? void 0 : e.suppressAria), this.suppressAria || (Xt(s, "treeitem"), ri(s, this.level + 1), this.params.disabled && si(s, !0)), (null == e ? void 0 : e.suppressTabIndex) || s.setAttribute("tabindex", "-1"), this.params.disabled || this.addListeners(s, e), this.suppressFocus = !!(null == e ? void 0 : e.suppressFocus)
      }
      refreshTooltip(e, t) {
        this.tooltip = e, this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), e && this.menuItemComp && (this.tooltipFeature = this.createBean(new Is({
          getGui: () => this.getGui(),
          getTooltipValue: () => this.tooltip,
          getLocation: () => "menu",
          shouldDisplayTooltip: t
        })))
      }
      destroy() {
        this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy()
      }
    };
    Ql.EVENT_CLOSE_MENU = "closeMenu", Ql.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated", Ql.ACTIVATION_DELAY = 80, C([fe("popupService")], Ql.prototype, "popupService", 2), C([fe("userComponentFactory")], Ql.prototype, "userComponentFactory", 2);
    var Zl = Ql,
      ec = class e extends _s {
        constructor(t) {
          super(e.getTemplate(t)), this.config = t, this.closable = !0
        }
        static getTemplate(e) {
          const t = e.cssIdentifier || "default";
          return `<div class="ag-panel ag-${t}-panel" tabindex="-1">\n            <div ref="eTitleBar" class="ag-panel-title-bar ag-${t}-panel-title-bar ag-unselectable">\n                <span ref="eTitle" class="ag-panel-title-bar-title ag-${t}-panel-title-bar-title"></span>\n                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${t}-panel-title-bar-buttons"></div>\n            </div>\n            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-${t}-panel-content-wrapper"></div>\n        </div>`
        }
        postConstruct() {
          const {
            component: e,
            closable: t,
            hideTitleBar: i,
            title: r,
            minWidth: s = 250,
            width: n,
            minHeight: o = 250,
            height: a,
            centered: l,
            popup: c,
            x: h,
            y: u
          } = this.config;
          this.positionableFeature = new Hs(this.getGui(), {
            minWidth: s,
            width: n,
            minHeight: o,
            height: a,
            centered: l,
            x: h,
            y: u,
            popup: c,
            calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
          }), this.createManagedBean(this.positionableFeature);
          const d = this.getGui();
          e && this.setBodyComponent(e), i ? ur(this.eTitleBar, !1) : (r && this.setTitle(r), this.setClosable(null != t ? t : this.closable)), this.addManagedListener(this.eTitleBar, "mousedown", e => {
            if (d.contains(e.relatedTarget) || d.contains(this.gos.getActiveDomElement()) || this.eTitleBarButtons.contains(e.target)) return void e.preventDefault();
            const t = this.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
            t && t.focus()
          }), c && this.positionableFeature.isPositioned() || (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0")
        }
        renderComponent() {
          const e = this.getGui();
          e.focus(), this.close = () => {
            e.parentElement.removeChild(e), this.destroy()
          }
        }
        getHeight() {
          return this.positionableFeature.getHeight()
        }
        setHeight(e) {
          this.positionableFeature.setHeight(e)
        }
        getWidth() {
          return this.positionableFeature.getWidth()
        }
        setWidth(e) {
          this.positionableFeature.setWidth(e)
        }
        setClosable(t) {
          if (t !== this.closable && (this.closable = t), t) {
            const t = this.closeButtonComp = new _s(e.CLOSE_BTN_TEMPLATE);
            this.getContext().createBean(t);
            const i = t.getGui(),
              r = Zr("close", this.gos);
            r.classList.add("ag-panel-title-bar-button-icon"), i.appendChild(r), this.addTitleBarButton(t), t.addManagedListener(i, "click", this.onBtClose.bind(this))
          } else if (this.closeButtonComp) {
            const e = this.closeButtonComp.getGui();
            e.parentElement.removeChild(e), this.closeButtonComp = this.destroyBean(this.closeButtonComp)
          }
        }
        setBodyComponent(e) {
          e.setParentComponent(this), this.eContentWrapper.appendChild(e.getGui())
        }
        addTitleBarButton(e, t) {
          const i = this.eTitleBarButtons,
            r = i.children,
            s = r.length;
          null == t && (t = s), t = Math.max(0, Math.min(t, s)), e.addCssClass("ag-panel-title-bar-button");
          const n = e.getGui();
          0 === t ? i.insertAdjacentElement("afterbegin", n) : t === s ? i.insertAdjacentElement("beforeend", n) : r[t - 1].insertAdjacentElement("afterend", n), e.setParentComponent(this)
        }
        getBodyHeight() {
          return fr(this.eContentWrapper)
        }
        getBodyWidth() {
          return Tr(this.eContentWrapper)
        }
        setTitle(e) {
          this.eTitle.innerText = e
        }
        onBtClose() {
          this.close()
        }
        destroy() {
          this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
          const e = this.getGui();
          e && Lr(e) && this.close(), super.destroy()
        }
      };
    ec.CLOSE_BTN_TEMPLATE = '<div class="ag-button"></div>', C([ys("eContentWrapper")], ec.prototype, "eContentWrapper", 2), C([ys("eTitleBar")], ec.prototype, "eTitleBar", 2), C([ys("eTitleBarButtons")], ec.prototype, "eTitleBarButtons", 2), C([ys("eTitle")], ec.prototype, "eTitle", 2), C([pe], ec.prototype, "postConstruct", 1);
    var tc = ec;
    C([fe("popupService")], class extends tc {
      constructor(e) {
        super(T(f({}, e), {
          popup: !0
        })), this.isMaximizable = !1, this.isMaximized = !1, this.maximizeListeners = [], this.resizeListenerDestroy = null, this.lastPosition = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      }
      postConstruct() {
        const e = this.getGui(),
          {
            movable: t,
            resizable: i,
            maximizable: r
          } = this.config;
        this.addCssClass("ag-dialog"), super.postConstruct(), this.addManagedListener(e, "focusin", t => {
          this.popupService.bringPopupToFront(e)
        }), t && this.setMovable(t), r && this.setMaximizable(r), i && this.setResizable(i)
      }
      renderComponent() {
        const e = this.getGui(),
          {
            alwaysOnTop: t,
            modal: i,
            title: r,
            afterGuiAttached: s
          } = this.config,
          n = this.localeService.getLocaleTextFunc(),
          o = this.popupService.addPopup({
            modal: i,
            eChild: e,
            closeOnEsc: !0,
            closedCallback: this.onClosed.bind(this),
            alwaysOnTop: t,
            ariaLabel: r || n("ariaLabelDialog", "Dialog"),
            afterGuiAttached: s
          });
        o && (this.close = o.hideFunc)
      }
      onClosed(e) {
        var t, i;
        this.destroy(), null == (i = (t = this.config).closedCallback) || i.call(t, e)
      }
      toggleMaximize() {
        const e = this.positionableFeature.getPosition();
        if (this.isMaximized) {
          const {
            x: e,
            y: t,
            width: i,
            height: r
          } = this.lastPosition;
          this.setWidth(i), this.setHeight(r), this.positionableFeature.offsetElement(e, t)
        } else this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = e.x, this.lastPosition.y = e.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
        this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon()
      }
      refreshMaximizeIcon() {
        ur(this.maximizeIcon, !this.isMaximized), ur(this.minimizeIcon, this.isMaximized)
      }
      clearMaximizebleListeners() {
        this.maximizeListeners.length && (this.maximizeListeners.forEach(e => e()), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null)
      }
      destroy() {
        this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), super.destroy()
      }
      setResizable(e) {
        this.positionableFeature.setResizable(e)
      }
      setMovable(e) {
        this.positionableFeature.setMovable(e, this.eTitleBar)
      }
      setMaximizable(e) {
        if (!e) return this.clearMaximizebleListeners(), void(this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0));
        const t = this.eTitleBar;
        if (!t || e === this.isMaximizable) return;
        const i = this.buildMaximizeAndMinimizeElements();
        this.refreshMaximizeIcon(), i.addManagedListener(i.getGui(), "click", this.toggleMaximize.bind(this)), this.addTitleBarButton(i, 0), this.maximizeListeners.push(this.addManagedListener(t, "dblclick", this.toggleMaximize.bind(this))), this.resizeListenerDestroy = this.addManagedListener(this, "resize", () => {
          this.isMaximized = !1, this.refreshMaximizeIcon()
        })
      }
      buildMaximizeAndMinimizeElements() {
        const e = this.maximizeButtonComp = this.createBean(new _s('<div class="ag-dialog-button"></span>')),
          t = e.getGui();
        return this.maximizeIcon = Zr("maximize", this.gos), t.appendChild(this.maximizeIcon), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), this.minimizeIcon = Zr("minimize", this.gos), t.appendChild(this.minimizeIcon), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon"), e
      }
    }.prototype, "popupService", 2);
    var ic = 0,
      rc = class extends ct {
        constructor() {
          super(...arguments), this.popupList = []
        }
        postConstruct() {
          this.ctrlsService.whenReady(e => {
            this.gridCtrl = e.gridCtrl
          }), this.addManagedListener(this.eventService, Et.EVENT_GRID_STYLES_CHANGED, this.handleThemeChange.bind(this))
        }
        getPopupParent() {
          const e = this.gos.get("popupParent");
          return e || this.gridCtrl.getGui()
        }
        positionPopupForMenu(e) {
          const {
            eventSource: t,
            ePopup: i
          } = e, r = this.getPopupIndex(i);
          if (-1 !== r) {
            this.popupList[r].alignedToElement = t
          }
          const s = t.getBoundingClientRect(),
            n = this.getParentRect(),
            o = this.keepXYWithinBounds(i, s.top - n.top, 0),
            a = i.clientWidth > 0 ? i.clientWidth : 200;
          i.style.minWidth = `${a}px`;
          const l = n.right - n.left - a;
          let c;

          function h() {
            return s.right - n.left - 2
          }

          function u() {
            return s.left - n.left - a
          }
          this.gos.get("enableRtl") ? (c = u(), c < 0 && (c = h(), this.setAlignedStyles(i, "left")), c > l && (c = 0, this.setAlignedStyles(i, "right"))) : (c = h(), c > l && (c = u(), this.setAlignedStyles(i, "right")), c < 0 && (c = 0, this.setAlignedStyles(i, "left"))), i.style.left = `${c}px`, i.style.top = `${o}px`
        }
        positionPopupUnderMouseEvent(e) {
          const {
            ePopup: t,
            nudgeX: i,
            nudgeY: r,
            skipObserver: s
          } = e;
          this.positionPopup({
            ePopup: t,
            nudgeX: i,
            nudgeY: r,
            keepWithinBounds: !0,
            skipObserver: s,
            updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
            postProcessCallback: () => this.callPostProcessPopup(e.type, e.ePopup, null, e.mouseEvent, e.column, e.rowNode)
          })
        }
        calculatePointerAlign(e) {
          const t = this.getParentRect();
          return {
            x: e.clientX - t.left,
            y: e.clientY - t.top
          }
        }
        positionPopupByComponent(e) {
          const {
            ePopup: t,
            nudgeX: i,
            nudgeY: r,
            keepWithinBounds: s,
            eventSource: n,
            alignSide: o = "left",
            position: a = "over",
            column: l,
            rowNode: c,
            type: h
          } = e, u = n.getBoundingClientRect(), d = this.getParentRect(), p = this.getPopupIndex(t);
          if (-1 !== p) {
            this.popupList[p].alignedToElement = n
          }
          this.positionPopup({
            ePopup: t,
            nudgeX: i,
            nudgeY: r,
            keepWithinBounds: s,
            updatePosition: () => {
              let i, s = u.left - d.left;
              if ("right" === o && (s -= t.offsetWidth - u.width), "over" === a) i = u.top - d.top, this.setAlignedStyles(t, "over");
              else {
                this.setAlignedStyles(t, "under");
                i = "under" === this.shouldRenderUnderOrAbove(t, u, d, e.nudgeY || 0) ? u.top - d.top + u.height : u.top - t.offsetHeight - 2 * (r || 0) - d.top
              }
              return {
                x: s,
                y: i
              }
            },
            postProcessCallback: () => this.callPostProcessPopup(h, t, n, null, l, c)
          })
        }
        shouldRenderUnderOrAbove(e, t, i, r) {
          const s = i.bottom - t.bottom,
            n = t.top - i.top,
            o = e.offsetHeight + r;
          return s > o ? "under" : n > o || n > s ? "above" : "under"
        }
        setAlignedStyles(e, t) {
          const i = this.getPopupIndex(e);
          if (-1 === i) return;
          const r = this.popupList[i],
            {
              alignedToElement: s
            } = r;
          if (!s) return;
          ["right", "left", "over", "above", "under"].forEach(t => {
            s.classList.remove(`ag-has-popup-positioned-${t}`), e.classList.remove(`ag-popup-positioned-${t}`)
          }), t && (s.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`))
        }
        callPostProcessPopup(e, t, i, r, s, n) {
          const o = this.gos.getCallback("postProcessPopup");
          if (o) {
            o({
              column: s,
              rowNode: n,
              ePopup: t,
              type: e,
              eventSource: i,
              mouseEvent: r
            })
          }
        }
        positionPopup(e) {
          const {
            ePopup: t,
            keepWithinBounds: i,
            nudgeX: r,
            nudgeY: s,
            skipObserver: n,
            updatePosition: o
          } = e, a = {
            width: 0,
            height: 0
          }, l = (n = !1) => {
            let {
              x: l,
              y: c
            } = o();
            n && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, r && (l += r), s && (c += s), i && (l = this.keepXYWithinBounds(t, l, 1), c = this.keepXYWithinBounds(t, c, 0)), t.style.left = `${l}px`, t.style.top = `${c}px`, e.postProcessCallback && e.postProcessCallback())
          };
          if (l(), !n) {
            const e = this.resizeObserverService.observeResize(t, () => l(!0));
            setTimeout(() => e(), rc.WAIT_FOR_POPUP_CONTENT_RESIZE)
          }
        }
        getActivePopups() {
          return this.popupList.map(e => e.element)
        }
        getPopupList() {
          return this.popupList
        }
        getParentRect() {
          const e = this.gos.getDocument();
          let t = this.getPopupParent();
          return t === e.body ? t = e.documentElement : "static" === getComputedStyle(t).position && (t = t.offsetParent), Sr(t)
        }
        keepXYWithinBounds(e, t, i) {
          const r = 0 === i,
            s = r ? "clientHeight" : "clientWidth",
            n = r ? "top" : "left",
            o = r ? "offsetHeight" : "offsetWidth",
            a = r ? "scrollTop" : "scrollLeft",
            l = this.gos.getDocument(),
            c = l.documentElement,
            h = this.getPopupParent(),
            u = h.getBoundingClientRect(),
            d = l.documentElement.getBoundingClientRect(),
            p = h === l.body,
            E = e[o];
          let g = p ? (r ? mr : Cr)(c) + c[a] : h[s];
          p && (g -= Math.abs(d[n] - u[n]));
          const f = g - E;
          return Math.min(Math.max(t, 0), Math.abs(f))
        }
        addPopup(e) {
          const t = this.gos.getDocument(),
            {
              eChild: i,
              ariaLabel: r,
              alwaysOnTop: s,
              positionCallback: n,
              anchorToElement: o
            } = e;
          if (!t) return console.warn("AG Grid: could not find the document, document is empty"), {
            hideFunc: () => {}
          };
          const a = this.getPopupIndex(i);
          if (-1 !== a) {
            return {
              hideFunc: this.popupList[a].hideFunc
            }
          }
          this.initialisePopupPosition(i);
          const l = this.createPopupWrapper(i, r, !!s),
            c = this.addEventListenersToPopup(T(f({}, e), {
              wrapperEl: l
            }));
          return n && n(), this.addPopupToPopupList(i, l, c, o), {
            hideFunc: c
          }
        }
        initialisePopupPosition(e) {
          const t = this.getPopupParent().getBoundingClientRect();
          v(e.style.top) || (e.style.top = -1 * t.top + "px"), v(e.style.left) || (e.style.left = -1 * t.left + "px")
        }
        createPopupWrapper(e, t, i) {
          const r = this.getPopupParent(),
            s = document.createElement("div"),
            {
              allThemes: n
            } = this.environment.getTheme();
          return n.length && s.classList.add(...n), s.classList.add("ag-popup"), e.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Xt(e, "dialog"), qt(e, t), s.appendChild(e), r.appendChild(s), i ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), s
        }
        handleThemeChange() {
          const {
            allThemes: e
          } = this.environment.getTheme();
          for (const t of this.popupList) {
            for (const e of Array.from(t.wrapper.classList)) e.startsWith("ag-theme-") && t.wrapper.classList.remove(e);
            e.length && t.wrapper.classList.add(...e)
          }
        }
        addEventListenersToPopup(e) {
          const t = this.gos.getDocument(),
            i = this.getPopupParent(),
            {
              wrapperEl: r,
              eChild: s,
              closedCallback: n,
              afterGuiAttached: o,
              closeOnEsc: a,
              modal: l
            } = e;
          let c = !1;
          const h = e => {
              if (!r.contains(this.gos.getActiveDomElement())) return;
              e.key !== ts.ESCAPE || tt(e) || p({
                keyboardEvent: e
              })
            },
            u = e => p({
              mouseEvent: e
            }),
            d = e => p({
              touchEvent: e
            }),
            p = (e = {}) => {
              const {
                mouseEvent: o,
                touchEvent: a,
                keyboardEvent: l,
                forceHide: p
              } = e;
              (p || !this.isEventFromCurrentPopup({
                mouseEvent: o,
                touchEvent: a
              }, s) && !c) && (c = !0, i.removeChild(r), t.removeEventListener("keydown", h), t.removeEventListener("mousedown", u), t.removeEventListener("touchstart", d), t.removeEventListener("contextmenu", u), this.eventService.removeEventListener(Et.EVENT_DRAG_STARTED, u), n && n(o || a || l), this.removePopupFromPopupList(s))
            };
          return o && o({
            hidePopup: p
          }), window.setTimeout(() => {
            a && t.addEventListener("keydown", h), l && (t.addEventListener("mousedown", u), this.eventService.addEventListener(Et.EVENT_DRAG_STARTED, u), t.addEventListener("touchstart", d), t.addEventListener("contextmenu", u))
          }, 0), p
        }
        addPopupToPopupList(e, t, i, r) {
          this.popupList.push({
            element: e,
            wrapper: t,
            hideFunc: i,
            instanceId: ic++,
            isAnchored: !!r
          }), r && this.setPopupPositionRelatedToElement(e, r)
        }
        getPopupIndex(e) {
          return this.popupList.findIndex(t => t.element === e)
        }
        setPopupPositionRelatedToElement(e, t) {
          const i = this.getPopupIndex(e);
          if (-1 === i) return;
          const r = this.popupList[i];
          if (r.stopAnchoringPromise && r.stopAnchoringPromise.then(e => e && e()), r.stopAnchoringPromise = void 0, r.isAnchored = !1, !t) return;
          const s = this.keepPopupPositionedRelativeTo({
            element: t,
            ePopup: e,
            hidePopup: r.hideFunc
          });
          return r.stopAnchoringPromise = s, r.isAnchored = !0, s
        }
        removePopupFromPopupList(e) {
          this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter(t => t.element !== e)
        }
        keepPopupPositionedRelativeTo(e) {
          const t = this.getPopupParent(),
            i = t.getBoundingClientRect(),
            {
              element: r,
              ePopup: s
            } = e,
            n = r.getBoundingClientRect(),
            o = i.top - n.top,
            a = i.left - n.left;
          let l = o,
            c = a;
          const h = s.style.top,
            u = parseInt(h.substring(0, h.length - 1), 10),
            d = s.style.left,
            p = parseInt(d.substring(0, d.length - 1), 10);
          return new Rs(i => {
            this.getFrameworkOverrides().setInterval(() => {
              const i = t.getBoundingClientRect(),
                n = r.getBoundingClientRect();
              if (0 == n.top && 0 == n.left && 0 == n.height && 0 == n.width) return void e.hidePopup();
              const h = i.top - n.top;
              if (h != l) {
                const e = this.keepXYWithinBounds(s, u + o - h, 0);
                s.style.top = `${e}px`
              }
              l = h;
              const d = i.left - n.left;
              if (d != c) {
                const e = this.keepXYWithinBounds(s, p + a - d, 1);
                s.style.left = `${e}px`
              }
              c = d
            }, 200).then(e => {
              i(() => {
                null != e && window.clearInterval(e)
              })
            })
          })
        }
        hasAnchoredPopup() {
          return this.popupList.some(e => e.isAnchored)
        }
        isEventFromCurrentPopup(e, t) {
          const {
            mouseEvent: i,
            touchEvent: r
          } = e, s = i || r;
          if (!s) return !1;
          const n = this.getPopupIndex(t);
          if (-1 === n) return !1;
          for (let e = n; e < this.popupList.length; e++) {
            if (st(this.popupList[e].element, s)) return !0
          }
          return this.isElementWithinCustomPopup(s.target)
        }
        isElementWithinCustomPopup(e) {
          const t = this.gos.getDocument();
          for (; e && e !== t.body;) {
            if (e.classList.contains("ag-custom-component-popup") || null === e.parentElement) return !0;
            e = e.parentElement
          }
          return !1
        }
        getWrapper(e) {
          for (; !e.classList.contains("ag-popup") && e.parentElement;) e = e.parentElement;
          return e.classList.contains("ag-popup") ? e : null
        }
        setAlwaysOnTop(e, t) {
          const i = this.getWrapper(e);
          i && (i.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(i))
        }
        bringPopupToFront(e) {
          const t = this.getPopupParent(),
            i = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")),
            r = i.length,
            s = Array.prototype.slice.call(t.querySelectorAll(".ag-popup.ag-always-on-top")),
            n = s.length,
            o = this.getWrapper(e);
          if (!o || r <= 1 || !t.contains(e)) return;
          const a = i.indexOf(o),
            l = o.querySelectorAll("div"),
            c = [];
          if (l.forEach(e => {
              0 !== e.scrollTop && c.push([e, e.scrollTop])
            }), n) {
            o.classList.contains("ag-always-on-top") ? a !== r - 1 && Me(s).insertAdjacentElement("afterend", o) : a !== r - n - 1 && s[0].insertAdjacentElement("beforebegin", o)
          } else a !== r - 1 && Me(i).insertAdjacentElement("afterend", o);
          for (; c.length;) {
            const e = c.pop();
            e[0].scrollTop = e[1]
          }
        }
      };
    rc.WAIT_FOR_POPUP_CONTENT_RESIZE = 200, C([fe("focusService")], rc.prototype, "focusService", 2), C([fe("ctrlsService")], rc.prototype, "ctrlsService", 2), C([fe("resizeObserverService")], rc.prototype, "resizeObserverService", 2), C([pe], rc.prototype, "postConstruct", 1), rc = C([ge("popupService")], rc);
    var sc = class extends _s {
        constructor() {
          super('\n        <div class="ag-autocomplete-row" role="presentation">\n            <div class="ag-autocomplete-row-label"></div>\n        </div>'), this.hasHighlighting = !1
        }
        setState(e, t) {
          this.value = e, this.render(), this.updateSelected(t)
        }
        updateSelected(e) {
          this.addOrRemoveCssClass("ag-autocomplete-row-selected", e)
        }
        setSearchString(e) {
          var t;
          let i = !1;
          if (v(e)) {
            const r = null == (t = this.value) ? void 0 : t.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
            if (r >= 0) {
              i = !0, this.hasHighlighting = !0;
              const t = r + e.length,
                s = Nt(this.value.slice(0, r)),
                n = Nt(this.value.slice(r, t)),
                o = Nt(this.value.slice(t));
              this.getGui().lastElementChild.innerHTML = `${s}<b>${n}</b>${o}`
            }
          }!i && this.hasHighlighting && (this.hasHighlighting = !1, this.render())
        }
        render() {
          var e;
          this.getGui().lastElementChild.innerHTML = null != (e = Nt(this.value)) ? e : "&nbsp;"
        }
      },
      nc = class e extends Pn {
        constructor(t) {
          super(e.TEMPLATE), this.params = t, this.searchString = ""
        }
        destroy() {
          super.destroy()
        }
        init() {
          this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList = this.createManagedBean(new Bl({
            cssIdentifier: "autocomplete"
          })), this.virtualList.setComponentCreator(this.createRowComponent.bind(this)), this.eList.appendChild(this.virtualList.getGui()), this.virtualList.setModel({
            getRowCount: () => this.autocompleteEntries.length,
            getRow: e => this.autocompleteEntries[e]
          });
          const e = this.virtualList.getGui();
          this.addManagedListener(e, "click", () => this.params.onConfirmed()), this.addManagedListener(e, "mousemove", this.onMouseMove.bind(this)), this.addManagedListener(e, "mousedown", e => e.preventDefault()), this.setSelectedValue(0)
        }
        onNavigationKeyDown(e, t) {
          e.preventDefault();
          const i = this.autocompleteEntries.indexOf(this.selectedValue),
            r = t === ts.UP ? i - 1 : i + 1;
          this.checkSetSelectedValue(r)
        }
        setSearch(e) {
          this.searchString = e, v(e) ? this.runSearch() : (this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList.refresh(), this.checkSetSelectedValue(0)), this.updateSearchInList()
        }
        runContainsSearch(e, t) {
          let i, r = !1;
          const s = e.toLocaleLowerCase(),
            n = t.filter(e => {
              const t = e.toLocaleLowerCase().indexOf(s),
                n = 0 === t,
                o = t >= 0;
              return o && (!i || !r && n || r === n && e.length < i.length) && (i = e, r = n), o
            });
          return !i && n.length && (i = n[0]), {
            topMatch: i,
            allMatches: n
          }
        }
        runSearch() {
          var e, t;
          const {
            autocompleteEntries: i
          } = this.params, r = i.map(e => {
            var t;
            return null != (t = e.displayValue) ? t : e.key
          });
          let s, n;
          if (this.params.useFuzzySearch) s = $r(this.searchString, r, !0).values, n = s.length ? s[0] : void 0;
          else {
            const e = this.runContainsSearch(this.searchString, r);
            s = e.allMatches, n = e.topMatch
          }
          let o = i.filter(({
            key: e,
            displayValue: t
          }) => s.includes(null != t ? t : e));
          if (!o.length && this.selectedValue && (null == (t = null == (e = this.params) ? void 0 : e.forceLastSelection) ? void 0 : t.call(e, this.selectedValue, this.searchString)) && (o = [this.selectedValue]), this.autocompleteEntries = o, this.virtualList.refresh(), !n) return;
          const a = s.indexOf(n);
          this.checkSetSelectedValue(a)
        }
        updateSearchInList() {
          this.virtualList.forEachRenderedRow(e => e.setSearchString(this.searchString))
        }
        checkSetSelectedValue(e) {
          e >= 0 && e < this.autocompleteEntries.length && this.setSelectedValue(e)
        }
        setSelectedValue(e) {
          const t = this.autocompleteEntries[e];
          this.selectedValue !== t && (this.selectedValue = t, this.virtualList.ensureIndexVisible(e), this.virtualList.forEachRenderedRow((t, i) => {
            t.updateSelected(e === i)
          }))
        }
        createRowComponent(e) {
          var t;
          const i = new sc;
          return this.getContext().createBean(i), i.setState(null != (t = e.displayValue) ? t : e.key, e === this.selectedValue), i
        }
        onMouseMove(e) {
          const t = this.virtualList.getGui().getBoundingClientRect(),
            i = this.virtualList.getScrollTop(),
            r = e.clientY - t.top + i,
            s = Math.floor(r / this.virtualList.getRowHeight());
          this.checkSetSelectedValue(s)
        }
        afterGuiAttached() {
          this.virtualList.refresh()
        }
        getSelectedValue() {
          var e;
          return this.autocompleteEntries.length && null != (e = this.selectedValue) ? e : null
        }
      };
    nc.TEMPLATE = '<div class="ag-autocomplete-list-popup">\n            <div ref="eList" class="ag-autocomplete-list"></div>\n        <div>', C([ys("eList")], nc.prototype, "eList", 2), C([pe], nc.prototype, "init", 1);
    var oc = nc,
      ac = class e extends _s {
        constructor() {
          super('\n            <div class="ag-autocomplete" role="presentation">\n                <ag-input-text-field ref="eAutocompleteInput"></ag-input-text-field>\n            </div>'), this.isListOpen = !1, this.lastPosition = 0, this.valid = !0
        }
        postConstruct() {
          this.eAutocompleteInput.onValueChange(e => this.onValueChanged(e)), this.eAutocompleteInput.getInputElement().setAttribute("autocomplete", "off"), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.addGuiEventListener("click", this.updatePositionAndList.bind(this)), this.addDestroyFunc(() => {
            this.destroyBean(this.autocompleteList)
          }), this.addGuiEventListener("focusout", () => this.onFocusOut())
        }
        onValueChanged(e) {
          const t = A(e);
          this.updateValue(t), this.updateAutocompleteList(t)
        }
        updateValue(t) {
          this.updateLastPosition(), this.dispatchEvent({
            type: e.EVENT_VALUE_CHANGED,
            value: t
          }), this.validate(t)
        }
        updateAutocompleteList(e) {
          var t, i, r, s;
          const n = null != (i = null == (t = this.listGenerator) ? void 0 : t.call(this, e, this.lastPosition)) ? i : {
            enabled: !1
          };
          if (n.type && n.type === (null == (r = this.autocompleteListParams) ? void 0 : r.type) || this.isListOpen && this.closeList(), this.autocompleteListParams = n, null == (s = this.autocompleteListParams) ? void 0 : s.enabled) {
            this.isListOpen || this.openList();
            const {
              searchString: e
            } = this.autocompleteListParams;
            this.autocompleteList.setSearch(null != e ? e : "")
          } else this.isListOpen && this.closeList()
        }
        onKeyDown(e) {
          const t = e.key;
          switch (this.updateLastPosition(), t) {
            case ts.ENTER:
              this.onEnterKeyDown(e);
              break;
            case ts.TAB:
              this.onTabKeyDown(e);
              break;
            case ts.DOWN:
            case ts.UP:
              this.onUpDownKeyDown(e, t);
              break;
            case ts.LEFT:
            case ts.RIGHT:
            case ts.PAGE_HOME:
            case ts.PAGE_END:
              setTimeout(() => {
                this.updatePositionAndList()
              });
              break;
            case ts.ESCAPE:
              this.onEscapeKeyDown(e);
              break;
            case ts.SPACE:
              e.ctrlKey && !this.isListOpen && (e.preventDefault(), this.forceOpenList())
          }
        }
        confirmSelection() {
          var t;
          const i = null == (t = this.autocompleteList) ? void 0 : t.getSelectedValue();
          i && (this.closeList(), this.dispatchEvent({
            type: e.EVENT_OPTION_SELECTED,
            value: this.getValue(),
            position: this.lastPosition,
            updateEntry: i,
            autocompleteType: this.autocompleteListParams.type
          }))
        }
        onTabKeyDown(e) {
          this.isListOpen && (e.preventDefault(), e.stopPropagation(), this.confirmSelection())
        }
        onEnterKeyDown(e) {
          e.preventDefault(), this.isListOpen ? this.confirmSelection() : this.onCompleted()
        }
        onUpDownKeyDown(e, t) {
          var i;
          e.preventDefault(), this.isListOpen ? null == (i = this.autocompleteList) || i.onNavigationKeyDown(e, t) : this.forceOpenList()
        }
        onEscapeKeyDown(e) {
          this.isListOpen && (e.preventDefault(), e.stopPropagation(), this.closeList(), this.setCaret(this.lastPosition, !0))
        }
        onFocusOut() {
          this.isListOpen && this.closeList()
        }
        updatePositionAndList() {
          var e;
          this.updateLastPosition(), this.updateAutocompleteList(null != (e = this.eAutocompleteInput.getValue()) ? e : null)
        }
        setCaret(e, t) {
          const i = this.gos.getDocument(),
            r = this.gos.getActiveDomElement();
          !t || r && r !== i.body || this.eAutocompleteInput.getFocusableElement().focus();
          const s = this.eAutocompleteInput.getInputElement();
          s.setSelectionRange(e, e), e === s.value.length && (s.scrollLeft = s.scrollWidth)
        }
        forceOpenList() {
          this.onValueChanged(this.eAutocompleteInput.getValue())
        }
        updateLastPosition() {
          var e;
          this.lastPosition = null != (e = this.eAutocompleteInput.getInputElement().selectionStart) ? e : 0
        }
        validate(t) {
          var i;
          this.validator && (this.validationMessage = this.validator(t), this.eAutocompleteInput.getInputElement().setCustomValidity(null != (i = this.validationMessage) ? i : ""), this.valid = !this.validationMessage, this.dispatchEvent({
            type: e.EVENT_VALID_CHANGED,
            isValid: this.valid,
            validationMessage: this.validationMessage
          }))
        }
        openList() {
          this.isListOpen = !0, this.autocompleteList = this.createBean(new oc({
            autocompleteEntries: this.autocompleteListParams.entries,
            onConfirmed: () => this.confirmSelection(),
            forceLastSelection: this.forceLastSelection
          }));
          const e = this.autocompleteList.getGui(),
            t = {
              ePopup: e,
              type: "autocomplete",
              eventSource: this.getGui(),
              position: "under",
              alignSide: this.gos.get("enableRtl") ? "right" : "left",
              keepWithinBounds: !0
            },
            i = this.popupService.addPopup({
              eChild: e,
              anchorToElement: this.getGui(),
              positionCallback: () => this.popupService.positionPopupByComponent(t),
              ariaLabel: this.listAriaLabel
            });
          this.hidePopup = i.hideFunc, this.autocompleteList.afterGuiAttached()
        }
        closeList() {
          this.isListOpen = !1, this.hidePopup(), this.destroyBean(this.autocompleteList), this.autocompleteList = null
        }
        onCompleted() {
          this.isListOpen && this.closeList(), this.dispatchEvent({
            type: e.EVENT_VALUE_CONFIRMED,
            value: this.getValue(),
            isValid: this.isValid()
          })
        }
        getValue() {
          return A(this.eAutocompleteInput.getValue())
        }
        setInputPlaceholder(e) {
          return this.eAutocompleteInput.setInputPlaceholder(e), this
        }
        setInputAriaLabel(e) {
          return this.eAutocompleteInput.setInputAriaLabel(e), this
        }
        setListAriaLabel(e) {
          return this.listAriaLabel = e, this
        }
        setListGenerator(e) {
          return this.listGenerator = e, this
        }
        setValidator(e) {
          return this.validator = e, this
        }
        isValid() {
          return this.valid
        }
        setValue(e) {
          const {
            value: t,
            position: i,
            silent: r,
            updateListOnlyIfOpen: s,
            restoreFocus: n
          } = e;
          this.eAutocompleteInput.setValue(t, !0), this.setCaret(null != i ? i : this.lastPosition, n), r || this.updateValue(t), s && !this.isListOpen || this.updateAutocompleteList(t)
        }
        setForceLastSelection(e) {
          return this.forceLastSelection = e, this
        }
        setInputDisabled(e) {
          return this.eAutocompleteInput.setDisabled(e), this
        }
      };
    ac.EVENT_VALUE_CHANGED = "eventValueChanged", ac.EVENT_VALUE_CONFIRMED = "eventValueConfirmed", ac.EVENT_OPTION_SELECTED = "eventOptionSelected", ac.EVENT_VALID_CHANGED = "eventValidChanged", C([fe("popupService")], ac.prototype, "popupService", 2), C([ys("eAutocompleteInput")], ac.prototype, "eAutocompleteInput", 2), C([pe], ac.prototype, "postConstruct", 1);
    var lc = ac,
      cc = class e extends _s {
        constructor(e, t, i, r) {
          super(), this.dragSourceDropTarget = e, this.ghost = t, this.horizontal = i, this.template = r
        }
        init() {
          var t;
          this.setTemplate(null != (t = this.template) ? t : e.TEMPLATE);
          const i = this.getGui();
          this.addElementClasses(i), this.addElementClasses(this.eDragHandle, "drag-handle"), this.addElementClasses(this.eText, "text"), this.addElementClasses(this.eButton, "button"), this.eDragHandle.appendChild(Zr("columnDrag", this.gos)), this.eButton.appendChild(Zr("cancel", this.gos)), this.setupComponents(), !this.ghost && this.isDraggable() && this.addDragSource(), this.setupAria(), this.setupTooltip(), this.activateTabIndex(), this.refreshDraggable()
        }
        isDraggable() {
          return !0
        }
        refreshDraggable() {
          this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !this.isDraggable())
        }
        setupAria() {
          const e = this.localeService.getLocaleTextFunc(),
            t = [this.getAriaDisplayName()];
          this.addAdditionalAriaInstructions(t, e), qt(this.getGui(), t.join(". "))
        }
        addAdditionalAriaInstructions(e, t) {
          if (this.isRemovable()) {
            const i = t("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
            e.push(i)
          }
        }
        setupTooltip() {
          const e = () => {
            const e = this.getTooltip();
            this.setTooltip({
              newTooltipText: e
            })
          };
          e(), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, e)
        }
        getDragSourceId() {}
        getDefaultIconName() {
          return Kn.ICON_NOT_ALLOWED
        }
        addDragSource() {
          const {
            dragAndDropService: e,
            eDragHandle: t
          } = this, i = this.createGetDragItem(), r = this.getDefaultIconName(), s = {
            type: this.getDragSourceType(),
            sourceId: this.getDragSourceId(),
            eElement: t,
            getDefaultIconName: () => r,
            getDragItem: i,
            dragItemName: this.getDisplayName()
          };
          e.addDragSource(s, !0), this.addDestroyFunc(() => e.removeDragSource(s))
        }
        setupComponents() {
          this.setTextValue(), this.setupRemove(), this.ghost && this.addCssClass("ag-column-drop-cell-ghost")
        }
        isRemovable() {
          return !0
        }
        refreshRemove() {
          ur(this.eButton, this.isRemovable())
        }
        setupRemove() {
          this.refreshRemove();
          const t = {
            type: e.EVENT_COLUMN_REMOVE
          };
          this.addGuiEventListener("keydown", e => this.onKeyDown(e)), this.addManagedListener(this.eButton, "click", e => {
            this.dispatchEvent(t), e.stopPropagation()
          });
          const i = new In(this.eButton);
          this.addManagedListener(i, In.EVENT_TAP, () => {
            this.dispatchEvent(t)
          }), this.addDestroyFunc(i.destroy.bind(i))
        }
        onKeyDown(t) {
          t.key === ts.DELETE && this.isRemovable() && (t.preventDefault(), this.dispatchEvent({
            type: e.EVENT_COLUMN_REMOVE
          }))
        }
        getDisplayValue() {
          return this.getDisplayName()
        }
        setTextValue() {
          const e = Nt(this.getDisplayValue());
          this.eText.innerHTML = e
        }
        addElementClasses(e, t) {
          t = t ? `-${t}` : "";
          const i = this.horizontal ? "horizontal" : "vertical";
          e.classList.add(`ag-column-drop-cell${t}`, `ag-column-drop-${i}-cell${t}`)
        }
        destroy() {
          super.destroy(), this.dragSourceDropTarget = null
        }
      };
    cc.EVENT_COLUMN_REMOVE = "columnRemove", cc.TEMPLATE = '<span role="option">\n          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>\n          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>\n          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>\n        </span>', C([fe("dragAndDropService")], cc.prototype, "dragAndDropService", 2), C([ys("eText")], cc.prototype, "eText", 2), C([ys("eDragHandle")], cc.prototype, "eDragHandle", 2), C([ys("eButton")], cc.prototype, "eButton", 2), C([pe], cc.prototype, "init", 1);
    var hc = cc,
      uc = class e extends _s {
        constructor(t) {
          super('<div class="ag-unselectable" role="presentation"></div>'), this.horizontal = t, this.state = e.STATE_NOT_DRAGGING, this.guiDestroyFunctions = [], this.childPillComponents = [], this.resizeEnabled = !1, this.addElementClasses(this.getGui()), this.ePillDropList = document.createElement("div"), this.addElementClasses(this.ePillDropList, "list"), Xt(this.ePillDropList, "listbox")
        }
        isHorizontal() {
          return this.horizontal
        }
        toggleResizable(e) {
          this.positionableFeature.setResizable(!!e && {
            bottom: !0
          }), this.resizeEnabled = e
        }
        isSourceEventFromTarget(e) {
          const {
            dropZoneTarget: t,
            dragSource: i
          } = e;
          return t.contains(i.eElement)
        }
        destroy() {
          this.destroyGui(), super.destroy()
        }
        destroyGui() {
          this.guiDestroyFunctions.forEach(e => e()), this.guiDestroyFunctions.length = 0, this.childPillComponents.length = 0, Nr(this.getGui()), Nr(this.ePillDropList)
        }
        init(e) {
          this.params = null != e ? e : {}, this.createManagedBean(new xs(this.getFocusableElement(), {
            handleKeyDown: this.handleKeyDown.bind(this)
          })), this.setupDropTarget(), this.positionableFeature = new Hs(this.getGui(), {
            minHeight: 100
          }), this.createManagedBean(this.positionableFeature), this.refreshGui(), qt(this.ePillDropList, this.getAriaLabel())
        }
        handleKeyDown(e) {
          const t = !this.horizontal;
          let i = e.key === ts.DOWN,
            r = e.key === ts.UP;
          if (!t) {
            const t = this.gos.get("enableRtl");
            i = !t && e.key === ts.RIGHT || t && e.key === ts.LEFT, r = !t && e.key === ts.LEFT || t && e.key === ts.RIGHT
          }
          if (!i && !r) return;
          const s = this.focusService.findNextFocusableElement(this.getFocusableElement(), !1, r);
          s && (e.preventDefault(), s.focus())
        }
        addElementClasses(e, t) {
          t = t ? `-${t}` : "";
          const i = this.horizontal ? "horizontal" : "vertical";
          e.classList.add(`ag-column-drop${t}`, `ag-column-drop-${i}${t}`)
        }
        setupDropTarget() {
          this.dropTarget = {
            getContainer: this.getGui.bind(this),
            getIconName: this.getIconName.bind(this),
            onDragging: this.onDragging.bind(this),
            onDragEnter: this.onDragEnter.bind(this),
            onDragLeave: this.onDragLeave.bind(this),
            onDragStop: this.onDragStop.bind(this),
            isInterestedIn: this.isInterestedIn.bind(this)
          }, this.dragAndDropService.addDropTarget(this.dropTarget)
        }
        minimumAllowedNewInsertIndex() {
          return 0
        }
        checkInsertIndex(e) {
          const t = this.getNewInsertIndex(e);
          if (t < 0) return !1;
          const i = this.minimumAllowedNewInsertIndex(),
            r = Math.max(i, t),
            s = r !== this.insertIndex;
          return s && (this.insertIndex = r), s
        }
        getNewInsertIndex(e) {
          const t = e.event,
            i = this.horizontal ? t.clientX : t.clientY,
            r = this.childPillComponents.map(e => e.getGui().getBoundingClientRect()),
            s = r.findIndex(e => this.horizontal ? e.right > i && e.left < i : e.top < i && e.bottom > i);
          if (-1 === s) {
            const e = this.gos.get("enableRtl");
            if (r.every(e => i > (this.horizontal ? e.right : e.bottom))) return e && this.horizontal ? 0 : this.childPillComponents.length;
            return r.every(e => i < (this.horizontal ? e.left : e.top)) ? e && this.horizontal ? this.childPillComponents.length : 0 : this.insertIndex
          }
          return this.insertIndex <= s ? s + 1 : s
        }
        checkDragStartedBySelf(t) {
          this.state === e.STATE_NOT_DRAGGING && (this.state = e.STATE_REARRANGE_ITEMS, this.potentialDndItems = this.getItems(t.dragSource.getDragItem()), this.refreshGui(), this.checkInsertIndex(t), this.refreshGui())
        }
        onDragging(e) {
          this.checkDragStartedBySelf(e), this.checkInsertIndex(e) && this.refreshGui()
        }
        handleDragEnterEnd(e) {}
        onDragEnter(t) {
          const i = this.getItems(t.dragSource.getDragItem());
          this.state = e.STATE_NEW_ITEMS_IN;
          const r = i.filter(e => this.isItemDroppable(e, t)),
            s = r.every(e => -1 !== this.childPillComponents.map(e => e.getItem()).indexOf(e));
          0 !== r.length && (this.potentialDndItems = r, s ? this.state = e.STATE_NOT_DRAGGING : (this.handleDragEnterEnd(t), this.checkInsertIndex(t), this.refreshGui()))
        }
        isPotentialDndItems() {
          return be(this.potentialDndItems)
        }
        handleDragLeaveEnd(e) {}
        onDragLeave(t) {
          if (this.state === e.STATE_REARRANGE_ITEMS) {
            const e = this.getItems(t.dragSource.getDragItem());
            this.removeItems(e)
          }
          this.isPotentialDndItems() && (this.handleDragLeaveEnd(t), this.potentialDndItems = [], this.refreshGui()), this.state = e.STATE_NOT_DRAGGING
        }
        refreshOnDragStop() {
          return !0
        }
        onDragStop() {
          if (this.isPotentialDndItems()) {
            let t = !1;
            this.state === e.STATE_NEW_ITEMS_IN ? (this.addItems(this.potentialDndItems), t = !0) : t = this.rearrangeItems(this.potentialDndItems), this.potentialDndItems = [], !this.refreshOnDragStop() && t || this.refreshGui()
          }
          this.state = e.STATE_NOT_DRAGGING
        }
        removeItems(e) {
          const t = this.getExistingItems().filter(t => !Xe(e, t));
          this.updateItems(t)
        }
        addItems(e) {
          if (!e) return;
          const t = this.getExistingItems().slice(),
            i = e.filter(e => t.indexOf(e) < 0);
          Ye(t, i, this.insertIndex), this.updateItems(t)
        }
        addItem(e) {
          this.insertIndex = this.getExistingItems().length, this.addItems([e]), this.refreshGui()
        }
        rearrangeItems(e) {
          const t = this.getNonGhostItems().slice();
          return Ye(t, e, this.insertIndex), !Fe(t, this.getExistingItems()) && (this.updateItems(t), !0)
        }
        refreshGui() {
          const e = this.ePillDropList.scrollTop,
            t = this.resizeEnabled,
            i = this.getFocusedItem();
          let r = this.focusService.findNextFocusableElement();
          r || (r = this.focusService.findNextFocusableElement(void 0, !1, !0)), this.toggleResizable(!1), this.destroyGui(), this.addIconAndTitleToGui(), this.addEmptyMessageToGui(), this.addItemsToGui(), this.isHorizontal() || (this.ePillDropList.scrollTop = e), t && this.toggleResizable(t), this.focusService.isKeyboardMode() && this.restoreFocus(i, r)
        }
        getFocusedItem() {
          const e = this.getGui(),
            t = this.gos.getActiveDomElement();
          if (!e.contains(t)) return -1;
          return Array.from(e.querySelectorAll(".ag-column-drop-cell")).indexOf(t)
        }
        restoreFocus(e, t) {
          const i = this.getGui(),
            r = Array.from(i.querySelectorAll(".ag-column-drop-cell"));
          if (-1 === e) return;
          0 === r.length && t.focus();
          const s = r[Math.min(r.length - 1, e)];
          s && s.focus()
        }
        focusList(e) {
          const t = e ? this.childPillComponents.length - 1 : 0;
          this.restoreFocus(t, this.getFocusableElement())
        }
        getNonGhostItems() {
          const e = this.getExistingItems();
          return this.isPotentialDndItems() ? e.filter(e => !Xe(this.potentialDndItems, e)) : e
        }
        addItemsToGui() {
          const e = this.getNonGhostItems().map(e => this.createItemComponent(e, !1));
          if (this.isPotentialDndItems()) {
            const t = this.potentialDndItems.map(e => this.createItemComponent(e, !0));
            this.insertIndex >= e.length ? e.push(...t) : e.splice(this.insertIndex, 0, ...t)
          }
          this.appendChild(this.ePillDropList), e.forEach((e, t) => {
            t > 0 && this.addArrow(this.ePillDropList), this.ePillDropList.appendChild(e.getGui())
          }), this.addAriaLabelsToComponents()
        }
        addAriaLabelsToComponents() {
          this.childPillComponents.forEach((e, t) => {
            const i = e.getGui();
            hi(i, t + 1), ci(i, this.childPillComponents.length)
          })
        }
        createItemComponent(e, t) {
          const i = this.createPillComponent(e, this.dropTarget, t, this.horizontal);
          return i.addEventListener(hc.EVENT_COLUMN_REMOVE, this.removeItems.bind(this, [e])), this.context.createBean(i), this.guiDestroyFunctions.push(() => this.destroyBean(i)), t || this.childPillComponents.push(i), i
        }
        addIconAndTitleToGui() {
          const {
            title: e,
            icon: t
          } = this.params;
          if (!e || !t) return;
          const i = document.createElement("div");
          if (ni(i, !0), this.addElementClasses(i, "title-bar"), this.addElementClasses(t, "icon"), this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingItemsEmpty()), i.appendChild(t), !this.horizontal) {
            const t = document.createElement("span");
            this.addElementClasses(t, "title"), t.innerHTML = e, i.appendChild(t)
          }
          this.appendChild(i)
        }
        isExistingItemsEmpty() {
          return 0 === this.getExistingItems().length
        }
        addEmptyMessageToGui() {
          const {
            emptyMessage: e
          } = this.params;
          if (!e || !this.isExistingItemsEmpty() || this.isPotentialDndItems()) return;
          const t = document.createElement("span");
          t.innerHTML = e, this.addElementClasses(t, "empty-message"), this.ePillDropList.appendChild(t)
        }
        addArrow(e) {
          if (this.horizontal) {
            const t = Zr(this.gos.get("enableRtl") ? "smallLeft" : "smallRight", this.gos);
            this.addElementClasses(t, "cell-separator"), e.appendChild(t)
          }
        }
      };
    uc.STATE_NOT_DRAGGING = "notDragging", uc.STATE_NEW_ITEMS_IN = "newItemsIn", uc.STATE_REARRANGE_ITEMS = "rearrangeItems", C([fe("focusService")], uc.prototype, "focusService", 2), C([fe("dragAndDropService")], uc.prototype, "dragAndDropService", 2);
    var dc = ["touchstart", "touchend", "touchmove", "touchcancel"],
      pc = class {
        constructor(e = "javascript") {
          this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = e => e(), this.wrapOutgoing = e => e()
        }
        setInterval(e, t) {
          return new Rs(i => {
            i(window.setInterval(e, t))
          })
        }
        addEventListener(e, t, i, r) {
          const s = Xe(dc, t);
          e.addEventListener(t, i, {
            capture: !!r,
            passive: s
          })
        }
        get shouldWrapOutgoing() {
          return !1
        }
        frameworkComponent(e) {
          return null
        }
        isFrameworkComponent(e) {
          return !1
        }
        getDocLink(e) {
          return `https://www.ag-grid.com/${"solid"===this.frameworkName?"react":this.frameworkName}-data-grid${e?`/${e}`:""}`
        }
      },
      Ec = class extends ct {
        getNextCellToFocus(e, t, i = !1) {
          return i ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t)
        }
        getNextCellToFocusWithCtrlPressed(e, t) {
          const i = e === ts.UP,
            r = e === ts.DOWN,
            s = e === ts.LEFT;
          let n, o;
          if (i || r) o = i ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow(), n = t.column;
          else {
            const e = this.columnModel.getAllDisplayedColumns(),
              i = this.gos.get("enableRtl");
            o = t.rowIndex, n = s !== i ? e[0] : Me(e)
          }
          return {
            rowIndex: o,
            rowPinned: null,
            column: n
          }
        }
        getNextCellToFocusWithoutCtrlPressed(e, t) {
          let i = t,
            r = !1;
          for (; !r;) {
            switch (e) {
              case ts.UP:
                i = this.getCellAbove(i);
                break;
              case ts.DOWN:
                i = this.getCellBelow(i);
                break;
              case ts.RIGHT:
                i = this.gos.get("enableRtl") ? this.getCellToLeft(i) : this.getCellToRight(i);
                break;
              case ts.LEFT:
                i = this.gos.get("enableRtl") ? this.getCellToRight(i) : this.getCellToLeft(i);
                break;
              default:
                i = null, console.warn("AG Grid: unknown key for navigation " + e)
            }
            r = !i || this.isCellGoodToFocusOn(i)
          }
          return i
        }
        isCellGoodToFocusOn(e) {
          const t = e.column;
          let i;
          switch (e.rowPinned) {
            case "top":
              i = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
              break;
            case "bottom":
              i = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
              break;
            default:
              i = this.rowModel.getRow(e.rowIndex)
          }
          if (!i) return !1;
          return !t.isSuppressNavigable(i)
        }
        getCellToLeft(e) {
          if (!e) return null;
          const t = this.columnModel.getDisplayedColBefore(e.column);
          return t ? {
            rowIndex: e.rowIndex,
            column: t,
            rowPinned: e.rowPinned
          } : null
        }
        getCellToRight(e) {
          if (!e) return null;
          const t = this.columnModel.getDisplayedColAfter(e.column);
          return t ? {
            rowIndex: e.rowIndex,
            column: t,
            rowPinned: e.rowPinned
          } : null
        }
        getRowBelow(e) {
          const t = e.rowIndex,
            i = e.rowPinned;
          if (this.isLastRowInContainer(e)) switch (i) {
            case "bottom":
              return null;
            case "top":
              return this.rowModel.isRowsToRender() ? {
                rowIndex: this.paginationProxy.getPageFirstRow(),
                rowPinned: null
              } : this.pinnedRowModel.isRowsToRender("bottom") ? {
                rowIndex: 0,
                rowPinned: "bottom"
              } : null;
            default:
              return this.pinnedRowModel.isRowsToRender("bottom") ? {
                rowIndex: 0,
                rowPinned: "bottom"
              } : null
          }
          const r = this.rowModel.getRow(e.rowIndex),
            s = this.getNextStickyPosition(r);
          return s || {
            rowIndex: t + 1,
            rowPinned: i
          }
        }
        getNextStickyPosition(e, t) {
          if (!this.gos.isGroupRowsSticky() || !e || !e.sticky) return;
          let i = [];
          i = this.rowRenderer.getStickyTopRowCtrls().some(t => t.getRowNode().rowIndex === e.rowIndex) ? [...this.rowRenderer.getStickyTopRowCtrls()].sort((e, t) => e.getRowNode().rowIndex - t.getRowNode().rowIndex) : [...this.rowRenderer.getStickyBottomRowCtrls()].sort((e, t) => t.getRowNode().rowIndex - e.getRowNode().rowIndex);
          const r = t ? -1 : 1,
            s = i.findIndex(t => t.getRowNode().rowIndex === e.rowIndex),
            n = i[s + r];
          return n ? {
            rowIndex: n.getRowNode().rowIndex,
            rowPinned: null
          } : void 0
        }
        getCellBelow(e) {
          if (!e) return null;
          const t = this.getRowBelow(e);
          return t ? {
            rowIndex: t.rowIndex,
            column: e.column,
            rowPinned: t.rowPinned
          } : null
        }
        isLastRowInContainer(e) {
          const t = e.rowPinned,
            i = e.rowIndex;
          if ("top" === t) {
            return this.pinnedRowModel.getPinnedTopRowData().length - 1 <= i
          }
          if ("bottom" === t) {
            return this.pinnedRowModel.getPinnedBottomRowData().length - 1 <= i
          }
          return this.paginationProxy.getPageLastRow() <= i
        }
        getRowAbove(e) {
          const t = e.rowIndex,
            i = e.rowPinned;
          if (i ? 0 === t : t === this.paginationProxy.getPageFirstRow()) return "top" === i ? null : i && this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
          const r = this.rowModel.getRow(e.rowIndex),
            s = this.getNextStickyPosition(r, !0);
          return s || {
            rowIndex: t - 1,
            rowPinned: i
          }
        }
        getCellAbove(e) {
          if (!e) return null;
          const t = this.getRowAbove({
            rowIndex: e.rowIndex,
            rowPinned: e.rowPinned
          });
          return t ? {
            rowIndex: t.rowIndex,
            column: e.column,
            rowPinned: t.rowPinned
          } : null
        }
        getLastBodyCell() {
          return {
            rowIndex: this.paginationProxy.getPageLastRow(),
            rowPinned: null
          }
        }
        getLastFloatingTopRow() {
          return {
            rowIndex: this.pinnedRowModel.getPinnedTopRowData().length - 1,
            rowPinned: "top"
          }
        }
        getNextTabbedCell(e, t) {
          return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e)
        }
        getNextTabbedCellForwards(e) {
          const t = this.columnModel.getAllDisplayedColumns();
          let i = e.rowIndex,
            r = e.rowPinned,
            s = this.columnModel.getDisplayedColAfter(e.column);
          if (!s) {
            s = t[0];
            const n = this.getRowBelow(e);
            if (N(n)) return null;
            if (!n.rowPinned && !this.paginationProxy.isRowInPage(n)) return null;
            i = n ? n.rowIndex : null, r = n ? n.rowPinned : null
          }
          return {
            rowIndex: i,
            column: s,
            rowPinned: r
          }
        }
        getNextTabbedCellBackwards(e) {
          const t = this.columnModel.getAllDisplayedColumns();
          let i = e.rowIndex,
            r = e.rowPinned,
            s = this.columnModel.getDisplayedColBefore(e.column);
          if (!s) {
            s = Me(t);
            const n = this.getRowAbove({
              rowIndex: e.rowIndex,
              rowPinned: e.rowPinned
            });
            if (N(n)) return null;
            if (!n.rowPinned && !this.paginationProxy.isRowInPage(n)) return null;
            i = n ? n.rowIndex : null, r = n ? n.rowPinned : null
          }
          return {
            rowIndex: i,
            column: s,
            rowPinned: r
          }
        }
      };
    C([fe("columnModel")], Ec.prototype, "columnModel", 2), C([fe("rowModel")], Ec.prototype, "rowModel", 2), C([fe("rowRenderer")], Ec.prototype, "rowRenderer", 2), C([fe("pinnedRowModel")], Ec.prototype, "pinnedRowModel", 2), C([fe("paginationProxy")], Ec.prototype, "paginationProxy", 2), Ec = C([ge("cellNavigationService")], Ec);
    var gc = class extends ct {
      constructor() {
        super(...arguments), this.consuming = !1
      }
      setBeans(e) {
        this.logger = e.create("AlignedGridsService")
      }
      getAlignedGridApis() {
        var e;
        let t = null != (e = this.gos.get("alignedGrids")) ? e : [];
        const i = "function" == typeof t;
        "function" == typeof t && (t = t());
        const r = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
        return t.map(e => {
          var t;
          if (!e) return j("alignedGrids contains an undefined option."), i || j('You may want to configure via a callback to avoid setup race conditions:\n                     "alignedGrids: () => [linkedGrid]"'), void j(r());
          if (e instanceof zo) return e;
          const s = e;
          return "current" in s ? null == (t = s.current) ? void 0 : t.api : (s.api || j(`alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${r()}`), s.api)
        }).filter(e => !!e && !e.isDestroyed())
      }
      init() {
        this.addManagedListener(this.eventService, Et.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this))
      }
      fireEvent(e) {
        this.consuming || this.getAlignedGridApis().forEach(t => {
          if (t.isDestroyed()) return;
          const i = t.__getAlignedGridService();
          e(i)
        })
      }
      onEvent(e) {
        this.consuming = !0, e(), this.consuming = !1
      }
      fireColumnEvent(e) {
        this.fireEvent(t => {
          t.onColumnEvent(e)
        })
      }
      fireScrollEvent(e) {
        "horizontal" === e.direction && this.fireEvent(t => {
          t.onScrollEvent(e)
        })
      }
      onScrollEvent(e) {
        this.onEvent(() => {
          this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0)
        })
      }
      getMasterColumns(e) {
        const t = [];
        return e.columns ? e.columns.forEach(e => {
          t.push(e)
        }) : e.column && t.push(e.column), t
      }
      getColumnIds(e) {
        const t = [];
        return e.columns ? e.columns.forEach(e => {
          t.push(e.getColId())
        }) : e.column && t.push(e.column.getColId()), t
      }
      onColumnEvent(e) {
        this.onEvent(() => {
          switch (e.type) {
            case Et.EVENT_COLUMN_MOVED:
            case Et.EVENT_COLUMN_VISIBLE:
            case Et.EVENT_COLUMN_PINNED:
            case Et.EVENT_COLUMN_RESIZED:
              const t = e;
              this.processColumnEvent(t);
              break;
            case Et.EVENT_COLUMN_GROUP_OPENED:
              const i = e;
              this.processGroupOpenedEvent(i);
              break;
            case Et.EVENT_COLUMN_PIVOT_CHANGED:
              console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.")
          }
        })
      }
      processGroupOpenedEvent(e) {
        e.columnGroups.forEach(t => {
          let i = null;
          if (t) {
            const e = t.getGroupId();
            i = this.columnModel.getProvidedColumnGroup(e)
          }
          t && !i || (this.logger.log("onColumnEvent-> processing " + e + " expanded = " + t.isExpanded()), this.columnModel.setColumnGroupOpened(i, t.isExpanded(), "alignedGridChanged"))
        })
      }
      processColumnEvent(e) {
        var t;
        const i = e.column;
        let r = null;
        if (i && (r = this.columnModel.getPrimaryColumn(i.getColId())), i && !r) return;
        const s = this.getMasterColumns(e);
        switch (e.type) {
          case Et.EVENT_COLUMN_MOVED: {
            const t = e,
              i = e.api.getColumnState().map(e => ({
                colId: e.colId
              }));
            this.columnModel.applyColumnState({
              state: i,
              applyOrder: !0
            }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} toIndex = ${t.toIndex}`)
          }
          break;
        case Et.EVENT_COLUMN_VISIBLE: {
          const t = e,
            i = e.api.getColumnState().map(e => ({
              colId: e.colId,
              hide: e.hide
            }));
          this.columnModel.applyColumnState({
            state: i
          }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} visible = ${t.visible}`)
        }
        break;
        case Et.EVENT_COLUMN_PINNED: {
          const t = e,
            i = e.api.getColumnState().map(e => ({
              colId: e.colId,
              pinned: e.pinned
            }));
          this.columnModel.applyColumnState({
            state: i
          }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} pinned = ${t.pinned}`)
        }
        break;
        case Et.EVENT_COLUMN_RESIZED:
          const i = e,
            r = {};
          s.forEach(t => {
            this.logger.log(`onColumnEvent-> processing ${e.type} actualWidth = ${t.getActualWidth()}`), r[t.getId()] = {
              key: t.getColId(),
              newWidth: t.getActualWidth()
            }
          }), null == (t = i.flexColumns) || t.forEach(e => {
            r[e.getId()] && delete r[e.getId()]
          }), this.columnModel.setColumnWidths(Object.values(r), !1, i.finished, "alignedGridChanged")
        }
        const n = this.ctrlsService.getGridBodyCtrl().isVerticalScrollShowing();
        this.getAlignedGridApis().forEach(e => {
          e.setGridOption("alwaysShowVerticalScroll", n)
        })
      }
    };
    C([fe("columnModel")], gc.prototype, "columnModel", 2), C([fe("ctrlsService")], gc.prototype, "ctrlsService", 2), C([S(0, Ce("loggerFactory"))], gc.prototype, "setBeans", 1), C([pe], gc.prototype, "init", 1), gc = C([ge("alignedGridsService")], gc);
    var fc = class extends ct {
      constructor() {
        super(...arguments), this.selectedNodes = new Map, this.lastRowNode = null
      }
      init() {
        this.rowSelection = this.gos.get("rowSelection"), this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
          this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.rowSelection = this.gos.get("rowSelection"), this.deselectAllRowNodes({
            source: "api"
          })
        }), this.addManagedListener(this.eventService, Et.EVENT_ROW_SELECTED, this.onRowSelected.bind(this))
      }
      destroy() {
        super.destroy(), this.resetNodes(), this.lastRowNode = null
      }
      isMultiselect() {
        return "multiple" === this.rowSelection
      }
      setNodesSelected(e) {
        var t;
        const {
          newValue: i,
          clearSelection: r,
          suppressFinishActions: s,
          rangeSelect: n,
          nodes: o,
          event: a,
          source: l = "api"
        } = e;
        if (0 === o.length) return 0;
        if (o.length > 1 && !this.isMultiselect()) return console.warn("AG Grid: cannot multi select while rowSelection='single'"), 0;
        const c = this.groupSelectsChildren && !0 === e.groupSelectsFiltered,
          h = o.map(e => e.footer ? e.sibling : e);
        if (n) {
          if (o.length > 1) return console.warn("AG Grid: cannot range select while selecting multiple rows"), 0;
          let e = null;
          if ("checkboxSelected" === l && !1 === i && this.lastRowNode && (this.lastRowNode.id ? e = this.lastRowNode : this.lastRowNode = null), null == e && (e = this.getLastSelectedNode()), e) {
            const t = h[0];
            if (t !== e && this.isMultiselect()) return this.selectRange(t, e, i, l)
          }
        }
        this.lastRowNode = i ? null : h[0];
        let u = 0;
        for (let e = 0; e < h.length; e++) {
          const r = h[e];
          if (!(c && r.group)) {
            r.selectThisNode(i, a, l) && u++
          }
          this.groupSelectsChildren && (null == (t = r.childrenAfterGroup) ? void 0 : t.length) && (u += this.selectChildren(r, i, c, l))
        }
        if (!s) {
          if (i && (r || !this.isMultiselect()) && (u += this.clearOtherNodes(h[0], l)), u > 0) {
            this.updateGroupsFromChildrenSelections(l);
            const e = {
              type: Et.EVENT_SELECTION_CHANGED,
              source: l
            };
            this.eventService.dispatchEvent(e)
          }
        }
        return u
      }
      selectRange(e, t, i = !0, r) {
        const s = this.rowModel.getNodesInRangeForSelection(e, t);
        let n = 0;
        s.forEach(e => {
          if (e.group && this.groupSelectsChildren) return;
          e.selectThisNode(i, void 0, r) && n++
        }), this.updateGroupsFromChildrenSelections(r);
        const o = {
          type: Et.EVENT_SELECTION_CHANGED,
          source: r
        };
        return this.eventService.dispatchEvent(o), n
      }
      selectChildren(e, t, i, r) {
        const s = i ? e.childrenAfterAggFilter : e.childrenAfterGroup;
        return N(s) ? 0 : this.setNodesSelected({
          newValue: t,
          clearSelection: !1,
          suppressFinishActions: !0,
          groupSelectsFiltered: i,
          source: r,
          nodes: s
        })
      }
      getLastSelectedNode() {
        const e = Array.from(this.selectedNodes.keys());
        if (0 == e.length) return null;
        const t = this.selectedNodes.get(Me(e));
        return t || null
      }
      getSelectedNodes() {
        const e = [];
        return this.selectedNodes.forEach(t => {
          t && e.push(t)
        }), e
      }
      getSelectedRows() {
        const e = [];
        return this.selectedNodes.forEach(t => {
          t && t.data && e.push(t.data)
        }), e
      }
      getSelectionCount() {
        return this.selectedNodes.size
      }
      filterFromSelection(e) {
        const t = new Map;
        this.selectedNodes.forEach((i, r) => {
          i && e(i) && t.set(r, i)
        }), this.selectedNodes = t
      }
      updateGroupsFromChildrenSelections(e, t) {
        if (!this.groupSelectsChildren) return !1;
        if ("clientSide" !== this.rowModel.getType()) return !1;
        const i = this.rowModel.getRootNode();
        t || (t = new yl(!0, i)).setInactive();
        let r = !1;
        return t.forEachChangedNodeDepthFirst(t => {
          if (t !== i) {
            const i = t.calculateSelectedFromChildren();
            r = t.selectThisNode(null !== i && i, void 0, e) || r
          }
        }), r
      }
      clearOtherNodes(e, t) {
        const i = new Map;
        let r = 0;
        return this.selectedNodes.forEach(s => {
          if (s && s.id !== e.id) {
            const e = this.selectedNodes.get(s.id);
            r += e.setSelectedParams({
              newValue: !1,
              clearSelection: !1,
              suppressFinishActions: !0,
              source: t
            }), this.groupSelectsChildren && s.parent && i.set(s.parent.id, s.parent)
          }
        }), i.forEach(e => {
          const i = e.calculateSelectedFromChildren();
          e.selectThisNode(null !== i && i, void 0, t)
        }), r
      }
      onRowSelected(e) {
        const t = e.node;
        this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id))
      }
      syncInRowNode(e, t) {
        this.syncInOldRowNode(e, t), this.syncInNewRowNode(e)
      }
      syncInOldRowNode(e, t) {
        if (v(t) && e.id !== t.id && t) {
          const i = t.id;
          this.selectedNodes.get(i) == e && this.selectedNodes.set(t.id, t)
        }
      }
      syncInNewRowNode(e) {
        this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(!1)
      }
      reset(e) {
        const t = this.getSelectionCount();
        if (this.resetNodes(), t) {
          const t = {
            type: Et.EVENT_SELECTION_CHANGED,
            source: e
          };
          this.eventService.dispatchEvent(t)
        }
      }
      resetNodes() {
        var e;
        null == (e = this.selectedNodes) || e.clear()
      }
      getBestCostNodeSelection() {
        if ("clientSide" !== this.rowModel.getType()) return;
        const e = this.rowModel.getTopLevelNodes();
        if (null === e) return;
        const t = [];
        return function e(i) {
          for (let r = 0, s = i.length; r < s; r++) {
            const s = i[r];
            if (s.isSelected()) t.push(s);
            else {
              const t = s;
              t.group && t.children && e(t.children)
            }
          }
        }(e), t
      }
      isEmpty() {
        let e = 0;
        return this.selectedNodes.forEach(t => {
          t && e++
        }), 0 === e
      }
      deselectAllRowNodes(e) {
        const t = e => e.selectThisNode(!1, void 0, r),
          i = "clientSide" === this.rowModel.getType(),
          {
            source: r,
            justFiltered: s,
            justCurrentPage: n
          } = e;
        if (n || s) {
          if (!i) return void console.error("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
          this.getNodesToSelect(s, n).forEach(t)
        } else this.selectedNodes.forEach(e => {
          e && t(e)
        }), this.reset(r);
        i && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(r);
        const o = {
          type: Et.EVENT_SELECTION_CHANGED,
          source: r
        };
        this.eventService.dispatchEvent(o)
      }
      getSelectedCounts(e, t) {
        let i = 0,
          r = 0;
        return this.getNodesToSelect(e, t).forEach(e => {
          this.groupSelectsChildren && e.group || (e.isSelected() ? i++ : e.selectable && r++)
        }), {
          selectedCount: i,
          notSelectedCount: r
        }
      }
      getSelectAllState(e, t) {
        const {
          selectedCount: i,
          notSelectedCount: r
        } = this.getSelectedCounts(e, t);
        return (0 !== i || 0 !== r) && (i > 0 && r > 0 ? null : i > 0)
      }
      hasNodesToSelect(e = !1, t = !1) {
        return this.getNodesToSelect(e, t).filter(e => e.selectable).length > 0
      }
      getNodesToSelect(e = !1, t = !1) {
        if ("clientSide" !== this.rowModel.getType()) throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
        const i = [];
        if (t) return this.paginationProxy.forEachNodeOnPage(e => {
          if (e.group) {
            if (!e.expanded) {
              const t = e => {
                var r;
                i.push(e), (null == (r = e.childrenAfterFilter) ? void 0 : r.length) && e.childrenAfterFilter.forEach(t)
              };
              return void t(e)
            }
            this.groupSelectsChildren || i.push(e)
          } else i.push(e)
        }), i;
        const r = this.rowModel;
        return e ? (r.forEachNodeAfterFilter(e => {
          i.push(e)
        }), i) : (r.forEachNode(e => {
          i.push(e)
        }), i)
      }
      selectAllRowNodes(e) {
        if ("clientSide" !== this.rowModel.getType()) throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
        const {
          source: t,
          justFiltered: i,
          justCurrentPage: r
        } = e;
        this.getNodesToSelect(i, r).forEach(e => e.selectThisNode(!0, void 0, t)), "clientSide" === this.rowModel.getType() && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t);
        const s = {
          type: Et.EVENT_SELECTION_CHANGED,
          source: t
        };
        this.eventService.dispatchEvent(s)
      }
      getSelectionState() {
        const e = [];
        return this.selectedNodes.forEach(t => {
          (null == t ? void 0 : t.id) && e.push(t.id)
        }), e.length ? e : null
      }
      setSelectionState(e, t) {
        if (!Array.isArray(e)) return;
        const i = new Set(e),
          r = [];
        this.rowModel.forEachNode(e => {
          i.has(e.id) && r.push(e)
        }), this.setNodesSelected({
          newValue: !0,
          nodes: r,
          source: t
        })
      }
    };
    C([fe("rowModel")], fc.prototype, "rowModel", 2), C([fe("paginationProxy")], fc.prototype, "paginationProxy", 2), C([pe], fc.prototype, "init", 1), fc = C([ge("selectionService")], fc);
    var Tc = class {
      constructor(e) {
        this.viaApi = (e, ...t) => (z(`Since v31, 'columnApi.${e}' is deprecated and moved to 'api.${e}'.`), this.api[e](...t)), this.api = e
      }
      sizeColumnsToFit(e) {
        this.viaApi("sizeColumnsToFit", e)
      }
      setColumnGroupOpened(e, t) {
        this.viaApi("setColumnGroupOpened", e, t)
      }
      getColumnGroup(e, t) {
        return this.viaApi("getColumnGroup", e, t)
      }
      getProvidedColumnGroup(e) {
        return this.viaApi("getProvidedColumnGroup", e)
      }
      getDisplayNameForColumn(e, t) {
        return this.viaApi("getDisplayNameForColumn", e, t)
      }
      getDisplayNameForColumnGroup(e, t) {
        return this.viaApi("getDisplayNameForColumnGroup", e, t)
      }
      getColumn(e) {
        return this.viaApi("getColumn", e)
      }
      getColumns() {
        return this.viaApi("getColumns")
      }
      applyColumnState(e) {
        return this.viaApi("applyColumnState", e)
      }
      getColumnState() {
        return this.viaApi("getColumnState")
      }
      resetColumnState() {
        this.viaApi("resetColumnState")
      }
      getColumnGroupState() {
        return this.viaApi("getColumnGroupState")
      }
      setColumnGroupState(e) {
        this.viaApi("setColumnGroupState", e)
      }
      resetColumnGroupState() {
        this.viaApi("resetColumnGroupState")
      }
      isPinning() {
        return this.viaApi("isPinning")
      }
      isPinningLeft() {
        return this.viaApi("isPinningLeft")
      }
      isPinningRight() {
        return this.viaApi("isPinningRight")
      }
      getDisplayedColAfter(e) {
        return this.viaApi("getDisplayedColAfter", e)
      }
      getDisplayedColBefore(e) {
        return this.viaApi("getDisplayedColBefore", e)
      }
      setColumnVisible(e, t) {
        this.viaApi("setColumnVisible", e, t)
      }
      setColumnsVisible(e, t) {
        this.viaApi("setColumnsVisible", e, t)
      }
      setColumnPinned(e, t) {
        this.viaApi("setColumnPinned", e, t)
      }
      setColumnsPinned(e, t) {
        this.viaApi("setColumnsPinned", e, t)
      }
      getAllGridColumns() {
        return this.viaApi("getAllGridColumns")
      }
      getDisplayedLeftColumns() {
        return this.viaApi("getDisplayedLeftColumns")
      }
      getDisplayedCenterColumns() {
        return this.viaApi("getDisplayedCenterColumns")
      }
      getDisplayedRightColumns() {
        return this.viaApi("getDisplayedRightColumns")
      }
      getAllDisplayedColumns() {
        return this.viaApi("getAllDisplayedColumns")
      }
      getAllDisplayedVirtualColumns() {
        return this.viaApi("getAllDisplayedVirtualColumns")
      }
      moveColumn(e, t) {
        this.viaApi("moveColumn", e, t)
      }
      moveColumnByIndex(e, t) {
        this.viaApi("moveColumnByIndex", e, t)
      }
      moveColumns(e, t) {
        this.viaApi("moveColumns", e, t)
      }
      moveRowGroupColumn(e, t) {
        this.viaApi("moveRowGroupColumn", e, t)
      }
      setColumnAggFunc(e, t) {
        this.viaApi("setColumnAggFunc", e, t)
      }
      setColumnWidth(e, t, i = !0, r) {
        this.viaApi("setColumnWidth", e, t, i, r)
      }
      setColumnWidths(e, t = !0, i) {
        this.viaApi("setColumnWidths", e, t, i)
      }
      setPivotMode(e) {
        this.viaApi("setPivotMode", e)
      }
      isPivotMode() {
        return this.viaApi("isPivotMode")
      }
      getPivotResultColumn(e, t) {
        return this.viaApi("getPivotResultColumn", e, t)
      }
      setValueColumns(e) {
        this.viaApi("setValueColumns", e)
      }
      getValueColumns() {
        return this.viaApi("getValueColumns")
      }
      removeValueColumn(e) {
        this.viaApi("removeValueColumn", e)
      }
      removeValueColumns(e) {
        this.viaApi("removeValueColumns", e)
      }
      addValueColumn(e) {
        this.viaApi("addValueColumn", e)
      }
      addValueColumns(e) {
        this.viaApi("addValueColumns", e)
      }
      setRowGroupColumns(e) {
        this.viaApi("setRowGroupColumns", e)
      }
      removeRowGroupColumn(e) {
        this.viaApi("removeRowGroupColumn", e)
      }
      removeRowGroupColumns(e) {
        this.viaApi("removeRowGroupColumns", e)
      }
      addRowGroupColumn(e) {
        this.viaApi("addRowGroupColumn", e)
      }
      addRowGroupColumns(e) {
        this.viaApi("addRowGroupColumns", e)
      }
      getRowGroupColumns() {
        return this.viaApi("getRowGroupColumns")
      }
      setPivotColumns(e) {
        this.viaApi("setPivotColumns", e)
      }
      removePivotColumn(e) {
        this.viaApi("removePivotColumn", e)
      }
      removePivotColumns(e) {
        this.viaApi("removePivotColumns", e)
      }
      addPivotColumn(e) {
        this.viaApi("addPivotColumn", e)
      }
      addPivotColumns(e) {
        this.viaApi("addPivotColumns", e)
      }
      getPivotColumns() {
        return this.viaApi("getPivotColumns")
      }
      getLeftDisplayedColumnGroups() {
        return this.viaApi("getLeftDisplayedColumnGroups")
      }
      getCenterDisplayedColumnGroups() {
        return this.viaApi("getCenterDisplayedColumnGroups")
      }
      getRightDisplayedColumnGroups() {
        return this.viaApi("getRightDisplayedColumnGroups")
      }
      getAllDisplayedColumnGroups() {
        return this.viaApi("getAllDisplayedColumnGroups")
      }
      autoSizeColumn(e, t) {
        return this.viaApi("autoSizeColumn", e, t)
      }
      autoSizeColumns(e, t) {
        this.viaApi("autoSizeColumns", e, t)
      }
      autoSizeAllColumns(e) {
        this.viaApi("autoSizeAllColumns", e)
      }
      setPivotResultColumns(e) {
        this.viaApi("setPivotResultColumns", e)
      }
      getPivotResultColumns() {
        return this.viaApi("getPivotResultColumns")
      }
    };
    C([fe("gridApi")], Tc.prototype, "api", 2), Tc = C([ge("columnApi")], Tc);
    var mc = class extends ct {
      constructor() {
        super(...arguments), this.initialised = !1, this.isSsrm = !1
      }
      init() {
        this.isSsrm = this.gos.isRowModelType("serverSide"), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
        const e = e => this.callColumnCellValueChangedHandler(e),
          t = this.gos.useAsyncEvents();
        this.eventService.addEventListener(Et.EVENT_CELL_VALUE_CHANGED, e, t), this.addDestroyFunc(() => this.eventService.removeEventListener(Et.EVENT_CELL_VALUE_CHANGED, e, t)), this.addManagedPropertyListener("treeData", e => this.isTreeData = e.currentValue)
      }
      getValue(e, t, i = !1, r = !1) {
        if (this.initialised || this.init(), !t) return;
        const s = e.getColDef(),
          n = s.field,
          o = e.getColId(),
          a = t.data;
        let l;
        const c = t.groupData && void 0 !== t.groupData[o],
          h = !r && t.aggData && void 0 !== t.aggData[o],
          u = this.isSsrm && r && !!e.getColDef().aggFunc,
          d = this.isSsrm && t.footer && t.field && (!0 === e.getColDef().showRowGroup || e.getColDef().showRowGroup === t.field);
        if (i && s.filterValueGetter ? l = this.executeFilterValueGetter(s.filterValueGetter, a, e, t) : this.isTreeData && h ? l = t.aggData[o] : this.isTreeData && s.valueGetter ? l = this.executeValueGetter(s.valueGetter, a, e, t) : this.isTreeData && n && a ? l = B(a, n, e.isFieldContainsDots()) : c ? l = t.groupData[o] : h ? l = t.aggData[o] : s.valueGetter ? l = this.executeValueGetter(s.valueGetter, a, e, t) : d ? l = B(a, t.field, e.isFieldContainsDots()) : n && a && !u && (l = B(a, n, e.isFieldContainsDots())), this.cellExpressions && "string" == typeof l && 0 === l.indexOf("=")) {
          const i = l.substring(1);
          l = this.executeValueGetter(i, a, e, t)
        }
        if (null == l) {
          const i = this.getOpenedGroup(t, e);
          if (null != i) return i
        }
        return l
      }
      parseValue(e, t, i, r) {
        const s = e.getColDef(),
          n = this.gos.addGridCommonParams({
            node: t,
            data: null == t ? void 0 : t.data,
            oldValue: r,
            newValue: i,
            colDef: s,
            column: e
          }),
          o = s.valueParser;
        return v(o) ? "function" == typeof o ? o(n) : this.expressionService.evaluate(o, n) : i
      }
      formatValue(e, t, i, r, s = !0) {
        let n, o = null;
        const a = e.getColDef();
        if (r ? n = r : s && (n = a.valueFormatter), n) {
          const r = this.gos.addGridCommonParams({
            value: i,
            node: t,
            data: t ? t.data : null,
            colDef: a,
            column: e
          });
          o = "function" == typeof n ? n(r) : this.expressionService.evaluate(n, r)
        } else if (a.refData) return a.refData[i] || "";
        return null == o && Array.isArray(i) && (o = i.join(", ")), o
      }
      getOpenedGroup(e, t) {
        if (!this.gos.get("showOpenedGroup")) return;
        if (!t.getColDef().showRowGroup) return;
        const i = t.getColDef().showRowGroup;
        let r = e.parent;
        for (; null != r;) {
          if (r.rowGroupColumn && (!0 === i || i === r.rowGroupColumn.getColId())) return r.key;
          r = r.parent
        }
      }
      setValue(e, t, i, r) {
        const s = this.columnModel.getPrimaryColumn(t);
        if (!e || !s) return !1;
        N(e.data) && (e.data = {});
        const {
          field: n,
          valueSetter: o
        } = s.getColDef();
        if (N(n) && N(o)) return console.warn("AG Grid: you need either field or valueSetter set on colDef for editing to work"), !1;
        if (!this.dataTypeService.checkType(s, i)) return console.warn("AG Grid: Data type of the new value does not match the cell data type of the column"), !1;
        const a = this.gos.addGridCommonParams({
          node: e,
          data: e.data,
          oldValue: this.getValue(s, e),
          newValue: i,
          colDef: s.getColDef(),
          column: s
        });
        let l;
        if (a.newValue = i, l = v(o) ? "function" == typeof o ? o(a) : this.expressionService.evaluate(o, a) : this.setValueUsingField(e.data, n, i, s.isFieldContainsDots()), void 0 === l && (l = !0), !l) return !1;
        e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), a.newValue = this.getValue(s, e);
        const c = {
          type: Et.EVENT_CELL_VALUE_CHANGED,
          event: null,
          rowIndex: e.rowIndex,
          rowPinned: e.rowPinned,
          column: a.column,
          api: a.api,
          columnApi: a.columnApi,
          colDef: a.colDef,
          context: a.context,
          data: e.data,
          node: e,
          oldValue: a.oldValue,
          newValue: a.newValue,
          value: a.newValue,
          source: r
        };
        return this.eventService.dispatchEvent(c), !0
      }
      callColumnCellValueChangedHandler(e) {
        const t = e.colDef.onCellValueChanged;
        "function" == typeof t && this.getFrameworkOverrides().wrapOutgoing(() => {
          t({
            node: e.node,
            data: e.data,
            oldValue: e.oldValue,
            newValue: e.newValue,
            colDef: e.colDef,
            column: e.column,
            api: e.api,
            columnApi: e.columnApi,
            context: e.context
          })
        })
      }
      setValueUsingField(e, t, i, r) {
        if (!t) return !1;
        let s = !1;
        if (r) {
          const r = t.split(".");
          let n = e;
          for (; r.length > 0 && n;) {
            const e = r.shift();
            0 === r.length ? (s = n[e] === i, s || (n[e] = i)) : n = n[e]
          }
        } else s = e[t] === i, s || (e[t] = i);
        return !s
      }
      executeFilterValueGetter(e, t, i, r) {
        const s = this.gos.addGridCommonParams({
          data: t,
          node: r,
          column: i,
          colDef: i.getColDef(),
          getValue: this.getValueCallback.bind(this, r)
        });
        return "function" == typeof e ? e(s) : this.expressionService.evaluate(e, s)
      }
      executeValueGetter(e, t, i, r) {
        const s = i.getColId(),
          n = this.valueCache.getValue(r, s);
        if (void 0 !== n) return n;
        const o = this.gos.addGridCommonParams({
          data: t,
          node: r,
          column: i,
          colDef: i.getColDef(),
          getValue: this.getValueCallback.bind(this, r)
        });
        let a;
        return a = "function" == typeof e ? e(o) : this.expressionService.evaluate(e, o), this.valueCache.setValue(r, s, a), a
      }
      getValueCallback(e, t) {
        const i = this.columnModel.getPrimaryColumn(t);
        return i ? this.getValue(i, e) : null
      }
      getKeyForNode(e, t) {
        const i = this.getValue(e, t),
          r = e.getColDef().keyCreator;
        let s = i;
        if (r) {
          s = r(this.gos.addGridCommonParams({
            value: i,
            colDef: e.getColDef(),
            column: e,
            node: t,
            data: t.data
          }))
        }
        return "string" == typeof s || null == s || (s = String(s), "[object Object]" === s && z("a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key")), s
      }
    };
    C([fe("expressionService")], mc.prototype, "expressionService", 2), C([fe("columnModel")], mc.prototype, "columnModel", 2), C([fe("valueCache")], mc.prototype, "valueCache", 2), C([fe("dataTypeService")], mc.prototype, "dataTypeService", 2), C([pe], mc.prototype, "init", 1), mc = C([ge("valueService")], mc);
    var Cc = class extends ct {
      constructor() {
        super(...arguments), this.expressionToFunctionCache = {}
      }
      setBeans(e) {
        this.logger = e.create("ExpressionService")
      }
      evaluate(e, t) {
        if ("string" == typeof e) return this.evaluateExpression(e, t);
        console.error("AG Grid: value should be either a string or a function", e)
      }
      evaluateExpression(e, t) {
        try {
          const i = this.createExpressionFunction(e);
          return i(t.value, t.context, t.oldValue, t.newValue, t.value, t.node, t.data, t.colDef, t.rowIndex, t.api, t.columnApi, t.getValue, t.column, t.columnGroup)
        } catch (i) {
          return console.log("Processing of the expression failed"), console.log("Expression = " + e), console.log("Params =", t), console.log("Exception = " + i), null
        }
      }
      createExpressionFunction(e) {
        if (this.expressionToFunctionCache[e]) return this.expressionToFunctionCache[e];
        const t = this.createFunctionBody(e),
          i = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", t);
        return this.expressionToFunctionCache[e] = i, i
      }
      createFunctionBody(e) {
        return e.indexOf("return") >= 0 ? e : "return " + e + ";"
      }
    };
    C([S(0, Ce("loggerFactory"))], Cc.prototype, "setBeans", 1), Cc = C([ge("expressionService")], Cc);
    var Sc = class extends ct {
      setBeans(e) {
        this.logging = e.get("debug")
      }
      create(e) {
        return new Rc(e, this.isLogging.bind(this))
      }
      isLogging() {
        return this.logging
      }
    };
    C([S(0, Ce("gridOptionsService"))], Sc.prototype, "setBeans", 1), Sc = C([ge("loggerFactory")], Sc);
    var Rc = class {
        constructor(e, t) {
          this.name = e, this.isLoggingFunc = t
        }
        isLogging() {
          return this.isLoggingFunc()
        }
        log(e) {
          this.isLoggingFunc() && console.log("AG Grid." + this.name + ": " + e)
        }
      },
      Ac = class extends ct {
        setComp(e, t, i) {
          this.view = e, this.eGridHostDiv = t, this.eGui = i, this.eGui.setAttribute("grid-id", this.context.getGridId()), this.dragAndDropService.addDropTarget({
            getContainer: () => this.eGui,
            isInterestedIn: e => 1 === e || 0 === e,
            getIconName: () => Kn.ICON_NOT_ALLOWED
          }), this.mouseEventService.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new ea(this.view)), this.addRtlSupport();
          const r = this.resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
          this.addDestroyFunc(() => r()), this.ctrlsService.register("gridCtrl", this)
        }
        isDetailGrid() {
          var e;
          const t = this.focusService.findTabbableParent(this.getGui());
          return (null == (e = null == t ? void 0 : t.getAttribute("row-id")) ? void 0 : e.startsWith("detail")) || !1
        }
        showDropZones() {
          return he.__isRegistered("@ag-grid-enterprise/row-grouping", this.context.getGridId())
        }
        showSideBar() {
          return he.__isRegistered("@ag-grid-enterprise/side-bar", this.context.getGridId())
        }
        showStatusBar() {
          return he.__isRegistered("@ag-grid-enterprise/status-bar", this.context.getGridId())
        }
        showWatermark() {
          return he.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId())
        }
        onGridSizeChanged() {
          const e = {
            type: Et.EVENT_GRID_SIZE_CHANGED,
            clientWidth: this.eGridHostDiv.clientWidth,
            clientHeight: this.eGridHostDiv.clientHeight
          };
          this.eventService.dispatchEvent(e)
        }
        addRtlSupport() {
          const e = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
          this.view.setRtlClass(e)
        }
        destroyGridUi() {
          this.view.destroyGridUi()
        }
        getGui() {
          return this.eGui
        }
        setResizeCursor(e) {
          this.view.setCursor(e ? "ew-resize" : null)
        }
        disableUserSelect(e) {
          this.view.setUserSelect(e ? "none" : null)
        }
        focusNextInnerContainer(e) {
          const t = this.view.getFocusableContainers(),
            i = this.gos.getActiveDomElement(),
            r = t.findIndex(e => e.contains(i)) + (e ? -1 : 1);
          return !(r <= 0 || r >= t.length) && this.focusService.focusInto(t[r])
        }
        focusInnerElement(e) {
          const t = this.view.getFocusableContainers(),
            i = this.columnModel.getAllDisplayedColumns();
          if (e) {
            if (t.length > 1) return this.focusService.focusInto(Me(t), !0);
            const e = Me(i);
            if (this.focusService.focusGridView(e, !0)) return !0
          }
          if (0 === this.gos.get("headerHeight") || this.gos.get("suppressHeaderFocus")) {
            if (this.focusService.focusGridView(i[0])) return !0;
            for (let e = 1; e < t.length; e++)
              if (this.focusService.focusInto(t[e])) return !0;
            return !1
          }
          return this.focusService.focusFirstHeader()
        }
        forceFocusOutOfContainer(e = !1) {
          this.view.forceFocusOutOfContainer(e)
        }
      };
    C([fe("focusService")], Ac.prototype, "focusService", 2), C([fe("resizeObserverService")], Ac.prototype, "resizeObserverService", 2), C([fe("columnModel")], Ac.prototype, "columnModel", 2), C([fe("ctrlsService")], Ac.prototype, "ctrlsService", 2), C([fe("mouseEventService")], Ac.prototype, "mouseEventService", 2), C([fe("dragAndDropService")], Ac.prototype, "dragAndDropService", 2);
    var vc = class extends ml {
      constructor(e) {
        super(), this.eGridDiv = e
      }
      postConstruct() {
        this.logger = this.loggerFactory.create("GridComp");
        const e = {
          destroyGridUi: () => this.destroyBean(this),
          setRtlClass: e => this.addCssClass(e),
          forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
          updateLayoutClasses: this.updateLayoutClasses.bind(this),
          getFocusableContainers: this.getFocusableContainers.bind(this),
          setUserSelect: e => {
            this.getGui().style.userSelect = null != e ? e : "", this.getGui().style.webkitUserSelect = null != e ? e : ""
          },
          setCursor: e => {
            this.getGui().style.cursor = null != e ? e : ""
          }
        };
        this.ctrl = this.createManagedBean(new Ac);
        const t = this.createTemplate();
        this.setTemplate(t), this.ctrl.setComp(e, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
          onTabKeyDown: () => {},
          focusInnerElement: e => this.ctrl.focusInnerElement(e),
          forceFocusOutWhenTabGuardsAreEmpty: !0
        })
      }
      insertGridIntoDom() {
        const e = this.getGui();
        this.eGridDiv.appendChild(e), this.addDestroyFunc(() => {
          this.eGridDiv.removeChild(e), this.logger.log("Grid removed from DOM")
        })
      }
      updateLayoutClasses(e, t) {
        const i = this.eRootWrapperBody.classList;
        i.toggle("ag-layout-auto-height", t.autoHeight), i.toggle("ag-layout-normal", t.normal), i.toggle("ag-layout-print", t.print), this.addOrRemoveCssClass("ag-layout-auto-height", t.autoHeight), this.addOrRemoveCssClass("ag-layout-normal", t.normal), this.addOrRemoveCssClass("ag-layout-print", t.print)
      }
      createTemplate() {
        return `<div class="ag-root-wrapper" role="presentation">\n                ${this.ctrl.showDropZones()?"<ag-grid-header-drop-zones></ag-grid-header-drop-zones>":""}\n                <div class="ag-root-wrapper-body" ref="rootWrapperBody" role="presentation">\n                    <ag-grid-body ref="gridBody"></ag-grid-body>\n                    ${this.ctrl.showSideBar()?'<ag-side-bar ref="sideBar"></ag-side-bar>':""}\n                </div>\n                ${this.ctrl.showStatusBar()?'<ag-status-bar ref="statusBar"></ag-status-bar>':""}\n                <ag-pagination></ag-pagination>\n                ${this.ctrl.showWatermark()?"<ag-watermark></ag-watermark>":""}\n            </div>`
      }
      getFocusableElement() {
        return this.eRootWrapperBody
      }
      getFocusableContainers() {
        const e = [this.gridBodyComp.getGui()];
        return this.sideBarComp && e.push(this.sideBarComp.getGui()), e.filter(e => Lr(e))
      }
    };
    C([fe("loggerFactory")], vc.prototype, "loggerFactory", 2), C([ys("gridBody")], vc.prototype, "gridBodyComp", 2), C([ys("sideBar")], vc.prototype, "sideBarComp", 2), C([ys("rootWrapperBody")], vc.prototype, "eRootWrapperBody", 2), C([pe], vc.prototype, "postConstruct", 1);
    var Nc = class extends ct {
      progressSort(e, t, i) {
        const r = this.getNextSortDirection(e);
        this.setSortForColumn(e, r, t, i)
      }
      setSortForColumn(e, t, i, r) {
        "asc" !== t && "desc" !== t && (t = null);
        let s = [e];
        if (this.gos.isColumnsSortingCoupledToGroup() && e.getColDef().showRowGroup) {
          const t = this.columnModel.getSourceColumnsForGroupColumn(e),
            i = null == t ? void 0 : t.filter(e => e.isSortable());
          i && (s = [e, ...i])
        }
        s.forEach(e => e.setSort(t, r));
        const n = [];
        if (!((i || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"))) {
          const e = this.clearSortBarTheseColumns(s, r);
          n.push(...e)
        }
        this.updateSortIndex(e), n.push(...s), this.dispatchSortChangedEvents(r, n)
      }
      updateSortIndex(e) {
        const t = this.gos.isColumnsSortingCoupledToGroup(),
          i = this.columnModel.getGroupDisplayColumnForGroup(e.getId()),
          r = t && i || e,
          s = this.getColumnsWithSortingOrdered();
        this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach(e => e.setSortIndex(null));
        const n = s.filter(e => (!t || !e.getColDef().showRowGroup) && e !== r);
        (r.getSort() ? [...n, r] : n).forEach((e, t) => {
          e.setSortIndex(t)
        })
      }
      onSortChanged(e, t) {
        this.dispatchSortChangedEvents(e, t)
      }
      isSortActive() {
        const e = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter(e => !!e.getSort());
        return e && e.length > 0
      }
      dispatchSortChangedEvents(e, t) {
        const i = {
          type: Et.EVENT_SORT_CHANGED,
          source: e
        };
        t && (i.columns = t), this.eventService.dispatchEvent(i)
      }
      clearSortBarTheseColumns(e, t) {
        const i = [];
        return this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach(r => {
          e.includes(r) || (r.getSort() && i.push(r), r.setSort(void 0, t))
        }), i
      }
      getNextSortDirection(e) {
        let t;
        if (t = e.getColDef().sortingOrder ? e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? this.gos.get("sortingOrder") : Nc.DEFAULT_SORTING_ORDER, !Array.isArray(t) || t.length <= 0) return console.warn(`AG Grid: sortingOrder must be an array with at least one element, currently it's ${t}`), null;
        const i = t.indexOf(e.getSort()),
          r = i < 0,
          s = i == t.length - 1;
        let n;
        return n = r || s ? t[0] : t[i + 1], Nc.DEFAULT_SORTING_ORDER.indexOf(n) < 0 ? (console.warn("AG Grid: invalid sort type " + n), null) : n
      }
      getIndexedSortMap() {
        let e = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter(e => !!e.getSort());
        if (this.columnModel.isPivotMode()) {
          const t = this.gos.isColumnsSortingCoupledToGroup();
          e = e.filter(e => {
            const i = !!e.getAggFunc(),
              r = !e.isPrimary(),
              s = t ? this.columnModel.getGroupDisplayColumnForGroup(e.getId()) : e.getColDef().showRowGroup;
            return i || r || s
          })
        }
        const t = this.columnModel.getRowGroupColumns().filter(e => !!e.getSort()),
          i = {};
        e.forEach((e, t) => i[e.getId()] = t), e.sort((e, t) => {
          const r = e.getSortIndex(),
            s = t.getSortIndex();
          if (null != r && null != s) return r - s;
          if (null == r && null == s) {
            return i[e.getId()] > i[t.getId()] ? 1 : -1
          }
          return null == s ? -1 : 1
        });
        const r = this.gos.isColumnsSortingCoupledToGroup() && !!t.length;
        r && (e = [...new Set(e.map(e => {
          var t;
          return null != (t = this.columnModel.getGroupDisplayColumnForGroup(e.getId())) ? t : e
        }))]);
        const s = new Map;
        return e.forEach((e, t) => s.set(e, t)), r && t.forEach(e => {
          const t = this.columnModel.getGroupDisplayColumnForGroup(e.getId());
          s.set(e, s.get(t))
        }), s
      }
      getColumnsWithSortingOrdered() {
        return [...this.getIndexedSortMap().entries()].sort(([e, t], [i, r]) => t - r).map(([e]) => e)
      }
      getSortModel() {
        return this.getColumnsWithSortingOrdered().filter(e => e.getSort()).map(e => ({
          sort: e.getSort(),
          colId: e.getId()
        }))
      }
      getSortOptions() {
        return this.getColumnsWithSortingOrdered().filter(e => e.getSort()).map(e => ({
          sort: e.getSort(),
          column: e
        }))
      }
      canColumnDisplayMixedSort(e) {
        const t = this.gos.isColumnsSortingCoupledToGroup(),
          i = !!e.getColDef().showRowGroup;
        return t && i
      }
      getDisplaySortForColumn(e) {
        const t = this.columnModel.getSourceColumnsForGroupColumn(e);
        if (!this.canColumnDisplayMixedSort(e) || !(null == t ? void 0 : t.length)) return e.getSort();
        const i = null != e.getColDef().field || !!e.getColDef().valueGetter ? [e, ...t] : t,
          r = i[0].getSort();
        return i.every(e => e.getSort() == r) ? r : "mixed"
      }
      getDisplaySortIndexForColumn(e) {
        return this.getIndexedSortMap().get(e)
      }
    };
    Nc.DEFAULT_SORTING_ORDER = ["asc", "desc", null], C([fe("columnModel")], Nc.prototype, "columnModel", 2), Nc = C([ge("sortController")], Nc);
    var Ic = class extends ct {
      static addKeyboardModeEvents(e) {
        this.instanceCount > 0 || (e.addEventListener("keydown", Ic.toggleKeyboardMode), e.addEventListener("mousedown", Ic.toggleKeyboardMode))
      }
      static removeKeyboardModeEvents(e) {
        this.instanceCount > 0 || (e.addEventListener("keydown", Ic.toggleKeyboardMode), e.addEventListener("mousedown", Ic.toggleKeyboardMode))
      }
      static toggleKeyboardMode(e) {
        const t = Ic.keyboardModeActive,
          i = "keydown" === e.type;
        i && (e.ctrlKey || e.metaKey || e.altKey) || t !== i && (Ic.keyboardModeActive = i)
      }
      static unregisterGridCompController(e) {
        Ic.removeKeyboardModeEvents(e)
      }
      init() {
        const e = this.clearFocusedCell.bind(this);
        this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_GROUP_OPENED, e), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady(e => {
          this.gridCtrl = e.gridCtrl
        })
      }
      registerKeyboardFocusEvents() {
        const e = this.gos.getDocument();
        Ic.addKeyboardModeEvents(e), Ic.instanceCount++, this.addDestroyFunc(() => {
          Ic.instanceCount--, Ic.unregisterGridCompController(e)
        })
      }
      onColumnEverythingChanged() {
        if (!this.focusedCellPosition) return;
        const e = this.focusedCellPosition.column,
          t = this.columnModel.getGridColumn(e.getId());
        e !== t && this.clearFocusedCell()
      }
      isKeyboardMode() {
        return Ic.keyboardModeActive
      }
      getFocusCellToUseAfterRefresh() {
        return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), ma.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition
      }
      getFocusHeaderToUseAfterRefresh() {
        return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), Ja.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition
      }
      isDomDataMissingInHierarchy(e, t) {
        let i = e;
        for (; i;) {
          if (this.gos.getDomData(i, t)) return !1;
          i = i.parentNode
        }
        return !0
      }
      getFocusedCell() {
        return this.focusedCellPosition
      }
      shouldRestoreFocus(e) {
        return !!this.isCellRestoreFocused(e) && (setTimeout(() => {
          this.restoredFocusedCellPosition = null
        }, 0), !0)
      }
      isCellRestoreFocused(e) {
        return null != this.restoredFocusedCellPosition && this.cellPositionUtils.equals(e, this.restoredFocusedCellPosition)
      }
      setRestoreFocusedCell(e) {
        "react" === this.getFrameworkOverrides().renderingEngine && (this.restoredFocusedCellPosition = e)
      }
      getFocusEventParams() {
        const {
          rowIndex: e,
          rowPinned: t,
          column: i
        } = this.focusedCellPosition, r = {
          rowIndex: e,
          rowPinned: t,
          column: i,
          isFullWidthCell: !1
        }, s = this.rowRenderer.getRowByPosition({
          rowIndex: e,
          rowPinned: t
        });
        return s && (r.isFullWidthCell = s.isFullWidth()), r
      }
      clearFocusedCell() {
        if (this.restoredFocusedCellPosition = null, null == this.focusedCellPosition) return;
        const e = f({
          type: Et.EVENT_CELL_FOCUS_CLEARED
        }, this.getFocusEventParams());
        this.focusedCellPosition = null, this.eventService.dispatchEvent(e)
      }
      setFocusedCell(e) {
        const {
          column: t,
          rowIndex: i,
          rowPinned: r,
          forceBrowserFocus: s = !1,
          preventScrollOnBrowserFocus: n = !1
        } = e, o = this.columnModel.getGridColumn(t);
        if (!o) return void(this.focusedCellPosition = null);
        this.focusedCellPosition = o ? {
          rowIndex: i,
          rowPinned: A(r),
          column: o
        } : null;
        const a = T(f({
          type: Et.EVENT_CELL_FOCUSED
        }, this.getFocusEventParams()), {
          forceBrowserFocus: s,
          preventScrollOnBrowserFocus: n,
          floating: null
        });
        this.eventService.dispatchEvent(a)
      }
      isCellFocused(e) {
        return null != this.focusedCellPosition && this.cellPositionUtils.equals(e, this.focusedCellPosition)
      }
      isRowNodeFocused(e) {
        return this.isRowFocused(e.rowIndex, e.rowPinned)
      }
      isHeaderWrapperFocused(e) {
        if (null == this.focusedHeaderPosition) return !1;
        const t = e.getColumnGroupChild(),
          i = e.getRowIndex(),
          r = e.getPinned(),
          {
            column: s,
            headerRowIndex: n
          } = this.focusedHeaderPosition;
        return t === s && i === n && r == s.getPinned()
      }
      clearFocusedHeader() {
        this.focusedHeaderPosition = null
      }
      getFocusedHeader() {
        return this.focusedHeaderPosition
      }
      setFocusedHeader(e, t) {
        this.focusedHeaderPosition = {
          headerRowIndex: e,
          column: t
        }
      }
      focusHeaderPosition(e) {
        if (this.gos.get("suppressHeaderFocus")) return !1;
        const {
          direction: t,
          fromTab: i,
          allowUserOverride: r,
          event: s,
          fromCell: n,
          rowWithoutSpanValue: o
        } = e;
        let {
          headerPosition: a
        } = e;
        if (n && this.filterManager.isAdvancedFilterHeaderActive()) return this.focusAdvancedFilter(a);
        if (r) {
          const e = this.getFocusedHeader(),
            r = this.headerNavigationService.getHeaderRowCount();
          if (i) {
            const i = this.gos.getCallback("tabToNextHeader");
            i && (a = this.getHeaderPositionFromUserFunc({
              userFunc: i,
              direction: t,
              currentPosition: e,
              headerPosition: a,
              headerRowCount: r
            }))
          } else {
            const t = this.gos.getCallback("navigateToNextHeader");
            if (t && s) {
              a = t({
                key: s.key,
                previousHeaderPosition: e,
                nextHeaderPosition: a,
                headerRowCount: r,
                event: s
              })
            }
          }
        }
        return !!a && this.focusProvidedHeaderPosition({
          headerPosition: a,
          direction: t,
          event: s,
          fromCell: n,
          rowWithoutSpanValue: o
        })
      }
      focusHeaderPositionFromUserFunc(e) {
        if (this.gos.get("suppressHeaderFocus")) return !1;
        const {
          userFunc: t,
          headerPosition: i,
          direction: r,
          event: s
        } = e, n = this.getFocusedHeader(), o = this.headerNavigationService.getHeaderRowCount(), a = this.getHeaderPositionFromUserFunc({
          userFunc: t,
          direction: r,
          currentPosition: n,
          headerPosition: i,
          headerRowCount: o
        });
        return !!a && this.focusProvidedHeaderPosition({
          headerPosition: a,
          direction: r,
          event: s
        })
      }
      getHeaderPositionFromUserFunc(e) {
        const {
          userFunc: t,
          direction: i,
          currentPosition: r,
          headerPosition: s,
          headerRowCount: n
        } = e, o = t({
          backwards: "Before" === i,
          previousHeaderPosition: r,
          nextHeaderPosition: s,
          headerRowCount: n
        });
        return !0 === o || null === o ? (null === o && z("Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."), r) : !1 === o ? null : o
      }
      focusProvidedHeaderPosition(e) {
        const {
          headerPosition: t,
          direction: i,
          fromCell: r,
          rowWithoutSpanValue: s,
          event: n
        } = e;
        if (-1 === t.headerRowIndex) return this.filterManager.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(t) : this.focusGridView(t.column);
        this.headerNavigationService.scrollToColumn(t.column, i);
        const o = this.ctrlsService.getHeaderRowContainerCtrl(t.column.getPinned()).focusHeader(t.headerRowIndex, t.column, n);
        return o && (null != s || r) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(null != s ? s : -1), o
      }
      focusFirstHeader() {
        let e = this.columnModel.getAllDisplayedColumns()[0];
        if (!e) return !1;
        e.getParent() && (e = this.columnModel.getColumnGroupAtLevel(e, 0));
        const t = this.headerPositionUtils.getHeaderIndexToFocus(e, 0);
        return this.focusHeaderPosition({
          headerPosition: t,
          rowWithoutSpanValue: 0
        })
      }
      focusLastHeader(e) {
        const t = this.headerNavigationService.getHeaderRowCount() - 1,
          i = Me(this.columnModel.getAllDisplayedColumns());
        return this.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: t,
            column: i
          },
          rowWithoutSpanValue: -1,
          event: e
        })
      }
      focusPreviousFromFirstCell(e) {
        return this.filterManager.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(e)
      }
      isAnyCellFocused() {
        return !!this.focusedCellPosition
      }
      isRowFocused(e, t) {
        return null != this.focusedCellPosition && (this.focusedCellPosition.rowIndex === e && this.focusedCellPosition.rowPinned === A(t))
      }
      findFocusableElements(e, t, i = !1) {
        const r = lr;
        let s = cr;
        t && (s += ", " + t), i && (s += ', [tabindex="-1"]');
        const n = Array.prototype.slice.apply(e.querySelectorAll(r)).filter(e => Lr(e)),
          o = Array.prototype.slice.apply(e.querySelectorAll(s));
        if (!o.length) return n;
        return a = o, n.filter(e => -1 === a.indexOf(e));
        var a
      }
      focusInto(e, t = !1, i = !1) {
        const r = this.findFocusableElements(e, null, i),
          s = t ? Me(r) : r[0];
        return !!s && (s.focus({
          preventScroll: !0
        }), !0)
      }
      findFocusableElementBeforeTabGuard(e, t) {
        if (!t) return null;
        const i = this.findFocusableElements(e),
          r = i.indexOf(t);
        if (-1 === r) return null;
        let s = -1;
        for (let e = r - 1; e >= 0; e--)
          if (i[e].classList.contains("ag-tab-guard-top")) {
            s = e;
            break
          } return s <= 0 ? null : i[s - 1]
      }
      findNextFocusableElement(e = this.eGridDiv, t, i) {
        const r = this.findFocusableElements(e, t ? ':not([tabindex="-1"])' : null),
          s = this.gos.getActiveDomElement();
        let n;
        n = t ? r.findIndex(e => e.contains(s)) : r.indexOf(s);
        const o = n + (i ? -1 : 1);
        return o < 0 || o >= r.length ? null : r[o]
      }
      isTargetUnderManagedComponent(e, t) {
        if (!t) return !1;
        const i = e.querySelectorAll(`.${xs.FOCUS_MANAGED_CLASS}`);
        if (!i.length) return !1;
        for (let e = 0; e < i.length; e++)
          if (i[e].contains(t)) return !0;
        return !1
      }
      findTabbableParent(e, t = 5) {
        let i = 0;
        for (; e && null === Hi(e) && ++i <= t;) e = e.parentElement;
        return null === Hi(e) ? null : e
      }
      focusGridView(e, t) {
        var i;
        if (this.gos.get("suppressCellFocus")) return t ? this.gos.get("suppressHeaderFocus") ? this.focusNextGridCoreContainer(!0, !0) : this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
        const r = t ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
        if (!r) return !1;
        const {
          rowIndex: s,
          rowPinned: n
        } = r, o = this.getFocusedHeader();
        return !e && o && (e = o.column), !(null == s || !e) && (this.navigationService.ensureCellVisible({
          rowIndex: s,
          column: e,
          rowPinned: n
        }), this.setFocusedCell({
          rowIndex: s,
          column: e,
          rowPinned: A(n),
          forceBrowserFocus: !0
        }), null == (i = this.rangeService) || i.setRangeToCell({
          rowIndex: s,
          rowPinned: n,
          column: e
        }), !0)
      }
      focusNextGridCoreContainer(e, t = !1) {
        return !(t || !this.gridCtrl.focusNextInnerContainer(e)) || ((t || !e && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(e), !1)
      }
      focusAdvancedFilter(e) {
        var t, i;
        return this.advancedFilterFocusColumn = null == e ? void 0 : e.column, null != (i = null == (t = this.advancedFilterService) ? void 0 : t.getCtrl().focusHeaderComp()) && i
      }
      focusNextFromAdvancedFilter(e, t) {
        var i, r;
        const s = null != (r = t ? void 0 : this.advancedFilterFocusColumn) ? r : null == (i = this.columnModel.getAllDisplayedColumns()) ? void 0 : i[0];
        return e ? this.focusHeaderPosition({
          headerPosition: {
            column: s,
            headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
          }
        }) : this.focusGridView(s)
      }
      clearAdvancedFilterColumn() {
        this.advancedFilterFocusColumn = void 0
      }
    };
    Ic.keyboardModeActive = !1, Ic.instanceCount = 0, C([fe("eGridDiv")], Ic.prototype, "eGridDiv", 2), C([fe("columnModel")], Ic.prototype, "columnModel", 2), C([fe("headerNavigationService")], Ic.prototype, "headerNavigationService", 2), C([fe("headerPositionUtils")], Ic.prototype, "headerPositionUtils", 2), C([fe("rowRenderer")], Ic.prototype, "rowRenderer", 2), C([fe("rowPositionUtils")], Ic.prototype, "rowPositionUtils", 2), C([fe("cellPositionUtils")], Ic.prototype, "cellPositionUtils", 2), C([fe("navigationService")], Ic.prototype, "navigationService", 2), C([fe("ctrlsService")], Ic.prototype, "ctrlsService", 2), C([fe("filterManager")], Ic.prototype, "filterManager", 2), C([Te("rangeService")], Ic.prototype, "rangeService", 2), C([Te("advancedFilterService")], Ic.prototype, "advancedFilterService", 2), C([pe], Ic.prototype, "init", 1), Ic = C([ge("focusService")], Ic);
    var Oc = class extends ct {
      setMouseOver(e) {
        this.selectedColumns = e;
        const t = {
          type: Et.EVENT_COLUMN_HOVER_CHANGED
        };
        this.eventService.dispatchEvent(t)
      }
      clearMouseOver() {
        this.selectedColumns = null;
        const e = {
          type: Et.EVENT_COLUMN_HOVER_CHANGED
        };
        this.eventService.dispatchEvent(e)
      }
      isHovered(e) {
        return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0
      }
    };
    Oc = C([ge("columnHoverService")], Oc);
    var Lc = class extends ct {
      constructor() {
        super(...arguments), this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.suppressAnimation = !1, this.animationThreadCount = 0
      }
      postConstruct() {
        this.ctrlsService.whenReady(e => this.gridBodyCtrl = e.gridBodyCtrl)
      }
      isActive() {
        return this.active && !this.suppressAnimation
      }
      setSuppressAnimation(e) {
        this.suppressAnimation = e
      }
      start() {
        this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0)
      }
      finish() {
        this.active && this.flush(() => {
          this.active = !1
        })
      }
      executeNextVMTurn(e) {
        this.active ? this.executeNextFuncs.push(e) : e()
      }
      executeLaterVMTurn(e) {
        this.active ? this.executeLaterFuncs.push(e) : e()
      }
      ensureAnimationCssClassPresent() {
        this.animationThreadCount++;
        const e = this.animationThreadCount;
        this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
          this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1)
        })
      }
      flush(e) {
        if (0 === this.executeNextFuncs.length && 0 === this.executeLaterFuncs.length) return void e();
        const t = e => {
          for (; e.length;) {
            const t = e.pop();
            t && t()
          }
        };
        this.getFrameworkOverrides().wrapIncoming(() => {
          window.setTimeout(() => t(this.executeNextFuncs), 0), window.setTimeout(() => {
            e(), t(this.executeLaterFuncs)
          }, 200)
        })
      }
    };
    C([fe("ctrlsService")], Lc.prototype, "ctrlsService", 2), C([pe], Lc.prototype, "postConstruct", 1), Lc = C([ge("columnAnimationService")], Lc);
    var _c = class extends ct {
      postConstruct() {
        this.ctrlsService.whenReady(e => {
          this.centerRowsCtrl = e.center, this.addManagedListener(this.eventService, Et.EVENT_BODY_HEIGHT_CHANGED, this.checkPageSize.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_SCROLL_VISIBILITY_CHANGED, this.checkPageSize.bind(this)), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize()
        })
      }
      notActive() {
        return !this.gos.get("paginationAutoPageSize") || null == this.centerRowsCtrl
      }
      onPaginationAutoSizeChanged() {
        this.notActive() ? this.paginationProxy.unsetAutoCalculatedPageSize() : this.checkPageSize()
      }
      checkPageSize() {
        if (this.notActive()) return;
        const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
        if (e > 0) {
          const t = () => {
            const t = this.gos.getRowHeightAsNumber(),
              i = Math.floor(e / t);
            this.paginationProxy.setPageSize(i, "autoCalculated")
          };
          this.isBodyRendered ? re(() => t(), 50)() : (t(), this.isBodyRendered = !0)
        } else this.isBodyRendered = !1
      }
    };
    C([fe("ctrlsService")], _c.prototype, "ctrlsService", 2), C([fe("paginationProxy")], _c.prototype, "paginationProxy", 2), C([pe], _c.prototype, "postConstruct", 1), _c = C([ge("paginationAutoPageSizeService")], _c);
    var yc = class extends ct {
      constructor() {
        super(...arguments), this.cacheVersion = 0
      }
      init() {
        this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires")
      }
      onDataChanged() {
        this.neverExpires || this.expire()
      }
      expire() {
        this.cacheVersion++
      }
      setValue(e, t, i) {
        this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = i)
      }
      getValue(e, t) {
        if (this.active && e.__cacheVersion === this.cacheVersion) return e.__cacheData[t]
      }
    };
    C([pe], yc.prototype, "init", 1), yc = C([ge("valueCache")], yc);
    var wc = class extends ct {
      init() {
        "clientSide" === this.rowModel.getType() && (this.clientSideRowModel = this.rowModel), this.addManagedListener(this.eventService, Et.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this))
      }
      onCellValueChanged(e) {
        "paste" !== e.source && this.doChangeDetection(e.node, e.column)
      }
      doChangeDetection(e, t) {
        if (this.gos.get("suppressChangeDetection")) return;
        const i = [e];
        if (this.clientSideRowModel && !e.isRowPinned()) {
          const r = this.gos.get("aggregateOnlyChangedColumns"),
            s = new yl(r, this.clientSideRowModel.getRootNode());
          s.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(s), s.forEachChangedNodeDepthFirst(e => {
            i.push(e)
          })
        }
        this.rowRenderer.refreshCells({
          rowNodes: i
        })
      }
    };
    C([fe("rowModel")], wc.prototype, "rowModel", 2), C([fe("rowRenderer")], wc.prototype, "rowRenderer", 2), C([pe], wc.prototype, "init", 1), wc = C([ge("changeDetectionService")], wc);
    var Dc = class extends ct {
      adaptFunction(e, t) {
        const i = this.componentMetadataProvider.retrieve(e);
        return i && i.functionAdapter ? i.functionAdapter(t) : null
      }
      adaptCellRendererFunction(e) {
        return class {
          refresh(e) {
            return !1
          }
          getGui() {
            return this.eGui
          }
          init(t) {
            const i = e(t),
              r = typeof i;
            this.eGui = "string" !== r && "number" !== r && "boolean" !== r ? null != i ? i : _r("<span></span>") : _r("<span>" + i + "</span>")
          }
        }
      }
      doesImplementIComponent(e) {
        return !!e && (e.prototype && "getGui" in e.prototype)
      }
    };
    C([fe("componentMetadataProvider")], Dc.prototype, "componentMetadataProvider", 2), Dc = C([ge("agComponentUtils")], Dc);
    var Pc = class extends ct {
      postConstruct() {
        this.componentMetaData = {
          dateComponent: {
            mandatoryMethodList: ["getDate", "setDate"],
            optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "onParamsUpdated", "refresh"]
          },
          detailCellRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh"],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          headerComponent: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh"]
          },
          headerGroupComponent: {
            mandatoryMethodList: [],
            optionalMethodList: []
          },
          loadingCellRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: [],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          loadingOverlayComponent: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh"]
          },
          noRowsOverlayComponent: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh"]
          },
          floatingFilterComponent: {
            mandatoryMethodList: ["onParentModelChanged"],
            optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
          },
          cellRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh", "afterGuiAttached"],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          cellEditor: {
            mandatoryMethodList: ["getValue"],
            optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached", "refresh"]
          },
          innerRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: ["afterGuiAttached"],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          fullWidthCellRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh", "afterGuiAttached"],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          groupRowRenderer: {
            mandatoryMethodList: [],
            optionalMethodList: ["afterGuiAttached"],
            functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
          },
          filter: {
            mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
            optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged", "refresh"]
          },
          statusPanel: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh"]
          },
          toolPanel: {
            mandatoryMethodList: [],
            optionalMethodList: ["refresh", "getState"]
          },
          tooltipComponent: {
            mandatoryMethodList: [],
            optionalMethodList: []
          },
          menuItem: {
            mandatoryMethodList: [],
            optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
          }
        }
      }
      retrieve(e) {
        return this.componentMetaData[e]
      }
    };
    C([fe("agComponentUtils")], Pc.prototype, "agComponentUtils", 2), C([pe], Pc.prototype, "postConstruct", 1), Pc = C([ge("componentMetadataProvider")], Pc);
    var bc = {
        "ag-theme-custom": {
          headerHeight: 25,
          headerCellMinWidth: 24,
          listItemHeight: 20,
          rowHeight: 25,
          chartMenuPanelWidth: 220
        },
        "ag-theme-material": {
          headerHeight: 56,
          headerCellMinWidth: 48,
          listItemHeight: 32,
          rowHeight: 48,
          chartMenuPanelWidth: 240
        },
        "ag-theme-balham": {
          headerHeight: 32,
          headerCellMinWidth: 24,
          listItemHeight: 24,
          rowHeight: 28,
          chartMenuPanelWidth: 220
        },
        "ag-theme-alpine": {
          headerHeight: 48,
          headerCellMinWidth: 36,
          listItemHeight: 24,
          rowHeight: 42,
          chartMenuPanelWidth: 240
        },
        "ag-theme-quartz": {
          headerHeight: 48,
          headerCellMinWidth: 36,
          listItemHeight: 24,
          rowHeight: 42,
          chartMenuPanelWidth: 260
        }
      },
      Mc = {
        headerHeight: ["ag-header-row"],
        headerCellMinWidth: ["ag-header-cell"],
        listItemHeight: ["ag-virtual-list-item"],
        rowHeight: ["ag-row"],
        chartMenuPanelWidth: ["ag-chart-docked-container"]
      },
      Fc = class extends ct {
        constructor() {
          super(...arguments), this.calculatedSizes = {}, this.calculatedTheme = null
        }
        postConstruct() {
          var e;
          const t = null != (e = this.getTheme().el) ? e : this.eGridDiv;
          this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.mutationObserver = new MutationObserver(() => {
            this.calculatedSizes = {}, this.calculatedTheme = null, this.calculatedTheme = this.getTheme(), this.fireGridStylesChangedEvent()
          }), this.mutationObserver.observe(t || this.eGridDiv, {
            attributes: !0,
            attributeFilter: ["class"]
          })
        }
        fireGridStylesChangedEvent() {
          const e = {
            type: Et.EVENT_GRID_STYLES_CHANGED
          };
          this.eventService.dispatchEvent(e)
        }
        getSassVariable(e) {
          const {
            themeFamily: t,
            el: i
          } = this.getTheme();
          if (!t || 0 !== t.indexOf("ag-theme")) return;
          this.calculatedSizes || (this.calculatedSizes = {}), this.calculatedSizes[t] || (this.calculatedSizes[t] = {});
          const r = this.calculatedSizes[t][e];
          return null != r ? r : (this.calculatedSizes[t][e] = this.calculateValueForSassProperty(e, t, i), this.calculatedSizes[t][e])
        }
        calculateValueForSassProperty(e, t, i) {
          const r = "ag-theme-" + (t.match("material") ? "material" : t.match("balham") ? "balham" : t.match("alpine") ? "alpine" : "custom"),
            s = bc[r][e],
            n = this.gos.getDocument();
          if (i || (i = this.eGridDiv), !Mc[e]) return s;
          const o = Mc[e],
            a = n.createElement("div"),
            l = Array.from(i.classList);
          a.classList.add(t, ...l), a.style.position = "absolute";
          const c = o.reduce((e, t) => {
            const i = n.createElement("div");
            return i.style.position = "static", i.classList.add(t), e.appendChild(i), i
          }, a);
          let h = 0;
          if (n.body) {
            n.body.appendChild(a);
            const t = -1 !== e.toLowerCase().indexOf("height") ? "height" : "width";
            h = parseInt(window.getComputedStyle(c)[t], 10), n.body.removeChild(a)
          }
          return h || s
        }
        isThemeDark() {
          const {
            theme: e
          } = this.getTheme();
          return !!e && e.indexOf("dark") >= 0
        }
        chartMenuPanelWidth() {
          return this.getSassVariable("chartMenuPanelWidth")
        }
        getTheme() {
          if (this.calculatedTheme) return this.calculatedTheme;
          const e = /\bag-(material|(?:theme-([\w\-]*)))\b/g;
          let t = this.eGridDiv,
            i = null,
            r = [];
          for (; t;) {
            if (i = e.exec(t.className), i) {
              const i = t.className.match(e);
              i && (r = i);
              break
            }
            t = t.parentElement || void 0
          }
          if (!i) return {
            allThemes: r
          };
          const s = i[0];
          return this.calculatedTheme = {
            theme: s,
            el: t,
            themeFamily: s.replace(/-dark$/, ""),
            allThemes: r
          }, this.calculatedTheme
        }
        getFromTheme(e, t) {
          var i;
          return null != (i = this.getSassVariable(t)) ? i : e
        }
        getDefaultRowHeight() {
          return this.getFromTheme(25, "rowHeight")
        }
        getListItemHeight() {
          return this.getFromTheme(20, "listItemHeight")
        }
        refreshRowHeightVariable() {
          const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(),
            t = this.gos.get("rowHeight");
          if (null == t || isNaN(t) || !isFinite(t)) return null !== e && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
          const i = `${t}px`;
          return e != i ? (this.eGridDiv.style.setProperty("--ag-line-height", i), t) : "" != e ? parseFloat(e) : -1
        }
        getMinColWidth() {
          const e = this.getFromTheme(null, "headerCellMinWidth");
          return v(e) ? Math.max(e, 10) : 10
        }
        destroy() {
          this.calculatedSizes = null, this.mutationObserver && this.mutationObserver.disconnect(), super.destroy()
        }
      };
    C([fe("eGridDiv")], Fc.prototype, "eGridDiv", 2), C([pe], Fc.prototype, "postConstruct", 1), Fc = C([ge("environment")], Fc);
    var xc = class extends ct {
      constructor() {
        super(...arguments), this.scrollY = 0, this.uiBodyHeight = 0
      }
      agWire(e) {
        this.logger = e.create("RowContainerHeightService")
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this)), this.maxDivHeight = ki(), this.logger.log("maxDivHeight = " + this.maxDivHeight)
      }
      isStretching() {
        return this.stretching
      }
      getDivStretchOffset() {
        return this.divStretchOffset
      }
      updateOffset() {
        if (!this.stretching) return;
        const e = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top,
          t = this.getUiBodyHeight();
        (e !== this.scrollY || t !== this.uiBodyHeight) && (this.scrollY = e, this.uiBodyHeight = t, this.calculateOffset())
      }
      calculateOffset() {
        this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
        const e = this.scrollY / this.maxScrollY,
          t = e * this.pixelsToShave;
        this.logger.log(`Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`), this.setDivStretchOffset(t)
      }
      setUiContainerHeight(e) {
        e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({
          type: Et.EVENT_ROW_CONTAINER_HEIGHT_CHANGED
        }))
      }
      clearOffset() {
        this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0)
      }
      setDivStretchOffset(e) {
        const t = "number" == typeof e ? Math.floor(e) : null;
        this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({
          type: Et.EVENT_HEIGHT_SCALE_CHANGED
        }))
      }
      setModelHeight(e) {
        this.modelHeight = e, this.stretching = null != e && this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset()
      }
      getUiContainerHeight() {
        return this.uiContainerHeight
      }
      getRealPixelPosition(e) {
        return e - this.divStretchOffset
      }
      getUiBodyHeight() {
        const e = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
        return e.bottom - e.top
      }
      getScrollPositionForPixel(e) {
        if (this.pixelsToShave <= 0) return e;
        const t = e / (this.modelHeight - this.getUiBodyHeight());
        return this.maxScrollY * t
      }
    };
    C([fe("ctrlsService")], xc.prototype, "ctrlsService", 2), C([S(0, Ce("loggerFactory"))], xc.prototype, "agWire", 1), C([pe], xc.prototype, "postConstruct", 1), xc = C([ge("rowContainerHeightService")], xc);
    var Gc = class extends ct {
      init() {
        this.addManagedPropertyListener("isRowSelectable", () => this.updateSelectable())
      }
      updateSelectableAfterGrouping() {
        this.updateSelectable(!0)
      }
      updateSelectable(e = !1) {
        const t = !!this.gos.get("rowSelection"),
          i = this.gos.get("isRowSelectable");
        if (!t || !i) return;
        const r = this.gos.get("groupSelectsChildren"),
          s = "clientSide" === this.rowModel.getType() && r,
          n = [],
          o = t => {
            if (e && !t.group) return;
            if (s && t.group) {
              const e = t.childrenAfterGroup.some(e => !0 === e.selectable);
              return void t.setRowSelectable(e, !0)
            }
            const r = !i || i(t);
            t.setRowSelectable(r, !0), !r && t.isSelected() && n.push(t)
          };
        if (s) {
          const e = this.rowModel;
          new yl(!1, e.getRootNode()).forEachChangedNodeDepthFirst(o, !0, !0)
        } else this.rowModel.forEachNode(o);
        n.length && this.selectionService.setNodesSelected({
          nodes: n,
          newValue: !1,
          source: "selectableChanged"
        }), s && this.selectionService instanceof fc && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged")
      }
    };
    C([fe("rowModel")], Gc.prototype, "rowModel", 2), C([fe("selectionService")], Gc.prototype, "selectionService", 2), C([pe], Gc.prototype, "init", 1), Gc = C([ge("selectableService")], Gc);
    var Uc = class extends _s {
      constructor() {
        super(), this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1
      }
      postConstruct() {
        const e = this.gos.get("enableRtl");
        this.setTemplate(this.getTemplate());
        const {
          btFirst: t,
          btPrevious: i,
          btNext: r,
          btLast: s,
          pageSizeComp: n
        } = this;
        this.activateTabIndex([t, i, r, s]), t.insertAdjacentElement("afterbegin", Zr(e ? "last" : "first", this.gos)), i.insertAdjacentElement("afterbegin", Zr(e ? "next" : "previous", this.gos)), r.insertAdjacentElement("afterbegin", Zr(e ? "previous" : "next", this.gos)), s.insertAdjacentElement("afterbegin", Zr(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"], () => this.onPageSizeRelatedOptionsChange()), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.onPaginationChanged()
      }
      onPaginationChanged() {
        const e = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
        this.setDisplayed(e), e && (this.setupListeners(), this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels(), this.onPageSizeRelatedOptionsChange())
      }
      onPageSizeRelatedOptionsChange() {
        this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector())
      }
      setupListeners() {
        this.areListenersSetup || (this.addManagedListener(this.eventService, Et.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), [{
          el: this.btFirst,
          fn: this.onBtFirst.bind(this)
        }, {
          el: this.btPrevious,
          fn: this.onBtPrevious.bind(this)
        }, {
          el: this.btNext,
          fn: this.onBtNext.bind(this)
        }, {
          el: this.btLast,
          fn: this.onBtLast.bind(this)
        }].forEach(e => {
          const {
            el: t,
            fn: i
          } = e;
          this.addManagedListener(t, "click", i), this.addManagedListener(t, "keydown", e => {
            e.key !== ts.ENTER && e.key !== ts.SPACE || (e.preventDefault(), i())
          })
        }), this.areListenersSetup = !0)
      }
      onBtFirst() {
        this.previousAndFirstButtonsDisabled || this.paginationProxy.goToFirstPage()
      }
      setCurrentPageLabel() {
        const e = this.paginationProxy.getTotalPages() > 0,
          t = this.paginationProxy.getCurrentPage(),
          i = e ? t + 1 : 0;
        this.lbCurrent.textContent = this.formatNumber(i)
      }
      formatNumber(e) {
        const t = this.gos.getCallback("paginationNumberFormatter");
        if (t) {
          return t({
            value: e
          })
        }
        const i = this.localeService.getLocaleTextFunc();
        return Zi(e, i("thousandSeparator", ","), i("decimalSeparator", "."))
      }
      getTemplate() {
        const e = this.localeService.getLocaleTextFunc(),
          t = e("page", "Page"),
          i = e("to", "to"),
          r = e("of", "of"),
          s = e("firstPage", "First Page"),
          n = e("previousPage", "Previous Page"),
          o = e("nextPage", "Next Page"),
          a = e("lastPage", "Last Page"),
          l = this.getCompId();
        return `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">\n                <ag-page-size-selector ref="pageSizeComp"></ag-page-size-selector>\n                <span class="ag-paging-row-summary-panel" role="status">\n                    <span id="ag-${l}-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>\n                    <span id="ag-${l}-to">${i}</span>\n                    <span id="ag-${l}-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>\n                    <span id="ag-${l}-of">${r}</span>\n                    <span id="ag-${l}-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>\n                </span>\n                <span class="ag-paging-page-summary-panel" role="presentation">\n                    <div ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>\n                    <div ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>\n                    <span class="ag-paging-description" role="status">\n                        <span id="ag-${l}-start-page">${t}</span>\n                        <span id="ag-${l}-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>\n                        <span id="ag-${l}-of-page">${r}</span>\n                        <span id="ag-${l}-of-page-number" ref="lbTotal" class="ag-paging-number"></span>\n                    </span>\n                    <div ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>\n                    <div ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>\n                </span>\n            </div>`
      }
      onBtNext() {
        this.nextButtonDisabled || this.paginationProxy.goToNextPage()
      }
      onBtPrevious() {
        this.previousAndFirstButtonsDisabled || this.paginationProxy.goToPreviousPage()
      }
      onBtLast() {
        this.lastButtonDisabled || this.paginationProxy.goToLastPage()
      }
      enableOrDisableButtons() {
        const e = this.paginationProxy.getCurrentPage(),
          t = this.paginationProxy.isLastPageFound(),
          i = this.paginationProxy.getTotalPages();
        this.previousAndFirstButtonsDisabled = 0 === e, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
        const r = this.isZeroPagesToDisplay(),
          s = e === i - 1;
        this.nextButtonDisabled = s || r, this.lastButtonDisabled = !t || r || e === i - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled)
      }
      toggleButtonDisabled(e, t) {
        si(e, t), e.classList.toggle("ag-disabled", t)
      }
      updateRowLabels() {
        const e = this.paginationProxy.getCurrentPage(),
          t = this.paginationProxy.getPageSize(),
          i = this.paginationProxy.isLastPageFound(),
          r = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null;
        let s, n;
        if (this.isZeroPagesToDisplay() ? s = n = 0 : (s = t * e + 1, n = s + t - 1, i && n > r && (n = r)), this.lbFirstRowOnPage.textContent = this.formatNumber(s), this.rowNodeBlockLoader.isLoading()) {
          const e = this.localeService.getLocaleTextFunc();
          this.lbLastRowOnPage.innerHTML = e("pageLastRowUnknown", "?")
        } else this.lbLastRowOnPage.textContent = this.formatNumber(n)
      }
      isZeroPagesToDisplay() {
        const e = this.paginationProxy.isLastPageFound(),
          t = this.paginationProxy.getTotalPages();
        return e && 0 === t
      }
      setTotalLabels() {
        const e = this.paginationProxy.isLastPageFound(),
          t = this.paginationProxy.getTotalPages(),
          i = e ? this.paginationProxy.getMasterRowCount() : null;
        if (1 === i) {
          const e = this.paginationProxy.getRow(0);
          if (e && e.group && !(e.groupData || e.aggData)) return void this.setTotalLabelsToZero()
        }
        if (e) this.lbTotal.textContent = this.formatNumber(t), this.lbRecordCount.textContent = this.formatNumber(i);
        else {
          const e = this.localeService.getLocaleTextFunc()("more", "more");
          this.lbTotal.innerHTML = e, this.lbRecordCount.innerHTML = e
        }
      }
      setTotalLabelsToZero() {
        this.lbFirstRowOnPage.textContent = this.formatNumber(0), this.lbCurrent.textContent = this.formatNumber(0), this.lbLastRowOnPage.textContent = this.formatNumber(0), this.lbTotal.textContent = this.formatNumber(0), this.lbRecordCount.textContent = this.formatNumber(0)
      }
    };
    C([fe("paginationProxy")], Uc.prototype, "paginationProxy", 2), C([fe("rowNodeBlockLoader")], Uc.prototype, "rowNodeBlockLoader", 2), C([ys("btFirst")], Uc.prototype, "btFirst", 2), C([ys("btPrevious")], Uc.prototype, "btPrevious", 2), C([ys("btNext")], Uc.prototype, "btNext", 2), C([ys("btLast")], Uc.prototype, "btLast", 2), C([ys("lbRecordCount")], Uc.prototype, "lbRecordCount", 2), C([ys("lbFirstRowOnPage")], Uc.prototype, "lbFirstRowOnPage", 2), C([ys("lbLastRowOnPage")], Uc.prototype, "lbLastRowOnPage", 2), C([ys("lbCurrent")], Uc.prototype, "lbCurrent", 2), C([ys("lbTotal")], Uc.prototype, "lbTotal", 2), C([ys("pageSizeComp")], Uc.prototype, "pageSizeComp", 2), C([pe], Uc.prototype, "postConstruct", 1);
    var Hc = class e extends _s {
      constructor() {
        super(e.TEMPLATE), this.inProgress = !1, this.destroyRequested = !1
      }
      updateLayoutClasses(e, t) {
        const i = this.eOverlayWrapper.classList;
        i.toggle("ag-layout-auto-height", t.autoHeight), i.toggle("ag-layout-normal", t.normal), i.toggle("ag-layout-print", t.print)
      }
      postConstruct() {
        this.createManagedBean(new ea(this)), this.setDisplayed(!1, {
          skipAriaHidden: !0
        }), this.overlayService.registerOverlayWrapperComp(this)
      }
      setWrapperTypeClass(e) {
        const t = this.eOverlayWrapper.classList;
        this.activeOverlayWrapperCssClass && t.toggle(this.activeOverlayWrapperCssClass, !1), this.activeOverlayWrapperCssClass = e, t.toggle(e, !0)
      }
      showOverlay(e, t, i) {
        this.inProgress || (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.inProgress = !0, e && e.then(e => {
          this.inProgress = !1, this.eOverlayWrapper.appendChild(e.getGui()), this.activeOverlay = e, this.updateListenerDestroyFunc = i, this.destroyRequested && (this.destroyRequested = !1, this.destroyActiveOverlay())
        }), this.setDisplayed(!0, {
          skipAriaHidden: !0
        }))
      }
      destroyActiveOverlay() {
        var e;
        this.inProgress ? this.destroyRequested = !0 : this.activeOverlay && (this.activeOverlay = this.getContext().destroyBean(this.activeOverlay), null == (e = this.updateListenerDestroyFunc) || e.call(this), Nr(this.eOverlayWrapper))
      }
      hideOverlay() {
        this.destroyActiveOverlay(), this.setDisplayed(!1, {
          skipAriaHidden: !0
        })
      }
      destroy() {
        this.destroyActiveOverlay(), super.destroy()
      }
    };
    Hc.TEMPLATE = '\n        <div class="ag-overlay" role="presentation">\n            <div class="ag-overlay-panel" role="presentation">\n                <div class="ag-overlay-wrapper" ref="eOverlayWrapper" role="presentation"></div>\n            </div>\n        </div>', C([fe("overlayService")], Hc.prototype, "overlayService", 2), C([ys("eOverlayWrapper")], Hc.prototype, "eOverlayWrapper", 2), C([pe], Hc.prototype, "postConstruct", 1);
    var kc = Hc,
      Bc = class extends ct {
        getFirstRow() {
          let e, t = 0;
          return this.pinnedRowModel.getPinnedTopRowCount() ? e = "top" : this.rowModel.getRowCount() ? (e = null, t = this.paginationProxy.getPageFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (e = "bottom"), void 0 === e ? null : {
            rowIndex: t,
            rowPinned: e
          }
        }
        getLastRow() {
          let e, t = null;
          const i = this.pinnedRowModel.getPinnedBottomRowCount(),
            r = this.pinnedRowModel.getPinnedTopRowCount();
          return i ? (t = "bottom", e = i - 1) : this.rowModel.getRowCount() ? (t = null, e = this.paginationProxy.getPageLastRow()) : r && (t = "top", e = r - 1), void 0 === e ? null : {
            rowIndex: e,
            rowPinned: t
          }
        }
        getRowNode(e) {
          switch (e.rowPinned) {
            case "top":
              return this.pinnedRowModel.getPinnedTopRowData()[e.rowIndex];
            case "bottom":
              return this.pinnedRowModel.getPinnedBottomRowData()[e.rowIndex];
            default:
              return this.rowModel.getRow(e.rowIndex)
          }
        }
        sameRow(e, t) {
          return !e && !t || !(e && !t || !e && t) && (e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned)
        }
        before(e, t) {
          switch (e.rowPinned) {
            case "top":
              if ("top" !== t.rowPinned) return !0;
              break;
            case "bottom":
              if ("bottom" !== t.rowPinned) return !1;
              break;
            default:
              if (v(t.rowPinned)) return "top" !== t.rowPinned
          }
          return e.rowIndex < t.rowIndex
        }
      };
    C([fe("rowModel")], Bc.prototype, "rowModel", 2), C([fe("pinnedRowModel")], Bc.prototype, "pinnedRowModel", 2), C([fe("paginationProxy")], Bc.prototype, "paginationProxy", 2), Bc = C([ge("rowPositionUtils")], Bc);
    var Vc = class extends ct {
      createId(e) {
        const {
          rowIndex: t,
          rowPinned: i,
          column: r
        } = e;
        return this.createIdFromValues({
          rowIndex: t,
          column: r,
          rowPinned: i
        })
      }
      createIdFromValues(e) {
        const {
          rowIndex: t,
          rowPinned: i,
          column: r
        } = e;
        return `${t}.${null==i?"null":i}.${r.getId()}`
      }
      equals(e, t) {
        const i = e.column === t.column,
          r = e.rowPinned === t.rowPinned,
          s = e.rowIndex === t.rowIndex;
        return i && r && s
      }
    };
    Vc = C([ge("cellPositionUtils")], Vc);
    var Wc = class {
        constructor(e) {
          this.cellValueChanges = e
        }
      },
      Yc = class extends Wc {
        constructor(e, t, i, r) {
          super(e), this.initialRange = t, this.finalRange = i, this.ranges = r
        }
      },
      Kc = class e {
        constructor(t) {
          this.actionStack = [], this.maxStackSize = t || e.DEFAULT_STACK_SIZE, this.actionStack = new Array(this.maxStackSize)
        }
        pop() {
          return this.actionStack.pop()
        }
        push(e) {
          e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e))
        }
        clear() {
          this.actionStack = []
        }
        getCurrentStackSize() {
          return this.actionStack.length
        }
      };
    Kc.DEFAULT_STACK_SIZE = 10;
    var Xc = Kc,
      zc = class extends ct {
        constructor() {
          super(...arguments), this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = e => {
            const t = {
                column: e.column,
                rowIndex: e.rowIndex,
                rowPinned: e.rowPinned
              },
              i = null !== this.activeCellEdit && this.cellPositionUtils.equals(this.activeCellEdit, t),
              r = null !== this.activeRowEdit && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
            if (!(i || r || this.isPasting || this.isRangeInAction)) return;
            const {
              rowPinned: s,
              rowIndex: n,
              column: o,
              oldValue: a,
              value: l
            } = e, c = {
              rowPinned: s,
              rowIndex: n,
              columnId: o.getColId(),
              newValue: l,
              oldValue: a
            };
            this.cellValueChanges.push(c)
          }, this.clearStacks = () => {
            this.undoStack.clear(), this.redoStack.clear()
          }
        }
        init() {
          if (!this.gos.get("undoRedoCellEditing")) return;
          const e = this.gos.get("undoRedoCellEditingLimit");
          e <= 0 || (this.undoStack = new Xc(e), this.redoStack = new Xc(e), this.addRowEditingListeners(), this.addCellEditingListeners(), this.addPasteListeners(), this.addFillListeners(), this.addCellKeyListeners(), this.addManagedListener(this.eventService, Et.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged), this.addManagedListener(this.eventService, Et.EVENT_MODEL_UPDATED, e => {
            e.keepUndoRedoStack || this.clearStacks()
          }), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_GROUP_OPENED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_MOVED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PINNED, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VISIBLE, this.clearStacks), this.addManagedListener(this.eventService, Et.EVENT_ROW_DRAG_END, this.clearStacks), this.ctrlsService.whenReady(e => {
            this.gridBodyCtrl = e.gridBodyCtrl
          }))
        }
        getCurrentUndoStackSize() {
          return this.undoStack ? this.undoStack.getCurrentStackSize() : 0
        }
        getCurrentRedoStackSize() {
          return this.redoStack ? this.redoStack.getCurrentStackSize() : 0
        }
        undo(e) {
          const t = {
            type: Et.EVENT_UNDO_STARTED,
            source: e
          };
          this.eventService.dispatchEvent(t);
          const i = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo"),
            r = {
              type: Et.EVENT_UNDO_ENDED,
              source: e,
              operationPerformed: i
            };
          this.eventService.dispatchEvent(r)
        }
        redo(e) {
          const t = {
            type: Et.EVENT_REDO_STARTED,
            source: e
          };
          this.eventService.dispatchEvent(t);
          const i = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo"),
            r = {
              type: Et.EVENT_REDO_ENDED,
              source: e,
              operationPerformed: i
            };
          this.eventService.dispatchEvent(r)
        }
        undoRedo(e, t, i, r, s) {
          if (!e) return !1;
          const n = e.pop();
          return !(!n || !n.cellValueChanges) && (this.processAction(n, e => e[r], s), n instanceof Yc ? this.processRange(this.rangeService, n.ranges || [n[i]]) : this.processCell(n.cellValueChanges), t.push(n), !0)
        }
        processAction(e, t, i) {
          e.cellValueChanges.forEach(e => {
            const {
              rowIndex: r,
              rowPinned: s,
              columnId: n
            } = e, o = {
              rowIndex: r,
              rowPinned: s
            }, a = this.rowPositionUtils.getRowNode(o);
            a.displayed && a.setDataValue(n, t(e), i)
          })
        }
        processRange(e, t) {
          let i;
          e.removeAllCellRanges(!0), t.forEach((r, s) => {
            if (!r) return;
            const n = r.startRow,
              o = r.endRow;
            s === t.length - 1 && (i = {
              rowPinned: n.rowPinned,
              rowIndex: n.rowIndex,
              columnId: r.startColumn.getColId()
            }, this.setLastFocusedCell(i));
            const a = {
              rowStartIndex: n.rowIndex,
              rowStartPinned: n.rowPinned,
              rowEndIndex: o.rowIndex,
              rowEndPinned: o.rowPinned,
              columnStart: r.startColumn,
              columns: r.columns
            };
            e.addCellRange(a)
          })
        }
        processCell(e) {
          const t = e[0],
            {
              rowIndex: i,
              rowPinned: r
            } = t,
            s = {
              rowIndex: i,
              rowPinned: r
            },
            n = this.rowPositionUtils.getRowNode(s),
            o = {
              rowPinned: t.rowPinned,
              rowIndex: n.rowIndex,
              columnId: t.columnId
            };
          this.setLastFocusedCell(o, this.rangeService)
        }
        setLastFocusedCell(e, t) {
          const {
            rowIndex: i,
            columnId: r,
            rowPinned: s
          } = e, n = this.gridBodyCtrl.getScrollFeature(), o = this.columnModel.getGridColumn(r);
          if (!o) return;
          n.ensureIndexVisible(i), n.ensureColumnVisible(o);
          const a = {
            rowIndex: i,
            column: o,
            rowPinned: s
          };
          this.focusService.setFocusedCell(T(f({}, a), {
            forceBrowserFocus: !0
          })), null == t || t.setRangeToCell(a)
        }
        addRowEditingListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_ROW_EDITING_STARTED, e => {
            this.activeRowEdit = {
              rowIndex: e.rowIndex,
              rowPinned: e.rowPinned
            }
          }), this.addManagedListener(this.eventService, Et.EVENT_ROW_EDITING_STOPPED, () => {
            const e = new Wc(this.cellValueChanges);
            this.pushActionsToUndoStack(e), this.activeRowEdit = null
          })
        }
        addCellEditingListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_CELL_EDITING_STARTED, e => {
            this.activeCellEdit = {
              column: e.column,
              rowIndex: e.rowIndex,
              rowPinned: e.rowPinned
            }
          }), this.addManagedListener(this.eventService, Et.EVENT_CELL_EDITING_STOPPED, e => {
            this.activeCellEdit = null;
            if (e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
              const e = new Wc(this.cellValueChanges);
              this.pushActionsToUndoStack(e)
            }
          })
        }
        addPasteListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_PASTE_START, () => {
            this.isPasting = !0
          }), this.addManagedListener(this.eventService, Et.EVENT_PASTE_END, () => {
            const e = new Wc(this.cellValueChanges);
            this.pushActionsToUndoStack(e), this.isPasting = !1
          })
        }
        addFillListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_FILL_START, () => {
            this.isRangeInAction = !0
          }), this.addManagedListener(this.eventService, Et.EVENT_FILL_END, e => {
            const t = new Yc(this.cellValueChanges, e.initialRange, e.finalRange);
            this.pushActionsToUndoStack(t), this.isRangeInAction = !1
          })
        }
        addCellKeyListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, () => {
            this.isRangeInAction = !0
          }), this.addManagedListener(this.eventService, Et.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, () => {
            let e;
            e = this.rangeService && this.gos.get("enableRangeSelection") ? new Yc(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]) : new Wc(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1
          })
        }
        pushActionsToUndoStack(e) {
          this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear()
        }
      };
    C([fe("focusService")], zc.prototype, "focusService", 2), C([fe("ctrlsService")], zc.prototype, "ctrlsService", 2), C([fe("cellPositionUtils")], zc.prototype, "cellPositionUtils", 2), C([fe("rowPositionUtils")], zc.prototype, "rowPositionUtils", 2), C([fe("columnModel")], zc.prototype, "columnModel", 2), C([Te("rangeService")], zc.prototype, "rangeService", 2), C([pe], zc.prototype, "init", 1), zc = C([ge("undoRedoService")], zc);
    var $c = class extends ct {
      findHeader(e, t) {
        let i, r;
        if (e.column instanceof pt ? i = this.columnModel.getDisplayedGroupAtDirection(e.column, t) : (r = `getDisplayedCol${t}`, i = this.columnModel[r](e.column)), !i) return;
        let {
          headerRowIndex: s
        } = e;
        if ("filter" !== this.getHeaderRowType(s)) {
          const e = [i];
          for (; i.getParent();) i = i.getParent(), e.push(i);
          i = e[e.length - 1 - s]
        }
        const {
          column: n,
          headerRowIndex: o
        } = this.getHeaderIndexToFocus(i, s);
        return {
          column: n,
          headerRowIndex: o
        }
      }
      getHeaderIndexToFocus(e, t) {
        let i;
        if (e instanceof pt && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
          const r = e;
          i = r.getLeafColumns()[0];
          let s = i;
          for (; s !== r;) t++, s = s.getParent()
        }
        return {
          column: i || e,
          headerRowIndex: t
        }
      }
      isAnyChildSpanningHeaderHeight(e) {
        return !!e && e.getLeafColumns().some(e => e.isSpanHeaderHeight())
      }
      getColumnVisibleParent(e, t) {
        const i = this.getHeaderRowType(t),
          r = "column" === i;
        let s = "filter" === i ? e : e.getParent(),
          n = t - 1,
          o = n;
        if (r && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
          for (; s && s.isPadding();) s = s.getParent(), n--;
          o = n, n < 0 && (s = e, n = t, o = void 0)
        }
        return {
          column: s,
          headerRowIndex: n,
          headerRowIndexWithoutSpan: o
        }
      }
      getColumnVisibleChild(e, t, i = "After") {
        let r = e,
          s = t + 1,
          n = s;
        if ("group" === this.getHeaderRowType(t)) {
          const t = e.getDisplayedLeafColumns(),
            n = "After" === i ? t[0] : Me(t),
            o = [];
          let a = n;
          for (; a.getParent() !== e;) a = a.getParent(), o.push(a);
          if (r = n, n.isSpanHeaderHeight())
            for (let e = o.length - 1; e >= 0; e--) {
              const t = o[e];
              if (!t.isPadding()) {
                r = t;
                break
              }
              s++
            } else r = Me(o), r || (r = n)
        }
        return {
          column: r,
          headerRowIndex: s,
          headerRowIndexWithoutSpan: n
        }
      }
      getHeaderRowType(e) {
        const t = this.ctrlsService.getHeaderRowContainerCtrl();
        if (t) return t.getRowType(e)
      }
      findColAtEdgeForHeaderRow(e, t) {
        const i = this.columnModel.getAllDisplayedColumns(),
          r = i["start" === t ? 0 : i.length - 1];
        if (!r) return;
        const s = this.ctrlsService.getHeaderRowContainerCtrl(r.getPinned()).getRowType(e);
        if ("group" == s) {
          return {
            headerRowIndex: e,
            column: this.columnModel.getColumnGroupAtLevel(r, e)
          }
        }
        return {
          headerRowIndex: null == s ? -1 : e,
          column: r
        }
      }
    };
    C([fe("columnModel")], $c.prototype, "columnModel", 2), C([fe("ctrlsService")], $c.prototype, "ctrlsService", 2), $c = C([ge("headerPositionUtils")], $c);
    var jc = class {
      buildColumnDefs(e, t, i) {
        const r = [],
          s = {};
        return e.forEach(e => {
          let n = !0,
            o = this.createDefFromColumn(e, t, i),
            a = e.getOriginalParent(),
            l = null;
          for (; a;) {
            let e = null;
            if (a.isPadding()) {
              a = a.getOriginalParent();
              continue
            }
            const t = s[a.getGroupId()];
            if (t) {
              t.children.push(o), n = !1;
              break
            }
            if (e = this.createDefFromGroup(a), e && (e.children = [o], s[e.groupId] = e, o = e, a = a.getOriginalParent()), null != a && l === a) {
              n = !1;
              break
            }
            l = a
          }
          n && r.push(o)
        }), r
      }
      createDefFromGroup(e) {
        const t = U(e.getColGroupDef(), ["children"]);
        return t && (t.groupId = e.getGroupId()), t
      }
      createDefFromColumn(e, t, i) {
        const r = U(e.getColDef());
        return r.colId = e.getColId(), r.width = e.getActualWidth(), r.rowGroup = e.isRowGroupActive(), r.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, r.pivot = e.isPivotActive(), r.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, r.aggFunc = e.isValueActive() ? e.getAggFunc() : null, r.hide = !e.isVisible() || void 0, r.pinned = e.isPinned() ? e.getPinned() : null, r.sort = e.getSort() ? e.getSort() : null, r.sortIndex = null != e.getSortIndex() ? e.getSortIndex() : null, r
      }
    };
    jc = C([ge("columnDefFactory")], jc);
    var Jc = class {
      getInitialRowClasses(e) {
        const t = [];
        return v(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), $e(t, this.processClassesFromGridOptions(e.rowNode)), $e(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && ("left" === e.pinned && t.push("ag-cell-last-left-pinned"), "right" === e.pinned && t.push("ag-cell-first-right-pinned")), t
      }
      processClassesFromGridOptions(e) {
        const t = [],
          i = e => {
            "string" == typeof e ? t.push(e) : Array.isArray(e) && e.forEach(e => t.push(e))
          },
          r = this.gos.get("rowClass");
        if (r) {
          if ("function" == typeof r) return console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead"), [];
          i(r)
        }
        const s = this.gos.getCallback("getRowClass");
        if (s) {
          i(s({
            data: e.data,
            node: e,
            rowIndex: e.rowIndex
          }))
        }
        return t
      }
      preProcessRowClassRules(e) {
        const t = [];
        return this.processRowClassRules(e, e => {
          t.push(e)
        }, e => {}), t
      }
      processRowClassRules(e, t, i) {
        const r = this.gos.addGridCommonParams({
          data: e.data,
          node: e,
          rowIndex: e.rowIndex
        });
        this.stylingService.processClassRules(void 0, this.gos.get("rowClassRules"), r, t, i)
      }
      calculateRowLevel(e) {
        return e.group ? e.level : e.parent ? e.parent.level + 1 : 0
      }
    };
    C([fe("stylingService")], Jc.prototype, "stylingService", 2), C([fe("gridOptionsService")], Jc.prototype, "gos", 2), Jc = C([ge("rowCssClassCalculator")], Jc);
    var qc = class extends ct {
      init() {
        this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup(), this.addManagedPropertyListener("accentedSort", e => this.isAccentedSort = e.currentValue), this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup())
      }
      doFullSort(e, t) {
        const i = e.map((e, t) => ({
          currentPos: t,
          rowNode: e
        }));
        return i.sort(this.compareRowNodes.bind(this, t)), i.map(e => e.rowNode)
      }
      compareRowNodes(e, t, i) {
        const r = t.rowNode,
          s = i.rowNode;
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t],
            n = "desc" === i.sort,
            o = this.getValue(r, i.column),
            a = this.getValue(s, i.column);
          let l;
          const c = this.getComparator(i, r);
          l = c ? c(o, a, r, s, n) : Cs.defaultComparator(o, a, this.isAccentedSort);
          if (!isNaN(l) && 0 !== l) return "asc" === i.sort ? l : -1 * l
        }
        return t.currentPos - i.currentPos
      }
      getComparator(e, t) {
        const i = e.column,
          r = i.getColDef().comparator;
        if (null != r) return r;
        if (!i.getColDef().showRowGroup) return;
        const s = !t.group && i.getColDef().field;
        if (!s) return;
        const n = this.columnModel.getPrimaryColumn(s);
        return n ? n.getColDef().comparator : void 0
      }
      getValue(e, t) {
        var i, r;
        if (!this.primaryColumnsSortGroups) return this.valueService.getValue(t, e, !1, !1);
        if (e.rowGroupColumn === t) {
          if (this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive())) {
            const r = null == (i = e.allLeafChildren) ? void 0 : i[0];
            return r ? this.valueService.getValue(t, r, !1, !1) : void 0
          }
          const s = this.columnModel.getGroupDisplayColumnForGroup(t.getId());
          if (!s) return;
          return null == (r = e.groupData) ? void 0 : r[s.getId()]
        }
        return e.group && t.getColDef().showRowGroup ? void 0 : this.valueService.getValue(t, e, !1, !1)
      }
    };
    C([fe("valueService")], qc.prototype, "valueService", 2), C([fe("columnModel")], qc.prototype, "columnModel", 2), C([pe], qc.prototype, "init", 1), qc = C([ge("rowNodeSorter")], qc);
    var Qc = class extends ct {
      constructor() {
        super(...arguments), this.params = {}, this.ready = !1, this.readyCallbacks = []
      }
      checkReady() {
        const e = this.params;
        this.ready = null != e.gridCtrl && null != e.gridBodyCtrl && null != e.center && null != e.left && null != e.right && null != e.bottomCenter && null != e.bottomLeft && null != e.bottomRight && null != e.topCenter && null != e.topLeft && null != e.topRight && null != e.stickyTopCenter && null != e.stickyTopLeft && null != e.stickyTopRight && null != e.stickyBottomCenter && null != e.stickyBottomLeft && null != e.stickyBottomRight && null != e.centerHeader && null != e.leftHeader && null != e.rightHeader && null != e.fakeHScrollComp && null != e.fakeVScrollComp && null != e.gridHeaderCtrl, this.ready && (this.readyCallbacks.forEach(t => t(e)), this.readyCallbacks.length = 0)
      }
      whenReady(e) {
        this.ready ? e(this.params) : this.readyCallbacks.push(e)
      }
      register(e, t) {
        this.params[e] = t, this.checkReady()
      }
      registerHeaderContainer(e, t) {
        switch (t) {
          case "left":
            this.params.leftHeader = e;
            break;
          case "right":
            this.params.rightHeader = e;
            break;
          default:
            this.params.centerHeader = e
        }
        this.checkReady()
      }
      get(e) {
        return this.params[e]
      }
      getParams() {
        return this.params
      }
      getGridBodyCtrl() {
        return this.params.gridBodyCtrl
      }
      getHeaderRowContainerCtrls() {
        return [this.params.leftHeader, this.params.rightHeader, this.params.centerHeader]
      }
      getHeaderRowContainerCtrl(e) {
        switch (e) {
          case "left":
            return this.params.leftHeader;
          case "right":
            return this.params.rightHeader;
          default:
            return this.params.centerHeader
        }
      }
    };
    Qc.NAME = "ctrlsService", Qc = C([ge(Qc.NAME)], Qc);
    var Zc = class extends ct {
      constructor() {
        super(...arguments), this.registry = {}
      }
      register(e) {
        this.registry[e.controllerName] = e.controllerClass
      }
      getInstance(e) {
        const t = this.registry[e];
        if (null != t) return new t
      }
    };
    Zc = C([ge("ctrlsFactory")], Zc);
    var eh = class extends _s {
      constructor(e, t) {
        super(e), this.direction = t, this.hideTimeout = null
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", xi() || Gi())
      }
      initialiseInvisibleScrollbar() {
        void 0 === this.invisibleScrollbar && (this.invisibleScrollbar = Ki(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()))
      }
      addActiveListenerToggles() {
        const e = this.getGui();
        ["mouseenter", "mousedown", "touchstart"].forEach(t => this.addManagedListener(e, t, () => this.addOrRemoveCssClass("ag-scrollbar-active", !0))), ["mouseleave", "touchend"].forEach(t => this.addManagedListener(e, t, () => this.addOrRemoveCssClass("ag-scrollbar-active", !1)))
      }
      onScrollVisibilityChanged() {
        void 0 === this.invisibleScrollbar && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible())
      }
      hideAndShowInvisibleScrollAsNeeded() {
        this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL, e => {
          e.direction === this.direction && (null !== this.hideTimeout && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0))
        }), this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL_END, () => {
          this.hideTimeout = window.setTimeout(() => {
            this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null
          }, 400)
        })
      }
      attemptSettingScrollPosition(e) {
        const t = this.getViewport();
        ne(() => Lr(t), () => this.setScrollPosition(e), 100)
      }
      getViewport() {
        return this.eViewport
      }
      getContainer() {
        return this.eContainer
      }
      onScrollCallback(e) {
        this.addManagedListener(this.getViewport(), "scroll", e)
      }
    };
    C([ys("eViewport")], eh.prototype, "eViewport", 2), C([ys("eContainer")], eh.prototype, "eContainer", 2), C([fe("scrollVisibleService")], eh.prototype, "scrollVisibleService", 2), C([fe("ctrlsService")], eh.prototype, "ctrlsService", 2), C([fe("animationFrameService")], eh.prototype, "animationFrameService", 2);
    var th = class e extends eh {
      constructor() {
        super(e.TEMPLATE, "horizontal")
      }
      postConstruct() {
        super.postConstruct();
        const e = this.setFakeHScrollSpacerWidths.bind(this);
        this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new Ia(e => this.eContainer.style.width = `${e}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this))
      }
      initialiseInvisibleScrollbar() {
        void 0 === this.invisibleScrollbar && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom())
      }
      onPinnedRowDataChanged() {
        this.refreshCompBottom()
      }
      refreshCompBottom() {
        if (!this.invisibleScrollbar) return;
        const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
        this.getGui().style.bottom = `${e}px`
      }
      onScrollVisibilityChanged() {
        super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths()
      }
      setFakeHScrollSpacerWidths() {
        const e = this.scrollVisibleService.isVerticalScrollShowing();
        let t = this.columnModel.getDisplayedColumnsRightWidth();
        const i = !this.enableRtl && e,
          r = this.gos.getScrollbarWidth();
        i && (t += r), xr(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= r);
        let s = this.columnModel.getDisplayedColumnsLeftWidth();
        this.enableRtl && e && (s += r), xr(this.eLeftSpacer, s), this.eLeftSpacer.classList.toggle("ag-scroller-corner", s <= r)
      }
      setScrollVisible() {
        const e = this.scrollVisibleService.isHorizontalScrollShowing(),
          t = this.invisibleScrollbar,
          i = this.gos.get("suppressHorizontalScroll"),
          r = e && this.gos.getScrollbarWidth() || 0,
          s = i ? 0 : 0 === r && t ? 16 : r;
        this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Ur(this.getGui(), s), Ur(this.eViewport, s), Ur(this.eContainer, s), this.setDisplayed(e, {
          skipAriaHidden: !0
        })
      }
      getScrollPosition() {
        return Ar(this.getViewport(), this.enableRtl)
      }
      setScrollPosition(e) {
        Lr(this.getViewport()) || this.attemptSettingScrollPosition(e), vr(this.getViewport(), e, this.enableRtl)
      }
    };
    th.TEMPLATE = '<div class="ag-body-horizontal-scroll" aria-hidden="true">\n            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>\n            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">\n                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>\n            </div>\n            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>\n        </div>', C([ys("eLeftSpacer")], th.prototype, "eLeftSpacer", 2), C([ys("eRightSpacer")], th.prototype, "eRightSpacer", 2), C([fe("columnModel")], th.prototype, "columnModel", 2), C([fe("pinnedRowModel")], th.prototype, "pinnedRowModel", 2), C([pe], th.prototype, "postConstruct", 1);
    var ih = th,
      rh = class extends ct {
        postConstruct() {
          const e = this.checkContainerWidths.bind(this);
          this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedPropertyListener("domLayout", e)
        }
        checkContainerWidths() {
          const e = this.gos.isDomLayout("print"),
            t = e ? 0 : this.columnModel.getDisplayedColumnsLeftWidth(),
            i = e ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
          t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({
            type: Et.EVENT_LEFT_PINNED_WIDTH_CHANGED
          })), i != this.rightWidth && (this.rightWidth = i, this.eventService.dispatchEvent({
            type: Et.EVENT_RIGHT_PINNED_WIDTH_CHANGED
          }))
        }
        getPinnedRightWidth() {
          return this.rightWidth
        }
        getPinnedLeftWidth() {
          return this.leftWidth
        }
      };
    C([fe("columnModel")], rh.prototype, "columnModel", 2), C([pe], rh.prototype, "postConstruct", 1), rh = C([ge("pinnedWidthService")], rh);
    var sh = class extends ct {
      constructor() {
        super(...arguments), this.events = []
      }
      postConstruct() {
        "clientSide" == this.rowModel.getType() && (this.clientSideRowModel = this.rowModel)
      }
      dispatchExpanded(e, t) {
        if (null == this.clientSideRowModel) return void this.eventService.dispatchEvent(e);
        this.events.push(e);
        const i = () => {
          this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach(e => this.eventService.dispatchEvent(e)), this.events = []
        };
        t ? i() : (null == this.dispatchExpandedDebounced && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(i)), this.dispatchExpandedDebounced())
      }
    };
    C([fe("animationFrameService")], sh.prototype, "animationFrameService", 2), C([fe("rowModel")], sh.prototype, "rowModel", 2), C([pe], sh.prototype, "postConstruct", 1), sh = C([ge("rowNodeEventThrottle")], sh);
    var nh = (e, t) => {
        var i;
        return "clientSide" === (null != (i = t.rowModelType) ? i : "clientSide") ? {
          module: "@ag-grid-enterprise/row-grouping"
        } : null
      },
      oh = {
        enableRowGroup: nh,
        rowGroup: nh,
        rowGroupIndex: nh,
        enablePivot: nh,
        enableValue: nh,
        pivot: nh,
        pivotIndex: nh,
        aggFunc: nh,
        cellEditor: e => "agRichSelect" === e.cellEditor || "agRichSelectCellEditor" === e.cellEditor ? {
          module: "@ag-grid-enterprise/rich-select"
        } : null,
        menuTabs: e => {
          var t;
          const i = ["columnsMenuTab", "generalMenuTab"];
          return (null == (t = e.menuTabs) ? void 0 : t.some(e => i.includes(e))) ? {
            module: "@ag-grid-enterprise/menu"
          } : null
        },
        columnsMenuParams: {
          module: ["@ag-grid-enterprise/menu", "@ag-grid-enterprise/column-tool-panel"]
        },
        columnChooserParams: {
          module: ["@ag-grid-enterprise/menu", "@ag-grid-enterprise/column-tool-panel"]
        },
        headerCheckboxSelection: {
          supportedRowModels: ["clientSide", "serverSide"],
          dependencies: (e, {
            rowSelection: t
          }) => "multiple" === t ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
        },
        headerCheckboxSelectionFilteredOnly: {
          supportedRowModels: ["clientSide"],
          dependencies: (e, {
            rowSelection: t
          }) => "multiple" === t ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
        },
        headerCheckboxSelectionCurrentPageOnly: {
          supportedRowModels: ["clientSide"],
          dependencies: (e, {
            rowSelection: t
          }) => "multiple" === t ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
        },
        children: () => ah
      },
      ah = {
        objectName: "colDef",
        allProperties: Object.keys({
          headerName: void 0,
          columnGroupShow: void 0,
          headerClass: void 0,
          toolPanelClass: void 0,
          headerValueGetter: void 0,
          pivotKeys: void 0,
          groupId: void 0,
          colId: void 0,
          sort: void 0,
          initialSort: void 0,
          field: void 0,
          type: void 0,
          cellDataType: void 0,
          tooltipComponent: void 0,
          tooltipField: void 0,
          headerTooltip: void 0,
          cellClass: void 0,
          showRowGroup: void 0,
          filter: void 0,
          initialAggFunc: void 0,
          defaultAggFunc: void 0,
          aggFunc: void 0,
          pinned: void 0,
          initialPinned: void 0,
          chartDataType: void 0,
          cellAriaRole: void 0,
          cellEditorPopupPosition: void 0,
          headerGroupComponent: void 0,
          headerGroupComponentParams: void 0,
          cellStyle: void 0,
          cellRenderer: void 0,
          cellRendererParams: void 0,
          cellEditor: void 0,
          cellEditorParams: void 0,
          filterParams: void 0,
          pivotValueColumn: void 0,
          headerComponent: void 0,
          headerComponentParams: void 0,
          floatingFilterComponent: void 0,
          floatingFilterComponentParams: void 0,
          tooltipComponentParams: void 0,
          refData: void 0,
          columnsMenuParams: void 0,
          columnChooserParams: void 0,
          children: void 0,
          sortingOrder: void 0,
          allowedAggFuncs: void 0,
          menuTabs: void 0,
          pivotTotalColumnIds: void 0,
          cellClassRules: void 0,
          icons: void 0,
          sortIndex: void 0,
          initialSortIndex: void 0,
          flex: void 0,
          initialFlex: void 0,
          width: void 0,
          initialWidth: void 0,
          minWidth: void 0,
          maxWidth: void 0,
          rowGroupIndex: void 0,
          initialRowGroupIndex: void 0,
          pivotIndex: void 0,
          initialPivotIndex: void 0,
          suppressCellFlash: void 0,
          suppressColumnsToolPanel: void 0,
          suppressFiltersToolPanel: void 0,
          openByDefault: void 0,
          marryChildren: void 0,
          suppressStickyLabel: void 0,
          hide: void 0,
          initialHide: void 0,
          rowGroup: void 0,
          initialRowGroup: void 0,
          pivot: void 0,
          initialPivot: void 0,
          checkboxSelection: void 0,
          showDisabledCheckboxes: void 0,
          headerCheckboxSelection: void 0,
          headerCheckboxSelectionFilteredOnly: void 0,
          headerCheckboxSelectionCurrentPageOnly: void 0,
          suppressMenu: void 0,
          suppressHeaderMenuButton: void 0,
          suppressMovable: void 0,
          lockPosition: void 0,
          lockVisible: void 0,
          lockPinned: void 0,
          unSortIcon: void 0,
          suppressSizeToFit: void 0,
          suppressAutoSize: void 0,
          enableRowGroup: void 0,
          enablePivot: void 0,
          enableValue: void 0,
          editable: void 0,
          suppressPaste: void 0,
          suppressNavigable: void 0,
          enableCellChangeFlash: void 0,
          rowDrag: void 0,
          dndSource: void 0,
          autoHeight: void 0,
          wrapText: void 0,
          sortable: void 0,
          resizable: void 0,
          singleClickEdit: void 0,
          floatingFilter: void 0,
          cellEditorPopup: void 0,
          suppressFillHandle: void 0,
          wrapHeaderText: void 0,
          autoHeaderHeight: void 0,
          dndSourceOnRowDrag: void 0,
          valueGetter: void 0,
          valueSetter: void 0,
          filterValueGetter: void 0,
          keyCreator: void 0,
          valueFormatter: void 0,
          valueParser: void 0,
          comparator: void 0,
          equals: void 0,
          pivotComparator: void 0,
          suppressKeyboardEvent: void 0,
          suppressHeaderKeyboardEvent: void 0,
          colSpan: void 0,
          rowSpan: void 0,
          getQuickFilterText: void 0,
          onCellValueChanged: void 0,
          onCellClicked: void 0,
          onCellDoubleClicked: void 0,
          onCellContextMenu: void 0,
          rowDragText: void 0,
          tooltipValueGetter: void 0,
          cellRendererSelector: void 0,
          cellEditorSelector: void 0,
          suppressSpanHeaderHeight: void 0,
          useValueFormatterForExport: void 0,
          useValueParserForImport: void 0,
          mainMenuItems: void 0,
          contextMenuItems: void 0,
          suppressFloatingFilterButton: void 0,
          suppressHeaderFilterButton: void 0,
          suppressHeaderContextMenu: void 0,
          loadingCellRenderer: void 0,
          loadingCellRendererParams: void 0,
          loadingCellRendererSelector: void 0
        }),
        docsUrl: "column-properties/",
        deprecations: {
          columnsMenuParams: {
            version: "31.1",
            message: "Use `columnChooserParams` instead."
          },
          suppressMenu: {
            version: "31.1",
            message: "Use `suppressHeaderMenuButton` instead."
          },
          suppressCellFlash: {
            version: "31.2",
            message: "Use `enableCellChangeFlash={false}` in the ColDef"
          },
          dndSource: {
            version: "31.2",
            message: "This feature has been replaced by `Row Dragging to an External DropZone`."
          },
          dndSourceOnRowDrag: {
            version: "31.2",
            message: "This feature has been replaced by `Row Dragging to an External DropZone`."
          }
        },
        validations: oh
      },
      lh = {
        suppressContextMenu: !1,
        preventDefaultOnContextMenu: !1,
        allowContextMenuWithControlKey: !1,
        suppressMenuHide: !1,
        enableBrowserTooltips: !1,
        tooltipTrigger: "hover",
        tooltipShowDelay: 2e3,
        tooltipHideDelay: 1e4,
        tooltipMouseTrack: !1,
        tooltipShowMode: "standard",
        tooltipInteraction: !1,
        copyHeadersToClipboard: !1,
        copyGroupHeadersToClipboard: !1,
        clipboardDelimiter: "\t",
        suppressCopyRowsToClipboard: !1,
        suppressCopySingleCellRanges: !1,
        suppressLastEmptyLineOnPaste: !1,
        suppressClipboardPaste: !1,
        suppressClipboardApi: !1,
        suppressCutToClipboard: !1,
        maintainColumnOrder: !1,
        suppressFieldDotNotation: !1,
        allowDragFromColumnsToolPanel: !1,
        suppressMovableColumns: !1,
        suppressColumnMoveAnimation: !1,
        suppressDragLeaveHidesColumns: !1,
        suppressRowGroupHidesColumns: !1,
        suppressAutoSize: !1,
        autoSizePadding: 20,
        skipHeaderOnAutoSize: !1,
        singleClickEdit: !1,
        suppressClickEdit: !1,
        readOnlyEdit: !1,
        stopEditingWhenCellsLoseFocus: !1,
        enterNavigatesVertically: !1,
        enterNavigatesVerticallyAfterEdit: !1,
        enableCellEditingOnBackspace: !1,
        undoRedoCellEditing: !1,
        undoRedoCellEditingLimit: 10,
        suppressCsvExport: !1,
        suppressExcelExport: !1,
        cacheQuickFilter: !1,
        includeHiddenColumnsInQuickFilter: !1,
        excludeChildrenWhenTreeDataFiltering: !1,
        enableAdvancedFilter: !1,
        includeHiddenColumnsInAdvancedFilter: !1,
        enableCharts: !1,
        suppressChartToolPanelsButton: !1,
        masterDetail: !1,
        keepDetailRows: !1,
        keepDetailRowsCount: 10,
        detailRowAutoHeight: !1,
        tabIndex: 0,
        rowBuffer: 10,
        valueCache: !1,
        valueCacheNeverExpires: !1,
        enableCellExpressions: !1,
        suppressTouch: !1,
        suppressFocusAfterRefresh: !1,
        suppressAsyncEvents: !1,
        suppressBrowserResizeObserver: !1,
        suppressPropertyNamesCheck: !1,
        suppressChangeDetection: !1,
        debug: !1,
        suppressLoadingOverlay: !1,
        suppressNoRowsOverlay: !1,
        pagination: !1,
        paginationPageSize: 100,
        paginationPageSizeSelector: !0,
        paginationAutoPageSize: !1,
        paginateChildRows: !1,
        suppressPaginationPanel: !1,
        pivotMode: !1,
        pivotPanelShow: "never",
        pivotDefaultExpanded: 0,
        pivotSuppressAutoColumn: !1,
        suppressExpandablePivotGroups: !1,
        functionsReadOnly: !1,
        suppressAggFuncInHeader: !1,
        alwaysAggregateAtRootLevel: !1,
        aggregateOnlyChangedColumns: !1,
        suppressAggFilteredOnly: !1,
        removePivotHeaderRowWhenSingleValueColumn: !1,
        animateRows: !0,
        enableCellChangeFlash: !1,
        cellFlashDelay: 500,
        cellFlashDuration: 500,
        cellFadeDelay: 1e3,
        cellFadeDuration: 1e3,
        allowShowChangeAfterFilter: !1,
        domLayout: "normal",
        ensureDomOrder: !1,
        enableRtl: !1,
        suppressColumnVirtualisation: !1,
        suppressMaxRenderedRowRestriction: !1,
        suppressRowVirtualisation: !1,
        rowDragManaged: !1,
        suppressRowDrag: !1,
        suppressMoveWhenRowDragging: !1,
        rowDragEntireRow: !1,
        rowDragMultiRow: !1,
        embedFullWidthRows: !1,
        groupDisplayType: "singleColumn",
        groupDefaultExpanded: 0,
        groupMaintainOrder: !1,
        groupSelectsChildren: !1,
        groupIncludeTotalFooter: !1,
        groupSuppressBlankHeader: !1,
        groupSelectsFiltered: !1,
        showOpenedGroup: !1,
        groupRemoveSingleChildren: !1,
        groupRemoveLowestSingleChildren: !1,
        groupHideOpenParents: !1,
        groupAllowUnbalanced: !1,
        rowGroupPanelShow: "never",
        suppressMakeColumnVisibleAfterUnGroup: !1,
        treeData: !1,
        rowGroupPanelSuppressSort: !1,
        suppressGroupRowsSticky: !1,
        rowModelType: "clientSide",
        asyncTransactionWaitMillis: 50,
        suppressModelUpdateAfterUpdateTransaction: !1,
        cacheOverflowSize: 1,
        infiniteInitialRowCount: 1,
        serverSideInitialRowCount: 1,
        suppressServerSideInfiniteScroll: !1,
        cacheBlockSize: 100,
        maxBlocksInCache: -1,
        maxConcurrentDatasourceRequests: 2,
        blockLoadDebounceMillis: 0,
        purgeClosedRowNodes: !1,
        serverSideSortAllLevels: !1,
        serverSideOnlyRefreshFilteredGroups: !1,
        serverSideSortOnServer: !1,
        serverSideFilterOnServer: !1,
        serverSidePivotResultFieldSeparator: "_",
        viewportRowModelPageSize: 5,
        viewportRowModelBufferSize: 5,
        alwaysShowHorizontalScroll: !1,
        alwaysShowVerticalScroll: !1,
        debounceVerticalScrollbar: !1,
        suppressHorizontalScroll: !1,
        suppressScrollOnNewData: !1,
        suppressScrollWhenPopupsAreOpen: !1,
        suppressAnimationFrame: !1,
        suppressMiddleClickScrolls: !1,
        suppressPreventDefaultOnMouseWheel: !1,
        rowMultiSelectWithClick: !1,
        suppressRowDeselection: !1,
        suppressRowClickSelection: !1,
        suppressCellFocus: !1,
        suppressHeaderFocus: !1,
        suppressMultiRangeSelection: !1,
        enableCellTextSelection: !1,
        enableRangeSelection: !1,
        enableRangeHandle: !1,
        enableFillHandle: !1,
        fillHandleDirection: "xy",
        suppressClearOnFillReduction: !1,
        accentedSort: !1,
        unSortIcon: !1,
        suppressMultiSort: !1,
        alwaysMultiSort: !1,
        suppressMaintainUnsortedOrder: !1,
        suppressRowHoverHighlight: !1,
        suppressRowTransform: !1,
        columnHoverHighlight: !1,
        deltaSort: !1,
        enableGroupEdit: !1,
        suppressGroupMaintainValueType: !1,
        functionsPassive: !1,
        groupLockGroupColumns: 0,
        serverSideEnableClientSideSort: !1,
        suppressServerSideFullWidthLoadingRow: !1,
        pivotMaxGeneratedColumns: -1
      },
      ch = {
        sideBar: {
          module: "@ag-grid-enterprise/side-bar"
        },
        statusBar: {
          module: "@ag-grid-enterprise/status-bar"
        },
        enableCharts: {
          module: "@ag-grid-enterprise/charts"
        },
        getMainMenuItems: {
          module: "@ag-grid-enterprise/menu"
        },
        getContextMenuItems: {
          module: "@ag-grid-enterprise/menu"
        },
        allowContextMenuWithControlKey: {
          module: "@ag-grid-enterprise/menu"
        },
        enableAdvancedFilter: {
          module: "@ag-grid-enterprise/advanced-filter"
        },
        treeData: {
          supportedRowModels: ["clientSide", "serverSide"],
          module: "@ag-grid-enterprise/row-grouping",
          dependencies: e => {
            var t;
            const i = null != (t = e.rowModelType) ? t : "clientSide";
            switch (i) {
              case "clientSide":
                const t = `treeData requires 'getDataPath' in the ${i} row model.`;
                return e.getDataPath ? null : t;
              case "serverSide":
                const r = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${i} row model.`;
                return e.isServerSideGroup && e.getServerSideGroupKey ? null : r
            }
            return null
          }
        },
        masterDetail: {
          module: "@ag-grid-enterprise/master-detail"
        },
        enableRangeSelection: {
          module: "@ag-grid-enterprise/range-selection"
        },
        enableRangeHandle: {
          dependencies: {
            enableRangeSelection: [!0]
          }
        },
        enableFillHandle: {
          dependencies: {
            enableRangeSelection: [!0]
          }
        },
        groupDefaultExpanded: {
          supportedRowModels: ["clientSide"]
        },
        groupIncludeFooter: {
          supportedRowModels: ["clientSide", "serverSide"],
          dependencies: e => {
            var t;
            switch (null != (t = e.rowModelType) ? t : "clientSide") {
              case "clientSide":
                return null;
              case "serverSide":
                const t = "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll";
                return e.suppressServerSideInfiniteScroll ? t : null
            }
            return null
          }
        },
        groupIncludeTotalFooter: {
          supportedRowModels: ["clientSide"]
        },
        groupRemoveSingleChildren: {
          dependencies: {
            groupHideOpenParents: [void 0, !1],
            groupRemoveLowestSingleChildren: [void 0, !1]
          }
        },
        groupRemoveLowestSingleChildren: {
          dependencies: {
            groupHideOpenParents: [void 0, !1],
            groupRemoveSingleChildren: [void 0, !1]
          }
        },
        groupSelectsChildren: {
          dependencies: {
            rowSelection: ["multiple"]
          }
        },
        suppressParentsInRowNodes: {
          dependencies: {
            groupSelectsChildren: [void 0, !1]
          }
        },
        viewportDatasource: {
          supportedRowModels: ["viewport"],
          module: "@ag-grid-enterprise/viewport-row-model"
        },
        serverSideDatasource: {
          supportedRowModels: ["serverSide"],
          module: "@ag-grid-enterprise/server-side-row-model"
        },
        cacheBlockSize: {
          supportedRowModels: ["serverSide", "infinite"]
        },
        datasource: {
          supportedRowModels: ["infinite"],
          module: "@ag-grid-community/infinite-row-model"
        },
        rowData: {
          supportedRowModels: ["clientSide"],
          module: "@ag-grid-community/client-side-row-model"
        },
        columnDefs: () => ah,
        defaultColDef: () => ah,
        defaultColGroupDef: () => ah,
        autoGroupColumnDef: () => ah
      },
      hh = {
        objectName: "gridOptions",
        allProperties: [...Gt.ALL_PROPERTIES, ...Ht.EVENT_CALLBACKS],
        propertyExceptions: ["api", "columnApi"],
        docsUrl: "grid-options/",
        deprecations: {
          enableChartToolPanelsButton: {
            version: "29"
          },
          functionsPassive: {
            version: "29.2"
          },
          onColumnRowGroupChangeRequest: {
            version: "29.2"
          },
          onColumnPivotChangeRequest: {
            version: "29.2"
          },
          onColumnValueChangeRequest: {
            version: "29.2"
          },
          onColumnAggFuncChangeRequest: {
            version: "29.2"
          },
          serverSideFilterAllLevels: {
            version: "30",
            message: "All server-side group levels are now filtered by default. This can be toggled using `serverSideOnlyRefreshFilteredGroups`."
          },
          suppressAggAtRootLevel: {
            version: "30",
            message: "The root level aggregation is now suppressed by default. This can be toggled using  `alwaysAggregateAtRootLevel`."
          },
          excludeHiddenColumnsFromQuickFilter: {
            version: "30",
            message: "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `includeHiddenColumnsInQuickFilter`."
          },
          enterMovesDown: {
            version: "30",
            renamed: "enterNavigatesVertically"
          },
          enterMovesDownAfterEdit: {
            version: "30",
            renamed: "enterNavigatesVerticallyAfterEdit"
          },
          suppressParentsInRowNodes: {
            version: "30.2",
            message: "Using suppressParentsInRowNodes is no longer recommended. To serialize nodes it is now recommended to instead remove the parent node reference before serialization."
          },
          advancedFilterModel: {
            version: "31",
            message: "Use `initialState.filter.advancedFilterModel` instead."
          },
          suppressAsyncEvents: {
            version: "31",
            message: "Events should be handled asynchronously."
          },
          cellFadeDelay: {
            version: "31.1",
            renamed: "cellFadeDuration"
          },
          cellFlashDelay: {
            version: "31.1",
            renamed: "cellFlashDuration"
          },
          suppressServerSideInfiniteScroll: {
            version: "31.1"
          },
          serverSideSortOnServer: {
            version: "31.1"
          },
          serverSideFilterOnServer: {
            version: "31.1"
          },
          enableCellChangeFlash: {
            version: "31.2",
            message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns."
          },
          groupIncludeFooter: {
            version: "31.3",
            message: "Use `groupTotalRow` instead."
          },
          groupIncludeTotalFooter: {
            version: "31.3",
            message: "Use `grandTotalRow` instead."
          }
        },
        validations: ch
      },
      uh = class {
        constructor() {
          this.destroyed = !1, this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new Re, this.globalEventHandlerFactory = e => (t, i) => {
            if (this.destroyed) return;
            const r = gt.has(t);
            if (r && !e || !r && e) return;
            const s = Ht.getCallbackForEvent(t),
              n = this.gridOptions[s];
            "function" == typeof n && this.frameworkOverrides.wrapOutgoing(() => {
              n(i)
            })
          }
        }
        get context() {
          return this.gridOptions.context
        }
        init() {
          this.columnApi = new Tc(this.api);
          const e = !this.get("suppressAsyncEvents");
          this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), e), this.eventService.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.getScrollbarWidth()
        }
        destroy() {
          this.destroyed = !0, this.columnApi = void 0
        }
        get(e) {
          var t;
          return null != (t = this.gridOptions[e]) ? t : lh[e]
        }
        getCallback(e) {
          return this.mergeGridCommonParams(this.gridOptions[e])
        }
        exists(e) {
          return v(this.gridOptions[e])
        }
        mergeGridCommonParams(e) {
          if (e) {
            return t => {
              const i = t;
              return i.api = this.api, i.columnApi = this.columnApi, i.context = this.context, e(i)
            }
          }
          return e
        }
        static toBoolean(e) {
          return "boolean" == typeof e ? e : "string" == typeof e && ("TRUE" === e.toUpperCase() || "" == e)
        }
        static toNumber(e) {
          if ("number" == typeof e) return e;
          if ("string" == typeof e) {
            const t = parseInt(e);
            if (isNaN(t)) return;
            return t
          }
        }
        static toConstrainedNum(e, t) {
          return i => {
            const r = uh.toNumber(i);
            if (!(null == r || r < e || r > t)) return r
          }
        }
        static getCoercedValue(e, t) {
          const i = uh.PROPERTY_COERCIONS.get(e);
          return i ? i(t) : t
        }
        static getCoercedGridOptions(e) {
          const t = {};
          return Object.entries(e).forEach(([e, i]) => {
            const r = uh.getCoercedValue(e, i);
            t[e] = r
          }), t
        }
        updateGridOptions({
          options: e,
          force: t,
          source: i = "api"
        }) {
          const r = {
              id: uh.changeSetId++,
              properties: []
            },
            s = [];
          Object.entries(e).forEach(([e, n]) => {
            "api" === i && Ft[e] && z(`${e} is an initial property and cannot be updated.`);
            const o = uh.getCoercedValue(e, n),
              a = t || "object" == typeof o && "api" === i,
              l = this.gridOptions[e];
            if (a || l !== o) {
              this.gridOptions[e] = o;
              const t = {
                type: e,
                currentValue: o,
                previousValue: l,
                changeSet: r,
                source: i
              };
              s.push(t)
            }
          }), this.validationService.processGridOptions(this.gridOptions), r.properties = s.map(e => e.type), s.forEach(e => {
            this.gridOptions.debug && console.log(`AG Grid: Updated property ${e.type} from `, e.previousValue, " to  ", e.currentValue), this.propertyEventService.dispatchEvent(e)
          })
        }
        addEventListener(e, t) {
          this.propertyEventService.addEventListener(e, t)
        }
        removeEventListener(e, t) {
          this.propertyEventService.removeEventListener(e, t)
        }
        getScrollbarWidth() {
          if (null == this.scrollbarWidth) {
            const e = "number" == typeof this.gridOptions.scrollbarWidth && this.gridOptions.scrollbarWidth >= 0 ? this.gridOptions.scrollbarWidth : Wi();
            null != e && (this.scrollbarWidth = e, this.eventService.dispatchEvent({
              type: Et.EVENT_SCROLLBAR_WIDTH_CHANGED
            }))
          }
          return this.scrollbarWidth
        }
        isRowModelType(e) {
          return this.gridOptions.rowModelType === e || "clientSide" === e && N(this.gridOptions.rowModelType)
        }
        isDomLayout(e) {
          var t;
          return (null != (t = this.gridOptions.domLayout) ? t : "normal") === e
        }
        isRowSelection() {
          return "single" === this.gridOptions.rowSelection || "multiple" === this.gridOptions.rowSelection
        }
        useAsyncEvents() {
          return !this.get("suppressAsyncEvents")
        }
        isGetRowHeightFunction() {
          return "function" == typeof this.gridOptions.getRowHeight
        }
        getRowHeightForNode(e, t = !1, i) {
          if (null == i && (i = this.environment.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
            if (t) return {
              height: i,
              estimated: !0
            };
            const r = {
                node: e,
                data: e.data
              },
              s = this.getCallback("getRowHeight")(r);
            if (this.isNumeric(s)) return 0 === s && z("The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."), {
              height: Math.max(1, s),
              estimated: !1
            }
          }
          if (e.detail && this.get("masterDetail")) return this.getMasterDetailRowHeight();
          return {
            height: this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : i,
            estimated: !1
          }
        }
        getMasterDetailRowHeight() {
          return this.get("detailRowAutoHeight") ? {
            height: 1,
            estimated: !1
          } : this.isNumeric(this.gridOptions.detailRowHeight) ? {
            height: this.gridOptions.detailRowHeight,
            estimated: !1
          } : {
            height: 300,
            estimated: !1
          }
        }
        getRowHeightAsNumber() {
          if (!this.gridOptions.rowHeight || N(this.gridOptions.rowHeight)) return this.environment.getDefaultRowHeight();
          const e = this.environment.refreshRowHeightVariable();
          return -1 !== e ? e : (console.warn("AG Grid row height must be a number if not using standard row model"), this.environment.getDefaultRowHeight())
        }
        isNumeric(e) {
          return !isNaN(e) && "number" == typeof e && isFinite(e)
        }
        getDomDataKey() {
          return this.domDataKey
        }
        getDomData(e, t) {
          const i = e[this.getDomDataKey()];
          return i ? i[t] : void 0
        }
        setDomData(e, t, i) {
          const r = this.getDomDataKey();
          let s = e[r];
          N(s) && (s = {}, e[r] = s), s[t] = i
        }
        getDocument() {
          let e = null;
          return this.gridOptions.getDocument && v(this.gridOptions.getDocument) ? e = this.gridOptions.getDocument() : this.eGridDiv && (e = this.eGridDiv.ownerDocument), e && v(e) ? e : document
        }
        getWindow() {
          return this.getDocument().defaultView || window
        }
        getRootNode() {
          return this.eGridDiv.getRootNode()
        }
        getActiveDomElement() {
          return this.getRootNode().activeElement
        }
        getAsyncTransactionWaitMillis() {
          return v(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50
        }
        isAnimateRows() {
          return !this.get("ensureDomOrder") && this.get("animateRows")
        }
        isGroupRowsSticky() {
          return !(this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print"))
        }
        isColumnsSortingCoupledToGroup() {
          const e = this.gridOptions.autoGroupColumnDef;
          return !(null == e ? void 0 : e.comparator) && !this.get("treeData")
        }
        getGroupAggFiltering() {
          const e = this.gridOptions.groupAggFiltering;
          return "function" == typeof e ? this.getCallback("groupAggFiltering") : !0 === e ? () => !0 : void 0
        }
        getGrandTotalRow() {
          const e = this.gridOptions.grandTotalRow;
          if (e) return e;
          return this.gridOptions.groupIncludeTotalFooter ? "bottom" : void 0
        }
        getGroupTotalRowCallback() {
          const e = this.get("groupTotalRow");
          if ("function" == typeof e) return this.getCallback("groupTotalRow");
          if (e) return () => e;
          const t = this.get("groupIncludeFooter");
          if ("function" == typeof t) {
            const e = this.getCallback("groupIncludeFooter");
            return t => e(t) ? "bottom" : void 0
          }
          return () => t ? "bottom" : void 0
        }
        isGroupMultiAutoColumn() {
          return this.gridOptions.groupDisplayType ? "multipleColumns" === this.gridOptions.groupDisplayType : this.get("groupHideOpenParents")
        }
        isGroupUseEntireRow(e) {
          return !e && "groupRows" === this.gridOptions.groupDisplayType
        }
        getGridCommonParams() {
          return {
            api: this.api,
            columnApi: this.columnApi,
            context: this.context
          }
        }
        addGridCommonParams(e) {
          const t = e;
          return t.api = this.api, t.columnApi = this.columnApi, t.context = this.context, t
        }
      };
    uh.PROPERTY_COERCIONS = new Map([...Gt.BOOLEAN_PROPERTIES.map(e => [e, uh.toBoolean]), ...Gt.NUMBER_PROPERTIES.map(e => [e, uh.toNumber]), ["groupAggFiltering", e => "function" == typeof e ? e : uh.toBoolean(e)],
      ["pageSize", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["autoSizePadding", uh.toConstrainedNum(0, Number.MAX_VALUE)],
      ["keepDetailRowsCount", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["rowBuffer", uh.toConstrainedNum(0, Number.MAX_VALUE)],
      ["infiniteInitialRowCount", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["cacheOverflowSize", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["cacheBlockSize", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["serverSideInitialRowCount", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["viewportRowModelPageSize", uh.toConstrainedNum(1, Number.MAX_VALUE)],
      ["viewportRowModelBufferSize", uh.toConstrainedNum(0, Number.MAX_VALUE)]
    ]), uh.changeSetId = 0, C([fe("gridOptions")], uh.prototype, "gridOptions", 2), C([fe("eventService")], uh.prototype, "eventService", 2), C([fe("environment")], uh.prototype, "environment", 2), C([fe("frameworkOverrides")], uh.prototype, "frameworkOverrides", 2), C([fe("eGridDiv")], uh.prototype, "eGridDiv", 2), C([fe("validationService")], uh.prototype, "validationService", 2), C([fe("gridApi")], uh.prototype, "api", 2), C([pe], uh.prototype, "init", 1), C([Ee], uh.prototype, "destroy", 1), uh = C([ge("gridOptionsService")], uh);
    var dh = class extends ct {
      getLocaleTextFunc() {
        const e = this.gos.getCallback("getLocaleText");
        if (e) return (t, i, r) => e({
          key: t,
          defaultValue: i,
          variableValues: r
        });
        const t = this.gos.get("localeText");
        return (e, i, r) => {
          let s = t && t[e];
          if (s && r && r.length) {
            let e = 0;
            for (; !(e >= r.length);) {
              if (-1 === s.indexOf("${variable}")) break;
              s = s.replace("${variable}", r[e++])
            }
          }
          return null != s ? s : i
        }
      }
    };
    dh = C([ge("localeService")], dh);
    var ph = class e extends eh {
      constructor() {
        super(e.TEMPLATE, "vertical")
      }
      postConstruct() {
        super.postConstruct(), this.createManagedBean(new va(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedListener(this.eventService, Et.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onRowContainerHeightChanged.bind(this))
      }
      setScrollVisible() {
        const e = this.scrollVisibleService.isVerticalScrollShowing(),
          t = this.invisibleScrollbar,
          i = e && this.gos.getScrollbarWidth() || 0,
          r = 0 === i && t ? 16 : i;
        this.addOrRemoveCssClass("ag-scrollbar-invisible", t), xr(this.getGui(), r), xr(this.eViewport, r), xr(this.eContainer, r), this.setDisplayed(e, {
          skipAriaHidden: !0
        })
      }
      onRowContainerHeightChanged() {
        const {
          ctrlsService: e
        } = this, t = e.getGridBodyCtrl().getBodyViewportElement(), i = this.getScrollPosition(), r = t.scrollTop;
        i != r && this.setScrollPosition(r, !0)
      }
      getScrollPosition() {
        return this.getViewport().scrollTop
      }
      setScrollPosition(e, t) {
        t || Lr(this.getViewport()) || this.attemptSettingScrollPosition(e), this.getViewport().scrollTop = e
      }
    };
    ph.TEMPLATE = '<div class="ag-body-vertical-scroll" aria-hidden="true">\n            <div class="ag-body-vertical-scroll-viewport" ref="eViewport">\n                <div class="ag-body-vertical-scroll-container" ref="eContainer"></div>\n            </div>\n        </div>', C([pe], ph.prototype, "postConstruct", 1);
    var Eh = ph,
      gh = {
        january: "January",
        february: "February",
        march: "March",
        april: "April",
        may: "May",
        june: "June",
        july: "July",
        august: "August",
        september: "September",
        october: "October",
        november: "November",
        december: "December"
      },
      fh = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
      Th = class extends ct {
        constructor() {
          super(...arguments), this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = []
        }
        init() {
          this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
            this.groupHideOpenParents = this.gos.get("groupHideOpenParents")
          }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", e => {
            this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(Pt(e.source))
          })
        }
        processDataTypeDefinitions() {
          var e;
          const t = this.getDefaultDataTypes();
          this.dataTypeDefinitions = {}, Object.entries(t).forEach(([e, t]) => {
            this.dataTypeDefinitions[e] = T(f({}, t), {
              groupSafeValueFormatter: this.createGroupSafeValueFormatter(t)
            })
          });
          const i = null != (e = this.gos.get("dataTypeDefinitions")) ? e : {};
          this.dataTypeMatchers = {}, Object.entries(i).forEach(([e, r]) => {
            const s = this.processDataTypeDefinition(r, i, [e], t);
            s && (this.dataTypeDefinitions[e] = s, r.dataTypeMatcher && (this.dataTypeMatchers[e] = r.dataTypeMatcher))
          }), this.checkObjectValueHandlers(t), ["dateString", "text", "number", "boolean", "date"].forEach(e => {
            const i = this.dataTypeMatchers[e];
            i && delete this.dataTypeMatchers[e], this.dataTypeMatchers[e] = null != i ? i : t[e].dataTypeMatcher
          })
        }
        mergeDataTypeDefinitions(e, t) {
          const i = f(f({}, e), t);
          return e.columnTypes && t.columnTypes && t.appendColumnTypes && (i.columnTypes = [...this.convertColumnTypes(e.columnTypes), ...this.convertColumnTypes(t.columnTypes)]), i
        }
        processDataTypeDefinition(e, t, i, r) {
          let s;
          const n = e.extendsDataType;
          if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
            let i = r[n];
            const o = t[n];
            if (i && o && (i = o), !this.validateDataTypeDefinition(e, i, n)) return;
            s = this.mergeDataTypeDefinitions(i, e)
          } else {
            if (i.includes(n)) return void z('Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.');
            const o = t[n];
            if (!this.validateDataTypeDefinition(e, o, n)) return;
            const a = this.processDataTypeDefinition(o, t, [...i, n], r);
            if (!a) return;
            s = this.mergeDataTypeDefinitions(a, e)
          }
          return T(f({}, s), {
            groupSafeValueFormatter: this.createGroupSafeValueFormatter(s)
          })
        }
        validateDataTypeDefinition(e, t, i) {
          return t ? t.baseDataType === e.baseDataType || (z('The "baseDataType" property of a data type definition must match that of its parent.'), !1) : (z(`The data type definition ${i} does not exist.`), !1)
        }
        createGroupSafeValueFormatter(e) {
          if (e.valueFormatter) return t => {
            var i, r;
            if (null == (i = t.node) ? void 0 : i.group) {
              const i = t.column.getAggFunc();
              if (i) {
                if ("first" === i || "last" === i) return e.valueFormatter(t);
                if ("number" === e.baseDataType && "count" !== i) {
                  if ("number" == typeof t.value) return e.valueFormatter(t);
                  if ("object" == typeof t.value) {
                    if (!t.value) return;
                    if ("toNumber" in t.value) return e.valueFormatter(T(f({}, t), {
                      value: t.value.toNumber()
                    }));
                    if ("value" in t.value) return e.valueFormatter(T(f({}, t), {
                      value: t.value.value
                    }))
                  }
                }
              }
              if (!this.gos.get("suppressGroupMaintainValueType")) return
            } else if (this.groupHideOpenParents && t.column.isRowGroupActive()) {
              if ("string" != typeof t.value || (null == (r = e.dataTypeMatcher) ? void 0 : r.call(e, t.value))) return e.valueFormatter(t);
              if (!this.gos.get("suppressGroupMaintainValueType")) return
            }
            return e.valueFormatter(t)
          }
        }
        updateColDefAndGetDataTypeDefinitionColumnType(e, t, i) {
          let {
            cellDataType: r
          } = t;
          const {
            field: s
          } = t;
          if (void 0 === r && (r = e.cellDataType), null != r && !0 !== r || (r = !!this.canInferCellDataType(e, t) && this.inferCellDataType(s, i)), !r) return void(e.cellDataType = !1);
          const n = this.dataTypeDefinitions[r];
          if (n) return e.cellDataType = r, n.groupSafeValueFormatter && (e.valueFormatter = n.groupSafeValueFormatter), n.valueParser && (e.valueParser = n.valueParser), n.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, n, i), n.columnTypes;
          z(`Missing data type definition - "${r}"`)
        }
        updateColDefAndGetColumnType(e, t, i) {
          var r, s;
          const n = this.updateColDefAndGetDataTypeDefinitionColumnType(e, t, i),
            o = null != (s = null != (r = t.type) ? r : n) ? s : e.type;
          return e.type = o, o ? this.convertColumnTypes(o) : void 0
        }
        addColumnListeners(e) {
          if (!this.isWaitingForRowData) return;
          const t = this.columnStateUpdatesPendingInference[e.getColId()];
          if (!t) return;
          const i = e => {
            t.add(e.key)
          };
          e.addEventListener(Le.EVENT_STATE_UPDATED, i), this.columnStateUpdateListenerDestroyFuncs.push(() => e.removeEventListener(Le.EVENT_STATE_UPDATED, i))
        }
        canInferCellDataType(e, t) {
          var i;
          if ("clientSide" !== this.rowModel.getType()) return !1;
          const r = {
            cellRenderer: !0,
            valueGetter: !0,
            valueParser: !0,
            refData: !0
          };
          if (this.doColDefPropsPreventInference(t, r)) return !1;
          const s = null === t.type ? e.type : t.type;
          if (s) {
            const e = null != (i = this.gos.get("columnTypes")) ? i : {};
            if (this.convertColumnTypes(s).some(t => {
                const i = e[t.trim()];
                return i && this.doColDefPropsPreventInference(i, r)
              })) return !1
          }
          return !this.doColDefPropsPreventInference(e, r)
        }
        doColDefPropsPreventInference(e, t) {
          return [
            ["cellRenderer", "agSparklineCellRenderer"],
            ["valueGetter", void 0],
            ["valueParser", void 0],
            ["refData", void 0]
          ].some(([i, r]) => this.doesColDefPropPreventInference(e, t, i, r))
        }
        doesColDefPropPreventInference(e, t, i, r) {
          if (!t[i]) return !1;
          const s = e[i];
          return null === s ? (t[i] = !1, !1) : void 0 === r ? !!s : s === r
        }
        inferCellDataType(e, t) {
          var i;
          if (!e) return;
          let r;
          const s = this.getInitialData();
          if (s) {
            const t = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
            r = B(s, e, t)
          } else this.initWaitForRowData(t);
          if (null == r) return;
          const [n] = null != (i = Object.entries(this.dataTypeMatchers).find(([e, t]) => t(r))) ? i : ["object"];
          return n
        }
        getInitialData() {
          const e = this.gos.get("rowData");
          if (null == e ? void 0 : e.length) return e[0];
          if (this.initialData) return this.initialData; {
            const e = this.rowModel.getRootNode().allLeafChildren;
            if (null == e ? void 0 : e.length) return e[0].data
          }
          return null
        }
        initWaitForRowData(e) {
          if (this.columnStateUpdatesPendingInference[e] = new Set, this.isWaitingForRowData) return;
          this.isWaitingForRowData = !0;
          const t = this.isColumnTypeOverrideInDataTypeDefinitions;
          t && this.columnModel.queueResizeOperations();
          const i = this.addManagedListener(this.eventService, Et.EVENT_ROW_DATA_UPDATE_STARTED, e => {
            const {
              firstRowData: r
            } = e;
            if (!r) return;
            null == i || i(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(r, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations();
            const s = {
              type: Et.EVENT_DATA_TYPES_INFERRED
            };
            this.eventService.dispatchEvent(s)
          })
        }
        isPendingInference() {
          return this.isWaitingForRowData
        }
        processColumnsPendingInference(e, t) {
          this.initialData = e;
          const i = [];
          this.columnStateUpdateListenerDestroyFuncs.forEach(e => e()), this.columnStateUpdateListenerDestroyFuncs = [];
          const r = {},
            s = {};
          Object.entries(this.columnStateUpdatesPendingInference).forEach(([e, n]) => {
            const o = this.columnModel.getGridColumn(e);
            if (!o) return;
            const a = o.getColDef();
            if (!this.columnModel.resetColumnDefIntoColumn(o, "cellDataTypeInferred")) return;
            const l = o.getColDef();
            if (t && l.type && l.type !== a.type) {
              const t = this.getUpdatedColumnState(o, n);
              t.rowGroup && null == t.rowGroupIndex && (r[e] = t), t.pivot && null == t.pivotIndex && (s[e] = t), i.push(t)
            }
          }), t && i.push(...this.columnModel.generateColumnStateForRowGroupAndPivotIndexes(r, s)), i.length && this.columnModel.applyColumnState({
            state: i
          }, "cellDataTypeInferred"), this.initialData = null
        }
        getUpdatedColumnState(e, t) {
          const i = this.columnModel.getColumnStateFromColDef(e);
          return t.forEach(e => {
            delete i[e], "rowGroup" === e ? delete i.rowGroupIndex : "pivot" === e && delete i.pivotIndex
          }), i
        }
        checkObjectValueHandlers(e) {
          const t = this.dataTypeDefinitions.object,
            i = e.object;
          this.hasObjectValueParser = t.valueParser !== i.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== i.valueFormatter
        }
        convertColumnTypes(e) {
          let t = [];
          if (e instanceof Array) {
            e.some(e => "string" != typeof e) ? console.warn("if colDef.type is supplied an array it should be of type 'string[]'") : t = e
          } else "string" == typeof e ? t = e.split(",") : console.warn("colDef.type should be of type 'string' | 'string[]'");
          return t
        }
        getDateStringTypeDefinition(e) {
          var t;
          return e && null != (t = this.getDataTypeDefinition(e)) ? t : this.dataTypeDefinitions.dateString
        }
        getDateParserFunction(e) {
          return this.getDateStringTypeDefinition(e).dateParser
        }
        getDateFormatterFunction(e) {
          return this.getDateStringTypeDefinition(e).dateFormatter
        }
        getDataTypeDefinition(e) {
          const t = e.getColDef();
          if (t.cellDataType) return this.dataTypeDefinitions[t.cellDataType]
        }
        getBaseDataType(e) {
          var t;
          return null == (t = this.getDataTypeDefinition(e)) ? void 0 : t.baseDataType
        }
        checkType(e, t) {
          var i;
          if (null == t) return !0;
          const r = null == (i = this.getDataTypeDefinition(e)) ? void 0 : i.dataTypeMatcher;
          return !r || r(t)
        }
        validateColDef(e) {
          "object" === e.cellDataType && (e.valueFormatter !== this.dataTypeDefinitions.object.groupSafeValueFormatter || this.hasObjectValueFormatter || z('Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && z('Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'))
        }
        setColDefPropertiesForBaseDataType(e, t, i) {
          const r = (e, i, r) => {
              let s = e.getColDef().valueFormatter;
              return s === t.groupSafeValueFormatter && (s = t.valueFormatter), this.valueService.formatValue(e, i, r, s)
            },
            s = he.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId()),
            n = this.localeService.getLocaleTextFunc(),
            o = t => {
              const {
                filterParams: i
              } = e;
              e.filterParams = "object" == typeof i ? f(f({}, i), t) : t
            };
          switch (t.baseDataType) {
            case "number":
              e.cellEditor = "agNumberCellEditor", s && o({
                comparator: (e, t) => {
                  const i = null == e ? 0 : parseInt(e),
                    r = null == t ? 0 : parseInt(t);
                  return i === r ? 0 : i > r ? 1 : -1
                }
              });
              break;
            case "boolean":
              e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = e => !!e.colDef.editable && e.event.key === ts.SPACE, o(s ? {
                valueFormatter: e => v(e.value) ? n(String(e.value), e.value ? "True" : "False") : n("blanks", "(Blanks)")
              } : {
                maxNumConditions: 1,
                debounceMs: 0,
                filterOptions: ["empty", {
                  displayKey: "true",
                  displayName: "True",
                  predicate: (e, t) => t,
                  numberOfInputs: 0
                }, {
                  displayKey: "false",
                  displayName: "False",
                  predicate: (e, t) => !1 === t,
                  numberOfInputs: 0
                }]
              });
              break;
            case "date":
              e.cellEditor = "agDateCellEditor", e.keyCreator = e => r(e.column, e.node, e.value), s && o({
                valueFormatter: e => {
                  const t = r(e.column, e.node, e.value);
                  return v(t) ? t : n("blanks", "(Blanks)")
                },
                treeList: !0,
                treeListFormatter: (e, t) => {
                  if (1 === t && null != e) {
                    const t = fh[Number(e) - 1];
                    return n(t, gh[t])
                  }
                  return null != e ? e : n("blanks", "(Blanks)")
                }
              });
              break;
            case "dateString": {
              e.cellEditor = "agDateStringCellEditor", e.keyCreator = e => r(e.column, e.node, e.value);
              const i = t.dateParser;
              o(s ? {
                valueFormatter: e => {
                  const t = r(e.column, e.node, e.value);
                  return v(t) ? t : n("blanks", "(Blanks)")
                },
                treeList: !0,
                treeListPathGetter: e => {
                  const t = i(null != e ? e : void 0);
                  return t ? [String(t.getFullYear()), String(t.getMonth() + 1), String(t.getDate())] : null
                },
                treeListFormatter: (e, t) => {
                  if (1 === t && null != e) {
                    const t = fh[Number(e) - 1];
                    return n(t, gh[t])
                  }
                  return null != e ? e : n("blanks", "(Blanks)")
                }
              } : {
                comparator: (e, t) => {
                  const r = i(t);
                  return null == t || r < e ? -1 : r > e ? 1 : 0
                }
              });
              break
            }
            case "object":
              e.cellEditorParams = {
                useFormatter: !0
              }, e.comparator = (e, t) => {
                const s = this.columnModel.getPrimaryColumn(i),
                  n = null == s ? void 0 : s.getColDef();
                if (!s || !n) return 0;
                const o = null == e ? "" : r(s, null, e),
                  a = null == t ? "" : r(s, null, t);
                return o === a ? 0 : o > a ? 1 : -1
              }, e.keyCreator = e => r(e.column, e.node, e.value), s ? o({
                valueFormatter: e => {
                  const t = r(e.column, e.node, e.value);
                  return v(t) ? t : n("blanks", "(Blanks)")
                }
              }) : e.filterValueGetter = e => r(e.column, e.node, this.valueService.getValue(e.column, e.node))
          }
        }
        getDefaultDataTypes() {
          const e = e => !!e.match("^\\d{4}-\\d{2}-\\d{2}$"),
            t = this.localeService.getLocaleTextFunc();
          return {
            number: {
              baseDataType: "number",
              valueParser: e => {
                var t, i;
                return "" === (null == (i = null == (t = e.newValue) ? void 0 : t.trim) ? void 0 : i.call(t)) ? null : Number(e.newValue)
              },
              valueFormatter: e => null == e.value ? "" : "number" != typeof e.value || isNaN(e.value) ? t("invalidNumber", "Invalid Number") : String(e.value),
              dataTypeMatcher: e => "number" == typeof e
            },
            text: {
              baseDataType: "text",
              valueParser: e => "" === e.newValue ? null : O(e.newValue),
              dataTypeMatcher: e => "string" == typeof e
            },
            boolean: {
              baseDataType: "boolean",
              valueParser: e => {
                var t, i;
                return null == e.newValue ? e.newValue : "" === (null == (i = null == (t = e.newValue) ? void 0 : t.trim) ? void 0 : i.call(t)) ? null : "true" === String(e.newValue).toLowerCase()
              },
              valueFormatter: e => null == e.value ? "" : String(e.value),
              dataTypeMatcher: e => "boolean" == typeof e
            },
            date: {
              baseDataType: "date",
              valueParser: e => sr(null == e.newValue ? null : String(e.newValue)),
              valueFormatter: e => {
                var i;
                return null == e.value ? "" : e.value instanceof Date && !isNaN(e.value.getTime()) ? null != (i = tr(e.value, !1)) ? i : "" : t("invalidDate", "Invalid Date")
              },
              dataTypeMatcher: e => e instanceof Date
            },
            dateString: {
              baseDataType: "dateString",
              dateParser: e => {
                var t;
                return null != (t = sr(e)) ? t : void 0
              },
              dateFormatter: e => {
                var t;
                return null != (t = tr(null != e ? e : null, !1)) ? t : void 0
              },
              valueParser: t => e(String(t.newValue)) ? t.newValue : null,
              valueFormatter: t => e(String(t.value)) ? t.value : "",
              dataTypeMatcher: t => "string" == typeof t && e(t)
            },
            object: {
              baseDataType: "object",
              valueParser: () => null,
              valueFormatter: e => {
                var t;
                return null != (t = O(e.value)) ? t : ""
              }
            }
          }
        }
      };
    C([fe("rowModel")], Th.prototype, "rowModel", 2), C([fe("columnModel")], Th.prototype, "columnModel", 2), C([fe("valueService")], Th.prototype, "valueService", 2), C([pe], Th.prototype, "init", 1), Th = C([ge("dataTypeService")], Th);
    var mh = class extends ct {
      constructor() {
        super(...arguments), this.waitingForColumns = !1
      }
      postConstruct() {
        this.addManagedPropertyListener("columnDefs", e => this.setColumnDefs(e))
      }
      start() {
        this.ctrlsService.whenReady(() => {
          const e = this.gos.get("columnDefs");
          e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady()
        })
      }
      setColumnsAndData(e) {
        this.columnModel.setColumnDefs(null != e ? e : [], "gridInitializing"), this.rowModel.start()
      }
      gridReady() {
        this.dispatchGridReadyEvent();
        const e = he.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId());
        new Rc("AG Grid", () => this.gos.get("debug")).log(`initialised successfully, enterprise = ${e}`)
      }
      dispatchGridReadyEvent() {
        const e = {
          type: Et.EVENT_GRID_READY
        };
        this.eventService.dispatchEvent(e)
      }
      setColumnDefs(e) {
        const t = this.gos.get("columnDefs");
        if (t) return this.waitingForColumns ? (this.waitingForColumns = !1, void this.setColumnsAndData(t)) : void this.columnModel.setColumnDefs(t, Pt(e.source))
      }
    };
    C([fe("ctrlsService")], mh.prototype, "ctrlsService", 2), C([fe("columnModel")], mh.prototype, "columnModel", 2), C([fe("rowModel")], mh.prototype, "rowModel", 2), C([pe], mh.prototype, "postConstruct", 1), mh = C([ge("syncService")], mh);
    var Ch = class extends ct {
      constructor() {
        super(...arguments), this.manuallyDisplayed = !1
      }
      postConstruct() {
        this.addManagedListener(this.eventService, Et.EVENT_ROW_DATA_UPDATED, () => this.onRowDataUpdated()), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded())
      }
      registerOverlayWrapperComp(e) {
        this.overlayWrapperComp = e, (!this.gos.get("columnDefs") || this.gos.isRowModelType("clientSide") && !this.gos.get("rowData")) && this.showLoadingOverlay()
      }
      showLoadingOverlay() {
        if (this.gos.get("suppressLoadingOverlay")) return;
        const e = this.userComponentFactory.getLoadingOverlayCompDetails({});
        this.showOverlay(e, "ag-overlay-loading-wrapper", "loadingOverlayComponentParams")
      }
      showNoRowsOverlay() {
        if (this.gos.get("suppressNoRowsOverlay")) return;
        const e = this.userComponentFactory.getNoRowsOverlayCompDetails({});
        this.showOverlay(e, "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams")
      }
      showOverlay(e, t, i) {
        const r = e.newAgStackInstance(),
          s = this.addManagedPropertyListener(i, ({
            currentValue: e
          }) => {
            r.then(t => {
              t.refresh && t.refresh(this.gos.addGridCommonParams(f({}, null != e ? e : {})))
            })
          });
        this.manuallyDisplayed = this.columnModel.isReady() && !this.paginationProxy.isEmpty(), this.overlayWrapperComp.showOverlay(r, t, s)
      }
      hideOverlay() {
        this.manuallyDisplayed = !1, this.overlayWrapperComp.hideOverlay()
      }
      showOrHideOverlay() {
        const e = this.paginationProxy.isEmpty(),
          t = this.gos.get("suppressNoRowsOverlay");
        e && !t ? this.showNoRowsOverlay() : this.hideOverlay()
      }
      onRowDataUpdated() {
        this.showOrHideOverlay()
      }
      onNewColumnsLoaded() {
        !this.columnModel.isReady() || this.paginationProxy.isEmpty() || this.manuallyDisplayed || this.hideOverlay()
      }
    };
    C([fe("userComponentFactory")], Ch.prototype, "userComponentFactory", 2), C([fe("paginationProxy")], Ch.prototype, "paginationProxy", 2), C([fe("columnModel")], Ch.prototype, "columnModel", 2), C([pe], Ch.prototype, "postConstruct", 1), Ch = C([ge("overlayService")], Ch);
    var Sh = class extends ct {
      constructor() {
        super(...arguments), this.suppressEvents = !0, this.queuedUpdateSources = new Set, this.dispatchStateUpdateEventDebounced = re(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = re(() => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), 0), this.onRowSelectedDebounced = re(() => {
          this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState())
        }, 0), this.staleStateKeys = new Set
      }
      postConstruct() {
        var e;
        this.isClientSideRowModel = "clientSide" === this.rowModel.getType(), this.cachedState = null != (e = this.gos.get("initialState")) ? e : {}, this.ctrlsService.whenReady(() => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
        const t = this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, ({
            source: e
          }) => {
            "gridInitializing" === e && (null == t || t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()))
          }),
          i = this.addManagedListener(this.eventService, Et.EVENT_ROW_COUNT_READY, () => {
            null == i || i(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady())
          }),
          r = this.addManagedListener(this.eventService, Et.EVENT_FIRST_DATA_RENDERED, () => {
            null == r || r(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered())
          })
      }
      getState() {
        return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState
      }
      setupStateOnGridReady() {
        this.updateCachedState("sideBar", this.getSideBarState()), this.addManagedListener(this.eventService, Et.EVENT_TOOL_PANEL_VISIBLE_CHANGED, () => this.updateCachedState("sideBar", this.getSideBarState())), this.addManagedListener(this.eventService, Et.EVENT_SIDE_BAR_UPDATED, () => this.updateCachedState("sideBar", this.getSideBarState()))
      }
      setupStateOnColumnsInitialised() {
        var e;
        const t = null != (e = this.gos.get("initialState")) ? e : {};
        this.setColumnState(t), this.setColumnGroupState(t), this.updateColumnState(["aggregation", "columnOrder", "columnPinning", "columnSizing", "columnVisibility", "pivot", "pivot", "rowGroup", "sort"]), this.updateCachedState("columnGroup", this.getColumnGroupState()), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VALUE_CHANGED, () => this.updateColumnState(["aggregation"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_MOVED, () => this.updateColumnState(["columnOrder"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PINNED, () => this.updateColumnState(["columnPinning"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_RESIZED, () => this.updateColumnState(["columnSizing"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VISIBLE, () => this.updateColumnState(["columnVisibility"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_CHANGED, () => this.updateColumnState(["pivot"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.updateColumnState(["pivot"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateColumnState(["rowGroup"])), this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, () => this.updateColumnState(["sort"])), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, () => this.updateColumnState(["aggregation", "columnOrder", "columnPinning", "columnSizing", "columnVisibility", "pivot", "pivot", "rowGroup", "sort"])), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_GROUP_OPENED, () => this.updateCachedState("columnGroup", this.getColumnGroupState()))
      }
      setupStateOnRowCountReady() {
        var e;
        const {
          filter: t,
          rowGroupExpansion: i,
          rowSelection: r,
          pagination: s
        } = null != (e = this.gos.get("initialState")) ? e : {}, n = this.gos.get("advancedFilterModel");
        (t || n) && this.setFilterState(t, n), i && this.setRowGroupExpansionState(i), r && this.setRowSelectionState(r), s && this.setPaginationState(s), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState()), this.addManagedListener(this.eventService, Et.EVENT_FILTER_CHANGED, () => this.updateCachedState("filter", this.getFilterState())), this.addManagedListener(this.eventService, Et.EVENT_ROW_GROUP_OPENED, () => this.onRowGroupOpenedDebounced()), this.addManagedListener(this.eventService, Et.EVENT_EXPAND_COLLAPSE_ALL, () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState())), this.addManagedListener(this.eventService, Et.EVENT_SELECTION_CHANGED, () => {
          this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced()
        }), this.addManagedListener(this.eventService, Et.EVENT_PAGINATION_CHANGED, e => {
          (e.newPage || e.newPageSize) && this.updateCachedState("pagination", this.getPaginationState())
        })
      }
      setupStateOnFirstDataRendered() {
        var e;
        const {
          scroll: t,
          rangeSelection: i,
          focusedCell: r,
          columnOrder: s
        } = null != (e = this.gos.get("initialState")) ? e : {};
        r && this.setFocusedCellState(r), i && this.setRangeSelectionState(i), t && this.setScrollState(t), this.setColumnPivotState(!!(null == s ? void 0 : s.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState()), this.updateCachedState("rangeSelection", this.getRangeSelectionState()), this.updateCachedState("scroll", this.getScrollState()), this.addManagedListener(this.eventService, Et.EVENT_CELL_FOCUSED, () => this.updateCachedState("focusedCell", this.getFocusedCellState())), this.addManagedListener(this.eventService, Et.EVENT_RANGE_SELECTION_CHANGED, e => {
          e.finished && this.updateCachedState("rangeSelection", this.getRangeSelectionState())
        }), this.addManagedListener(this.eventService, Et.EVENT_BODY_SCROLL_END, () => this.updateCachedState("scroll", this.getScrollState()))
      }
      getColumnState() {
        const e = this.columnModel.isPivotMode(),
          t = [],
          i = [],
          r = [],
          s = [],
          n = [],
          o = [],
          a = [],
          l = [],
          c = [],
          h = this.columnModel.getColumnState();
        for (let e = 0; e < h.length; e++) {
          const {
            colId: u,
            sort: d,
            sortIndex: p,
            rowGroup: E,
            rowGroupIndex: g,
            aggFunc: f,
            pivot: T,
            pivotIndex: m,
            pinned: C,
            hide: S,
            width: R,
            flex: A
          } = h[e];
          c.push(u), d && (t[null != p ? p : 0] = {
            colId: u,
            sort: d
          }), E && (i[null != g ? g : 0] = u), "string" == typeof f && r.push({
            colId: u,
            aggFunc: f
          }), T && (s[null != m ? m : 0] = u), C && ("right" === C ? o : n).push(u), S && a.push(u), (A || R) && l.push({
            colId: u,
            flex: null != A ? A : void 0,
            width: R
          })
        }
        return {
          sort: t.length ? {
            sortModel: t
          } : void 0,
          rowGroup: i.length ? {
            groupColIds: i
          } : void 0,
          aggregation: r.length ? {
            aggregationModel: r
          } : void 0,
          pivot: s.length || e ? {
            pivotMode: e,
            pivotColIds: s
          } : void 0,
          columnPinning: n.length || o.length ? {
            leftColIds: n,
            rightColIds: o
          } : void 0,
          columnVisibility: a.length ? {
            hiddenColIds: a
          } : void 0,
          columnSizing: l.length ? {
            columnSizingModel: l
          } : void 0,
          columnOrder: c.length ? {
            orderedColIds: c
          } : void 0
        }
      }
      setColumnState(e) {
        const {
          sort: t,
          rowGroup: i,
          aggregation: r,
          pivot: s,
          columnPinning: n,
          columnVisibility: o,
          columnSizing: a,
          columnOrder: l
        } = e, c = {}, h = e => {
          let t = c[e];
          return t || (t = {
            colId: e
          }, c[e] = t, t)
        };
        t && t.sortModel.forEach(({
          colId: e,
          sort: t
        }, i) => {
          const r = h(e);
          r.sort = t, r.sortIndex = i
        }), i && i.groupColIds.forEach((e, t) => {
          const i = h(e);
          i.rowGroup = !0, i.rowGroupIndex = t
        }), r && r.aggregationModel.forEach(({
          colId: e,
          aggFunc: t
        }) => {
          h(e).aggFunc = t
        }), s && (s.pivotColIds.forEach((e, t) => {
          const i = h(e);
          i.pivot = !0, i.pivotIndex = t
        }), this.gos.updateGridOptions({
          options: {
            pivotMode: s.pivotMode
          },
          source: "gridInitializing"
        })), n && (n.leftColIds.forEach(e => {
          h(e).pinned = "left"
        }), n.rightColIds.forEach(e => {
          h(e).pinned = "right"
        })), o && o.hiddenColIds.forEach(e => {
          h(e).hide = !0
        }), a && a.columnSizingModel.forEach(({
          colId: e,
          flex: t,
          width: i
        }) => {
          const r = h(e);
          r.flex = null != t ? t : null, r.width = i
        });
        const u = null == l ? void 0 : l.orderedColIds,
          d = !!(null == u ? void 0 : u.length),
          p = d ? u.map(e => h(e)) : Object.values(c);
        if (p.length) {
          this.columnStates = p;
          const e = {
            sort: null,
            sortIndex: null,
            rowGroup: null,
            rowGroupIndex: null,
            aggFunc: null,
            pivot: null,
            pivotIndex: null,
            pinned: null,
            hide: null,
            flex: null
          };
          this.columnModel.applyColumnState({
            state: p,
            applyOrder: d,
            defaultState: e
          }, "gridInitializing")
        }
      }
      setColumnPivotState(e) {
        const t = this.columnStates;
        this.columnStates = void 0;
        const i = this.columnGroupStates;
        if (this.columnGroupStates = void 0, this.columnModel.isSecondaryColumnsPresent()) {
          if (t) {
            let i = [];
            for (const e of t) this.columnModel.getSecondaryColumn(e.colId) && i.push(e);
            this.columnModel.applyColumnState({
              state: i,
              applyOrder: e
            }, "gridInitializing")
          }
          i && this.columnModel.setColumnGroupState(i, "gridInitializing")
        }
      }
      getColumnGroupState() {
        const e = this.columnModel.getColumnGroupState(),
          t = [];
        return e.forEach(({
          groupId: e,
          open: i
        }) => {
          i && t.push(e)
        }), t.length ? {
          openColumnGroupIds: t
        } : void 0
      }
      setColumnGroupState(e) {
        var t;
        if (!e.hasOwnProperty("columnGroup")) return;
        const i = new Set(null == (t = e.columnGroup) ? void 0 : t.openColumnGroupIds),
          r = this.columnModel.getColumnGroupState().map(({
            groupId: e
          }) => {
            const t = i.has(e);
            return t && i.delete(e), {
              groupId: e,
              open: t
            }
          });
        i.forEach(e => {
          r.push({
            groupId: e,
            open: !0
          })
        }), r.length && (this.columnGroupStates = r), this.columnModel.setColumnGroupState(r, "gridInitializing")
      }
      getFilterState() {
        var e;
        let t = this.filterManager.getFilterModel();
        t && 0 === Object.keys(t).length && (t = void 0);
        const i = null != (e = this.filterManager.getAdvancedFilterModel()) ? e : void 0;
        return t || i ? {
          filterModel: t,
          advancedFilterModel: i
        } : void 0
      }
      setFilterState(e, t) {
        const {
          filterModel: i,
          advancedFilterModel: r
        } = null != e ? e : {
          advancedFilterModel: t
        };
        i && this.filterManager.setFilterModel(i, "columnFilter"), r && this.filterManager.setAdvancedFilterModel(r)
      }
      getRangeSelectionState() {
        var e;
        const t = null == (e = this.rangeService) ? void 0 : e.getCellRanges().map(e => {
          const {
            id: t,
            type: i,
            startRow: r,
            endRow: s,
            columns: n,
            startColumn: o
          } = e;
          return {
            id: t,
            type: i,
            startRow: r,
            endRow: s,
            colIds: n.map(e => e.getColId()),
            startColId: o.getColId()
          }
        });
        return (null == t ? void 0 : t.length) ? {
          cellRanges: t
        } : void 0
      }
      setRangeSelectionState(e) {
        if (!this.gos.get("enableRangeSelection") || !this.rangeService) return;
        const t = [];
        e.cellRanges.forEach(e => {
          const i = [];
          if (e.colIds.forEach(e => {
              const t = this.columnModel.getGridColumn(e);
              t && i.push(t)
            }), !i.length) return;
          let r = this.columnModel.getGridColumn(e.startColId);
          if (!r) {
            const e = this.columnModel.getAllDisplayedColumns(),
              t = new Set(i);
            r = e.find(e => t.has(e))
          }
          t.push(T(f({}, e), {
            columns: i,
            startColumn: r
          }))
        }), this.rangeService.setCellRanges(t)
      }
      getScrollState() {
        var e, t, i;
        if (!this.isClientSideRowModel) return;
        const r = null == (e = this.ctrlsService.getGridBodyCtrl()) ? void 0 : e.getScrollFeature(),
          {
            left: s
          } = null != (t = null == r ? void 0 : r.getHScrollPosition()) ? t : {
            left: 0
          },
          {
            top: n
          } = null != (i = null == r ? void 0 : r.getVScrollPosition()) ? i : {
            top: 0
          };
        return n || s ? {
          top: n,
          left: s
        } : void 0
      }
      setScrollState(e) {
        var t;
        if (!this.isClientSideRowModel) return;
        const {
          top: i,
          left: r
        } = e;
        null == (t = this.ctrlsService.getGridBodyCtrl()) || t.getScrollFeature().setScrollPosition(i, r)
      }
      getSideBarState() {
        var e, t;
        return null == (t = null == (e = this.sideBarService) ? void 0 : e.getSideBarComp()) ? void 0 : t.getState()
      }
      getFocusedCellState() {
        if (!this.isClientSideRowModel) return;
        const e = this.focusService.getFocusedCell();
        if (e) {
          const {
            column: t,
            rowIndex: i,
            rowPinned: r
          } = e;
          return {
            colId: t.getColId(),
            rowIndex: i,
            rowPinned: r
          }
        }
      }
      setFocusedCellState(e) {
        if (!this.isClientSideRowModel) return;
        const {
          colId: t,
          rowIndex: i,
          rowPinned: r
        } = e;
        this.focusService.setFocusedCell({
          column: this.columnModel.getGridColumn(t),
          rowIndex: i,
          rowPinned: r,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        })
      }
      getPaginationState() {
        const e = this.paginationProxy.getCurrentPage(),
          t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationProxy.getPageSize();
        if (e || t) return {
          page: e,
          pageSize: t
        }
      }
      setPaginationState(e) {
        e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationProxy.setPageSize(e.pageSize, "initialState"), "number" == typeof e.page && this.paginationProxy.setPage(e.page)
      }
      getRowSelectionState() {
        var e;
        const t = this.selectionService.getSelectionState();
        return !t || !Array.isArray(t) && (!1 === t.selectAll || !1 === t.selectAllChildren) && !(null == (e = null == t ? void 0 : t.toggledNodes) ? void 0 : e.length) ? void 0 : t
      }
      setRowSelectionState(e) {
        this.selectionService.setSelectionState(e, "gridInitializing")
      }
      getRowGroupExpansionState() {
        const e = this.expansionService.getExpandedRows();
        return e.length ? {
          expandedRowGroupIds: e
        } : void 0
      }
      setRowGroupExpansionState(e) {
        this.expansionService.expandRows(e.expandedRowGroupIds)
      }
      updateColumnState(e) {
        const t = this.getColumnState();
        let i = !1;
        Object.entries(t).forEach(([e, t]) => {
          w(t, this.cachedState[e]) || (i = !0)
        }), this.cachedState = f(f({}, this.cachedState), t), i && this.dispatchStateUpdateEvent(e)
      }
      updateCachedState(e, t) {
        const i = this.cachedState[e];
        this.setCachedStateValue(e, t), w(t, i) || this.dispatchStateUpdateEvent([e])
      }
      setCachedStateValue(e, t) {
        this.cachedState = T(f({}, this.cachedState), {
          [e]: t
        })
      }
      refreshStaleState() {
        this.staleStateKeys.forEach(e => {
          if ("rowSelection" === e) this.setCachedStateValue(e, this.getRowSelectionState())
        }), this.staleStateKeys.clear()
      }
      dispatchStateUpdateEvent(e) {
        this.suppressEvents || (e.forEach(e => this.queuedUpdateSources.add(e)), this.dispatchStateUpdateEventDebounced())
      }
      dispatchQueuedStateUpdateEvents() {
        const e = Array.from(this.queuedUpdateSources);
        this.queuedUpdateSources.clear();
        const t = {
          type: Et.EVENT_STATE_UPDATED,
          sources: e,
          state: this.cachedState
        };
        this.eventService.dispatchEvent(t)
      }
      suppressEventsAndDispatchInitEvent(e) {
        this.suppressEvents = !0, this.columnAnimationService.setSuppressAnimation(!0), e(), setTimeout(() => {
          this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]))
        })
      }
    };
    C([fe("filterManager")], Sh.prototype, "filterManager", 2), C([fe("ctrlsService")], Sh.prototype, "ctrlsService", 2), C([fe("focusService")], Sh.prototype, "focusService", 2), C([fe("columnModel")], Sh.prototype, "columnModel", 2), C([fe("paginationProxy")], Sh.prototype, "paginationProxy", 2), C([fe("rowModel")], Sh.prototype, "rowModel", 2), C([fe("selectionService")], Sh.prototype, "selectionService", 2), C([fe("expansionService")], Sh.prototype, "expansionService", 2), C([fe("columnAnimationService")], Sh.prototype, "columnAnimationService", 2), C([Te("sideBarService")], Sh.prototype, "sideBarService", 2), C([Te("rangeService")], Sh.prototype, "rangeService", 2), C([pe], Sh.prototype, "postConstruct", 1), Sh = C([ge("stateService")], Sh);
    var Rh = class extends ct {
      init() {
        this.processGridOptions(this.gridOptions)
      }
      processGridOptions(e) {
        this.processOptions(e, hh)
      }
      processColumnDefs(e) {
        this.processOptions(e, ah)
      }
      processOptions(e, t) {
        const {
          validations: i,
          deprecations: r,
          allProperties: s,
          propertyExceptions: n,
          objectName: o,
          docsUrl: a
        } = t;
        s && !0 !== this.gridOptions.suppressPropertyNamesCheck && this.checkProperties(e, [...null != n ? n : [], ...Object.keys(r)], s, o, a);
        const l = new Set;
        Object.keys(e).forEach(t => {
          var s;
          const n = r[t];
          if (n)
            if ("renamed" in n) {
              const {
                renamed: i,
                version: r
              } = n;
              l.add(`As of v${r}, ${String(t)} is deprecated. Please use ${String(i)} instead.`), e[i] = e[t]
            } else {
              const {
                message: e,
                version: i
              } = n;
              l.add(`As of v${i}, ${String(t)} is deprecated. ${null!=e?e:""}`)
            } const o = e[t];
          if (null == o || !1 === o) return;
          const a = i[t];
          let c;
          if (!a) return;
          if ("function" == typeof a) {
            const i = a(e, this.gridOptions);
            if (!i) return;
            if ("objectName" in i) {
              const r = e[t];
              return Array.isArray(r) ? void r.forEach(e => {
                this.processOptions(e, i)
              }) : void this.processOptions(e[t], i)
            }
            c = i
          } else c = a;
          const {
            module: h,
            dependencies: u,
            supportedRowModels: d
          } = c;
          if (d) {
            const e = null != (s = this.gridOptions.rowModelType) ? s : "clientSide";
            if (!d.includes(e)) return void l.add(`${String(t)} is not supported with the '${e}' row model.`)
          }
          if (h) {
            const e = Array.isArray(h) ? h : [h];
            let i = !0;
            if (e.forEach(e => {
                he.__assertRegistered(e, String(t), this.context.getGridId()) || (i = !1, l.add(`${String(t)} is only available when ${e} is loaded.`))
              }), !i) return
          }
          if (u) {
            const i = this.checkForWarning(t, u, e);
            if (i) return void l.add(i)
          }
        }), l.size > 0 && l.forEach(e => {
          z(e)
        })
      }
      checkForWarning(e, t, i) {
        if ("function" == typeof t) return t(i, this.gridOptions);
        const r = Object.entries(t).find(([e, t]) => {
          const r = i[e];
          return !t.includes(r)
        });
        if (!r) return null;
        const [s, n] = r;
        return n.length > 1 ? `'${String(e)}' requires '${s}' to be one of [${n.join(", ")}].` : `'${String(e)}' requires '${s}' to be ${n[0]}.`
      }
      checkProperties(e, t, i, r, s) {
        const n = zr(Object.getOwnPropertyNames(e), ["__ob__", "__v_skip", "__metadata__", ...t, ...i], i);
        if (x(n, (e, t) => {
            z(`invalid ${r} property '${e}' did you mean any of these: ${t.slice(0,8).join(", ")}`)
          }), Object.keys(n).length > 0 && s) {
          const e = this.getFrameworkOverrides().getDocLink(s);
          z(`to see all the valid ${r} properties please check: ${e}`)
        }
      }
    };
    C([fe("gridOptions")], Rh.prototype, "gridOptions", 2), C([pe], Rh.prototype, "init", 1), Rh = C([ge("validationService")], Rh);
    var Ah = class extends ct {
      constructor() {
        super(...arguments), this.syncEventListeners = new Map, this.asyncEventListeners = new Map, this.syncGlobalEventListeners = new Set, this.globalEventListenerPairs = new Map
      }
      postConstruct() {
        this.frameworkEventWrappingService = new Ae(this.getFrameworkOverrides())
      }
      addEventListener(e, t) {
        const i = this.frameworkEventWrappingService.wrap(t),
          r = this.gos.useAsyncEvents() && !gt.has(e),
          s = r ? this.asyncEventListeners : this.syncEventListeners;
        s.has(e) || s.set(e, new Set), s.get(e).add(i), this.eventService.addEventListener(e, i, r)
      }
      removeEventListener(e, t) {
        var i;
        const r = this.frameworkEventWrappingService.unwrap(t),
          s = this.asyncEventListeners.get(e),
          n = !!(null == s ? void 0 : s.delete(r));
        n || null == (i = this.syncEventListeners.get(e)) || i.delete(r), this.eventService.removeEventListener(e, r, n)
      }
      addGlobalListener(e) {
        const t = this.frameworkEventWrappingService.wrapGlobal(e);
        if (this.gos.useAsyncEvents()) {
          const i = (e, i) => {
              gt.has(e) && t(e, i)
            },
            r = (e, i) => {
              gt.has(e) || t(e, i)
            };
          this.globalEventListenerPairs.set(e, {
            syncListener: i,
            asyncListener: r
          }), this.eventService.addGlobalListener(i, !1), this.eventService.addGlobalListener(r, !0)
        } else this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, !1)
      }
      removeGlobalListener(e) {
        const t = this.frameworkEventWrappingService.unwrapGlobal(e);
        if (this.globalEventListenerPairs.has(t)) {
          const {
            syncListener: i,
            asyncListener: r
          } = this.globalEventListenerPairs.get(t);
          this.eventService.removeGlobalListener(i, !1), this.eventService.removeGlobalListener(r, !0), this.globalEventListenerPairs.delete(e)
        } else this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, !1)
      }
      destroyEventListeners(e, t) {
        e.forEach((e, i) => {
          e.forEach(e => this.eventService.removeEventListener(i, e, t)), e.clear()
        }), e.clear()
      }
      destroyGlobalListeners(e, t) {
        e.forEach(e => this.eventService.removeGlobalListener(e, t)), e.clear()
      }
      destroy() {
        super.destroy(), this.destroyEventListeners(this.syncEventListeners, !1), this.destroyEventListeners(this.asyncEventListeners, !0), this.destroyGlobalListeners(this.syncGlobalEventListeners, !1), this.globalEventListenerPairs.forEach(({
          syncListener: e,
          asyncListener: t
        }) => {
          this.eventService.removeGlobalListener(e, !1), this.eventService.removeGlobalListener(t, !0)
        }), this.globalEventListenerPairs.clear()
      }
    };
    C([pe], Ah.prototype, "postConstruct", 1), Ah = C([ge("apiEventService")], Ah);
    var vh = class extends _s {
      constructor() {
        super('<span class="ag-paging-page-size"></span>'), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
          if (!this.selectPageSizeComp) return;
          const e = this.selectPageSizeComp.getValue();
          if (!e) return;
          const t = Number(e);
          isNaN(t) || t < 1 || t === this.paginationProxy.getPageSize() || (this.paginationProxy.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus())
        }
      }
      init() {
        this.addManagedPropertyListener("paginationPageSizeSelector", () => {
          this.onPageSizeSelectorValuesChange()
        }), this.addManagedListener(this.eventService, Et.EVENT_PAGINATION_CHANGED, e => this.handlePaginationChanged(e))
      }
      handlePaginationChanged(e) {
        if (!this.selectPageSizeComp || !(null == e ? void 0 : e.newPageSize)) return;
        const t = this.paginationProxy.getPageSize();
        this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0)
      }
      toggleSelectDisplay(e) {
        this.selectPageSizeComp && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp && this.appendChild(this.selectPageSizeComp))
      }
      reset() {
        Nr(this.getGui()), this.selectPageSizeComp && (this.destroyBean(this.selectPageSizeComp), this.selectPageSizeComp = void 0)
      }
      onPageSizeSelectorValuesChange() {
        this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector()
      }
      shouldShowPageSizeSelector() {
        return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && !1 !== this.gos.get("paginationPageSizeSelector")
      }
      reloadPageSizesSelector() {
        const e = this.getPageSizeSelectorValues(),
          t = this.paginationProxy.getPageSize(),
          i = !t || !e.includes(t);
        i && (e.unshift(""), z("The paginationPageSize grid option is set to a value that is not in the list of page size options.\n                Please make sure that the paginationPageSize grid option is set to one of the values in the \n                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.")), this.selectPageSizeComp && (this.destroyBean(this.selectPageSizeComp), this.selectPageSizeComp = void 0);
        const r = this.localeService.getLocaleTextFunc(),
          s = r("pageSizeSelectorLabel", "Page Size:"),
          n = e.map(e => ({
            value: String(e),
            text: String(e)
          })),
          o = r("ariaPageSizeSelectorLabel", "Page Size");
        this.selectPageSizeComp = this.createManagedBean(new $s).addOptions(n).setValue(String(i ? "" : t)).setAriaLabel(o).setLabel(s).onValueChange(() => this.handlePageSizeItemSelected()), this.hasEmptyOption = i
      }
      getPageSizeSelectorValues() {
        const e = [20, 50, 100],
          t = this.gos.get("paginationPageSizeSelector");
        return Array.isArray(t) && this.validateValues(t) ? [...t].sort((e, t) => e - t) : e
      }
      validateValues(e) {
        if (!e.length) return z("The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.\n                If you want to hide the page size selector, please set the paginationPageSizeSelector to false."), !1;
        for (let t = 0; t < e.length; t++) {
          const i = e[t],
            r = i > 0;
          if (!("number" == typeof i)) return z("The paginationPageSizeSelector grid option contains a non-numeric value.\n                    Please make sure that all values in the paginationPageSizeSelector array are numbers."), !1;
          if (!r) return z("The paginationPageSizeSelector grid option contains a negative number or zero.\n                    Please make sure that all values in the paginationPageSizeSelector array are positive."), !1
        }
        return !0
      }
      destroy() {
        this.toggleSelectDisplay(!1), super.destroy()
      }
    };
    C([fe("paginationProxy")], vh.prototype, "paginationProxy", 2), C([pe], vh.prototype, "init", 1);
    var Nh = class extends ct {
      constructor() {
        super(), this.descriptionContainer = null, this.announceValue = re(this.announceValue.bind(this), 200)
      }
      postConstruct() {
        const e = this.gos.getDocument(),
          t = this.descriptionContainer = e.createElement("div");
        t.classList.add("ag-aria-description-container"), ei(t, "polite"), ii(t, "additions text"), ti(t, !0), this.eGridDiv.appendChild(t)
      }
      announceValue(e) {
        this.descriptionContainer && (this.descriptionContainer.textContent = "", setTimeout(() => {
          this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e)
        }, 50))
      }
      destroy() {
        super.destroy();
        const {
          descriptionContainer: e
        } = this;
        e && (Nr(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null
      }
    };
    C([fe("eGridDiv")], Nh.prototype, "eGridDiv", 2), C([pe], Nh.prototype, "postConstruct", 1), Nh = C([ge("ariaAnnouncementService")], Nh);
    var Ih = class {};
    Ih.gridOptions = void 0;
    var Oh = 1,
      Lh = class {
        create(e, t, i, r, s) {
          var n;
          let o = {};
          Ih.gridOptions ? (k(o, Ih.gridOptions, !0, !0), o = f(f({}, o), t)) : o = t;
          const a = uh.getCoercedGridOptions(o),
            l = !!a.debug,
            c = null != (n = a.gridId) ? n : String(Oh++),
            h = this.getRegisteredModules(s, c),
            u = this.createBeansList(a.rowModelType, h, c),
            d = this.createProvidedBeans(e, a, s);
          if (!u) return void j("Failed to create grid.");
          const p = {
              providedBeanInstances: d,
              beanClasses: u,
              debug: l,
              gridId: c
            },
            E = new Rc("Context", () => p.debug),
            g = new ue(p, E),
            T = g.getBean("beans");
          this.registerModuleUserComponents(T, h), this.registerStackComponents(T, h), this.registerControllers(T, h), i(g), T.syncService.start(), r && r(g);
          return g.getBean("gridApi")
        }
        registerControllers(e, t) {
          t.forEach(t => {
            t.controllers && t.controllers.forEach(t => e.ctrlsFactory.register(t))
          })
        }
        registerStackComponents(e, t) {
          const i = this.createAgStackComponentsList(t);
          e.agStackComponentsRegistry.setupComponents(i)
        }
        getRegisteredModules(e, t) {
          const i = e ? e.modules : null,
            r = he.__getRegisteredModules(t),
            s = [],
            n = {},
            o = (e, t, i) => {
              var r;
              n[(r = t).moduleName] || (n[r.moduleName] = !0, s.push(r), he.__register(r, e, i)), t.dependantModules && t.dependantModules.forEach(t => o(e, t, i))
            };
          return i && i.forEach(e => o(!0, e, t)), r && r.forEach(e => o(!he.__isPackageBased(), e, void 0)), s
        }
        registerModuleUserComponents(e, t) {
          this.extractModuleEntity(t, e => e.userComponents ? e.userComponents : []).forEach(t => {
            e.userComponentRegistry.registerDefaultComponent(t.componentName, t.componentClass)
          })
        }
        createProvidedBeans(e, t, i) {
          let r = i ? i.frameworkOverrides : null;
          N(r) && (r = new pc);
          const s = {
            gridOptions: t,
            eGridDiv: e,
            globalEventListener: i ? i.globalEventListener : null,
            globalSyncEventListener: i ? i.globalSyncEventListener : null,
            frameworkOverrides: r
          };
          return i && i.providedBeanInstances && Object.assign(s, i.providedBeanInstances), s
        }
        createAgStackComponentsList(e) {
          let t = [{
            componentName: "AgCheckbox",
            componentClass: Js
          }, {
            componentName: "AgRadioButton",
            componentClass: qs
          }, {
            componentName: "AgToggleButton",
            componentClass: Fl
          }, {
            componentName: "AgInputTextField",
            componentClass: hn
          }, {
            componentName: "AgInputTextArea",
            componentClass: xl
          }, {
            componentName: "AgInputNumberField",
            componentClass: un
          }, {
            componentName: "AgInputDateField",
            componentClass: Gl
          }, {
            componentName: "AgInputRange",
            componentClass: Ul
          }, {
            componentName: "AgRichSelect",
            componentClass: Vl
          }, {
            componentName: "AgSelect",
            componentClass: $s
          }, {
            componentName: "AgSlider",
            componentClass: Yl
          }, {
            componentName: "AgGridBody",
            componentClass: wa
          }, {
            componentName: "AgHeaderRoot",
            componentClass: El
          }, {
            componentName: "AgSortIndicator",
            componentClass: Ln
          }, {
            componentName: "AgPagination",
            componentClass: Uc
          }, {
            componentName: "AgPageSizeSelector",
            componentClass: vh
          }, {
            componentName: "AgOverlayWrapper",
            componentClass: kc
          }, {
            componentName: "AgGroupComponent",
            componentClass: Xl
          }, {
            componentName: "AgRowContainer",
            componentClass: Ua
          }, {
            componentName: "AgFakeHorizontalScroll",
            componentClass: ih
          }, {
            componentName: "AgFakeVerticalScroll",
            componentClass: Eh
          }, {
            componentName: "AgAutocomplete",
            componentClass: lc
          }];
          const i = this.extractModuleEntity(e, e => e.agStackComponents ? e.agStackComponents : []);
          return t = t.concat(i), t
        }
        createBeansList(e = "clientSide", t, i) {
          const r = t.filter(t => !t.rowModel || t.rowModel === e),
            s = {
              clientSide: "@ag-grid-community/client-side-row-model",
              infinite: "@ag-grid-community/infinite-row-model",
              serverSide: "@ag-grid-enterprise/server-side-row-model",
              viewport: "@ag-grid-enterprise/viewport-row-model"
            };
          if (!s[e]) return void j("Could not find row model for rowModelType = " + e);
          if (!he.__assertRegistered(s[e], `rowModelType = '${e}'`, i)) return;
          const n = [la, Bc, Vc, $c, _c, zo, Co, Dc, Pc, Sl, ko, xc, gl, dh, Rh, _l, Wo, Mt, Re, uh, rc, fc, jo, Dt, ul, bl, Ol, Cc, ht, gc, ba, yc, mc, Sc, Nl, fl, Kn, Tc, Ic, Pa, Fc, Ec, Ml, Da, Nc, Oc, Lc, Gc, mt, wc, Rl, zc, kt, jc, Jc, Pl, qc, Qc, rh, sh, Zc, Th, $o, mh, Ch, Sh, Al, Ah, Nh, vl],
            o = this.extractModuleEntity(r, e => e.beans ? e.beans : []);
          n.push(...o);
          const a = [];
          return n.forEach(e => {
            a.indexOf(e) < 0 && a.push(e)
          }), a
        }
        extractModuleEntity(e, t) {
          return [].concat(...e.map(t))
        }
      },
      _h = class {};
    _h.CHART_TYPE_TO_SERIES_TYPE = {
      column: "bar",
      groupedColumn: "bar",
      stackedColumn: "bar",
      normalizedColumn: "bar",
      bar: "bar",
      groupedBar: "bar",
      stackedBar: "bar",
      normalizedBar: "bar",
      line: "line",
      scatter: "scatter",
      bubble: "bubble",
      pie: "pie",
      donut: "donut",
      doughnut: "donut",
      area: "area",
      stackedArea: "area",
      normalizedArea: "area",
      histogram: "histogram",
      radarLine: "radar-line",
      radarArea: "radar-area",
      nightingale: "nightingale",
      radialColumn: "radial-column",
      radialBar: "radial-bar",
      sunburst: "sunburst",
      rangeBar: "range-bar",
      rangeArea: "range-area",
      boxPlot: "box-plot",
      treemap: "treemap",
      heatmap: "heatmap",
      waterfall: "waterfall"
    }, _h.COMBO_CHART_TYPES = ["columnLineCombo", "areaColumnCombo", "customCombo"], _h.SERIES_GROUP_TYPES = ["grouped", "stacked", "normalized"];
    var yh = "undefined" == typeof global ? {} : global;
    yh.HTMLElement = "undefined" == typeof HTMLElement ? {} : HTMLElement, yh.HTMLButtonElement = "undefined" == typeof HTMLButtonElement ? {} : HTMLButtonElement, yh.HTMLSelectElement = "undefined" == typeof HTMLSelectElement ? {} : HTMLSelectElement, yh.HTMLInputElement = "undefined" == typeof HTMLInputElement ? {} : HTMLInputElement, yh.Node = "undefined" == typeof Node ? {} : Node, yh.MouseEvent = "undefined" == typeof MouseEvent ? {} : MouseEvent;
    var wh = class e {
      constructor(t, i, r, s, n, o) {
        this.nextId = 0, this.rowCountReady = !1, this.allNodesMap = {}, this.rootNode = t, this.gos = i, this.eventService = r, this.columnModel = s, this.beans = o, this.selectionService = n, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = e.ROOT_NODE_ID, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = []
      }
      getCopyOfNodesMap() {
        return Cs.cloneObject(this.allNodesMap)
      }
      getRowNode(e) {
        return this.allNodesMap[e]
      }
      setRowData(t) {
        if ("string" == typeof t) return void console.warn("AG Grid: rowData must be an array.");
        this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(t);
        const i = this.rootNode,
          r = this.rootNode.sibling;
        i.childrenAfterFilter = null, i.childrenAfterGroup = null, i.childrenAfterAggFilter = null, i.childrenAfterSort = null, i.childrenMapped = null, i.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, t ? i.allLeafChildren = t.map(t => this.createNode(t, this.rootNode, e.TOP_LEVEL)) : (i.allLeafChildren = [], i.childrenAfterGroup = []), r && (r.childrenAfterFilter = i.childrenAfterFilter, r.childrenAfterGroup = i.childrenAfterGroup, r.childrenAfterAggFilter = i.childrenAfterAggFilter, r.childrenAfterSort = i.childrenAfterSort, r.childrenMapped = i.childrenMapped, r.allLeafChildren = i.allLeafChildren)
      }
      updateRowData(e, t) {
        this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e.add);
        const i = {
            remove: [],
            update: [],
            add: []
          },
          r = [];
        return this.executeRemove(e, i, r), this.executeUpdate(e, i, r), this.executeAdd(e, i), this.updateSelection(r, "rowDataChanged"), t && Cs.sortRowNodesByOrder(this.rootNode.allLeafChildren, t), i
      }
      isRowCountReady() {
        return this.rowCountReady
      }
      dispatchRowDataUpdateStartedEvent(e) {
        const t = {
          type: Et.EVENT_ROW_DATA_UPDATE_STARTED,
          firstRowData: (null == e ? void 0 : e.length) ? e[0] : null
        };
        this.eventService.dispatchEvent(t)
      }
      updateSelection(e, t) {
        const i = e.length > 0;
        if (i && this.selectionService.setNodesSelected({
            newValue: !1,
            nodes: e,
            suppressFinishActions: !0,
            source: t
          }), this.selectionService.updateGroupsFromChildrenSelections(t), i) {
          const e = {
            type: Et.EVENT_SELECTION_CHANGED,
            source: t
          };
          this.eventService.dispatchEvent(e)
        }
      }
      executeAdd(t, i) {
        var r;
        const {
          add: s,
          addIndex: n
        } = t;
        if (Cs.missingOrEmpty(s)) return;
        const o = s.map(t => this.createNode(t, this.rootNode, e.TOP_LEVEL));
        if ("number" == typeof n && n >= 0) {
          const {
            allLeafChildren: e
          } = this.rootNode, t = e.length;
          let i = n;
          if (this.gos.get("treeData") && n > 0 && t > 0)
            for (let s = 0; s < t; s++)
              if ((null == (r = e[s]) ? void 0 : r.rowIndex) == n - 1) {
                i = s + 1;
                break
              } const s = e.slice(0, i),
            a = e.slice(i, e.length);
          this.rootNode.allLeafChildren = [...s, ...o, ...a]
        } else this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...o];
        this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren), i.add = o
      }
      executeRemove(e, t, i) {
        const {
          remove: r
        } = e;
        if (Cs.missingOrEmpty(r)) return;
        const s = {};
        r.forEach(e => {
          const r = this.lookupRowNode(e);
          r && (r.isSelected() && i.push(r), r.clearRowTopAndRowIndex(), s[r.id] = !0, delete this.allNodesMap[r.id], t.remove.push(r))
        }), this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter(e => !s[e.id]), this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren)
      }
      executeUpdate(t, i, r) {
        const {
          update: s
        } = t;
        Cs.missingOrEmpty(s) || s.forEach(t => {
          const s = this.lookupRowNode(t);
          s && (s.updateData(t), !s.selectable && s.isSelected() && r.push(s), this.setMasterForRow(s, t, e.TOP_LEVEL, !1), i.update.push(s))
        })
      }
      lookupRowNode(e) {
        const t = this.gos.getCallback("getRowId");
        let i;
        if (t) {
          const r = t({
            data: e,
            level: 0
          });
          if (i = this.allNodesMap[r], !i) return console.error(`AG Grid: could not find row id=${r}, data item was not found for this id`), null
        } else if (i = this.rootNode.allLeafChildren.find(t => t.data === e), !i) return console.error("AG Grid: could not find data item as object was not found", e), console.error("Consider using getRowId to help the Grid find matching row data"), null;
        return i || null
      }
      createNode(e, t, i) {
        const r = new Vn(this.beans);
        r.group = !1, this.setMasterForRow(r, e, i, !0);
        const s = this.gos.get("suppressParentsInRowNodes");
        return t && !s && (r.parent = t), r.level = i, r.setDataAndId(e, this.nextId.toString()), this.allNodesMap[r.id] && console.warn(`AG Grid: duplicate node id '${r.id}' detected from getRowId callback, this could cause issues in your grid.`), this.allNodesMap[r.id] = r, this.nextId++, r
      }
      setMasterForRow(e, t, i, r) {
        if (this.gos.get("treeData")) e.setMaster(!1), r && (e.expanded = !1);
        else {
          if (this.gos.get("masterDetail")) {
            const i = this.gos.get("isRowMaster");
            i ? e.setMaster(i(t)) : e.setMaster(!0)
          } else e.setMaster(!1);
          if (r) {
            const t = this.columnModel.getRowGroupColumns(),
              r = i + (t ? t.length : 0);
            e.expanded = !!e.master && this.isExpanded(r)
          }
        }
      }
      isExpanded(e) {
        const t = this.gos.get("groupDefaultExpanded");
        return -1 === t || e < t
      }
    };
    wh.TOP_LEVEL = 0, wh.ROOT_NODE_ID = "ROOT_NODE_ID";
    var Dh = wh,
      Ph = class extends ct {
        constructor() {
          super(...arguments), this.onRowHeightChanged_debounced = Cs.debounce(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowCountReady = !1
        }
        init() {
          const e = this.refreshModel.bind(this, {
              step: "group"
            }),
            t = !this.gos.get("suppressAnimationFrame"),
            i = this.refreshModel.bind(this, {
              step: "group",
              afterColumnsChanged: !0,
              keepRenderedRows: !0,
              animate: t
            });
          this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, i), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {
            step: "pivot"
          })), this.addManagedListener(this.eventService, Et.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, Et.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_GRID_READY, () => this.onGridReady()), this.addPropertyListeners(), this.rootNode = new Vn(this.beans), this.nodeManager = new Dh(this.rootNode, this.gos, this.eventService, this.columnModel, this.selectionService, this.beans)
        }
        addPropertyListeners() {
          const e = new Set(["treeData", "masterDetail"]),
            t = new Set(["suppressParentsInRowNodes", "groupDefaultExpanded", "groupAllowUnbalanced", "initialGroupOrderComparator", "groupHideOpenParents", "groupDisplayType"]),
            i = new Set(["excludeChildrenWhenTreeDataFiltering"]),
            r = new Set(["removePivotHeaderRowWhenSingleValueColumn", "pivotRowTotals", "pivotColumnGroupTotals", "suppressExpandablePivotGroups"]),
            s = new Set(["getGroupRowAgg", "alwaysAggregateAtRootLevel", "groupIncludeTotalFooter", "suppressAggFilteredOnly", "grandTotalRow"]),
            n = new Set(["postSortRows", "groupDisplayType", "accentedSort"]),
            o = new Set([]),
            a = new Set(["groupRemoveSingleChildren", "groupRemoveLowestSingleChildren", "groupIncludeFooter", "groupTotalRow"]),
            l = [...e, ...t, ...i, ...r, ...r, ...s, ...n, ...o, ...a];
          this.addManagedPropertyListeners(l, l => {
            var c;
            const h = null == (c = l.changeSet) ? void 0 : c.properties;
            if (!h) return;
            const u = e => h.some(t => e.has(t));
            u(e) ? this.setRowData(this.rootNode.allLeafChildren.map(e => e.data)) : u(t) ? this.refreshModel({
              step: "group"
            }) : u(i) ? this.refreshModel({
              step: "filter"
            }) : u(r) ? this.refreshModel({
              step: "pivot"
            }) : u(s) ? this.refreshModel({
              step: "aggregate"
            }) : u(n) ? this.refreshModel({
              step: "sort"
            }) : u(o) ? this.refreshModel({
              step: "filter_aggregates"
            }) : u(a) && this.refreshModel({
              step: "map"
            })
          }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights())
        }
        start() {
          this.hasStarted = !0, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData()
        }
        setInitialData() {
          const e = this.gos.get("rowData");
          e && (this.shouldSkipSettingDataOnStart = !0, this.setRowData(e))
        }
        ensureRowHeightsValid(e, t, i, r) {
          let s, n = !1;
          do {
            s = !1;
            const o = this.getRowIndexAtPixel(e),
              a = this.getRowIndexAtPixel(t),
              l = Math.max(o, i),
              c = Math.min(a, r);
            for (let e = l; e <= c; e++) {
              const t = this.getRow(e);
              if (t.rowHeightEstimated) {
                const e = this.gos.getRowHeightForNode(t);
                t.setRowHeight(e.height), s = !0, n = !0
              }
            }
            s && this.setRowTopAndRowIndex()
          } while (s);
          return n
        }
        setRowTopAndRowIndex() {
          const e = this.environment.getDefaultRowHeight();
          let t = 0;
          const i = new Set,
            r = this.gos.isDomLayout("normal");
          for (let s = 0; s < this.rowsToDisplay.length; s++) {
            const n = this.rowsToDisplay[s];
            if (null != n.id && i.add(n.id), null == n.rowHeight) {
              const t = this.gos.getRowHeightForNode(n, r, e);
              n.setRowHeight(t.height, t.estimated)
            }
            n.setRowTop(t), n.setRowIndex(s), t += n.rowHeight
          }
          return i
        }
        clearRowTopAndRowIndex(e, t) {
          const i = e.isActive(),
            r = e => {
              e && null != e.id && !t.has(e.id) && e.clearRowTopAndRowIndex()
            },
            s = e => {
              if (r(e), r(e.detailNode), r(e.sibling), e.hasChildren() && e.childrenAfterGroup) {
                const t = -1 == e.level;
                i && !t && !e.expanded || e.childrenAfterGroup.forEach(s)
              }
            };
          s(this.rootNode)
        }
        ensureRowsAtPixel(e, t, i = 0) {
          const r = this.getRowIndexAtPixel(t),
            s = this.getRow(r),
            n = !this.gos.get("suppressAnimationFrame");
          return s !== e[0] && (e.forEach(e => {
            Cs.removeFromArray(this.rootNode.allLeafChildren, e)
          }), e.forEach((e, t) => {
            Cs.insertIntoArray(this.rootNode.allLeafChildren, e, Math.max(r + i, 0) + t)
          }), this.refreshModel({
            step: "group",
            keepRenderedRows: !0,
            keepEditingRows: !0,
            animate: n
          }), !0)
        }
        highlightRowAtPixel(e, t) {
          const i = null != t ? this.getRowIndexAtPixel(t) : null,
            r = null != i ? this.getRow(i) : null;
          if (!r || !e || r === e || null == t) return void(this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null));
          const s = this.getHighlightPosition(t, r);
          this.lastHighlightedRow && this.lastHighlightedRow !== r && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null), r.setHighlighted(s), this.lastHighlightedRow = r
        }
        getHighlightPosition(e, t) {
          if (!t) {
            const i = this.getRowIndexAtPixel(e);
            if (!(t = this.getRow(i || 0))) return 1
          }
          const {
            rowTop: i,
            rowHeight: r
          } = t;
          return e - i < r / 2 ? 0 : 1
        }
        getLastHighlightedRowNode() {
          return this.lastHighlightedRow
        }
        isLastRowIndexKnown() {
          return !0
        }
        getRowCount() {
          return this.rowsToDisplay ? this.rowsToDisplay.length : 0
        }
        getTopLevelRowCount() {
          if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode) return 1;
          const e = this.rootNode.childrenAfterAggFilter;
          return e ? e.length : 0
        }
        getTopLevelRowDisplayedIndex(e) {
          if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode) return e;
          let t = this.rootNode.childrenAfterSort[e];
          if (this.gos.get("groupHideOpenParents"))
            for (; t.expanded && t.childrenAfterSort && t.childrenAfterSort.length > 0;) t = t.childrenAfterSort[0];
          return t.rowIndex
        }
        getRowBounds(e) {
          if (Cs.missing(this.rowsToDisplay)) return null;
          const t = this.rowsToDisplay[e];
          return t ? {
            rowTop: t.rowTop,
            rowHeight: t.rowHeight
          } : null
        }
        onRowGroupOpened() {
          const e = this.gos.isAnimateRows();
          this.refreshModel({
            step: "map",
            keepRenderedRows: !0,
            animate: e
          })
        }
        onFilterChanged(e) {
          if (e.afterDataChange) return;
          const t = this.gos.isAnimateRows(),
            i = 0 === e.columns.length || e.columns.some(e => e.isPrimary()) ? "filter" : "filter_aggregates";
          this.refreshModel({
            step: i,
            keepRenderedRows: !0,
            animate: t
          })
        }
        onSortChanged() {
          const e = this.gos.isAnimateRows();
          this.refreshModel({
            step: "sort",
            keepRenderedRows: !0,
            animate: e,
            keepEditingRows: !0
          })
        }
        getType() {
          return "clientSide"
        }
        onValueChanged() {
          this.columnModel.isPivotActive() ? this.refreshModel({
            step: "pivot"
          }) : this.refreshModel({
            step: "aggregate"
          })
        }
        createChangePath(e) {
          const t = Cs.missingOrEmpty(e),
            i = new yl(!1, this.rootNode);
          return (t || this.gos.get("treeData")) && i.setInactive(), i
        }
        isSuppressModelUpdateAfterUpdateTransaction(e) {
          if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction")) return !1;
          if (null == e.rowNodeTransactions) return !1;
          const t = e.rowNodeTransactions.filter(e => null != e.add && e.add.length > 0 || null != e.remove && e.remove.length > 0);
          return null == t || 0 == t.length
        }
        buildRefreshModelParams(e) {
          let t = "group";
          const i = {
            everything: "group",
            group: "group",
            filter: "filter",
            map: "map",
            aggregate: "aggregate",
            sort: "sort",
            pivot: "pivot"
          };
          if (Cs.exists(e) && (t = i[e]), Cs.missing(t)) return void console.error(`AG Grid: invalid step ${e}, available steps are ${Object.keys(i).join(", ")}`);
          return {
            step: t,
            keepRenderedRows: !0,
            keepEditingRows: !0,
            animate: !this.gos.get("suppressAnimationFrame")
          }
        }
        refreshModel(e) {
          if (!this.hasStarted || this.isRefreshingModel || this.columnModel.shouldRowModelIgnoreRefresh()) return;
          let t = "object" == typeof e && "step" in e ? e : this.buildRefreshModelParams(e);
          if (!t) return;
          if (this.isSuppressModelUpdateAfterUpdateTransaction(t)) return;
          const i = this.createChangePath(t.rowNodeTransactions);
          switch (this.isRefreshingModel = !0, t.step) {
            case "group":
              this.doRowGrouping(t.rowNodeTransactions, t.rowNodeOrder, i, !!t.afterColumnsChanged);
            case "filter":
              this.doFilter(i);
            case "pivot":
              this.doPivot(i);
            case "aggregate":
              this.doAggregate(i);
            case "filter_aggregates":
              this.doFilterAggregates(i);
            case "sort":
              this.doSort(t.rowNodeTransactions, i);
            case "map":
              this.doRowsToDisplay()
          }
          const r = this.setRowTopAndRowIndex();
          this.clearRowTopAndRowIndex(i, r), this.isRefreshingModel = !1;
          const s = {
            type: Et.EVENT_MODEL_UPDATED,
            animate: t.animate,
            keepRenderedRows: t.keepRenderedRows,
            newData: t.newData,
            newPage: !1,
            keepUndoRedoStack: t.keepUndoRedoStack
          };
          this.eventService.dispatchEvent(s)
        }
        isEmpty() {
          const e = Cs.missing(this.rootNode.allLeafChildren) || 0 === this.rootNode.allLeafChildren.length;
          return Cs.missing(this.rootNode) || e || !this.columnModel.isReady()
        }
        isRowsToRender() {
          return Cs.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0
        }
        getNodesInRangeForSelection(e, t) {
          let i = !t,
            r = !1;
          const s = [],
            n = this.gos.get("groupSelectsChildren");
          return this.forEachNodeAfterFilterAndSort(o => {
            if (r) return;
            if (i && (o === t || o === e) && (r = !0, o.group && n)) return void s.push(...o.allLeafChildren);
            if (!i) {
              if (o !== t && o !== e) return;
              i = !0
            }(!o.group || !n) && s.push(o)
          }), s
        }
        setDatasource(e) {
          console.error("AG Grid: should never call setDatasource on clientSideRowController")
        }
        getTopLevelNodes() {
          return this.rootNode ? this.rootNode.childrenAfterGroup : null
        }
        getRootNode() {
          return this.rootNode
        }
        getRow(e) {
          return this.rowsToDisplay[e]
        }
        isRowPresent(e) {
          return this.rowsToDisplay.indexOf(e) >= 0
        }
        getRowIndexAtPixel(e) {
          if (this.isEmpty() || 0 === this.rowsToDisplay.length) return -1;
          let t = 0,
            i = this.rowsToDisplay.length - 1;
          if (e <= 0) return 0;
          if (Cs.last(this.rowsToDisplay).rowTop <= e) return this.rowsToDisplay.length - 1;
          let r = -1,
            s = -1;
          for (;;) {
            const n = Math.floor((t + i) / 2),
              o = this.rowsToDisplay[n];
            if (this.isRowInPixel(o, e)) return n;
            o.rowTop < e ? t = n + 1 : o.rowTop > e && (i = n - 1);
            if (r === t && s === i) return n;
            r = t, s = i
          }
        }
        isRowInPixel(e, t) {
          const i = e.rowTop,
            r = e.rowTop + e.rowHeight;
          return i <= t && r > t
        }
        forEachLeafNode(e) {
          this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, i) => e(t, i))
        }
        forEachNode(e, t = !1) {
          this.recursivelyWalkNodesAndCallback({
            nodes: [...this.rootNode.childrenAfterGroup || []],
            callback: e,
            recursionType: 0,
            index: 0,
            includeFooterNodes: t
          })
        }
        forEachNodeAfterFilter(e, t = !1) {
          this.recursivelyWalkNodesAndCallback({
            nodes: [...this.rootNode.childrenAfterAggFilter || []],
            callback: e,
            recursionType: 1,
            index: 0,
            includeFooterNodes: t
          })
        }
        forEachNodeAfterFilterAndSort(e, t = !1) {
          this.recursivelyWalkNodesAndCallback({
            nodes: [...this.rootNode.childrenAfterSort || []],
            callback: e,
            recursionType: 2,
            index: 0,
            includeFooterNodes: t
          })
        }
        forEachPivotNode(e, t = !1) {
          this.recursivelyWalkNodesAndCallback({
            nodes: [this.rootNode],
            callback: e,
            recursionType: 3,
            index: 0,
            includeFooterNodes: t
          })
        }
        recursivelyWalkNodesAndCallback(e) {
          const {
            nodes: t,
            callback: i,
            recursionType: r,
            includeFooterNodes: s
          } = e;
          let {
            index: n
          } = e;
          const o = e => {
            var r;
            const o = null == (r = t[0]) ? void 0 : r.parent;
            if (!o) return;
            const a = s && this.gos.getGrandTotalRow(),
              l = this.gos.getGroupTotalRowCallback(),
              c = s && l({
                node: o
              });
            o === this.rootNode ? a === e && (o.createFooter(), i(o.sibling, n++)) : c === e && (o.createFooter(), i(o.sibling, n++))
          };
          o("top");
          for (let e = 0; e < t.length; e++) {
            const o = t[e];
            if (i(o, n++), o.hasChildren() && !o.footer) {
              let e = null;
              switch (r) {
                case 0:
                  e = o.childrenAfterGroup;
                  break;
                case 1:
                  e = o.childrenAfterAggFilter;
                  break;
                case 2:
                  e = o.childrenAfterSort;
                  break;
                case 3:
                  e = o.leafGroup ? null : o.childrenAfterSort
              }
              e && (n = this.recursivelyWalkNodesAndCallback({
                nodes: [...e],
                callback: i,
                recursionType: r,
                index: n,
                includeFooterNodes: s
              }))
            }
          }
          return o("bottom"), n
        }
        doAggregate(e) {
          var t;
          null == (t = this.aggregationStage) || t.execute({
            rowNode: this.rootNode,
            changedPath: e
          })
        }
        doFilterAggregates(e) {
          this.filterAggregatesStage ? this.filterAggregatesStage.execute({
            rowNode: this.rootNode,
            changedPath: e
          }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter
        }
        expandOrCollapseAll(e) {
          const t = this.gos.get("treeData"),
            i = this.columnModel.isPivotActive(),
            r = s => {
              s && s.forEach(s => {
                const n = () => {
                  s.expanded = e, r(s.childrenAfterGroup)
                };
                if (t) {
                  return void(Cs.exists(s.childrenAfterGroup) && n())
                }
                if (i) {
                  return void(!s.leafGroup && n())
                }
                s.group && n()
              })
            };
          this.rootNode && r(this.rootNode.childrenAfterGroup), this.refreshModel({
            step: "map"
          });
          const s = e ? "expandAll" : "collapseAll",
            n = {
              type: Et.EVENT_EXPAND_COLLAPSE_ALL,
              source: s
            };
          this.eventService.dispatchEvent(n)
        }
        doSort(e, t) {
          this.sortStage.execute({
            rowNode: this.rootNode,
            rowNodeTransactions: e,
            changedPath: t
          })
        }
        doRowGrouping(e, t, i, r) {
          if (this.groupStage) {
            if (e ? this.groupStage.execute({
                rowNode: this.rootNode,
                rowNodeTransactions: e,
                rowNodeOrder: t,
                changedPath: i
              }) : this.groupStage.execute({
                rowNode: this.rootNode,
                changedPath: i,
                afterColumnsChanged: r
              }), this.gos.get("groupSelectsChildren")) {
              if (this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", i)) {
                const e = {
                  type: Et.EVENT_SELECTION_CHANGED,
                  source: "rowGroupChanged"
                };
                this.eventService.dispatchEvent(e)
              }
            }
          } else this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren, this.rootNode.sibling && (this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup), this.rootNode.updateHasChildren();
          this.nodeManager.isRowCountReady() && (this.rowCountReady = !0, this.eventService.dispatchEventOnce({
            type: Et.EVENT_ROW_COUNT_READY
          }))
        }
        doFilter(e) {
          this.filterStage.execute({
            rowNode: this.rootNode,
            changedPath: e
          })
        }
        doPivot(e) {
          var t;
          null == (t = this.pivotStage) || t.execute({
            rowNode: this.rootNode,
            changedPath: e
          })
        }
        getCopyOfNodesMap() {
          return this.nodeManager.getCopyOfNodesMap()
        }
        getRowNode(e) {
          if ("string" == typeof e && 0 == e.indexOf(Vn.ID_PREFIX_ROW_GROUP)) {
            let t;
            return this.forEachNode(i => {
              i.id === e && (t = i)
            }), t
          }
          return this.nodeManager.getRowNode(e)
        }
        setRowData(e) {
          this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh()
        }
        dispatchUpdateEventsAndRefresh() {
          const e = {
            type: Et.EVENT_ROW_DATA_UPDATED
          };
          this.eventService.dispatchEvent(e), this.refreshModel({
            step: "group",
            newData: !0
          })
        }
        batchUpdateRowData(e, t) {
          if (null == this.applyAsyncTransactionsTimeout) {
            this.rowDataTransactionBatch = [];
            const e = this.gos.getAsyncTransactionWaitMillis();
            this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
              this.executeBatchUpdateRowData()
            }, e)
          }
          this.rowDataTransactionBatch.push({
            rowDataTransaction: e,
            callback: t
          })
        }
        flushAsyncTransactions() {
          null != this.applyAsyncTransactionsTimeout && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData())
        }
        executeBatchUpdateRowData() {
          this.valueCache.onDataChanged();
          const e = [],
            t = [];
          let i = !1;
          if (this.rowDataTransactionBatch && this.rowDataTransactionBatch.forEach(r => {
              const s = this.nodeManager.updateRowData(r.rowDataTransaction, void 0);
              t.push(s), r.callback && e.push(r.callback.bind(null, s)), "number" == typeof r.rowDataTransaction.addIndex && (i = !0)
            }), this.commonUpdateRowData(t, void 0, i), e.length > 0 && window.setTimeout(() => {
              e.forEach(e => e())
            }, 0), t.length > 0) {
            const e = {
              type: Et.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
              results: t
            };
            this.eventService.dispatchEvent(e)
          }
          this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0
        }
        updateRowData(e, t) {
          this.valueCache.onDataChanged();
          const i = this.nodeManager.updateRowData(e, t),
            r = "number" == typeof e.addIndex;
          return this.commonUpdateRowData([i], t, r), i
        }
        createRowNodeOrder() {
          if (this.gos.get("suppressMaintainUnsortedOrder")) return;
          const e = {};
          if (this.rootNode && this.rootNode.allLeafChildren)
            for (let t = 0; t < this.rootNode.allLeafChildren.length; t++) {
              e[this.rootNode.allLeafChildren[t].id] = t
            }
          return e
        }
        commonUpdateRowData(e, t, i) {
          if (!this.hasStarted) return;
          const r = !this.gos.get("suppressAnimationFrame");
          i && (t = this.createRowNodeOrder());
          const s = {
            type: Et.EVENT_ROW_DATA_UPDATED
          };
          this.eventService.dispatchEvent(s), this.refreshModel({
            step: "group",
            rowNodeTransactions: e,
            rowNodeOrder: t,
            keepRenderedRows: !0,
            keepEditingRows: !0,
            animate: r
          })
        }
        doRowsToDisplay() {
          this.rowsToDisplay = this.flattenStage.execute({
            rowNode: this.rootNode
          })
        }
        onRowHeightChanged() {
          this.refreshModel({
            step: "map",
            keepRenderedRows: !0,
            keepEditingRows: !0,
            keepUndoRedoStack: !0
          })
        }
        onRowHeightChangedDebounced() {
          this.onRowHeightChanged_debounced()
        }
        resetRowHeights() {
          const e = this.resetRowHeightsForAllRowNodes();
          this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, !0), e && this.onRowHeightChanged()
        }
        resetRowHeightsForAllRowNodes() {
          let e = !1;
          return this.forEachNode(t => {
            t.setRowHeight(t.rowHeight, !0);
            const i = t.detailNode;
            i && i.setRowHeight(i.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0
          }), e
        }
        onGridStylesChanges() {
          this.columnModel.isAutoRowHeightActive() || this.resetRowHeights()
        }
        onGridReady() {
          this.hasStarted || this.setInitialData()
        }
        isRowDataLoaded() {
          return this.rowCountReady
        }
      };
    C([fe("columnModel")], Ph.prototype, "columnModel", 2), C([fe("selectionService")], Ph.prototype, "selectionService", 2), C([fe("valueCache")], Ph.prototype, "valueCache", 2), C([fe("beans")], Ph.prototype, "beans", 2), C([fe("filterStage")], Ph.prototype, "filterStage", 2), C([fe("sortStage")], Ph.prototype, "sortStage", 2), C([fe("flattenStage")], Ph.prototype, "flattenStage", 2), C([Te("groupStage")], Ph.prototype, "groupStage", 2), C([Te("aggregationStage")], Ph.prototype, "aggregationStage", 2), C([Te("pivotStage")], Ph.prototype, "pivotStage", 2), C([Te("filterAggregatesStage")], Ph.prototype, "filterAggregatesStage", 2), C([pe], Ph.prototype, "init", 1), Ph = C([ge("rowModel")], Ph);
    var bh = class extends ct {
      execute(e) {
        const {
          changedPath: t
        } = e;
        this.filterService.filter(t)
      }
    };
    C([fe("filterService")], bh.prototype, "filterService", 2), bh = C([ge("filterStage")], bh);
    var Mh = class extends ct {
      execute(e) {
        const t = this.sortController.getSortOptions(),
          i = Cs.exists(t) && t.length > 0,
          r = i && Cs.exists(e.rowNodeTransactions) && this.gos.get("deltaSort"),
          s = t.some(e => this.gos.isColumnsSortingCoupledToGroup() ? e.column.isPrimary() && e.column.isRowGroupActive() : !!e.column.getColDef().showRowGroup);
        this.sortService.sort(t, i, r, e.rowNodeTransactions, e.changedPath, s)
      }
    };
    C([fe("sortService")], Mh.prototype, "sortService", 2), C([fe("sortController")], Mh.prototype, "sortController", 2), Mh = C([ge("sortStage")], Mh);
    var Fh = class extends ct {
      execute(e) {
        const t = e.rowNode,
          i = [],
          r = this.beans.columnModel.isPivotMode(),
          s = r && t.leafGroup,
          n = s ? [t] : t.childrenAfterSort,
          o = this.getFlattenDetails();
        this.recursivelyAddToRowsToDisplay(o, n, i, r, 0);
        if (!s && i.length > 0 && o.grandTotalRow) {
          t.createFooter();
          const e = "top" === o.grandTotalRow;
          this.addRowNodeToRowsToDisplay(o, t.sibling, i, 0, e)
        }
        return i
      }
      getFlattenDetails() {
        const e = this.gos.get("groupRemoveSingleChildren");
        return {
          groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"),
          groupRemoveSingleChildren: e,
          isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
          hideOpenParents: this.gos.get("groupHideOpenParents"),
          grandTotalRow: this.gos.getGrandTotalRow(),
          groupTotalRow: this.gos.getGroupTotalRowCallback()
        }
      }
      recursivelyAddToRowsToDisplay(e, t, i, r, s) {
        if (!Cs.missingOrEmpty(t))
          for (let n = 0; n < t.length; n++) {
            const o = t[n],
              a = o.hasChildren(),
              l = r && !a,
              c = e.groupRemoveSingleChildren && a && 1 === o.childrenAfterGroup.length,
              h = e.groupRemoveLowestSingleChildren && a && o.leafGroup && 1 === o.childrenAfterGroup.length,
              u = r && o.leafGroup,
              d = e.hideOpenParents && o.expanded && !o.master && !u;
            if (!(l || d || c || h) && this.addRowNodeToRowsToDisplay(e, o, i, s), !r || !o.leafGroup)
              if (a) {
                const t = c || h;
                if (o.expanded || t) {
                  const n = e.groupTotalRow({
                    node: o
                  });
                  n || o.destroyFooter();
                  const a = t ? s : s + 1;
                  "top" === n && (o.createFooter(), this.addRowNodeToRowsToDisplay(e, o.sibling, i, a)), this.recursivelyAddToRowsToDisplay(e, o.childrenAfterSort, i, r, a), "bottom" === n && (o.createFooter(), this.addRowNodeToRowsToDisplay(e, o.sibling, i, a))
                }
              } else if (o.master && o.expanded) {
              const t = this.createDetailNode(o);
              this.addRowNodeToRowsToDisplay(e, t, i, s)
            }
          }
      }
      addRowNodeToRowsToDisplay(e, t, i, r, s) {
        s ? i.unshift(t) : i.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : r)
      }
      createDetailNode(e) {
        if (Cs.exists(e.detailNode)) return e.detailNode;
        const t = new Vn(this.beans);
        return t.detail = !0, t.selectable = !1, t.parent = e, Cs.exists(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t
      }
    };
    C([fe("beans")], Fh.prototype, "beans", 2), Fh = C([ge("flattenStage")], Fh);
    var xh = class extends ct {
      sort(e, t, i, r, s, n) {
        const o = this.gos.get("groupMaintainOrder"),
          a = this.columnModel.getAllGridColumns().some(e => e.isRowGroupActive());
        let l = {};
        i && r && (l = this.calculateDirtyNodes(r));
        const c = this.columnModel.isPivotMode(),
          h = this.gos.getCallback("postSortRows"),
          u = r => {
            var u;
            this.pullDownGroupDataForHideOpenParents(r.childrenAfterAggFilter, !0);
            const d = c && r.leafGroup;
            if (o && a && !r.leafGroup && !n) {
              const e = null == (u = this.columnModel.getRowGroupColumns()) ? void 0 : u[r.level + 1],
                t = null === (null == e ? void 0 : e.getSort()),
                i = r.childrenAfterAggFilter.slice(0);
              if (r.childrenAfterSort && !t) {
                const e = {};
                r.childrenAfterSort.forEach((t, i) => {
                  e[t.id] = i
                }), i.sort((t, i) => {
                  var r, s;
                  return (null != (r = e[t.id]) ? r : 0) - (null != (s = e[i.id]) ? s : 0)
                })
              }
              r.childrenAfterSort = i
            } else r.childrenAfterSort = !t || d ? r.childrenAfterAggFilter.slice(0) : i ? this.doDeltaSort(r, l, s, e) : this.rowNodeSorter.doFullSort(r.childrenAfterAggFilter, e);
            if (r.sibling && (r.sibling.childrenAfterSort = r.childrenAfterSort), this.updateChildIndexes(r), h) {
              const e = {
                nodes: r.childrenAfterSort
              };
              h(e)
            }
          };
        s && s.forEachChangedNodeDepthFirst(u), this.updateGroupDataForHideOpenParents(s)
      }
      calculateDirtyNodes(e) {
        const t = {},
          i = e => {
            e && e.forEach(e => t[e.id] = !0)
          };
        return e && e.forEach(e => {
          i(e.add), i(e.update), i(e.remove)
        }), t
      }
      doDeltaSort(e, t, i, r) {
        const s = e.childrenAfterAggFilter,
          n = e.childrenAfterSort;
        if (!n) return this.rowNodeSorter.doFullSort(s, r);
        const o = {},
          a = [];
        s.forEach(e => {
          t[e.id] || !i.canSkip(e) ? a.push(e) : o[e.id] = !0
        });
        const l = n.filter(e => o[e.id]),
          c = (e, t) => ({
            currentPos: t,
            rowNode: e
          }),
          h = a.map(c).sort((e, t) => this.rowNodeSorter.compareRowNodes(r, e, t));
        return this.mergeSortedArrays(r, h, l.map(c)).map(({
          rowNode: e
        }) => e)
      }
      mergeSortedArrays(e, t, i) {
        const r = [];
        let s = 0,
          n = 0;
        for (; s < t.length && n < i.length;) {
          this.rowNodeSorter.compareRowNodes(e, t[s], i[n]) < 0 ? r.push(t[s++]) : r.push(i[n++])
        }
        for (; s < t.length;) r.push(t[s++]);
        for (; n < i.length;) r.push(i[n++]);
        return r
      }
      updateChildIndexes(e) {
        if (Cs.missing(e.childrenAfterSort)) return;
        const t = e.childrenAfterSort;
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            s = 0 === i,
            n = i === e.childrenAfterSort.length - 1;
          r.setFirstChild(s), r.setLastChild(n), r.setChildIndex(i)
        }
      }
      updateGroupDataForHideOpenParents(e) {
        if (!this.gos.get("groupHideOpenParents")) return;
        if (this.gos.get("treeData")) return Cs.warnOnce("The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."), !1;
        const t = e => {
          this.pullDownGroupDataForHideOpenParents(e.childrenAfterSort, !1), e.childrenAfterSort.forEach(e => {
            e.hasChildren() && t(e)
          })
        };
        e && e.executeFromRootNode(e => t(e))
      }
      pullDownGroupDataForHideOpenParents(e, t) {
        this.gos.get("groupHideOpenParents") && !Cs.missing(e) && e.forEach(e => {
          this.columnModel.getGroupDisplayColumns().forEach(i => {
            const r = i.getColDef().showRowGroup;
            if ("string" != typeof r) return void console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
            const s = r,
              n = this.columnModel.getPrimaryColumn(s);
            if (!(n === e.rowGroupColumn))
              if (t) e.setGroupValue(i.getId(), void 0);
              else {
                const t = e.getFirstChildOfFirstChild(n);
                t && e.setGroupValue(i.getId(), t.key)
              }
          })
        })
      }
    };
    C([fe("columnModel")], xh.prototype, "columnModel", 2), C([fe("rowNodeSorter")], xh.prototype, "rowNodeSorter", 2), xh = C([ge("sortService")], xh);
    var Gh = class extends ct {
      filter(e) {
        const t = this.filterManager.isChildFilterPresent();
        this.filterNodes(t, e)
      }
      filterNodes(e, t) {
        const i = (t, i) => {
          t.hasChildren() ? t.childrenAfterFilter = e && !i ? t.childrenAfterGroup.filter(e => {
            const t = e.childrenAfterFilter && e.childrenAfterFilter.length > 0,
              i = e.data && this.filterManager.doesRowPassFilter({
                rowNode: e
              });
            return t || i
          }) : t.childrenAfterGroup : t.childrenAfterFilter = t.childrenAfterGroup, t.sibling && (t.sibling.childrenAfterFilter = t.childrenAfterFilter)
        };
        if (this.doingTreeDataFiltering()) {
          const e = (t, r) => {
              if (t.childrenAfterGroup)
                for (let s = 0; s < t.childrenAfterGroup.length; s++) {
                  const n = t.childrenAfterGroup[s],
                    o = r || this.filterManager.doesRowPassFilter({
                      rowNode: n
                    });
                  n.childrenAfterGroup ? e(t.childrenAfterGroup[s], o) : i(n, o)
                }
              i(t, r)
            },
            r = t => e(t, !1);
          t.executeFromRootNode(r)
        } else {
          const e = e => i(e, !1);
          t.forEachChangedNodeDepthFirst(e, !0)
        }
      }
      doingTreeDataFiltering() {
        return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering")
      }
    };
    C([fe("filterManager")], Gh.prototype, "filterManager", 2), Gh = C([ge("filterService")], Gh);
    var Uh = class extends ct {
      postConstruct() {
        "clientSide" === this.rowModel.getType() && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()))
      }
      isActive() {
        const e = this.gos.exists("getRowId");
        return !this.gos.get("resetRowDataOnUpdate") && e
      }
      setRowData(e) {
        const t = this.createTransactionForRowData(e);
        if (!t) return;
        const [i, r] = t;
        this.clientSideRowModel.updateRowData(i, r)
      }
      createTransactionForRowData(e) {
        if (Cs.missing(this.clientSideRowModel)) return void console.error("AG Grid: ImmutableService only works with ClientSideRowModel");
        const t = this.gos.getCallback("getRowId");
        if (null == t) return void console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
        const i = {
            remove: [],
            update: [],
            add: []
          },
          r = this.clientSideRowModel.getCopyOfNodesMap(),
          s = this.gos.get("suppressMaintainUnsortedOrder") ? void 0 : {};
        return Cs.exists(e) && e.forEach((e, n) => {
          const o = t({
              data: e,
              level: 0
            }),
            a = r[o];
          if (s && (s[o] = n), a) {
            a.data !== e && i.update.push(e), r[o] = void 0
          } else i.add.push(e)
        }), Cs.iterateObject(r, (e, t) => {
          t && i.remove.push(t.data)
        }), [i, s]
      }
      onRowDataUpdated() {
        const e = this.gos.get("rowData");
        e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)))
      }
    };
    C([fe("rowModel")], Uh.prototype, "rowModel", 2), C([fe("rowRenderer")], Uh.prototype, "rowRenderer", 2), C([fe("selectionService")], Uh.prototype, "selectionService", 2), C([pe], Uh.prototype, "postConstruct", 1);
    var Hh = {
        version: "31.3.4",
        moduleName: "@ag-grid-community/client-side-row-model",
        rowModel: "clientSide",
        beans: [Ph, bh, Mh, Fh, xh, Gh, Uh = C([ge("immutableService")], Uh)]
      },
      kh = Object.defineProperty,
      Bh = Object.getOwnPropertyDescriptor,
      Vh = (e, t, i, r) => {
        for (var s, n = r > 1 ? void 0 : r ? Bh(t, i) : t, o = e.length - 1; o >= 0; o--)(s = e[o]) && (n = (r ? s(t, i, n) : s(n)) || n);
        return r && n && kh(t, i, n), n
      },
      Wh = class extends Dl {
        constructor(e, t, i) {
          super(e), this.parentCache = t, this.params = i, this.startRow = e * i.blockSize, this.endRow = this.startRow + i.blockSize
        }
        postConstruct() {
          this.createRowNodes()
        }
        getBlockStateJson() {
          return {
            id: "" + this.getId(),
            state: {
              blockNumber: this.getId(),
              startRow: this.getStartRow(),
              endRow: this.getEndRow(),
              pageStatus: this.getState()
            }
          }
        }
        setDataAndId(e, t, i) {
          Cs.exists(t) ? e.setDataAndId(t, i.toString()) : e.setDataAndId(void 0, void 0)
        }
        loadFromDatasource() {
          const e = this.createLoadParams();
          Cs.missing(this.params.datasource.getRows) ? console.warn("AG Grid: datasource is missing getRows method") : window.setTimeout(() => {
            this.params.datasource.getRows(e)
          }, 0)
        }
        processServerFail() {}
        createLoadParams() {
          return {
            startRow: this.getStartRow(),
            endRow: this.getEndRow(),
            successCallback: this.pageLoaded.bind(this, this.getVersion()),
            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
            sortModel: this.params.sortModel,
            filterModel: this.params.filterModel,
            context: this.gos.getGridCommonParams().context
          }
        }
        forEachNode(e, t, i) {
          this.rowNodes.forEach((r, s) => {
            this.startRow + s < i && e(r, t.next())
          })
        }
        getLastAccessed() {
          return this.lastAccessed
        }
        getRow(e, t = !1) {
          t || (this.lastAccessed = this.params.lastAccessedSequence.next());
          const i = e - this.startRow;
          return this.rowNodes[i]
        }
        getStartRow() {
          return this.startRow
        }
        getEndRow() {
          return this.endRow
        }
        createRowNodes() {
          this.rowNodes = [];
          for (let e = 0; e < this.params.blockSize; e++) {
            const t = this.startRow + e,
              i = new Vn(this.beans);
            i.setRowHeight(this.params.rowHeight), i.uiLevel = 0, i.setRowIndex(t), i.setRowTop(this.params.rowHeight * t), this.rowNodes.push(i)
          }
        }
        processServerResult(e) {
          this.rowNodes.forEach((t, i) => {
            const r = e.rowData ? e.rowData[i] : void 0;
            !t.id && t.alreadyRendered && r && (this.rowNodes[i] = new Vn(this.beans), this.rowNodes[i].setRowIndex(t.rowIndex), this.rowNodes[i].setRowTop(t.rowTop), this.rowNodes[i].setRowHeight(t.rowHeight), t.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[i], r, this.startRow + i)
          });
          const t = null != e.rowCount && e.rowCount >= 0 ? e.rowCount : void 0;
          this.parentCache.pageLoaded(this, t)
        }
        destroyRowNodes() {
          this.rowNodes.forEach(e => {
            e.clearRowTopAndRowIndex()
          })
        }
      };
    Vh([fe("beans")], Wh.prototype, "beans", 2), Vh([pe], Wh.prototype, "postConstruct", 1), Vh([Ee], Wh.prototype, "destroyRowNodes", 1);
    var Yh, Kh, Xh = class e extends ct {
      constructor(e) {
        super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount, this.params = e
      }
      setBeans(e) {
        this.logger = e.create("InfiniteCache")
      }
      getRow(e, t = !1) {
        const i = Math.floor(e / this.params.blockSize);
        let r = this.blocks[i];
        if (!r) {
          if (t) return;
          r = this.createBlock(i)
        }
        return r.getRow(e)
      }
      createBlock(e) {
        const t = this.createBean(new Wh(e, this, this.params));
        return this.blocks[t.getId()] = t, this.blockCount++, this.purgeBlocksIfNeeded(t), this.params.rowNodeBlockLoader.addBlock(t), t
      }
      refreshCache() {
        0 == this.blockCount ? this.purgeCache() : (this.getBlocksInOrder().forEach(e => e.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad())
      }
      destroyAllBlocks() {
        this.getBlocksInOrder().forEach(e => this.destroyBlock(e))
      }
      getRowCount() {
        return this.rowCount
      }
      isLastRowIndexKnown() {
        return this.lastRowIndexKnown
      }
      pageLoaded(e, t) {
        this.isAlive() && (this.logger.log(`onPageLoaded: page = ${e.getId()}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated())
      }
      purgeBlocksIfNeeded(t) {
        const i = this.getBlocksInOrder().filter(e => e != t);
        i.sort((e, t) => t.getLastAccessed() - e.getLastAccessed());
        const r = this.params.maxBlocksInCache > 0,
          s = r ? this.params.maxBlocksInCache - 1 : null,
          n = e.MAX_EMPTY_BLOCKS_TO_KEEP - 1;
        i.forEach((e, t) => {
          if (e.getState() === Wh.STATE_WAITING_TO_LOAD && t >= n || !!r && t >= s) {
            if (this.isBlockCurrentlyDisplayed(e)) return;
            if (this.isBlockFocused(e)) return;
            this.removeBlockFromCache(e)
          }
        })
      }
      isBlockFocused(e) {
        const t = this.focusService.getFocusCellToUseAfterRefresh();
        if (!t) return !1;
        if (null != t.rowPinned) return !1;
        const i = e.getStartRow(),
          r = e.getEndRow();
        return t.rowIndex >= i && t.rowIndex < r
      }
      isBlockCurrentlyDisplayed(e) {
        const t = e.getStartRow(),
          i = e.getEndRow() - 1;
        return this.rowRenderer.isRangeInRenderedViewport(t, i)
      }
      removeBlockFromCache(e) {
        e && this.destroyBlock(e)
      }
      checkRowCount(e, t) {
        if ("number" == typeof t && t >= 0) this.rowCount = t, this.lastRowIndexKnown = !0;
        else if (!this.lastRowIndexKnown) {
          const t = (e.getId() + 1) * this.params.blockSize + this.params.overflowSize;
          this.rowCount < t && (this.rowCount = t)
        }
      }
      setRowCount(e, t) {
        this.rowCount = e, Cs.exists(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated()
      }
      forEachNodeDeep(e) {
        const t = new Ss;
        this.getBlocksInOrder().forEach(i => i.forEachNode(e, t, this.rowCount))
      }
      getBlocksInOrder() {
        return Cs.getAllValuesInObject(this.blocks).sort((e, t) => e.getId() - t.getId())
      }
      destroyBlock(e) {
        delete this.blocks[e.getId()], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e)
      }
      onCacheUpdated() {
        if (this.isAlive()) {
          this.destroyAllBlocksPastVirtualRowCount();
          const e = {
            type: Et.EVENT_STORE_UPDATED
          };
          this.eventService.dispatchEvent(e)
        }
      }
      destroyAllBlocksPastVirtualRowCount() {
        const e = [];
        this.getBlocksInOrder().forEach(t => {
          t.getId() * this.params.blockSize >= this.rowCount && e.push(t)
        }), e.length > 0 && e.forEach(e => this.destroyBlock(e))
      }
      purgeCache() {
        this.getBlocksInOrder().forEach(e => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, 0 === this.rowCount && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated()
      }
      getRowNodesInRange(e, t) {
        const i = [];
        let r = -1,
          s = !1;
        const n = new Ss;
        Cs.missing(e) && (s = !0);
        let o = !1;
        this.getBlocksInOrder().forEach(a => {
          o || (s && r + 1 !== a.getId() ? o = !0 : (r = a.getId(), a.forEachNode(r => {
            const n = r === e || r === t;
            (s || n) && i.push(r), n && (s = !s)
          }, n, this.rowCount)))
        });
        return o || s ? [] : i
      }
    };
    Xh.MAX_EMPTY_BLOCKS_TO_KEEP = 2, Vh([fe("rowRenderer")], Xh.prototype, "rowRenderer", 2), Vh([fe("focusService")], Xh.prototype, "focusService", 2), Vh([(Yh = 0, Kh = Ce("loggerFactory"), (e, t) => Kh(e, t, Yh))], Xh.prototype, "setBeans", 1), Vh([Ee], Xh.prototype, "destroyAllBlocks", 1);
    var zh = Xh,
      $h = class extends ct {
        getRowBounds(e) {
          return {
            rowHeight: this.rowHeight,
            rowTop: this.rowHeight * e
          }
        }
        ensureRowHeightsValid(e, t, i, r) {
          return !1
        }
        init() {
          this.gos.isRowModelType("infinite") && (this.rowHeight = this.gos.getRowHeightAsNumber(), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps())
        }
        verifyProps() {
          this.gos.exists("initialGroupOrderComparator") && Cs.warnOnce("initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side")
        }
        start() {
          this.setDatasource(this.gos.get("datasource"))
        }
        destroyDatasource() {
          this.datasource && (this.getContext().destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null)
        }
        addEventListeners() {
          this.addManagedListener(this.eventService, Et.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this)), this.addManagedListener(this.eventService, Et.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this)), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
            this.rowHeight = this.gos.getRowHeightAsNumber(), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights()
          })
        }
        onFilterChanged() {
          this.reset()
        }
        onSortChanged() {
          this.reset()
        }
        onColumnEverything() {
          let e;
          e = !this.cacheParams || this.isSortModelDifferent(), e && this.reset()
        }
        isSortModelDifferent() {
          return !Cs.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel())
        }
        getType() {
          return "infinite"
        }
        setDatasource(e) {
          this.destroyDatasource(), this.datasource = e, e && this.reset()
        }
        isEmpty() {
          return !this.infiniteCache
        }
        isRowsToRender() {
          return !!this.infiniteCache
        }
        getNodesInRangeForSelection(e, t) {
          return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : []
        }
        reset() {
          if (!this.datasource) return;
          null != this.gos.getCallback("getRowId") || this.selectionService.reset("rowDataChanged"), this.resetCache()
        }
        createModelUpdatedEvent() {
          return {
            type: Et.EVENT_MODEL_UPDATED,
            newPage: !1,
            newPageSize: !1,
            newData: !1,
            keepRenderedRows: !0,
            animate: !1
          }
        }
        resetCache() {
          this.destroyCache(), this.cacheParams = {
            datasource: this.datasource,
            filterModel: this.filterManager.getFilterModel(),
            sortModel: this.sortController.getSortModel(),
            rowNodeBlockLoader: this.rowNodeBlockLoader,
            initialRowCount: this.gos.get("infiniteInitialRowCount"),
            maxBlocksInCache: this.gos.get("maxBlocksInCache"),
            rowHeight: this.gos.getRowHeightAsNumber(),
            overflowSize: this.gos.get("cacheOverflowSize"),
            blockSize: this.gos.get("cacheBlockSize"),
            lastAccessedSequence: new Ss
          }, this.infiniteCache = this.createBean(new zh(this.cacheParams)), this.eventService.dispatchEventOnce({
            type: Et.EVENT_ROW_COUNT_READY
          });
          const e = this.createModelUpdatedEvent();
          this.eventService.dispatchEvent(e)
        }
        updateRowHeights() {
          this.forEachNode(e => {
            e.setRowHeight(this.rowHeight), e.setRowTop(this.rowHeight * e.rowIndex)
          });
          const e = this.createModelUpdatedEvent();
          this.eventService.dispatchEvent(e)
        }
        destroyCache() {
          this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache))
        }
        onCacheUpdated() {
          const e = this.createModelUpdatedEvent();
          this.eventService.dispatchEvent(e)
        }
        getRow(e) {
          if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount())) return this.infiniteCache.getRow(e)
        }
        getRowNode(e) {
          let t;
          return this.forEachNode(i => {
            i.id === e && (t = i)
          }), t
        }
        forEachNode(e) {
          this.infiniteCache && this.infiniteCache.forEachNodeDeep(e)
        }
        getTopLevelRowCount() {
          return this.getRowCount()
        }
        getTopLevelRowDisplayedIndex(e) {
          return e
        }
        getRowIndexAtPixel(e) {
          if (0 !== this.rowHeight) {
            const t = Math.floor(e / this.rowHeight),
              i = this.getRowCount() - 1;
            return t > i ? i : t
          }
          return 0
        }
        getRowCount() {
          return this.infiniteCache ? this.infiniteCache.getRowCount() : 0
        }
        isRowPresent(e) {
          return !!this.getRowNode(e.id)
        }
        refreshCache() {
          this.infiniteCache && this.infiniteCache.refreshCache()
        }
        purgeCache() {
          this.infiniteCache && this.infiniteCache.purgeCache()
        }
        isLastRowIndexKnown() {
          return !!this.infiniteCache && this.infiniteCache.isLastRowIndexKnown()
        }
        setRowCount(e, t) {
          this.infiniteCache && this.infiniteCache.setRowCount(e, t)
        }
      };
    Vh([fe("filterManager")], $h.prototype, "filterManager", 2), Vh([fe("sortController")], $h.prototype, "sortController", 2), Vh([fe("selectionService")], $h.prototype, "selectionService", 2), Vh([fe("rowRenderer")], $h.prototype, "rowRenderer", 2), Vh([fe("rowNodeBlockLoader")], $h.prototype, "rowNodeBlockLoader", 2), Vh([pe], $h.prototype, "init", 1), Vh([Ee], $h.prototype, "destroyDatasource", 1);
    var jh = {
        version: "31.3.4",
        moduleName: "@ag-grid-community/infinite-row-model",
        rowModel: "infinite",
        beans: [$h = Vh([ge("rowModel")], $h)]
      },
      Jh = Object.defineProperty,
      qh = Object.defineProperties,
      Qh = Object.getOwnPropertyDescriptor,
      Zh = Object.getOwnPropertyDescriptors,
      eu = Object.getOwnPropertySymbols,
      tu = Object.prototype.hasOwnProperty,
      iu = Object.prototype.propertyIsEnumerable,
      ru = (e, t, i) => t in e ? Jh(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: i
      }) : e[t] = i,
      su = (e, t) => {
        for (var i in t || (t = {})) tu.call(t, i) && ru(e, i, t[i]);
        if (eu)
          for (var i of eu(t)) iu.call(t, i) && ru(e, i, t[i]);
        return e
      },
      nu = (e, t) => qh(e, Zh(t)),
      ou = (e, t, i, r) => {
        for (var s, n = r > 1 ? void 0 : r ? Qh(t, i) : t, o = e.length - 1; o >= 0; o--)(s = e[o]) && (n = (r ? s(t, i, n) : s(n)) || n);
        return r && n && Jh(t, i, n), n
      },
      au = (e, t, i) => new Promise((r, s) => {
        var n = e => {
            try {
              a(i.next(e))
            } catch (e) {
              s(e)
            }
          },
          o = e => {
            try {
              a(i.throw(e))
            } catch (e) {
              s(e)
            }
          },
          a = e => e.done ? r(e.value) : Promise.resolve(e.value).then(n, o);
        a((i = i.apply(e, t)).next())
      }),
      lu = class {
        setBeans(e) {
          this.beans = e
        }
        getFileName(e) {
          const t = this.getDefaultFileExtension();
          return null != e && e.length || (e = this.getDefaultFileName()), -1 === e.indexOf(".") ? `${e}.${t}` : e
        }
        getData(e) {
          const t = this.createSerializingSession(e);
          return this.beans.gridSerializer.serialize(t, e)
        }
        getDefaultFileName() {
          return `export.${this.getDefaultFileExtension()}`
        }
      },
      cu = class {
        constructor(e) {
          this.groupColumns = [];
          const {
            columnModel: t,
            valueService: i,
            gos: r,
            processCellCallback: s,
            processHeaderCallback: n,
            processGroupHeaderCallback: o,
            processRowGroupCallback: a
          } = e;
          this.columnModel = t, this.valueService = i, this.gos = r, this.processCellCallback = s, this.processHeaderCallback = n, this.processGroupHeaderCallback = o, this.processRowGroupCallback = a
        }
        prepare(e) {
          this.groupColumns = e.filter(e => !!e.getColDef().showRowGroup)
        }
        extractHeaderValue(e) {
          const t = this.getHeaderName(this.processHeaderCallback, e);
          return null != t ? t : ""
        }
        extractRowCellValue(e, t, i, r, s) {
          const n = this.gos.get("groupHideOpenParents") && !s.footer || !this.shouldRenderGroupSummaryCell(s, e, t) ? this.valueService.getValue(e, s) : this.createValueForGroupNode(e, s);
          return this.processCell({
            accumulatedRowIndex: i,
            rowNode: s,
            column: e,
            value: n,
            processCellCallback: this.processCellCallback,
            type: r
          })
        }
        shouldRenderGroupSummaryCell(e, t, i) {
          var r;
          if (!(e && e.group)) return !1;
          if (-1 !== this.groupColumns.indexOf(t)) {
            if (null != (null == (r = e.groupData) ? void 0 : r[t.getId()])) return !0;
            if (this.gos.isRowModelType("serverSide") && e.group) return !0;
            if (e.footer && -1 === e.level) {
              const e = t.getColDef();
              return null == e || !0 === e.showRowGroup || e.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId()
            }
          }
          const s = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
          return 0 === i && s
        }
        getHeaderName(e, t) {
          return e ? e(this.gos.addGridCommonParams({
            column: t
          })) : this.columnModel.getDisplayNameForColumn(t, "csv", !0)
        }
        createValueForGroupNode(e, t) {
          if (this.processRowGroupCallback) return this.processRowGroupCallback(this.gos.addGridCommonParams({
            column: e,
            node: t
          }));
          const i = this.gos.get("treeData"),
            r = this.gos.get("suppressGroupMaintainValueType"),
            s = t => {
              var s, n;
              if (i || r) return t.key;
              const o = null == (s = t.groupData) ? void 0 : s[e.getId()];
              return o && t.rowGroupColumn && !1 !== t.rowGroupColumn.getColDef().useValueFormatterForExport && null != (n = this.valueService.formatValue(t.rowGroupColumn, t, o)) ? n : o
            },
            n = t.footer,
            o = [s(t)];
          if (!this.gos.isGroupMultiAutoColumn())
            for (; t.parent;) t = t.parent, o.push(s(t));
          const a = o.reverse().join(" -> ");
          return n ? `Total ${a}` : a
        }
        processCell(e) {
          var t;
          const {
            accumulatedRowIndex: i,
            rowNode: r,
            column: s,
            value: n,
            processCellCallback: o,
            type: a
          } = e;
          return o ? {
            value: null != (t = o(this.gos.addGridCommonParams({
              accumulatedRowIndex: i,
              column: s,
              node: r,
              value: n,
              type: a,
              parseValue: e => this.valueService.parseValue(s, r, e, this.valueService.getValue(s, r)),
              formatValue: e => {
                var t;
                return null != (t = this.valueService.formatValue(s, r, e)) ? t : e
              }
            }))) ? t : ""
          } : !1 !== s.getColDef().useValueFormatterForExport ? {
            value: null != n ? n : "",
            valueFormatted: this.valueService.formatValue(s, r, n)
          } : {
            value: null != n ? n : ""
          }
        }
      },
      hu = class {
        static download(e, t) {
          const i = document.defaultView || window;
          if (!i) return void console.warn("AG Grid: There is no `window` associated with the current `document`");
          const r = document.createElement("a"),
            s = i.URL.createObjectURL(t);
          r.setAttribute("href", s), r.setAttribute("download", e), r.style.display = "none", document.body.appendChild(r), r.dispatchEvent(new MouseEvent("click", {
            bubbles: !1,
            cancelable: !0,
            view: i
          })), document.body.removeChild(r), i.setTimeout(() => {
            i.URL.revokeObjectURL(s)
          }, 0)
        }
      },
      uu = class extends cu {
        constructor(e) {
          super(e), this.isFirstLine = !0, this.result = "";
          const {
            suppressQuotes: t,
            columnSeparator: i
          } = e;
          this.suppressQuotes = t, this.columnSeparator = i
        }
        addCustomContent(e) {
          e && ("string" == typeof e ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, "\r\n"), this.result += e) : e.forEach(e => {
            this.beginNewLine(), e.forEach((e, t) => {
              0 !== t && (this.result += this.columnSeparator), this.result += this.putInQuotes(e.data.value || ""), e.mergeAcross && this.appendEmptyCells(e.mergeAcross)
            })
          }))
        }
        onNewHeaderGroupingRow() {
          return this.beginNewLine(), {
            onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
          }
        }
        onNewHeaderGroupingRowColumn(e, t, i, r) {
          0 != i && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(r)
        }
        appendEmptyCells(e) {
          for (let t = 1; t <= e; t++) this.result += this.columnSeparator + this.putInQuotes("")
        }
        onNewHeaderRow() {
          return this.beginNewLine(), {
            onColumn: this.onNewHeaderRowColumn.bind(this)
          }
        }
        onNewHeaderRowColumn(e, t) {
          0 != t && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e))
        }
        onNewBodyRow() {
          return this.beginNewLine(), {
            onColumn: this.onNewBodyRowColumn.bind(this)
          }
        }
        onNewBodyRowColumn(e, t, i) {
          var r;
          0 != t && (this.result += this.columnSeparator);
          const s = this.extractRowCellValue(e, t, t, "csv", i);
          this.result += this.putInQuotes(null != (r = s.valueFormatted) ? r : s.value)
        }
        putInQuotes(e) {
          if (this.suppressQuotes) return e;
          if (null == e) return '""';
          let t;
          "string" == typeof e ? t = e : "function" == typeof e.toString ? t = e.toString() : (console.warn("AG Grid: unknown value type during csv conversion"), t = "");
          return '"' + t.replace(/"/g, '""') + '"'
        }
        parse() {
          return this.result
        }
        beginNewLine() {
          this.isFirstLine || (this.result += "\r\n"), this.isFirstLine = !1
        }
      },
      du = class extends lu {
        postConstruct() {
          this.setBeans({
            gridSerializer: this.gridSerializer,
            gos: this.gos
          })
        }
        getMergedParams(e) {
          const t = this.gos.get("defaultCsvExportParams");
          return Object.assign({}, t, e)
        }
        export (e) {
          if (this.isExportSuppressed()) return void console.warn("AG Grid: Export cancelled. Export is not allowed as per your configuration.");
          const t = this.getMergedParams(e),
            i = this.getData(t),
            r = new Blob(["\ufeff", i], {
              type: "text/plain"
            }),
            s = "function" == typeof t.fileName ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
          hu.download(this.getFileName(s), r)
        }
        exportDataAsCsv(e) {
          this.export(e)
        }
        getDataAsCsv(e, t = !1) {
          const i = t ? Object.assign({}, e) : this.getMergedParams(e);
          return this.getData(i)
        }
        getDefaultFileExtension() {
          return "csv"
        }
        createSerializingSession(e) {
          const {
            columnModel: t,
            valueService: i,
            gos: r
          } = this, {
            processCellCallback: s,
            processHeaderCallback: n,
            processGroupHeaderCallback: o,
            processRowGroupCallback: a,
            suppressQuotes: l,
            columnSeparator: c
          } = e;
          return new uu({
            columnModel: t,
            valueService: i,
            gos: r,
            processCellCallback: s || void 0,
            processHeaderCallback: n || void 0,
            processGroupHeaderCallback: o || void 0,
            processRowGroupCallback: a || void 0,
            suppressQuotes: l || !1,
            columnSeparator: c || ","
          })
        }
        isExportSuppressed() {
          return this.gos.get("suppressCsvExport")
        }
      };
    ou([fe("columnModel")], du.prototype, "columnModel", 2), ou([fe("valueService")], du.prototype, "valueService", 2), ou([fe("gridSerializer")], du.prototype, "gridSerializer", 2), ou([fe("gridOptionsService")], du.prototype, "gos", 2), ou([pe], du.prototype, "postConstruct", 1), du = ou([ge("csvCreator")], du);
    var pu = class extends ct {
      serialize(e, t = {}) {
        const {
          allColumns: i,
          columnKeys: r,
          skipRowGroups: s
        } = t, n = this.getColumnsToExport(i, s, r);
        return Cs.compose(this.prepareSession(n), this.prependContent(t), this.exportColumnGroups(t, n), this.exportHeaders(t, n), this.processPinnedTopRows(t, n), this.processRows(t, n), this.processPinnedBottomRows(t, n), this.appendContent(t))(e).parse()
      }
      processRow(e, t, i, r) {
        const s = t.shouldRowBeSkipped || (() => !1),
          n = this.gos.get("groupRemoveSingleChildren"),
          o = this.gos.get("groupRemoveLowestSingleChildren"),
          a = null != t.rowPositions || !!t.onlySelected,
          l = this.gos.get("groupHideOpenParents") && !a,
          c = this.columnModel.isPivotMode() ? r.leafGroup : !r.group,
          h = !!r.footer,
          u = (t.skipRowGroups, o && r.leafGroup),
          d = 1 === r.allChildrenCount && (n || u);
        if (!c && !h && (t.skipRowGroups || d || l) || t.onlySelected && !r.isSelected() || t.skipPinnedTop && "top" === r.rowPinned || t.skipPinnedBottom && "bottom" === r.rowPinned) return;
        if (-1 === r.level && !c && !h) return;
        if (s(this.gos.addGridCommonParams({
            node: r
          }))) return;
        const p = e.onNewBodyRow(r);
        if (i.forEach((e, t) => {
            p.onColumn(e, t, r)
          }), t.getCustomContentBelowRow) {
          const i = t.getCustomContentBelowRow(this.gos.addGridCommonParams({
            node: r
          }));
          i && e.addCustomContent(i)
        }
      }
      appendContent(e) {
        return t => {
          const i = e.appendContent;
          return i && t.addCustomContent(i), t
        }
      }
      prependContent(e) {
        return t => {
          const i = e.prependContent;
          return i && t.addCustomContent(i), t
        }
      }
      prepareSession(e) {
        return t => (t.prepare(e), t)
      }
      exportColumnGroups(e, t) {
        return i => {
          if (!e.skipColumnGroupHeaders) {
            const r = new ft,
              s = this.displayedGroupCreator.createDisplayedGroups(t, r, null);
            this.recursivelyAddHeaderGroups(s, i, e.processGroupHeaderCallback)
          }
          return i
        }
      }
      exportHeaders(e, t) {
        return i => {
          if (!e.skipColumnHeaders) {
            const e = i.onNewHeaderRow();
            t.forEach((t, i) => {
              e.onColumn(t, i, void 0)
            })
          }
          return i
        }
      }
      processPinnedTopRows(e, t) {
        return i => {
          const r = this.processRow.bind(this, i, e, t);
          return e.rowPositions ? e.rowPositions.filter(e => "top" === e.rowPinned).sort((e, t) => e.rowIndex - t.rowIndex).map(e => this.pinnedRowModel.getPinnedTopRow(e.rowIndex)).forEach(r) : this.pinnedRowModel.forEachPinnedTopRow(r), i
        }
      }
      processRows(e, t) {
        return i => {
          const r = this.rowModel,
            s = r.getType(),
            n = "clientSide" === s,
            o = "serverSide" === s,
            a = !n && e.onlySelected,
            l = this.processRow.bind(this, i, e, t),
            {
              exportedRows: c = "filteredAndSorted"
            } = e;
          if (e.rowPositions) e.rowPositions.filter(e => null == e.rowPinned).sort((e, t) => e.rowIndex - t.rowIndex).map(e => r.getRow(e.rowIndex)).forEach(l);
          else if (this.columnModel.isPivotMode()) n ? r.forEachPivotNode(l, !0) : o ? r.forEachNodeAfterFilterAndSort(l, !0) : r.forEachNode(l);
          else if (e.onlySelectedAllPages || a) {
            const e = this.selectionService.getSelectedNodes();
            this.replicateSortedOrder(e), e.forEach(l)
          } else "all" === c ? r.forEachNode(l) : n || o ? r.forEachNodeAfterFilterAndSort(l, !0) : r.forEachNode(l);
          return i
        }
      }
      replicateSortedOrder(e) {
        const t = this.sortController.getSortOptions(),
          i = (e, r) => {
            var s, n, o, a;
            return null != e.rowIndex && null != r.rowIndex ? e.rowIndex - r.rowIndex : e.level === r.level ? (null == (s = e.parent) ? void 0 : s.id) === (null == (n = r.parent) ? void 0 : n.id) ? this.rowNodeSorter.compareRowNodes(t, {
              rowNode: e,
              currentPos: null != (o = e.rowIndex) ? o : -1
            }, {
              rowNode: r,
              currentPos: null != (a = r.rowIndex) ? a : -1
            }) : i(e.parent, r.parent) : e.level > r.level ? i(e.parent, r) : i(e, r.parent)
          };
        e.sort(i)
      }
      processPinnedBottomRows(e, t) {
        return i => {
          const r = this.processRow.bind(this, i, e, t);
          return e.rowPositions ? e.rowPositions.filter(e => "bottom" === e.rowPinned).sort((e, t) => e.rowIndex - t.rowIndex).map(e => this.pinnedRowModel.getPinnedBottomRow(e.rowIndex)).forEach(r) : this.pinnedRowModel.forEachPinnedBottomRow(r), i
        }
      }
      getColumnsToExport(e = !1, t = !1, i) {
        const r = this.columnModel.isPivotMode();
        if (i && i.length) return this.columnModel.getGridColumns(i);
        const s = this.gos.get("treeData");
        let n = [];
        return n = e && !r ? this.columnModel.getAllGridColumns() : this.columnModel.getAllDisplayedColumns(), t && !s && (n = n.filter(e => e.getColId() !== Tt)), n
      }
      recursivelyAddHeaderGroups(e, t, i) {
        const r = [];
        e.forEach(e => {
          const t = e;
          t.getChildren && t.getChildren().forEach(e => r.push(e))
        }), e.length > 0 && e[0] instanceof pt && this.doAddHeaderHeader(t, e, i), r && r.length > 0 && this.recursivelyAddHeaderGroups(r, t, i)
      }
      doAddHeaderHeader(e, t, i) {
        const r = e.onNewHeaderGroupingRow();
        let s = 0;
        t.forEach(e => {
          const t = e;
          let n;
          n = i ? i(this.gos.addGridCommonParams({
            columnGroup: t
          })) : this.columnModel.getDisplayNameForColumnGroup(t, "header");
          const o = t.getLeafColumns().reduce((e, t, i, r) => {
            let s = Cs.last(e);
            return "open" === t.getColumnGroupShow() ? s && null == s[1] || (s = [i], e.push(s)) : s && null == s[1] && (s[1] = i - 1), i === r.length - 1 && s && null == s[1] && (s[1] = i), e
          }, []);
          r.onColumn(t, n || "", s++, t.getLeafColumns().length - 1, o)
        })
      }
    };
    ou([fe("displayedGroupCreator")], pu.prototype, "displayedGroupCreator", 2), ou([fe("columnModel")], pu.prototype, "columnModel", 2), ou([fe("rowModel")], pu.prototype, "rowModel", 2), ou([fe("pinnedRowModel")], pu.prototype, "pinnedRowModel", 2), ou([fe("selectionService")], pu.prototype, "selectionService", 2), ou([fe("rowNodeSorter")], pu.prototype, "rowNodeSorter", 2), ou([fe("sortController")], pu.prototype, "sortController", 2);
    var Eu = {
      version: "31.3.4",
      moduleName: "@ag-grid-community/csv-export",
      beans: [du, pu = ou([ge("gridSerializer")], pu)]
    };

    function gu(e, t) {
      let i = "";
      for (let r = 0; r < t; r++) i += String.fromCharCode(255 & e), e >>>= 8;
      return i
    }
    var fu = e => {
        if (!e.length) return 0;
        let t = ~0,
          i = 0,
          r = 0,
          s = 0;
        for (let n = 0; n < e.length; n++) i = e[n], r = 255 & (t ^ i), s = mu[r], t = t >>> 8 ^ s;
        return -1 ^ t
      },
      Tu = e => e.length ? fu("string" == typeof e ? (new TextEncoder).encode(e) : e) : 0,
      mu = new Uint32Array([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]),
      Cu = e => au(void 0, null, function*() {
        const t = new Blob([e]),
          {
            size: i,
            content: r
          } = yield(s = t, au(void 0, null, function*() {
            let e = 0;
            const t = [],
              i = new WritableStream({
                write: i => {
                  t.push(i), e += i.length
                }
              }),
              r = new ReadableStream({
                start: e => {
                  const t = new FileReader;
                  t.onload = t => {
                    var i;
                    (null == (i = t.target) ? void 0 : i.result) && e.enqueue(t.target.result), e.close()
                  }, t.readAsArrayBuffer(s)
                }
              }),
              n = new window.CompressionStream("deflate-raw");
            return yield r.pipeThrough(n).pipeTo(i), {
              size: e,
              content: new Blob(t)
            }
          }));
        var s;
        return {
          size: i,
          content: new Uint8Array(yield r.arrayBuffer())
        }
      }),
      {
        utf8_encode: Su
      } = Cs,
      Ru = (e, t) => au(void 0, null, function*() {
        const {
          content: i
        } = e, {
          size: r,
          content: s
        } = i ? Nu(i) : {
          size: 0,
          content: Uint8Array.from([])
        };
        let n, o, a = !1;
        if ("file" === e.type && s && r > 0) {
          const e = yield Cu(s);
          n = e.content, o = e.size, a = !0
        }
        const l = vu(e, a, t, r, s, o);
        return nu(su({}, l), {
          content: n || s,
          isCompressed: a
        })
      }),
      Au = (e, t) => {
        const {
          content: i
        } = e, {
          content: r
        } = i ? Nu(i) : {
          content: Uint8Array.from([])
        }, s = vu(e, !1, t, r.length, r, void 0);
        return nu(su({}, s), {
          content: r,
          isCompressed: !1
        })
      },
      vu = (e, t, i, r, s, n) => {
        const {
          content: o,
          path: a,
          created: l
        } = e, c = (e => {
          let t = e.getHours();
          return t <<= 6, t |= e.getMinutes(), t <<= 5, t |= e.getSeconds() / 2, t
        })(l), h = (e => {
          let t = e.getFullYear() - 1980;
          return t <<= 4, t |= e.getMonth() + 1, t <<= 5, t |= e.getDate(), t
        })(l), u = Tu(s), d = void 0 !== n ? n : r, p = Su(a), E = p !== a;
        let g = "";
        if (E) {
          const e = gu(1, 1) + gu(Tu(p), 4) + p;
          g = "up" + gu(e.length, 2) + e
        }
        const f = "\0" + (E ? "\0\b" : "\0\0") + gu(t ? 8 : 0, 2) + gu(c, 2) + gu(h, 2) + gu(d ? u : 0, 4) + gu(null != n ? n : r, 4) + gu(r, 4) + gu(p.length, 2) + gu(g.length, 2),
          T = "PK" + f + p + g,
          m = "PK\0" + f + "\0\0\0\0\0\0" + (o ? "\0\0\0\0" : "\0\0\0") + gu(i, 4) + p + g;
        return {
          localFileHeader: Uint8Array.from(T, e => e.charCodeAt(0)),
          centralDirectoryHeader: Uint8Array.from(m, e => e.charCodeAt(0))
        }
      },
      Nu = e => {
        let t;
        if ("string" == typeof e) {
          t = (e => {
            const t = new Uint8Array(e.length);
            for (let i = 0; i < e.length; i++) t[i] = e.charCodeAt(i);
            return t
          })(atob(e.split(";base64,")[1]))
        } else t = e;
        return {
          size: t.length,
          content: t
        }
      },
      Iu = class {
        static addFolders(e) {
          e.forEach(this.addFolder.bind(this))
        }
        static addFolder(e) {
          this.folders.push({
            path: e,
            created: new Date,
            isBase64: !1,
            type: "folder"
          })
        }
        static addFile(e, t, i = !1) {
          this.files.push({
            path: e,
            created: new Date,
            content: i ? t : (new TextEncoder).encode(t),
            isBase64: i,
            type: "file"
          })
        }
        static getZipFile(e = "application/zip") {
          return au(this, null, function*() {
            const t = yield this.buildCompressedFileStream();
            return this.clearStream(), new Blob([t], {
              type: e
            })
          })
        }
        static getUncompressedZipFile(e = "application/zip") {
          const t = this.buildFileStream();
          return this.clearStream(), new Blob([t], {
            type: e
          })
        }
        static clearStream() {
          this.folders = [], this.files = []
        }
        static packageFiles(e) {
          let t = new Uint8Array(0),
            i = new Uint8Array(0),
            r = 0,
            s = 0;
          for (const n of e) {
            const {
              localFileHeader: e,
              centralDirectoryHeader: o,
              content: a
            } = n, l = new Uint8Array(t.length + e.length);
            l.set(t), l.set(e, t.length), t = l;
            const c = new Uint8Array(t.length + a.length);
            c.set(t), c.set(a, t.length), t = c;
            const h = new Uint8Array(i.length + o.length);
            h.set(i), h.set(o, i.length), i = h, r += e.length + a.length, s += o.length
          }
          const n = ((e, t, i) => {
              const r = "PK\0\0\0\0" + gu(e, 2) + gu(e, 2) + gu(t, 4) + gu(i, 4) + "\0\0";
              return Uint8Array.from(r, e => e.charCodeAt(0))
            })(e.length, s, r),
            o = new Uint8Array(t.length + i.length + n.length);
          return o.set(t), o.set(i, t.length), o.set(n, t.length + i.length), o
        }
        static buildCompressedFileStream() {
          return au(this, null, function*() {
            const e = [...this.folders, ...this.files],
              t = [];
            let i = 0;
            for (const r of e) {
              const e = yield Ru(r, i), {
                localFileHeader: s,
                content: n
              } = e;
              t.push(e), i += s.length + n.length
            }
            return this.packageFiles(t)
          })
        }
        static buildFileStream() {
          const e = [...this.folders, ...this.files],
            t = [];
          let i = 0;
          for (const r of e) {
            const e = Au(r, i),
              {
                localFileHeader: s,
                content: n
              } = e;
            t.push(e), i += s.length + n.length
          }
          return this.packageFiles(t)
        }
      };
    Iu.folders = [], Iu.files = [], he.__registerModules([Hh, jh, Eu], !1, void 0);
    var Ou = {
        version: "0.18.5"
      },
      Lu = 1200,
      _u = 1252,
      yu = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4],
      wu = {
        0: 1252,
        1: 65001,
        2: 65001,
        77: 1e4,
        128: 932,
        129: 949,
        130: 1361,
        134: 936,
        136: 950,
        161: 1253,
        162: 1254,
        163: 1258,
        177: 1255,
        178: 1256,
        186: 1257,
        204: 1251,
        222: 874,
        238: 1250,
        255: 1252,
        69: 6969
      },
      Du = function(e) {
        -1 != yu.indexOf(e) && (_u = wu[0] = e)
      };
    var Pu = function(e) {
      Lu = e, Du(e)
    };

    function bu() {
      Pu(1200), Du(1252)
    }

    function Mu(e) {
      for (var t = [], i = 0, r = e.length; i < r; ++i) t[i] = e.charCodeAt(i);
      return t
    }

    function Fu(e) {
      for (var t = [], i = 0; i < e.length >> 1; ++i) t[i] = String.fromCharCode(e.charCodeAt(2 * i + 1) + (e.charCodeAt(2 * i) << 8));
      return t.join("")
    }
    var xu, Gu = function(e) {
        var t = e.charCodeAt(0),
          i = e.charCodeAt(1);
        return 255 == t && 254 == i ? function(e) {
          for (var t = [], i = 0; i < e.length >> 1; ++i) t[i] = String.fromCharCode(e.charCodeAt(2 * i) + (e.charCodeAt(2 * i + 1) << 8));
          return t.join("")
        }(e.slice(2)) : 254 == t && 255 == i ? Fu(e.slice(2)) : 65279 == t ? e.slice(1) : e
      },
      Uu = function(e) {
        return String.fromCharCode(e)
      },
      Hu = function(e) {
        return String.fromCharCode(e)
      };

    function ku(e) {
      xu = e, Pu = function(e) {
        Lu = e, Du(e)
      }, Gu = function(e) {
        return 255 === e.charCodeAt(0) && 254 === e.charCodeAt(1) ? xu.utils.decode(1200, Mu(e.slice(2))) : e
      }, Uu = function(e) {
        return 1200 === Lu ? String.fromCharCode(e) : xu.utils.decode(Lu, [255 & e, e >> 8])[0]
      }, Hu = function(e) {
        return xu.utils.decode(_u, [e])[0]
      }, YE()
    }
    var Bu = null,
      Vu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    function Wu(e) {
      for (var t = "", i = 0, r = 0, s = 0, n = 0, o = 0, a = 0, l = 0, c = 0; c < e.length;) n = (i = e.charCodeAt(c++)) >> 2, o = (3 & i) << 4 | (r = e.charCodeAt(c++)) >> 4, a = (15 & r) << 2 | (s = e.charCodeAt(c++)) >> 6, l = 63 & s, isNaN(r) ? a = l = 64 : isNaN(s) && (l = 64), t += Vu.charAt(n) + Vu.charAt(o) + Vu.charAt(a) + Vu.charAt(l);
      return t
    }

    function Yu(e) {
      var t = "",
        i = 0,
        r = 0,
        s = 0,
        n = 0,
        o = 0,
        a = 0;
      e = e.replace(/[^\w\+\/\=]/g, "");
      for (var l = 0; l < e.length;) i = Vu.indexOf(e.charAt(l++)) << 2 | (n = Vu.indexOf(e.charAt(l++))) >> 4, t += String.fromCharCode(i), r = (15 & n) << 4 | (o = Vu.indexOf(e.charAt(l++))) >> 2, 64 !== o && (t += String.fromCharCode(r)), s = (3 & o) << 6 | (a = Vu.indexOf(e.charAt(l++))), 64 !== a && (t += String.fromCharCode(s));
      return t
    }
    var Ku = function() {
        return "undefined" != typeof Buffer && "undefined" != typeof process && void 0 !== process.versions && !!process.versions.node
      }(),
      Xu = function() {
        if ("undefined" != typeof Buffer) {
          var e = !Buffer.from;
          if (!e) try {
            Buffer.from("foo", "utf8")
          } catch (t) {
            e = !0
          }
          return e ? function(e, t) {
            return t ? new Buffer(e, t) : new Buffer(e)
          } : Buffer.from.bind(Buffer)
        }
        return function() {}
      }();

    function zu(e) {
      return Ku ? Buffer.alloc ? Buffer.alloc(e) : new Buffer(e) : "undefined" != typeof Uint8Array ? new Uint8Array(e) : new Array(e)
    }

    function $u(e) {
      return Ku ? Buffer.allocUnsafe ? Buffer.allocUnsafe(e) : new Buffer(e) : "undefined" != typeof Uint8Array ? new Uint8Array(e) : new Array(e)
    }
    var ju = function(e) {
      return Ku ? Xu(e, "binary") : e.split("").map(function(e) {
        return 255 & e.charCodeAt(0)
      })
    };

    function Ju(e) {
      if ("undefined" == typeof ArrayBuffer) return ju(e);
      for (var t = new ArrayBuffer(e.length), i = new Uint8Array(t), r = 0; r != e.length; ++r) i[r] = 255 & e.charCodeAt(r);
      return t
    }

    function qu(e) {
      if (Array.isArray(e)) return e.map(function(e) {
        return String.fromCharCode(e)
      }).join("");
      for (var t = [], i = 0; i < e.length; ++i) t[i] = String.fromCharCode(e[i]);
      return t.join("")
    }

    function Qu(e) {
      if ("undefined" == typeof ArrayBuffer) throw new Error("Unsupported");
      if (e instanceof ArrayBuffer) return Qu(new Uint8Array(e));
      for (var t = new Array(e.length), i = 0; i < e.length; ++i) t[i] = e[i];
      return t
    }
    var Zu = Ku ? function(e) {
      return Buffer.concat(e.map(function(e) {
        return Buffer.isBuffer(e) ? e : Xu(e)
      }))
    } : function(e) {
      if ("undefined" != typeof Uint8Array) {
        var t = 0,
          i = 0;
        for (t = 0; t < e.length; ++t) i += e[t].length;
        var r = new Uint8Array(i),
          s = 0;
        for (t = 0, i = 0; t < e.length; i += s, ++t)
          if (s = e[t].length, e[t] instanceof Uint8Array) r.set(e[t], i);
          else {
            if ("string" == typeof e[t]) throw "wtf";
            r.set(new Uint8Array(e[t]), i)
          } return r
      }
      return [].concat.apply([], e.map(function(e) {
        return Array.isArray(e) ? e : [].slice.call(e)
      }))
    };
    var ed = /\u0000/g,
      td = /[\u0001-\u0006]/g;

    function id(e) {
      for (var t = "", i = e.length - 1; i >= 0;) t += e.charAt(i--);
      return t
    }

    function rd(e, t) {
      var i = "" + e;
      return i.length >= t ? i : Cp("0", t - i.length) + i
    }

    function sd(e, t) {
      var i = "" + e;
      return i.length >= t ? i : Cp(" ", t - i.length) + i
    }

    function nd(e, t) {
      var i = "" + e;
      return i.length >= t ? i : i + Cp(" ", t - i.length)
    }
    var od = Math.pow(2, 32);

    function ad(e, t) {
      return e > od || e < -od ? function(e, t) {
        var i = "" + Math.round(e);
        return i.length >= t ? i : Cp("0", t - i.length) + i
      }(e, t) : function(e, t) {
        var i = "" + e;
        return i.length >= t ? i : Cp("0", t - i.length) + i
      }(Math.round(e), t)
    }

    function ld(e, t) {
      return t = t || 0, e.length >= 7 + t && 103 == (32 | e.charCodeAt(t)) && 101 == (32 | e.charCodeAt(t + 1)) && 110 == (32 | e.charCodeAt(t + 2)) && 101 == (32 | e.charCodeAt(t + 3)) && 114 == (32 | e.charCodeAt(t + 4)) && 97 == (32 | e.charCodeAt(t + 5)) && 108 == (32 | e.charCodeAt(t + 6))
    }
    var cd = [
        ["Sun", "Sunday"],
        ["Mon", "Monday"],
        ["Tue", "Tuesday"],
        ["Wed", "Wednesday"],
        ["Thu", "Thursday"],
        ["Fri", "Friday"],
        ["Sat", "Saturday"]
      ],
      hd = [
        ["J", "Jan", "January"],
        ["F", "Feb", "February"],
        ["M", "Mar", "March"],
        ["A", "Apr", "April"],
        ["M", "May", "May"],
        ["J", "Jun", "June"],
        ["J", "Jul", "July"],
        ["A", "Aug", "August"],
        ["S", "Sep", "September"],
        ["O", "Oct", "October"],
        ["N", "Nov", "November"],
        ["D", "Dec", "December"]
      ];
    var ud = {
        0: "General",
        1: "0",
        2: "0.00",
        3: "#,##0",
        4: "#,##0.00",
        9: "0%",
        10: "0.00%",
        11: "0.00E+00",
        12: "# ?/?",
        13: "# ??/??",
        14: "m/d/yy",
        15: "d-mmm-yy",
        16: "d-mmm",
        17: "mmm-yy",
        18: "h:mm AM/PM",
        19: "h:mm:ss AM/PM",
        20: "h:mm",
        21: "h:mm:ss",
        22: "m/d/yy h:mm",
        37: "#,##0 ;(#,##0)",
        38: "#,##0 ;[Red](#,##0)",
        39: "#,##0.00;(#,##0.00)",
        40: "#,##0.00;[Red](#,##0.00)",
        45: "mm:ss",
        46: "[h]:mm:ss",
        47: "mmss.0",
        48: "##0.0E+0",
        49: "@",
        56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
      },
      dd = {
        5: 37,
        6: 38,
        7: 39,
        8: 40,
        23: 0,
        24: 0,
        25: 0,
        26: 0,
        27: 14,
        28: 14,
        29: 14,
        30: 14,
        31: 14,
        50: 14,
        51: 14,
        52: 14,
        53: 14,
        54: 14,
        55: 14,
        56: 14,
        57: 14,
        58: 14,
        59: 1,
        60: 2,
        61: 3,
        62: 4,
        67: 9,
        68: 10,
        69: 12,
        70: 13,
        71: 14,
        72: 14,
        73: 15,
        74: 16,
        75: 17,
        76: 20,
        77: 21,
        78: 22,
        79: 45,
        80: 46,
        81: 47,
        82: 0
      },
      pd = {
        5: '"$"#,##0_);\\("$"#,##0\\)',
        63: '"$"#,##0_);\\("$"#,##0\\)',
        6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
        42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
        43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
        44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
      };

    function Ed(e, t, i) {
      for (var r = e < 0 ? -1 : 1, s = e * r, n = 0, o = 1, a = 0, l = 1, c = 0, h = 0, u = Math.floor(s); c < t && (a = (u = Math.floor(s)) * o + n, h = u * c + l, !(s - u < 5e-8));) s = 1 / (s - u), n = o, o = a, l = c, c = h;
      if (h > t && (c > t ? (h = l, a = n) : (h = c, a = o)), !i) return [0, r * a, h];
      var d = Math.floor(r * a / h);
      return [d, r * a - d * h, h]
    }

    function gd(e, t, i) {
      if (e > 2958465 || e < 0) return null;
      var r = 0 | e,
        s = Math.floor(86400 * (e - r)),
        n = 0,
        o = [],
        a = {
          D: r,
          T: s,
          u: 86400 * (e - r) - s,
          y: 0,
          m: 0,
          d: 0,
          H: 0,
          M: 0,
          S: 0,
          q: 0
        };
      if (Math.abs(a.u) < 1e-6 && (a.u = 0), t && t.date1904 && (r += 1462), a.u > .9999 && (a.u = 0, 86400 == ++s && (a.T = s = 0, ++r, ++a.D)), 60 === r) o = i ? [1317, 10, 29] : [1900, 2, 29], n = 3;
      else if (0 === r) o = i ? [1317, 8, 29] : [1900, 1, 0], n = 6;
      else {
        r > 60 && --r;
        var l = new Date(1900, 0, 1);
        l.setDate(l.getDate() + r - 1), o = [l.getFullYear(), l.getMonth() + 1, l.getDate()], n = l.getDay(), r < 60 && (n = (n + 6) % 7), i && (n = function(e, t) {
          t[0] -= 581;
          var i = e.getDay();
          e < 60 && (i = (i + 6) % 7);
          return i
        }(l, o))
      }
      return a.y = o[0], a.m = o[1], a.d = o[2], a.S = s % 60, s = Math.floor(s / 60), a.M = s % 60, s = Math.floor(s / 60), a.H = s, a.q = n, a
    }
    var fd = new Date(1899, 11, 31, 0, 0, 0),
      Td = fd.getTime(),
      md = new Date(1900, 2, 1, 0, 0, 0);

    function Cd(e, t) {
      var i = e.getTime();
      return t ? i -= 1262304e5 : e >= md && (i += 864e5), (i - (Td + 6e4 * (e.getTimezoneOffset() - fd.getTimezoneOffset()))) / 864e5
    }

    function Sd(e) {
      return -1 == e.indexOf(".") ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1")
    }

    function Rd(e) {
      var t, i = Math.floor(Math.log(Math.abs(e)) * Math.LOG10E);
      return t = i >= -4 && i <= -1 ? e.toPrecision(10 + i) : Math.abs(i) <= 9 ? function(e) {
        var t = e < 0 ? 12 : 11,
          i = Sd(e.toFixed(12));
        return i.length <= t || (i = e.toPrecision(10)).length <= t ? i : e.toExponential(5)
      }(e) : 10 === i ? e.toFixed(10).substr(0, 12) : function(e) {
        var t = Sd(e.toFixed(11));
        return t.length > (e < 0 ? 12 : 11) || "0" === t || "-0" === t ? e.toPrecision(6) : t
      }(e), Sd(function(e) {
        return -1 == e.indexOf("E") ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2")
      }(t.toUpperCase()))
    }

    function Ad(e, t) {
      switch (typeof e) {
        case "string":
          return e;
        case "boolean":
          return e ? "TRUE" : "FALSE";
        case "number":
          return (0 | e) === e ? e.toString(10) : Rd(e);
        case "undefined":
          return "";
        case "object":
          if (null == e) return "";
          if (e instanceof Date) return Wd(14, Cd(e, t && t.date1904), t)
      }
      throw new Error("unsupported value in General format: " + e)
    }

    function vd(e, t, i, r) {
      var s, n = "",
        o = 0,
        a = 0,
        l = i.y,
        c = 0;
      switch (e) {
        case 98:
          l = i.y + 543;
        case 121:
          switch (t.length) {
            case 1:
            case 2:
              s = l % 100, c = 2;
              break;
            default:
              s = l % 1e4, c = 4
          }
          break;
        case 109:
          switch (t.length) {
            case 1:
            case 2:
              s = i.m, c = t.length;
              break;
            case 3:
              return hd[i.m - 1][1];
            case 5:
              return hd[i.m - 1][0];
            default:
              return hd[i.m - 1][2]
          }
          break;
        case 100:
          switch (t.length) {
            case 1:
            case 2:
              s = i.d, c = t.length;
              break;
            case 3:
              return cd[i.q][0];
            default:
              return cd[i.q][1]
          }
          break;
        case 104:
          switch (t.length) {
            case 1:
            case 2:
              s = 1 + (i.H + 11) % 12, c = t.length;
              break;
            default:
              throw "bad hour format: " + t
          }
          break;
        case 72:
          switch (t.length) {
            case 1:
            case 2:
              s = i.H, c = t.length;
              break;
            default:
              throw "bad hour format: " + t
          }
          break;
        case 77:
          switch (t.length) {
            case 1:
            case 2:
              s = i.M, c = t.length;
              break;
            default:
              throw "bad minute format: " + t
          }
          break;
        case 115:
          if ("s" != t && "ss" != t && ".0" != t && ".00" != t && ".000" != t) throw "bad second format: " + t;
          return 0 !== i.u || "s" != t && "ss" != t ? (a = r >= 2 ? 3 === r ? 1e3 : 100 : 1 === r ? 10 : 1, (o = Math.round(a * (i.S + i.u))) >= 60 * a && (o = 0), "s" === t ? 0 === o ? "0" : "" + o / a : (n = rd(o, 2 + r), "ss" === t ? n.substr(0, 2) : "." + n.substr(2, t.length - 1))) : rd(i.S, t.length);
        case 90:
          switch (t) {
            case "[h]":
            case "[hh]":
              s = 24 * i.D + i.H;
              break;
            case "[m]":
            case "[mm]":
              s = 60 * (24 * i.D + i.H) + i.M;
              break;
            case "[s]":
            case "[ss]":
              s = 60 * (60 * (24 * i.D + i.H) + i.M) + Math.round(i.S + i.u);
              break;
            default:
              throw "bad abstime format: " + t
          }
          c = 3 === t.length ? 1 : 2;
          break;
        case 101:
          s = l, c = 1
      }
      return c > 0 ? rd(s, c) : ""
    }

    function Nd(e) {
      if (e.length <= 3) return e;
      for (var t = e.length % 3, i = e.substr(0, t); t != e.length; t += 3) i += (i.length > 0 ? "," : "") + e.substr(t, 3);
      return i
    }
    var Id = /%/g;

    function Od(e, t) {
      var i, r = e.indexOf("E") - e.indexOf(".") - 1;
      if (e.match(/^#+0.0E\+0$/)) {
        if (0 == t) return "0.0E+0";
        if (t < 0) return "-" + Od(e, -t);
        var s = e.indexOf("."); - 1 === s && (s = e.indexOf("E"));
        var n = Math.floor(Math.log(t) * Math.LOG10E) % s;
        if (n < 0 && (n += s), -1 === (i = (t / Math.pow(10, n)).toPrecision(r + 1 + (s + n) % s)).indexOf("e")) {
          var o = Math.floor(Math.log(t) * Math.LOG10E);
          for (-1 === i.indexOf(".") ? i = i.charAt(0) + "." + i.substr(1) + "E+" + (o - i.length + n) : i += "E+" + (o - n);
            "0." === i.substr(0, 2);) i = (i = i.charAt(0) + i.substr(2, s) + "." + i.substr(2 + s)).replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
          i = i.replace(/\+-/, "-")
        }
        i = i.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(e, t, i, r) {
          return t + i + r.substr(0, (s + n) % s) + "." + r.substr(n) + "E"
        })
      } else i = t.toExponential(r);
      return e.match(/E\+00$/) && i.match(/e[+-]\d$/) && (i = i.substr(0, i.length - 1) + "0" + i.charAt(i.length - 1)), e.match(/E\-/) && i.match(/e\+/) && (i = i.replace(/e\+/, "e")), i.replace("e", "E")
    }
    var Ld = /# (\?+)( ?)\/( ?)(\d+)/;
    var _d = /^#*0*\.([0#]+)/,
      yd = /\).*[0#]/,
      wd = /\(###\) ###\\?-####/;

    function Dd(e) {
      for (var t, i = "", r = 0; r != e.length; ++r) switch (t = e.charCodeAt(r)) {
        case 35:
          break;
        case 63:
          i += " ";
          break;
        case 48:
          i += "0";
          break;
        default:
          i += String.fromCharCode(t)
      }
      return i
    }

    function Pd(e, t) {
      var i = Math.pow(10, t);
      return "" + Math.round(e * i) / i
    }

    function bd(e, t) {
      var i = e - Math.floor(e),
        r = Math.pow(10, t);
      return t < ("" + Math.round(i * r)).length ? 0 : Math.round(i * r)
    }

    function Md(e, t, i) {
      if (40 === e.charCodeAt(0) && !t.match(yd)) {
        var r = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        return i >= 0 ? Md("n", r, i) : "(" + Md("n", r, -i) + ")"
      }
      if (44 === t.charCodeAt(t.length - 1)) return function(e, t, i) {
        for (var r = t.length - 1; 44 === t.charCodeAt(r - 1);) --r;
        return Gd(e, t.substr(0, r), i / Math.pow(10, 3 * (t.length - r)))
      }(e, t, i);
      if (-1 !== t.indexOf("%")) return function(e, t, i) {
        var r = t.replace(Id, ""),
          s = t.length - r.length;
        return Gd(e, r, i * Math.pow(10, 2 * s)) + Cp("%", s)
      }(e, t, i);
      if (-1 !== t.indexOf("E")) return Od(t, i);
      if (36 === t.charCodeAt(0)) return "$" + Md(e, t.substr(" " == t.charAt(1) ? 2 : 1), i);
      var s, n, o, a, l = Math.abs(i),
        c = i < 0 ? "-" : "";
      if (t.match(/^00+$/)) return c + ad(l, t.length);
      if (t.match(/^[#?]+$/)) return "0" === (s = ad(i, 0)) && (s = ""), s.length > t.length ? s : Dd(t.substr(0, t.length - s.length)) + s;
      if (n = t.match(Ld)) return function(e, t, i) {
        var r = parseInt(e[4], 10),
          s = Math.round(t * r),
          n = Math.floor(s / r),
          o = s - n * r,
          a = r;
        return i + (0 === n ? "" : "" + n) + " " + (0 === o ? Cp(" ", e[1].length + 1 + e[4].length) : sd(o, e[1].length) + e[2] + "/" + e[3] + rd(a, e[4].length))
      }(n, l, c);
      if (t.match(/^#+0+$/)) return c + ad(l, t.length - t.indexOf("0"));
      if (n = t.match(_d)) return s = Pd(i, n[1].length).replace(/^([^\.]+)$/, "$1." + Dd(n[1])).replace(/\.$/, "." + Dd(n[1])).replace(/\.(\d*)$/, function(e, t) {
        return "." + t + Cp("0", Dd(n[1]).length - t.length)
      }), -1 !== t.indexOf("0.") ? s : s.replace(/^0\./, ".");
      if (t = t.replace(/^#+([0.])/, "$1"), n = t.match(/^(0*)\.(#*)$/)) return c + Pd(l, n[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, n[1].length ? "0." : ".");
      if (n = t.match(/^#{1,3},##0(\.?)$/)) return c + Nd(ad(l, 0));
      if (n = t.match(/^#,##0\.([#0]*0)$/)) return i < 0 ? "-" + Md(e, t, -i) : Nd("" + (Math.floor(i) + function(e, t) {
        return t < ("" + Math.round((e - Math.floor(e)) * Math.pow(10, t))).length ? 1 : 0
      }(i, n[1].length))) + "." + rd(bd(i, n[1].length), n[1].length);
      if (n = t.match(/^#,#*,#0/)) return Md(e, t.replace(/^#,#*,/, ""), i);
      if (n = t.match(/^([0#]+)(\\?-([0#]+))+$/)) return s = id(Md(e, t.replace(/[\\-]/g, ""), i)), o = 0, id(id(t.replace(/\\/g, "")).replace(/[0#]/g, function(e) {
        return o < s.length ? s.charAt(o++) : "0" === e ? "0" : ""
      }));
      if (t.match(wd)) return "(" + (s = Md(e, "##########", i)).substr(0, 3) + ") " + s.substr(3, 3) + "-" + s.substr(6);
      var h = "";
      if (n = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) return o = Math.min(n[4].length, 7), a = Ed(l, Math.pow(10, o) - 1, !1), s = "" + c, " " == (h = Gd("n", n[1], a[1])).charAt(h.length - 1) && (h = h.substr(0, h.length - 1) + "0"), s += h + n[2] + "/" + n[3], (h = nd(a[2], o)).length < n[4].length && (h = Dd(n[4].substr(n[4].length - h.length)) + h), s += h;
      if (n = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) return o = Math.min(Math.max(n[1].length, n[4].length), 7), c + ((a = Ed(l, Math.pow(10, o) - 1, !0))[0] || (a[1] ? "" : "0")) + " " + (a[1] ? sd(a[1], o) + n[2] + "/" + n[3] + nd(a[2], o) : Cp(" ", 2 * o + 1 + n[2].length + n[3].length));
      if (n = t.match(/^[#0?]+$/)) return s = ad(i, 0), t.length <= s.length ? s : Dd(t.substr(0, t.length - s.length)) + s;
      if (n = t.match(/^([#0?]+)\.([#0]+)$/)) {
        s = "" + i.toFixed(Math.min(n[2].length, 10)).replace(/([^0])0+$/, "$1"), o = s.indexOf(".");
        var u = t.indexOf(".") - o,
          d = t.length - s.length - u;
        return Dd(t.substr(0, u) + s + t.substr(t.length - d))
      }
      if (n = t.match(/^00,000\.([#0]*0)$/)) return o = bd(i, n[1].length), i < 0 ? "-" + Md(e, t, -i) : Nd(function(e) {
        return e < 2147483647 && e > -2147483648 ? "" + (e >= 0 ? 0 | e : e - 1 | 0) : "" + Math.floor(e)
      }(i)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(e) {
        return "00," + (e.length < 3 ? rd(0, 3 - e.length) : "") + e
      }) + "." + rd(o, n[1].length);
      switch (t) {
        case "###,##0.00":
          return Md(e, "#,##0.00", i);
        case "###,###":
        case "##,###":
        case "#,###":
          var p = Nd(ad(l, 0));
          return "0" !== p ? c + p : "";
        case "###,###.00":
          return Md(e, "###,##0.00", i).replace(/^0\./, ".");
        case "#,###.00":
          return Md(e, "#,##0.00", i).replace(/^0\./, ".")
      }
      throw new Error("unsupported format |" + t + "|")
    }

    function Fd(e, t) {
      var i, r = e.indexOf("E") - e.indexOf(".") - 1;
      if (e.match(/^#+0.0E\+0$/)) {
        if (0 == t) return "0.0E+0";
        if (t < 0) return "-" + Fd(e, -t);
        var s = e.indexOf("."); - 1 === s && (s = e.indexOf("E"));
        var n = Math.floor(Math.log(t) * Math.LOG10E) % s;
        if (n < 0 && (n += s), !(i = (t / Math.pow(10, n)).toPrecision(r + 1 + (s + n) % s)).match(/[Ee]/)) {
          var o = Math.floor(Math.log(t) * Math.LOG10E); - 1 === i.indexOf(".") ? i = i.charAt(0) + "." + i.substr(1) + "E+" + (o - i.length + n) : i += "E+" + (o - n), i = i.replace(/\+-/, "-")
        }
        i = i.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(e, t, i, r) {
          return t + i + r.substr(0, (s + n) % s) + "." + r.substr(n) + "E"
        })
      } else i = t.toExponential(r);
      return e.match(/E\+00$/) && i.match(/e[+-]\d$/) && (i = i.substr(0, i.length - 1) + "0" + i.charAt(i.length - 1)), e.match(/E\-/) && i.match(/e\+/) && (i = i.replace(/e\+/, "e")), i.replace("e", "E")
    }

    function xd(e, t, i) {
      if (40 === e.charCodeAt(0) && !t.match(yd)) {
        var r = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        return i >= 0 ? xd("n", r, i) : "(" + xd("n", r, -i) + ")"
      }
      if (44 === t.charCodeAt(t.length - 1)) return function(e, t, i) {
        for (var r = t.length - 1; 44 === t.charCodeAt(r - 1);) --r;
        return Gd(e, t.substr(0, r), i / Math.pow(10, 3 * (t.length - r)))
      }(e, t, i);
      if (-1 !== t.indexOf("%")) return function(e, t, i) {
        var r = t.replace(Id, ""),
          s = t.length - r.length;
        return Gd(e, r, i * Math.pow(10, 2 * s)) + Cp("%", s)
      }(e, t, i);
      if (-1 !== t.indexOf("E")) return Fd(t, i);
      if (36 === t.charCodeAt(0)) return "$" + xd(e, t.substr(" " == t.charAt(1) ? 2 : 1), i);
      var s, n, o, a, l = Math.abs(i),
        c = i < 0 ? "-" : "";
      if (t.match(/^00+$/)) return c + rd(l, t.length);
      if (t.match(/^[#?]+$/)) return s = "" + i, 0 === i && (s = ""), s.length > t.length ? s : Dd(t.substr(0, t.length - s.length)) + s;
      if (n = t.match(Ld)) return function(e, t, i) {
        return i + (0 === t ? "" : "" + t) + Cp(" ", e[1].length + 2 + e[4].length)
      }(n, l, c);
      if (t.match(/^#+0+$/)) return c + rd(l, t.length - t.indexOf("0"));
      if (n = t.match(_d)) return s = (s = ("" + i).replace(/^([^\.]+)$/, "$1." + Dd(n[1])).replace(/\.$/, "." + Dd(n[1]))).replace(/\.(\d*)$/, function(e, t) {
        return "." + t + Cp("0", Dd(n[1]).length - t.length)
      }), -1 !== t.indexOf("0.") ? s : s.replace(/^0\./, ".");
      if (t = t.replace(/^#+([0.])/, "$1"), n = t.match(/^(0*)\.(#*)$/)) return c + ("" + l).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, n[1].length ? "0." : ".");
      if (n = t.match(/^#{1,3},##0(\.?)$/)) return c + Nd("" + l);
      if (n = t.match(/^#,##0\.([#0]*0)$/)) return i < 0 ? "-" + xd(e, t, -i) : Nd("" + i) + "." + Cp("0", n[1].length);
      if (n = t.match(/^#,#*,#0/)) return xd(e, t.replace(/^#,#*,/, ""), i);
      if (n = t.match(/^([0#]+)(\\?-([0#]+))+$/)) return s = id(xd(e, t.replace(/[\\-]/g, ""), i)), o = 0, id(id(t.replace(/\\/g, "")).replace(/[0#]/g, function(e) {
        return o < s.length ? s.charAt(o++) : "0" === e ? "0" : ""
      }));
      if (t.match(wd)) return "(" + (s = xd(e, "##########", i)).substr(0, 3) + ") " + s.substr(3, 3) + "-" + s.substr(6);
      var h = "";
      if (n = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) return o = Math.min(n[4].length, 7), a = Ed(l, Math.pow(10, o) - 1, !1), s = "" + c, " " == (h = Gd("n", n[1], a[1])).charAt(h.length - 1) && (h = h.substr(0, h.length - 1) + "0"), s += h + n[2] + "/" + n[3], (h = nd(a[2], o)).length < n[4].length && (h = Dd(n[4].substr(n[4].length - h.length)) + h), s += h;
      if (n = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) return o = Math.min(Math.max(n[1].length, n[4].length), 7), c + ((a = Ed(l, Math.pow(10, o) - 1, !0))[0] || (a[1] ? "" : "0")) + " " + (a[1] ? sd(a[1], o) + n[2] + "/" + n[3] + nd(a[2], o) : Cp(" ", 2 * o + 1 + n[2].length + n[3].length));
      if (n = t.match(/^[#0?]+$/)) return s = "" + i, t.length <= s.length ? s : Dd(t.substr(0, t.length - s.length)) + s;
      if (n = t.match(/^([#0]+)\.([#0]+)$/)) {
        s = "" + i.toFixed(Math.min(n[2].length, 10)).replace(/([^0])0+$/, "$1"), o = s.indexOf(".");
        var u = t.indexOf(".") - o,
          d = t.length - s.length - u;
        return Dd(t.substr(0, u) + s + t.substr(t.length - d))
      }
      if (n = t.match(/^00,000\.([#0]*0)$/)) return i < 0 ? "-" + xd(e, t, -i) : Nd("" + i).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(e) {
        return "00," + (e.length < 3 ? rd(0, 3 - e.length) : "") + e
      }) + "." + rd(0, n[1].length);
      switch (t) {
        case "###,###":
        case "##,###":
        case "#,###":
          var p = Nd("" + l);
          return "0" !== p ? c + p : "";
        default:
          if (t.match(/\.[0#?]*$/)) return xd(e, t.slice(0, t.lastIndexOf(".")), i) + Dd(t.slice(t.lastIndexOf(".")))
      }
      throw new Error("unsupported format |" + t + "|")
    }

    function Gd(e, t, i) {
      return (0 | i) === i ? xd(e, t, i) : Md(e, t, i)
    }
    var Ud = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;

    function Hd(e) {
      for (var t = 0, i = "", r = ""; t < e.length;) switch (i = e.charAt(t)) {
        case "G":
          ld(e, t) && (t += 6), t++;
          break;
        case '"':
          for (; 34 !== e.charCodeAt(++t) && t < e.length;);
          ++t;
          break;
        case "\\":
        case "_":
          t += 2;
          break;
        case "@":
          ++t;
          break;
        case "B":
        case "b":
          if ("1" === e.charAt(t + 1) || "2" === e.charAt(t + 1)) return !0;
        case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
        case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
          return !0;
        case "A":
        case "a":
        case "上":
          if ("A/P" === e.substr(t, 3).toUpperCase()) return !0;
          if ("AM/PM" === e.substr(t, 5).toUpperCase()) return !0;
          if ("上午/下午" === e.substr(t, 5).toUpperCase()) return !0;
          ++t;
          break;
        case "[":
          for (r = i;
            "]" !== e.charAt(t++) && t < e.length;) r += e.charAt(t);
          if (r.match(Ud)) return !0;
          break;
        case ".":
        case "0":
        case "#":
          for (; t < e.length && ("0#?.,E+-%".indexOf(i = e.charAt(++t)) > -1 || "\\" == i && "-" == e.charAt(t + 1) && "0#".indexOf(e.charAt(t + 2)) > -1););
          break;
        case "?":
          for (; e.charAt(++t) === i;);
          break;
        case "*":
          ++t, " " != e.charAt(t) && "*" != e.charAt(t) || ++t;
          break;
        case "(":
        case ")":
          ++t;
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          for (; t < e.length && "0123456789".indexOf(e.charAt(++t)) > -1;);
          break;
        default:
          ++t
      }
      return !1
    }
    var kd = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;

    function Bd(e, t) {
      if (null == t) return !1;
      var i = parseFloat(t[2]);
      switch (t[1]) {
        case "=":
          if (e == i) return !0;
          break;
        case ">":
          if (e > i) return !0;
          break;
        case "<":
          if (e < i) return !0;
          break;
        case "<>":
          if (e != i) return !0;
          break;
        case ">=":
          if (e >= i) return !0;
          break;
        case "<=":
          if (e <= i) return !0
      }
      return !1
    }

    function Vd(e, t) {
      var i = function(e) {
          for (var t = [], i = !1, r = 0, s = 0; r < e.length; ++r) switch (e.charCodeAt(r)) {
            case 34:
              i = !i;
              break;
            case 95:
            case 42:
            case 92:
              ++r;
              break;
            case 59:
              t[t.length] = e.substr(s, r - s), s = r + 1
          }
          if (t[t.length] = e.substr(s), !0 === i) throw new Error("Format |" + e + "| unterminated string ");
          return t
        }(e),
        r = i.length,
        s = i[r - 1].indexOf("@");
      if (r < 4 && s > -1 && --r, i.length > 4) throw new Error("cannot find right format for |" + i.join("|") + "|");
      if ("number" != typeof t) return [4, 4 === i.length || s > -1 ? i[i.length - 1] : "@"];
      switch (i.length) {
        case 1:
          i = s > -1 ? ["General", "General", "General", i[0]] : [i[0], i[0], i[0], "@"];
          break;
        case 2:
          i = s > -1 ? [i[0], i[0], i[0], i[1]] : [i[0], i[1], i[0], "@"];
          break;
        case 3:
          i = s > -1 ? [i[0], i[1], i[0], i[2]] : [i[0], i[1], i[2], "@"]
      }
      var n = t > 0 ? i[0] : t < 0 ? i[1] : i[2];
      if (-1 === i[0].indexOf("[") && -1 === i[1].indexOf("[")) return [r, n];
      if (null != i[0].match(/\[[=<>]/) || null != i[1].match(/\[[=<>]/)) {
        var o = i[0].match(kd),
          a = i[1].match(kd);
        return Bd(t, o) ? [r, i[0]] : Bd(t, a) ? [r, i[1]] : [r, i[null != o && null != a ? 2 : 1]]
      }
      return [r, n]
    }

    function Wd(e, t, i) {
      null == i && (i = {});
      var r = "";
      switch (typeof e) {
        case "string":
          r = "m/d/yy" == e && i.dateNF ? i.dateNF : e;
          break;
        case "number":
          null == (r = 14 == e && i.dateNF ? i.dateNF : (null != i.table ? i.table : ud)[e]) && (r = i.table && i.table[dd[e]] || ud[dd[e]]), null == r && (r = pd[e] || "General")
      }
      if (ld(r, 0)) return Ad(t, i);
      t instanceof Date && (t = Cd(t, i.date1904));
      var s = Vd(r, t);
      if (ld(s[1])) return Ad(t, i);
      if (!0 === t) t = "TRUE";
      else if (!1 === t) t = "FALSE";
      else if ("" === t || null == t) return "";
      return function(e, t, i, r) {
        for (var s, n, o, a = [], l = "", c = 0, h = "", u = "t", d = "H"; c < e.length;) switch (h = e.charAt(c)) {
          case "G":
            if (!ld(e, c)) throw new Error("unrecognized character " + h + " in " + e);
            a[a.length] = {
              t: "G",
              v: "General"
            }, c += 7;
            break;
          case '"':
            for (l = ""; 34 !== (o = e.charCodeAt(++c)) && c < e.length;) l += String.fromCharCode(o);
            a[a.length] = {
              t: "t",
              v: l
            }, ++c;
            break;
          case "\\":
            var p = e.charAt(++c),
              E = "(" === p || ")" === p ? p : "t";
            a[a.length] = {
              t: E,
              v: p
            }, ++c;
            break;
          case "_":
            a[a.length] = {
              t: "t",
              v: " "
            }, c += 2;
            break;
          case "@":
            a[a.length] = {
              t: "T",
              v: t
            }, ++c;
            break;
          case "B":
          case "b":
            if ("1" === e.charAt(c + 1) || "2" === e.charAt(c + 1)) {
              if (null == s && null == (s = gd(t, i, "2" === e.charAt(c + 1)))) return "";
              a[a.length] = {
                t: "X",
                v: e.substr(c, 2)
              }, u = h, c += 2;
              break
            }
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
              h = h.toLowerCase();
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              if (t < 0) return "";
              if (null == s && null == (s = gd(t, i))) return "";
              for (l = h; ++c < e.length && e.charAt(c).toLowerCase() === h;) l += h;
              "m" === h && "h" === u.toLowerCase() && (h = "M"), "h" === h && (h = d), a[a.length] = {
                t: h,
                v: l
              }, u = h;
              break;
            case "A":
            case "a":
            case "上":
              var g = {
                t: h,
                v: h
              };
              if (null == s && (s = gd(t, i)), "A/P" === e.substr(c, 3).toUpperCase() ? (null != s && (g.v = s.H >= 12 ? "P" : "A"), g.t = "T", d = "h", c += 3) : "AM/PM" === e.substr(c, 5).toUpperCase() ? (null != s && (g.v = s.H >= 12 ? "PM" : "AM"), g.t = "T", c += 5, d = "h") : "上午/下午" === e.substr(c, 5).toUpperCase() ? (null != s && (g.v = s.H >= 12 ? "下午" : "上午"), g.t = "T", c += 5, d = "h") : (g.t = "t", ++c), null == s && "T" === g.t) return "";
              a[a.length] = g, u = h;
              break;
            case "[":
              for (l = h;
                "]" !== e.charAt(c++) && c < e.length;) l += e.charAt(c);
              if ("]" !== l.slice(-1)) throw 'unterminated "[" block: |' + l + "|";
              if (l.match(Ud)) {
                if (null == s && null == (s = gd(t, i))) return "";
                a[a.length] = {
                  t: "Z",
                  v: l.toLowerCase()
                }, u = l.charAt(1)
              } else l.indexOf("$") > -1 && (l = (l.match(/\$([^-\[\]]*)/) || [])[1] || "$", Hd(e) || (a[a.length] = {
                t: "t",
                v: l
              }));
              break;
            case ".":
              if (null != s) {
                for (l = h; ++c < e.length && "0" === (h = e.charAt(c));) l += h;
                a[a.length] = {
                  t: "s",
                  v: l
                };
                break
              }
              case "0":
              case "#":
                for (l = h; ++c < e.length && "0#?.,E+-%".indexOf(h = e.charAt(c)) > -1;) l += h;
                a[a.length] = {
                  t: "n",
                  v: l
                };
                break;
              case "?":
                for (l = h; e.charAt(++c) === h;) l += h;
                a[a.length] = {
                  t: h,
                  v: l
                }, u = h;
                break;
              case "*":
                ++c, " " != e.charAt(c) && "*" != e.charAt(c) || ++c;
                break;
              case "(":
              case ")":
                a[a.length] = {
                  t: 1 === r ? "t" : h,
                  v: h
                }, ++c;
                break;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                for (l = h; c < e.length && "0123456789".indexOf(e.charAt(++c)) > -1;) l += e.charAt(c);
                a[a.length] = {
                  t: "D",
                  v: l
                };
                break;
              case " ":
                a[a.length] = {
                  t: h,
                  v: h
                }, ++c;
                break;
              case "$":
                a[a.length] = {
                  t: "t",
                  v: "$"
                }, ++c;
                break;
              default:
                if (-1 === ",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(h)) throw new Error("unrecognized character " + h + " in " + e);
                a[a.length] = {
                  t: "t",
                  v: h
                }, ++c
        }
        var f, T = 0,
          m = 0;
        for (c = a.length - 1, u = "t"; c >= 0; --c) switch (a[c].t) {
          case "h":
          case "H":
            a[c].t = d, u = "h", T < 1 && (T = 1);
            break;
          case "s":
            (f = a[c].v.match(/\.0+$/)) && (m = Math.max(m, f[0].length - 1)), T < 3 && (T = 3);
          case "d":
          case "y":
          case "M":
          case "e":
            u = a[c].t;
            break;
          case "m":
            "s" === u && (a[c].t = "M", T < 2 && (T = 2));
            break;
          case "X":
            break;
          case "Z":
            T < 1 && a[c].v.match(/[Hh]/) && (T = 1), T < 2 && a[c].v.match(/[Mm]/) && (T = 2), T < 3 && a[c].v.match(/[Ss]/) && (T = 3)
        }
        switch (T) {
          case 0:
            break;
          case 1:
            s.u >= .5 && (s.u = 0, ++s.S), s.S >= 60 && (s.S = 0, ++s.M), s.M >= 60 && (s.M = 0, ++s.H);
            break;
          case 2:
            s.u >= .5 && (s.u = 0, ++s.S), s.S >= 60 && (s.S = 0, ++s.M)
        }
        var C, S = "";
        for (c = 0; c < a.length; ++c) switch (a[c].t) {
          case "t":
          case "T":
          case " ":
          case "D":
            break;
          case "X":
            a[c].v = "", a[c].t = ";";
            break;
          case "d":
          case "m":
          case "y":
          case "h":
          case "H":
          case "M":
          case "s":
          case "e":
          case "b":
          case "Z":
            a[c].v = vd(a[c].t.charCodeAt(0), a[c].v, s, m), a[c].t = "t";
            break;
          case "n":
          case "?":
            for (C = c + 1; null != a[C] && ("?" === (h = a[C].t) || "D" === h || (" " === h || "t" === h) && null != a[C + 1] && ("?" === a[C + 1].t || "t" === a[C + 1].t && "/" === a[C + 1].v) || "(" === a[c].t && (" " === h || "n" === h || ")" === h) || "t" === h && ("/" === a[C].v || " " === a[C].v && null != a[C + 1] && "?" == a[C + 1].t));) a[c].v += a[C].v, a[C] = {
              v: "",
              t: ";"
            }, ++C;
            S += a[c].v, c = C - 1;
            break;
          case "G":
            a[c].t = "t", a[c].v = Ad(t, i)
        }
        var R, A, v = "";
        if (S.length > 0) {
          40 == S.charCodeAt(0) ? (R = t < 0 && 45 === S.charCodeAt(0) ? -t : t, A = Gd("n", S, R)) : (A = Gd("n", S, R = t < 0 && r > 1 ? -t : t), R < 0 && a[0] && "t" == a[0].t && (A = A.substr(1), a[0].v = "-" + a[0].v)), C = A.length - 1;
          var N = a.length;
          for (c = 0; c < a.length; ++c)
            if (null != a[c] && "t" != a[c].t && a[c].v.indexOf(".") > -1) {
              N = c;
              break
            } var I = a.length;
          if (N === a.length && -1 === A.indexOf("E")) {
            for (c = a.length - 1; c >= 0; --c) null != a[c] && -1 !== "n?".indexOf(a[c].t) && (C >= a[c].v.length - 1 ? (C -= a[c].v.length, a[c].v = A.substr(C + 1, a[c].v.length)) : C < 0 ? a[c].v = "" : (a[c].v = A.substr(0, C + 1), C = -1), a[c].t = "t", I = c);
            C >= 0 && I < a.length && (a[I].v = A.substr(0, C + 1) + a[I].v)
          } else if (N !== a.length && -1 === A.indexOf("E")) {
            for (C = A.indexOf(".") - 1, c = N; c >= 0; --c)
              if (null != a[c] && -1 !== "n?".indexOf(a[c].t)) {
                for (n = a[c].v.indexOf(".") > -1 && c === N ? a[c].v.indexOf(".") - 1 : a[c].v.length - 1, v = a[c].v.substr(n + 1); n >= 0; --n) C >= 0 && ("0" === a[c].v.charAt(n) || "#" === a[c].v.charAt(n)) && (v = A.charAt(C--) + v);
                a[c].v = v, a[c].t = "t", I = c
              } for (C >= 0 && I < a.length && (a[I].v = A.substr(0, C + 1) + a[I].v), C = A.indexOf(".") + 1, c = N; c < a.length; ++c)
              if (null != a[c] && (-1 !== "n?(".indexOf(a[c].t) || c === N)) {
                for (n = a[c].v.indexOf(".") > -1 && c === N ? a[c].v.indexOf(".") + 1 : 0, v = a[c].v.substr(0, n); n < a[c].v.length; ++n) C < A.length && (v += A.charAt(C++));
                a[c].v = v, a[c].t = "t", I = c
              }
          }
        }
        for (c = 0; c < a.length; ++c) null != a[c] && "n?".indexOf(a[c].t) > -1 && (R = r > 1 && t < 0 && c > 0 && "-" === a[c - 1].v ? -t : t, a[c].v = Gd(a[c].t, a[c].v, R), a[c].t = "t");
        var O = "";
        for (c = 0; c !== a.length; ++c) null != a[c] && (O += a[c].v);
        return O
      }(s[1], t, i, s[0])
    }

    function Yd(e, t) {
      if ("number" != typeof t) {
        t = +t || -1;
        for (var i = 0; i < 392; ++i)
          if (null != ud[i]) {
            if (ud[i] == e) {
              t = i;
              break
            }
          } else t < 0 && (t = i);
        t < 0 && (t = 391)
      }
      return ud[t] = e, t
    }

    function Kd(e) {
      for (var t = 0; 392 != t; ++t) void 0 !== e[t] && Yd(e[t], t)
    }

    function Xd() {
      var e;
      e || (e = {}), e[0] = "General", e[1] = "0", e[2] = "0.00", e[3] = "#,##0", e[4] = "#,##0.00", e[9] = "0%", e[10] = "0.00%", e[11] = "0.00E+00", e[12] = "# ?/?", e[13] = "# ??/??", e[14] = "m/d/yy", e[15] = "d-mmm-yy", e[16] = "d-mmm", e[17] = "mmm-yy", e[18] = "h:mm AM/PM", e[19] = "h:mm:ss AM/PM", e[20] = "h:mm", e[21] = "h:mm:ss", e[22] = "m/d/yy h:mm", e[37] = "#,##0 ;(#,##0)", e[38] = "#,##0 ;[Red](#,##0)", e[39] = "#,##0.00;(#,##0.00)", e[40] = "#,##0.00;[Red](#,##0.00)", e[45] = "mm:ss", e[46] = "[h]:mm:ss", e[47] = "mmss.0", e[48] = "##0.0E+0", e[49] = "@", e[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', ud = e
    }
    var zd = {
        format: Wd,
        load: Yd,
        _table: ud,
        load_table: Kd,
        parse_date_code: gd,
        is_date: Hd,
        get_table: function() {
          return zd._table = ud
        }
      },
      $d = {
        5: '"$"#,##0_);\\("$"#,##0\\)',
        6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        23: "General",
        24: "General",
        25: "General",
        26: "General",
        27: "m/d/yy",
        28: "m/d/yy",
        29: "m/d/yy",
        30: "m/d/yy",
        31: "m/d/yy",
        32: "h:mm:ss",
        33: "h:mm:ss",
        34: "h:mm:ss",
        35: "h:mm:ss",
        36: "m/d/yy",
        41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
        42: '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
        43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
        44: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
        50: "m/d/yy",
        51: "m/d/yy",
        52: "m/d/yy",
        53: "m/d/yy",
        54: "m/d/yy",
        55: "m/d/yy",
        56: "m/d/yy",
        57: "m/d/yy",
        58: "m/d/yy",
        59: "0",
        60: "0.00",
        61: "#,##0",
        62: "#,##0.00",
        63: '"$"#,##0_);\\("$"#,##0\\)',
        64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        67: "0%",
        68: "0.00%",
        69: "# ?/?",
        70: "# ??/??",
        71: "m/d/yy",
        72: "m/d/yy",
        73: "d-mmm-yy",
        74: "d-mmm",
        75: "mmm-yy",
        76: "h:mm",
        77: "h:mm:ss",
        78: "m/d/yy h:mm",
        79: "mm:ss",
        80: "[h]:mm:ss",
        81: "mmss.0"
      },
      jd = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
    var Jd = function() {
        var e = {};
        e.version = "1.2.0";
        var t = function() {
          for (var e = 0, t = new Array(256), i = 0; 256 != i; ++i) e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = i) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1, t[i] = e;
          return "undefined" != typeof Int32Array ? new Int32Array(t) : t
        }();
        var i = function(e) {
            var t = 0,
              i = 0,
              r = 0,
              s = "undefined" != typeof Int32Array ? new Int32Array(4096) : new Array(4096);
            for (r = 0; 256 != r; ++r) s[r] = e[r];
            for (r = 0; 256 != r; ++r)
              for (i = e[r], t = 256 + r; t < 4096; t += 256) i = s[t] = i >>> 8 ^ e[255 & i];
            var n = [];
            for (r = 1; 16 != r; ++r) n[r - 1] = "undefined" != typeof Int32Array ? s.subarray(256 * r, 256 * r + 256) : s.slice(256 * r, 256 * r + 256);
            return n
          }(t),
          r = i[0],
          s = i[1],
          n = i[2],
          o = i[3],
          a = i[4],
          l = i[5],
          c = i[6],
          h = i[7],
          u = i[8],
          d = i[9],
          p = i[10],
          E = i[11],
          g = i[12],
          f = i[13],
          T = i[14];
        return e.table = t, e.bstr = function(e, i) {
          for (var r = -1 ^ i, s = 0, n = e.length; s < n;) r = r >>> 8 ^ t[255 & (r ^ e.charCodeAt(s++))];
          return ~r
        }, e.buf = function(e, i) {
          for (var m = -1 ^ i, C = e.length - 15, S = 0; S < C;) m = T[e[S++] ^ 255 & m] ^ f[e[S++] ^ m >> 8 & 255] ^ g[e[S++] ^ m >> 16 & 255] ^ E[e[S++] ^ m >>> 24] ^ p[e[S++]] ^ d[e[S++]] ^ u[e[S++]] ^ h[e[S++]] ^ c[e[S++]] ^ l[e[S++]] ^ a[e[S++]] ^ o[e[S++]] ^ n[e[S++]] ^ s[e[S++]] ^ r[e[S++]] ^ t[e[S++]];
          for (C += 15; S < C;) m = m >>> 8 ^ t[255 & (m ^ e[S++])];
          return ~m
        }, e.str = function(e, i) {
          for (var r = -1 ^ i, s = 0, n = e.length, o = 0, a = 0; s < n;)(o = e.charCodeAt(s++)) < 128 ? r = r >>> 8 ^ t[255 & (r ^ o)] : o < 2048 ? r = (r = r >>> 8 ^ t[255 & (r ^ (192 | o >> 6 & 31))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & o))] : o >= 55296 && o < 57344 ? (o = 64 + (1023 & o), a = 1023 & e.charCodeAt(s++), r = (r = (r = (r = r >>> 8 ^ t[255 & (r ^ (240 | o >> 8 & 7))]) >>> 8 ^ t[255 & (r ^ (128 | o >> 2 & 63))]) >>> 8 ^ t[255 & (r ^ (128 | a >> 6 & 15 | (3 & o) << 4))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & a))]) : r = (r = (r = r >>> 8 ^ t[255 & (r ^ (224 | o >> 12 & 15))]) >>> 8 ^ t[255 & (r ^ (128 | o >> 6 & 63))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & o))];
          return ~r
        }, e
      }(),
      qd = function() {
        var e, t = {};

        function i(e) {
          if ("/" == e.charAt(e.length - 1)) return -1 === e.slice(0, -1).indexOf("/") ? e : i(e.slice(0, -1));
          var t = e.lastIndexOf("/");
          return -1 === t ? e : e.slice(0, t + 1)
        }

        function r(e) {
          if ("/" == e.charAt(e.length - 1)) return r(e.slice(0, -1));
          var t = e.lastIndexOf("/");
          return -1 === t ? e : e.slice(t + 1)
        }

        function s(e, t) {
          "string" == typeof t && (t = new Date(t));
          var i = t.getHours();
          i = (i = i << 6 | t.getMinutes()) << 5 | t.getSeconds() >>> 1, e.write_shift(2, i);
          var r = t.getFullYear() - 1980;
          r = (r = r << 4 | t.getMonth() + 1) << 5 | t.getDate(), e.write_shift(2, r)
        }

        function n(e) {
          rg(e, 0);
          for (var t = {}, i = 0; e.l <= e.length - 4;) {
            var r = e.read_shift(2),
              s = e.read_shift(2),
              n = e.l + s,
              o = {};
            if (21589 === r) 1 & (i = e.read_shift(1)) && (o.mtime = e.read_shift(4)), s > 5 && (2 & i && (o.atime = e.read_shift(4)), 4 & i && (o.ctime = e.read_shift(4))), o.mtime && (o.mt = new Date(1e3 * o.mtime));
            e.l = n, t[r] = o
          }
          return t
        }

        function o() {
          return e || (e = {})
        }

        function a(e, t) {
          if (80 == e[0] && 75 == e[1]) return re(e, t);
          if (109 == (32 | e[0]) && 105 == (32 | e[1])) return function(e, t) {
            if ("mime-version:" != A(e.slice(0, 13)).toLowerCase()) throw new Error("Unsupported MAD header");
            var i = t && t.root || "",
              r = (Ku && Buffer.isBuffer(e) ? e.toString("binary") : A(e)).split("\r\n"),
              s = 0,
              n = "";
            for (s = 0; s < r.length; ++s)
              if (n = r[s], /^Content-Location:/i.test(n) && (n = n.slice(n.indexOf("file")), i || (i = n.slice(0, n.lastIndexOf("/") + 1)), n.slice(0, i.length) != i))
                for (; i.length > 0 && (i = (i = i.slice(0, i.length - 1)).slice(0, i.lastIndexOf("/") + 1), n.slice(0, i.length) != i););
            var o = (r[1] || "").match(/boundary="(.*?)"/);
            if (!o) throw new Error("MAD cannot find boundary");
            var a = "--" + (o[1] || ""),
              l = [],
              c = [],
              h = {
                FileIndex: l,
                FullPaths: c
              };
            d(h);
            var u, p = 0;
            for (s = 0; s < r.length; ++s) {
              var E = r[s];
              E !== a && E !== a + "--" || (p++ && ce(h, r.slice(u, s), i), u = s)
            }
            return h
          }(e, t);
          if (e.length < 512) throw new Error("CFB file size " + e.length + " < 512");
          var i, r, s, n, o, a, p = 512,
            E = [],
            g = e.slice(0, 512);
          rg(g, 0);
          var f = function(e) {
            if (80 == e[e.l] && 75 == e[e.l + 1]) return [0, 0];
            e.chk(m, "Header Signature: "), e.l += 16;
            var t = e.read_shift(2, "u");
            return [e.read_shift(2, "u"), t]
          }(g);
          switch (i = f[0]) {
            case 3:
              p = 512;
              break;
            case 4:
              p = 4096;
              break;
            case 0:
              if (0 == f[1]) return re(e, t);
            default:
              throw new Error("Major Version: Expected 3 or 4 saw " + i)
          }
          512 !== p && rg(g = e.slice(0, p), 28);
          var C = e.slice(0, p);
          ! function(e, t) {
            var i = 9;
            switch (e.l += 2, i = e.read_shift(2)) {
              case 9:
                if (3 != t) throw new Error("Sector Shift: Expected 9 saw " + i);
                break;
              case 12:
                if (4 != t) throw new Error("Sector Shift: Expected 12 saw " + i);
                break;
              default:
                throw new Error("Sector Shift: Expected 9 or 12 saw " + i)
            }
            e.chk("0600", "Mini Sector Shift: "), e.chk("000000000000", "Reserved: ")
          }(g, i);
          var S = g.read_shift(4, "i");
          if (3 === i && 0 !== S) throw new Error("# Directory Sectors: Expected 0 saw " + S);
          g.l += 4, n = g.read_shift(4, "i"), g.l += 4, g.chk("00100000", "Mini Stream Cutoff Size: "), o = g.read_shift(4, "i"), r = g.read_shift(4, "i"), a = g.read_shift(4, "i"), s = g.read_shift(4, "i");
          for (var R = -1, v = 0; v < 109 && !((R = g.read_shift(4, "i")) < 0); ++v) E[v] = R;
          var N = function(e, t) {
            for (var i = Math.ceil(e.length / t) - 1, r = [], s = 1; s < i; ++s) r[s - 1] = e.slice(s * t, (s + 1) * t);
            return r[i - 1] = e.slice(i * t), r
          }(e, p);
          c(a, s, N, p, E);
          var I = function(e, t, i, r) {
            var s = e.length,
              n = [],
              o = [],
              a = [],
              l = [],
              c = r - 1,
              h = 0,
              u = 0,
              d = 0,
              p = 0;
            for (h = 0; h < s; ++h)
              if (a = [], (d = h + t) >= s && (d -= s), !o[d]) {
                l = [];
                var E = [];
                for (u = d; u >= 0;) {
                  E[u] = !0, o[u] = !0, a[a.length] = u, l.push(e[u]);
                  var g = i[Math.floor(4 * u / r)];
                  if (r < 4 + (p = 4 * u & c)) throw new Error("FAT boundary crossed: " + u + " 4 " + r);
                  if (!e[g]) break;
                  if (E[u = jE(e[g], p)]) break
                }
                n[d] = {
                  nodes: a,
                  data: NE([l])
                }
              } return n
          }(N, n, E, p);
          I[n].name = "!Directory", r > 0 && o !== T && (I[o].name = "!MiniFAT"), I[E[0]].name = "!FAT", I.fat_addrs = E, I.ssz = p;
          var O = [],
            L = [],
            _ = [];
          ! function(e, t, i, r, s, n, o, a) {
            for (var c, d = 0, p = r.length ? 2 : 0, E = t[e].data, g = 0, f = 0; g < E.length; g += 128) {
              var m = E.slice(g, g + 128);
              rg(m, 64), f = m.read_shift(2), c = OE(m, 0, f - p), r.push(c);
              var C = {
                name: c,
                type: m.read_shift(1),
                color: m.read_shift(1),
                L: m.read_shift(4, "i"),
                R: m.read_shift(4, "i"),
                C: m.read_shift(4, "i"),
                clsid: m.read_shift(16),
                state: m.read_shift(4, "i"),
                start: 0,
                size: 0
              };
              0 !== m.read_shift(2) + m.read_shift(2) + m.read_shift(2) + m.read_shift(2) && (C.ct = u(m, m.l - 8)), 0 !== m.read_shift(2) + m.read_shift(2) + m.read_shift(2) + m.read_shift(2) && (C.mt = u(m, m.l - 8)), C.start = m.read_shift(4, "i"), C.size = m.read_shift(4, "i"), C.size < 0 && C.start < 0 && (C.size = C.type = 0, C.start = T, C.name = ""), 5 === C.type ? (d = C.start, s > 0 && d !== T && (t[d].name = "!StreamData")) : C.size >= 4096 ? (C.storage = "fat", void 0 === t[C.start] && (t[C.start] = h(i, C.start, t.fat_addrs, t.ssz)), t[C.start].name = C.name, C.content = t[C.start].data.slice(0, C.size)) : (C.storage = "minifat", C.size < 0 ? C.size = 0 : d !== T && C.start !== T && t[d] && (C.content = l(C, t[d].data, (t[a] || {}).data))), C.content && rg(C.content, 0), n[c] = C, o.push(C)
            }
          }(n, I, N, O, r, {}, L, o),
          function(e, t, i) {
            for (var r = 0, s = 0, n = 0, o = 0, a = 0, l = i.length, c = [], h = []; r < l; ++r) c[r] = h[r] = r, t[r] = i[r];
            for (; a < h.length; ++a) s = e[r = h[a]].L, n = e[r].R, o = e[r].C, c[r] === r && (-1 !== s && c[s] !== s && (c[r] = c[s]), -1 !== n && c[n] !== n && (c[r] = c[n])), -1 !== o && (c[o] = r), -1 !== s && r != c[r] && (c[s] = c[r], h.lastIndexOf(s) < a && h.push(s)), -1 !== n && r != c[r] && (c[n] = c[r], h.lastIndexOf(n) < a && h.push(n));
            for (r = 1; r < l; ++r) c[r] === r && (-1 !== n && c[n] !== n ? c[r] = c[n] : -1 !== s && c[s] !== s && (c[r] = c[s]));
            for (r = 1; r < l; ++r)
              if (0 !== e[r].type) {
                if ((a = r) != c[a])
                  do {
                    a = c[a], t[r] = t[a] + "/" + t[r]
                  } while (0 !== a && -1 !== c[a] && a != c[a]);
                c[r] = -1
              } for (t[0] += "/", r = 1; r < l; ++r) 2 !== e[r].type && (t[r] += "/")
          }(L, _, O), O.shift();
          var y = {
            FileIndex: L,
            FullPaths: _
          };
          return t && t.raw && (y.raw = {
            header: C,
            sectors: N
          }), y
        }

        function l(e, t, i) {
          for (var r = e.start, s = e.size, n = [], o = r; i && s > 0 && o >= 0;) n.push(t.slice(o * f, o * f + f)), s -= f, o = jE(i, 4 * o);
          return 0 === n.length ? ng(0) : Zu(n).slice(0, e.size)
        }

        function c(e, t, i, r, s) {
          var n = T;
          if (e === T) {
            if (0 !== t) throw new Error("DIFAT chain shorter than expected")
          } else if (-1 !== e) {
            var o = i[e],
              a = (r >>> 2) - 1;
            if (!o) return;
            for (var l = 0; l < a && (n = jE(o, 4 * l)) !== T; ++l) s.push(n);
            c(jE(o, r - 4), t - 1, i, r, s)
          }
        }

        function h(e, t, i, r, s) {
          var n = [],
            o = [];
          s || (s = []);
          var a = r - 1,
            l = 0,
            c = 0;
          for (l = t; l >= 0;) {
            s[l] = !0, n[n.length] = l, o.push(e[l]);
            var h = i[Math.floor(4 * l / r)];
            if (r < 4 + (c = 4 * l & a)) throw new Error("FAT boundary crossed: " + l + " 4 " + r);
            if (!e[h]) break;
            l = jE(e[h], c)
          }
          return {
            nodes: n,
            data: NE([o])
          }
        }

        function u(e, t) {
          return new Date(1e3 * ($E(e, t + 4) / 1e7 * Math.pow(2, 32) + $E(e, t) / 1e7 - 11644473600))
        }

        function d(e, t) {
          var i = t || {},
            r = i.root || "Root Entry";
          if (e.FullPaths || (e.FullPaths = []), e.FileIndex || (e.FileIndex = []), e.FullPaths.length !== e.FileIndex.length) throw new Error("inconsistent CFB structure");
          0 === e.FullPaths.length && (e.FullPaths[0] = r + "/", e.FileIndex[0] = {
              name: r,
              type: 5
            }), i.CLSID && (e.FileIndex[0].clsid = i.CLSID),
            function(e) {
              var t = "Sh33tJ5";
              if (qd.find(e, "/" + t)) return;
              var i = ng(4);
              i[0] = 55, i[1] = i[3] = 50, i[2] = 54, e.FileIndex.push({
                name: t,
                type: 2,
                content: i,
                size: 4,
                L: 69,
                R: 69,
                C: 69
              }), e.FullPaths.push(e.FullPaths[0] + t), p(e)
            }(e)
        }

        function p(e, t) {
          d(e);
          for (var s = !1, n = !1, o = e.FullPaths.length - 1; o >= 0; --o) {
            var a = e.FileIndex[o];
            switch (a.type) {
              case 0:
                n ? s = !0 : (e.FileIndex.pop(), e.FullPaths.pop());
                break;
              case 1:
              case 2:
              case 5:
                n = !0, isNaN(a.R * a.L * a.C) && (s = !0), a.R > -1 && a.L > -1 && a.R == a.L && (s = !0);
                break;
              default:
                s = !0
            }
          }
          if (s || t) {
            var l = new Date(1987, 1, 19),
              c = 0,
              h = Object.create ? Object.create(null) : {},
              u = [];
            for (o = 0; o < e.FullPaths.length; ++o) h[e.FullPaths[o]] = !0, 0 !== e.FileIndex[o].type && u.push([e.FullPaths[o], e.FileIndex[o]]);
            for (o = 0; o < u.length; ++o) {
              var p = i(u[o][0]);
              (n = h[p]) || (u.push([p, {
                name: r(p).replace("/", ""),
                type: 1,
                clsid: S,
                ct: l,
                mt: l,
                content: null
              }]), h[p] = !0)
            }
            for (u.sort(function(e, t) {
                return function(e, t) {
                  for (var i = e.split("/"), r = t.split("/"), s = 0, n = 0, o = Math.min(i.length, r.length); s < o; ++s) {
                    if (n = i[s].length - r[s].length) return n;
                    if (i[s] != r[s]) return i[s] < r[s] ? -1 : 1
                  }
                  return i.length - r.length
                }(e[0], t[0])
              }), e.FullPaths = [], e.FileIndex = [], o = 0; o < u.length; ++o) e.FullPaths[o] = u[o][0], e.FileIndex[o] = u[o][1];
            for (o = 0; o < u.length; ++o) {
              var E = e.FileIndex[o],
                g = e.FullPaths[o];
              if (E.name = r(g).replace("/", ""), E.L = E.R = E.C = -(E.color = 1), E.size = E.content ? E.content.length : 0, E.start = 0, E.clsid = E.clsid || S, 0 === o) E.C = u.length > 1 ? 1 : -1, E.size = 0, E.type = 5;
              else if ("/" == g.slice(-1)) {
                for (c = o + 1; c < u.length && i(e.FullPaths[c]) != g; ++c);
                for (E.C = c >= u.length ? -1 : c, c = o + 1; c < u.length && i(e.FullPaths[c]) != i(g); ++c);
                E.R = c >= u.length ? -1 : c, E.type = 1
              } else i(e.FullPaths[o + 1] || "") == i(g) && (E.R = o + 1), E.type = 2
            }
          }
        }

        function E(e, t) {
          var i = t || {};
          if ("mad" == i.fileType) return function(e, t) {
            for (var i = t || {}, r = i.boundary || "SheetJS", s = ["MIME-Version: 1.0", 'Content-Type: multipart/related; boundary="' + (r = "------=" + r).slice(2) + '"', "", "", ""], n = e.FullPaths[0], o = n, a = e.FileIndex[0], l = 1; l < e.FullPaths.length; ++l)
              if (o = e.FullPaths[l].slice(n.length), (a = e.FileIndex[l]).size && a.content && "Sh33tJ5" != o) {
                o = o.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(e) {
                  return "_x" + e.charCodeAt(0).toString(16) + "_"
                }).replace(/[\u0080-\uFFFF]/g, function(e) {
                  return "_u" + e.charCodeAt(0).toString(16) + "_"
                });
                for (var c = a.content, h = Ku && Buffer.isBuffer(c) ? c.toString("binary") : A(c), u = 0, d = Math.min(1024, h.length), p = 0, E = 0; E <= d; ++E)(p = h.charCodeAt(E)) >= 32 && p < 128 && ++u;
                var g = u >= 4 * d / 5;
                s.push(r), s.push("Content-Location: " + (i.root || "file:///C:/SheetJS/") + o), s.push("Content-Transfer-Encoding: " + (g ? "quoted-printable" : "base64")), s.push("Content-Type: " + oe(a, o)), s.push(""), s.push(g ? le(h) : ae(h))
              } return s.push(r + "--\r\n"), s.join("\r\n")
          }(e, i);
          if (p(e), "zip" === i.fileType) return function(e, t) {
            var i = t || {},
              r = [],
              n = [],
              o = ng(1),
              a = i.compression ? 8 : 0,
              l = 0;
            0;
            var c = 0,
              h = 0,
              u = 0,
              d = 0,
              p = e.FullPaths[0],
              E = p,
              g = e.FileIndex[0],
              f = [],
              T = 0;
            for (c = 1; c < e.FullPaths.length; ++c)
              if (E = e.FullPaths[c].slice(p.length), (g = e.FileIndex[c]).size && g.content && "Sh33tJ5" != E) {
                var m = u,
                  C = ng(E.length);
                for (h = 0; h < E.length; ++h) C.write_shift(1, 127 & E.charCodeAt(h));
                C = C.slice(0, C.l), f[d] = Jd.buf(g.content, 0);
                var S = g.content;
                8 == a && (S = v(S)), (o = ng(30)).write_shift(4, 67324752), o.write_shift(2, 20), o.write_shift(2, l), o.write_shift(2, a), g.mt ? s(o, g.mt) : o.write_shift(4, 0), o.write_shift(-4, 8 & l ? 0 : f[d]), o.write_shift(4, 8 & l ? 0 : S.length), o.write_shift(4, 8 & l ? 0 : g.content.length), o.write_shift(2, C.length), o.write_shift(2, 0), u += o.length, r.push(o), u += C.length, r.push(C), u += S.length, r.push(S), 8 & l && ((o = ng(12)).write_shift(-4, f[d]), o.write_shift(4, S.length), o.write_shift(4, g.content.length), u += o.l, r.push(o)), (o = ng(46)).write_shift(4, 33639248), o.write_shift(2, 0), o.write_shift(2, 20), o.write_shift(2, l), o.write_shift(2, a), o.write_shift(4, 0), o.write_shift(-4, f[d]), o.write_shift(4, S.length), o.write_shift(4, g.content.length), o.write_shift(2, C.length), o.write_shift(2, 0), o.write_shift(2, 0), o.write_shift(2, 0), o.write_shift(2, 0), o.write_shift(4, 0), o.write_shift(4, m), T += o.l, n.push(o), T += C.length, n.push(C), ++d
              } return o = ng(22), o.write_shift(4, 101010256), o.write_shift(2, 0), o.write_shift(2, 0), o.write_shift(2, d), o.write_shift(2, d), o.write_shift(4, T), o.write_shift(4, u), o.write_shift(2, 0), Zu([Zu(r), Zu(n), o])
          }(e, i);
          var r = function(e) {
              for (var t = 0, i = 0, r = 0; r < e.FileIndex.length; ++r) {
                var s = e.FileIndex[r];
                if (s.content) {
                  var n = s.content.length;
                  n > 0 && (n < 4096 ? t += n + 63 >> 6 : i += n + 511 >> 9)
                }
              }
              for (var o = e.FullPaths.length + 3 >> 2, a = t + 127 >> 7, l = (t + 7 >> 3) + i + o + a, c = l + 127 >> 7, h = c <= 109 ? 0 : Math.ceil((c - 109) / 127); l + c + h + 127 >> 7 > c;) h = ++c <= 109 ? 0 : Math.ceil((c - 109) / 127);
              var u = [1, h, c, a, o, i, t, 0];
              return e.FileIndex[0].size = t << 6, u[7] = (e.FileIndex[0].start = u[0] + u[1] + u[2] + u[3] + u[4] + u[5]) + (u[6] + 7 >> 3), u
            }(e),
            n = ng(r[7] << 9),
            o = 0,
            a = 0;
          for (o = 0; o < 8; ++o) n.write_shift(1, C[o]);
          for (o = 0; o < 8; ++o) n.write_shift(2, 0);
          for (n.write_shift(2, 62), n.write_shift(2, 3), n.write_shift(2, 65534), n.write_shift(2, 9), n.write_shift(2, 6), o = 0; o < 3; ++o) n.write_shift(2, 0);
          for (n.write_shift(4, 0), n.write_shift(4, r[2]), n.write_shift(4, r[0] + r[1] + r[2] + r[3] - 1), n.write_shift(4, 0), n.write_shift(4, 4096), n.write_shift(4, r[3] ? r[0] + r[1] + r[2] - 1 : T), n.write_shift(4, r[3]), n.write_shift(-4, r[1] ? r[0] - 1 : T), n.write_shift(4, r[1]), o = 0; o < 109; ++o) n.write_shift(-4, o < r[2] ? r[1] + o : -1);
          if (r[1])
            for (a = 0; a < r[1]; ++a) {
              for (; o < 236 + 127 * a; ++o) n.write_shift(-4, o < r[2] ? r[1] + o : -1);
              n.write_shift(-4, a === r[1] - 1 ? T : a + 1)
            }
          var l = function(e) {
            for (a += e; o < a - 1; ++o) n.write_shift(-4, o + 1);
            e && (++o, n.write_shift(-4, T))
          };
          for (a = o = 0, a += r[1]; o < a; ++o) n.write_shift(-4, R.DIFSECT);
          for (a += r[2]; o < a; ++o) n.write_shift(-4, R.FATSECT);
          l(r[3]), l(r[4]);
          for (var c = 0, h = 0, u = e.FileIndex[0]; c < e.FileIndex.length; ++c)(u = e.FileIndex[c]).content && ((h = u.content.length) < 4096 || (u.start = a, l(h + 511 >> 9)));
          for (l(r[6] + 7 >> 3); 511 & n.l;) n.write_shift(-4, R.ENDOFCHAIN);
          for (a = o = 0, c = 0; c < e.FileIndex.length; ++c)(u = e.FileIndex[c]).content && (!(h = u.content.length) || h >= 4096 || (u.start = a, l(h + 63 >> 6)));
          for (; 511 & n.l;) n.write_shift(-4, R.ENDOFCHAIN);
          for (o = 0; o < r[4] << 2; ++o) {
            var d = e.FullPaths[o];
            if (d && 0 !== d.length) {
              u = e.FileIndex[o], 0 === o && (u.start = u.size ? u.start - 1 : T);
              var E = 0 === o && i.root || u.name;
              if (h = 2 * (E.length + 1), n.write_shift(64, E, "utf16le"), n.write_shift(2, h), n.write_shift(1, u.type), n.write_shift(1, u.color), n.write_shift(-4, u.L), n.write_shift(-4, u.R), n.write_shift(-4, u.C), u.clsid) n.write_shift(16, u.clsid, "hex");
              else
                for (c = 0; c < 4; ++c) n.write_shift(4, 0);
              n.write_shift(4, u.state || 0), n.write_shift(4, 0), n.write_shift(4, 0), n.write_shift(4, 0), n.write_shift(4, 0), n.write_shift(4, u.start), n.write_shift(4, u.size), n.write_shift(4, 0)
            } else {
              for (c = 0; c < 17; ++c) n.write_shift(4, 0);
              for (c = 0; c < 3; ++c) n.write_shift(4, -1);
              for (c = 0; c < 12; ++c) n.write_shift(4, 0)
            }
          }
          for (o = 1; o < e.FileIndex.length; ++o)
            if ((u = e.FileIndex[o]).size >= 4096)
              if (n.l = u.start + 1 << 9, Ku && Buffer.isBuffer(u.content)) u.content.copy(n, n.l, 0, u.size), n.l += u.size + 511 & -512;
              else {
                for (c = 0; c < u.size; ++c) n.write_shift(1, u.content[c]);
                for (; 511 & c; ++c) n.write_shift(1, 0)
              } for (o = 1; o < e.FileIndex.length; ++o)
            if ((u = e.FileIndex[o]).size > 0 && u.size < 4096)
              if (Ku && Buffer.isBuffer(u.content)) u.content.copy(n, n.l, 0, u.size), n.l += u.size + 63 & -64;
              else {
                for (c = 0; c < u.size; ++c) n.write_shift(1, u.content[c]);
                for (; 63 & c; ++c) n.write_shift(1, 0)
              } if (Ku) n.l = n.length;
          else
            for (; n.l < n.length;) n.write_shift(1, 0);
          return n
        }
        t.version = "1.2.1";
        var g, f = 64,
          T = -2,
          m = "d0cf11e0a1b11ae1",
          C = [208, 207, 17, 224, 161, 177, 26, 225],
          S = "00000000000000000000000000000000",
          R = {
            MAXREGSECT: -6,
            DIFSECT: -4,
            FATSECT: -3,
            ENDOFCHAIN: T,
            FREESECT: -1,
            HEADER_SIGNATURE: m,
            HEADER_MINOR_VERSION: "3e00",
            MAXREGSID: -6,
            NOSTREAM: -1,
            HEADER_CLSID: S,
            EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
          };

        function A(e) {
          for (var t = new Array(e.length), i = 0; i < e.length; ++i) t[i] = String.fromCharCode(e[i]);
          return t.join("")
        }

        function v(e) {
          return g ? g.deflateRawSync(e) : $(e)
        }
        var N = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          I = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258],
          O = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];

        function L(e) {
          var t = 139536 & (e << 1 | e << 11) | 558144 & (e << 5 | e << 15);
          return 255 & (t >> 16 | t >> 8 | t)
        }
        for (var _ = "undefined" != typeof Uint8Array, y = _ ? new Uint8Array(256) : [], w = 0; w < 256; ++w) y[w] = L(w);

        function D(e, t) {
          var i = y[255 & e];
          return t <= 8 ? i >>> 8 - t : (i = i << 8 | y[e >> 8 & 255], t <= 16 ? i >>> 16 - t : (i = i << 8 | y[e >> 16 & 255]) >>> 24 - t)
        }

        function P(e, t) {
          var i = 7 & t,
            r = t >>> 3;
          return (e[r] | (i <= 6 ? 0 : e[r + 1] << 8)) >>> i & 3
        }

        function b(e, t) {
          var i = 7 & t,
            r = t >>> 3;
          return (e[r] | (i <= 5 ? 0 : e[r + 1] << 8)) >>> i & 7
        }

        function M(e, t) {
          var i = 7 & t,
            r = t >>> 3;
          return (e[r] | (i <= 3 ? 0 : e[r + 1] << 8)) >>> i & 31
        }

        function F(e, t) {
          var i = 7 & t,
            r = t >>> 3;
          return (e[r] | (i <= 1 ? 0 : e[r + 1] << 8)) >>> i & 127
        }

        function x(e, t, i) {
          var r = 7 & t,
            s = t >>> 3,
            n = (1 << i) - 1,
            o = e[s] >>> r;
          return i < 8 - r ? o & n : (o |= e[s + 1] << 8 - r, i < 16 - r ? o & n : (o |= e[s + 2] << 16 - r, i < 24 - r ? o & n : (o |= e[s + 3] << 24 - r) & n))
        }

        function G(e, t, i) {
          var r = 7 & t,
            s = t >>> 3;
          return r <= 5 ? e[s] |= (7 & i) << r : (e[s] |= i << r & 255, e[s + 1] = (7 & i) >> 8 - r), t + 3
        }

        function U(e, t, i) {
          return i = (1 & i) << (7 & t), e[t >>> 3] |= i, t + 1
        }

        function H(e, t, i) {
          var r = t >>> 3;
          return i <<= 7 & t, e[r] |= 255 & i, i >>>= 8, e[r + 1] = i, t + 8
        }

        function k(e, t, i) {
          var r = t >>> 3;
          return i <<= 7 & t, e[r] |= 255 & i, i >>>= 8, e[r + 1] = 255 & i, e[r + 2] = i >>> 8, t + 16
        }

        function B(e, t) {
          var i = e.length,
            r = 2 * i > t ? 2 * i : t + 5,
            s = 0;
          if (i >= t) return e;
          if (Ku) {
            var n = $u(r);
            if (e.copy) e.copy(n);
            else
              for (; s < e.length; ++s) n[s] = e[s];
            return n
          }
          if (_) {
            var o = new Uint8Array(r);
            if (o.set) o.set(e);
            else
              for (; s < i; ++s) o[s] = e[s];
            return o
          }
          return e.length = r, e
        }

        function V(e) {
          for (var t = new Array(e), i = 0; i < e; ++i) t[i] = 0;
          return t
        }

        function W(e, t, i) {
          var r = 1,
            s = 0,
            n = 0,
            o = 0,
            a = 0,
            l = e.length,
            c = _ ? new Uint16Array(32) : V(32);
          for (n = 0; n < 32; ++n) c[n] = 0;
          for (n = l; n < i; ++n) e[n] = 0;
          l = e.length;
          var h = _ ? new Uint16Array(l) : V(l);
          for (n = 0; n < l; ++n) c[s = e[n]]++, r < s && (r = s), h[n] = 0;
          for (c[0] = 0, n = 1; n <= r; ++n) c[n + 16] = a = a + c[n - 1] << 1;
          for (n = 0; n < l; ++n) 0 != (a = e[n]) && (h[n] = c[a + 16]++);
          var u = 0;
          for (n = 0; n < l; ++n)
            if (0 != (u = e[n]))
              for (a = D(h[n], r) >> r - u, o = (1 << r + 4 - u) - 1; o >= 0; --o) t[a | o << u] = 15 & u | n << 4;
          return r
        }
        var Y = _ ? new Uint16Array(512) : V(512),
          K = _ ? new Uint16Array(32) : V(32);
        if (!_) {
          for (var X = 0; X < 512; ++X) Y[X] = 0;
          for (X = 0; X < 32; ++X) K[X] = 0
        }! function() {
          for (var e = [], t = 0; t < 32; t++) e.push(5);
          W(e, K, 32);
          var i = [];
          for (t = 0; t <= 143; t++) i.push(8);
          for (; t <= 255; t++) i.push(9);
          for (; t <= 279; t++) i.push(7);
          for (; t <= 287; t++) i.push(8);
          W(i, Y, 288)
        }();
        var z = function() {
          for (var e = _ ? new Uint8Array(32768) : [], t = 0, i = 0; t < O.length - 1; ++t)
            for (; i < O[t + 1]; ++i) e[i] = t;
          for (; i < 32768; ++i) e[i] = 29;
          var r = _ ? new Uint8Array(259) : [];
          for (t = 0, i = 0; t < I.length - 1; ++t)
            for (; i < I[t + 1]; ++i) r[i] = t;
          return function(t, i) {
            return t.length < 8 ? function(e, t) {
              for (var i = 0; i < e.length;) {
                var r = Math.min(65535, e.length - i),
                  s = i + r == e.length;
                for (t.write_shift(1, +s), t.write_shift(2, r), t.write_shift(2, 65535 & ~r); r-- > 0;) t[t.l++] = e[i++]
              }
              return t.l
            }(t, i) : function(t, i) {
              for (var s = 0, n = 0, o = _ ? new Uint16Array(32768) : []; n < t.length;) {
                var a = Math.min(65535, t.length - n);
                if (a < 10) {
                  for (7 & (s = G(i, s, +!(n + a != t.length))) && (s += 8 - (7 & s)), i.l = s / 8 | 0, i.write_shift(2, a), i.write_shift(2, 65535 & ~a); a-- > 0;) i[i.l++] = t[n++];
                  s = 8 * i.l
                } else {
                  s = G(i, s, +!(n + a != t.length) + 2);
                  for (var l = 0; a-- > 0;) {
                    var c = t[n],
                      h = -1,
                      u = 0;
                    if ((h = o[l = 32767 & (l << 5 ^ c)]) && ((h |= -32768 & n) > n && (h -= 32768), h < n))
                      for (; t[h + u] == t[n + u] && u < 250;) ++u;
                    if (u > 2) {
                      (c = r[u]) <= 22 ? s = H(i, s, y[c + 1] >> 1) - 1 : (H(i, s, 3), H(i, s += 5, y[c - 23] >> 5), s += 3);
                      var d = c < 8 ? 0 : c - 4 >> 2;
                      d > 0 && (k(i, s, u - I[c]), s += d), c = e[n - h], s = H(i, s, y[c] >> 3), s -= 3;
                      var p = c < 4 ? 0 : c - 2 >> 1;
                      p > 0 && (k(i, s, n - h - O[c]), s += p);
                      for (var E = 0; E < u; ++E) o[l] = 32767 & n, l = 32767 & (l << 5 ^ t[n]), ++n;
                      a -= u - 1
                    } else c <= 143 ? c += 48 : s = U(i, s, 1), s = H(i, s, y[c]), o[l] = 32767 & n, ++n
                  }
                  s = H(i, s, 0) - 1
                }
              }
              return i.l = (s + 7) / 8 | 0, i.l
            }(t, i)
          }
        }();

        function $(e) {
          var t = ng(50 + Math.floor(1.1 * e.length)),
            i = z(e, t);
          return t.slice(0, i)
        }
        var j = _ ? new Uint16Array(32768) : V(32768),
          J = _ ? new Uint16Array(32768) : V(32768),
          q = _ ? new Uint16Array(128) : V(128),
          Q = 1,
          Z = 1;

        function ee(e, t) {
          var i = M(e, t) + 257,
            r = M(e, t += 5) + 1,
            s = function(e, t) {
              var i = 7 & t,
                r = t >>> 3;
              return (e[r] | (i <= 4 ? 0 : e[r + 1] << 8)) >>> i & 15
            }(e, t += 5) + 4;
          t += 4;
          for (var n = 0, o = _ ? new Uint8Array(19) : V(19), a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], l = 1, c = _ ? new Uint8Array(8) : V(8), h = _ ? new Uint8Array(8) : V(8), u = o.length, d = 0; d < s; ++d) o[N[d]] = n = b(e, t), l < n && (l = n), c[n]++, t += 3;
          var p = 0;
          for (c[0] = 0, d = 1; d <= l; ++d) h[d] = p = p + c[d - 1] << 1;
          for (d = 0; d < u; ++d) 0 != (p = o[d]) && (a[d] = h[p]++);
          var E = 0;
          for (d = 0; d < u; ++d)
            if (0 != (E = o[d])) {
              p = y[a[d]] >> 8 - E;
              for (var g = (1 << 7 - E) - 1; g >= 0; --g) q[p | g << E] = 7 & E | d << 3
            } var f = [];
          for (l = 1; f.length < i + r;) switch (t += 7 & (p = q[F(e, t)]), p >>>= 3) {
            case 16:
              for (n = 3 + P(e, t), t += 2, p = f[f.length - 1]; n-- > 0;) f.push(p);
              break;
            case 17:
              for (n = 3 + b(e, t), t += 3; n-- > 0;) f.push(0);
              break;
            case 18:
              for (n = 11 + F(e, t), t += 7; n-- > 0;) f.push(0);
              break;
            default:
              f.push(p), l < p && (l = p)
          }
          var T = f.slice(0, i),
            m = f.slice(i);
          for (d = i; d < 286; ++d) T[d] = 0;
          for (d = r; d < 30; ++d) m[d] = 0;
          return Q = W(T, j, 286), Z = W(m, J, 30), t
        }

        function te(e, t) {
          var i = function(e, t) {
            if (3 == e[0] && !(3 & e[1])) return [zu(t), 2];
            for (var i = 0, r = 0, s = $u(t || 1 << 18), n = 0, o = s.length >>> 0, a = 0, l = 0; !(1 & r);)
              if (r = b(e, i), i += 3, r >>> 1 != 0)
                for (r >> 1 == 1 ? (a = 9, l = 5) : (i = ee(e, i), a = Q, l = Z);;) {
                  !t && o < n + 32767 && (o = (s = B(s, n + 32767)).length);
                  var c = x(e, i, a),
                    h = r >>> 1 == 1 ? Y[c] : j[c];
                  if (i += 15 & h, (h >>>= 4) >>> 8 & 255) {
                    if (256 == h) break;
                    var u = (h -= 257) < 8 ? 0 : h - 4 >> 2;
                    u > 5 && (u = 0);
                    var d = n + I[h];
                    u > 0 && (d += x(e, i, u), i += u), c = x(e, i, l), i += 15 & (h = r >>> 1 == 1 ? K[c] : J[c]);
                    var p = (h >>>= 4) < 4 ? 0 : h - 2 >> 1,
                      E = O[h];
                    for (p > 0 && (E += x(e, i, p), i += p), !t && o < d && (o = (s = B(s, d + 100)).length); n < d;) s[n] = s[n - E], ++n
                  } else s[n++] = h
                } else {
                  7 & i && (i += 8 - (7 & i));
                  var g = e[i >>> 3] | e[(i >>> 3) + 1] << 8;
                  if (i += 32, g > 0)
                    for (!t && o < n + g && (o = (s = B(s, n + g)).length); g-- > 0;) s[n++] = e[i >>> 3], i += 8
                }
            return t ? [s, i + 7 >>> 3] : [s.slice(0, n), i + 7 >>> 3]
          }(e.slice(e.l || 0), t);
          return e.l += i[1], i[0]
        }

        function ie(e, t) {
          if (!e) throw new Error(t);
          "undefined" != typeof console && console.error(t)
        }

        function re(e, t) {
          var i = e;
          rg(i, 0);
          var r = {
            FileIndex: [],
            FullPaths: []
          };
          d(r, {
            root: t.root
          });
          for (var s = i.length - 4;
            (80 != i[s] || 75 != i[s + 1] || 5 != i[s + 2] || 6 != i[s + 3]) && s >= 0;) --s;
          i.l = s + 4, i.l += 4;
          var o = i.read_shift(2);
          i.l += 6;
          var a = i.read_shift(4);
          for (i.l = a, s = 0; s < o; ++s) {
            i.l += 20;
            var l = i.read_shift(4),
              c = i.read_shift(4),
              h = i.read_shift(2),
              u = i.read_shift(2),
              p = i.read_shift(2);
            i.l += 8;
            var E = i.read_shift(4),
              g = n(i.slice(i.l + h, i.l + h + u));
            i.l += h + u + p;
            var f = i.l;
            i.l = E + 4, se(i, l, c, r, g), i.l = f
          }
          return r
        }

        function se(e, t, i, r, s) {
          e.l += 2;
          var o = e.read_shift(2),
            a = e.read_shift(2),
            l = function(e) {
              var t = 65535 & e.read_shift(2),
                i = 65535 & e.read_shift(2),
                r = new Date,
                s = 31 & i,
                n = 15 & (i >>>= 5);
              i >>>= 4, r.setMilliseconds(0), r.setFullYear(i + 1980), r.setMonth(n - 1), r.setDate(s);
              var o = 31 & t,
                a = 63 & (t >>>= 5);
              return t >>>= 6, r.setHours(t), r.setMinutes(a), r.setSeconds(o << 1), r
            }(e);
          if (8257 & o) throw new Error("Unsupported ZIP encryption");
          e.read_shift(4);
          for (var c = e.read_shift(4), h = e.read_shift(4), u = e.read_shift(2), d = e.read_shift(2), p = "", E = 0; E < u; ++E) p += String.fromCharCode(e[e.l++]);
          if (d) {
            var f = n(e.slice(e.l, e.l + d));
            (f[21589] || {}).mt && (l = f[21589].mt), ((s || {})[21589] || {}).mt && (l = s[21589].mt)
          }
          e.l += d;
          var T = e.slice(e.l, e.l + c);
          switch (a) {
            case 8:
              T = function(e, t) {
                if (!g) return te(e, t);
                var i = new(0, g.InflateRaw),
                  r = i._processChunk(e.slice(e.l), i._finishFlushFlag);
                return e.l += i.bytesRead, r
              }(e, h);
              break;
            case 0:
              break;
            default:
              throw new Error("Unsupported ZIP Compression method " + a)
          }
          var m = !1;
          8 & o && (134695760 == e.read_shift(4) && (e.read_shift(4), m = !0), c = e.read_shift(4), h = e.read_shift(4)), c != t && ie(m, "Bad compressed size: " + t + " != " + c), h != i && ie(m, "Bad uncompressed size: " + i + " != " + h), he(r, p, T, {
            unsafe: !0,
            mt: l
          })
        }
        var ne = {
          htm: "text/html",
          xml: "text/xml",
          gif: "image/gif",
          jpg: "image/jpeg",
          png: "image/png",
          mso: "application/x-mso",
          thmx: "application/vnd.ms-officetheme",
          sh33tj5: "application/octet-stream"
        };

        function oe(e, t) {
          if (e.ctype) return e.ctype;
          var i = e.name || "",
            r = i.match(/\.([^\.]+)$/);
          return r && ne[r[1]] || t && (r = (i = t).match(/[\.\\]([^\.\\])+$/)) && ne[r[1]] ? ne[r[1]] : "application/octet-stream"
        }

        function ae(e) {
          for (var t = Wu(e), i = [], r = 0; r < t.length; r += 76) i.push(t.slice(r, r + 76));
          return i.join("\r\n") + "\r\n"
        }

        function le(e) {
          var t = e.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(e) {
            var t = e.charCodeAt(0).toString(16).toUpperCase();
            return "=" + (1 == t.length ? "0" + t : t)
          });
          "\n" == (t = t.replace(/ $/gm, "=20").replace(/\t$/gm, "=09")).charAt(0) && (t = "=0D" + t.slice(1));
          for (var i = [], r = (t = t.replace(/\r(?!\n)/gm, "=0D").replace(/\n\n/gm, "\n=0A").replace(/([^\r\n])\n/gm, "$1=0A")).split("\r\n"), s = 0; s < r.length; ++s) {
            var n = r[s];
            if (0 != n.length)
              for (var o = 0; o < n.length;) {
                var a = 76,
                  l = n.slice(o, o + a);
                "=" == l.charAt(a - 1) ? a-- : "=" == l.charAt(a - 2) ? a -= 2 : "=" == l.charAt(a - 3) && (a -= 3), l = n.slice(o, o + a), (o += a) < n.length && (l += "="), i.push(l)
              } else i.push("")
          }
          return i.join("\r\n")
        }

        function ce(e, t, i) {
          for (var r, s = "", n = "", o = "", a = 0; a < 10; ++a) {
            var l = t[a];
            if (!l || l.match(/^\s*$/)) break;
            var c = l.match(/^(.*?):\s*([^\s].*)$/);
            if (c) switch (c[1].toLowerCase()) {
              case "content-location":
                s = c[2].trim();
                break;
              case "content-type":
                o = c[2].trim();
                break;
              case "content-transfer-encoding":
                n = c[2].trim()
            }
          }
          switch (++a, n.toLowerCase()) {
            case "base64":
              r = ju(Yu(t.slice(a).join("")));
              break;
            case "quoted-printable":
              r = function(e) {
                for (var t = [], i = 0; i < e.length; ++i) {
                  for (var r = e[i]; i <= e.length && "=" == r.charAt(r.length - 1);) r = r.slice(0, r.length - 1) + e[++i];
                  t.push(r)
                }
                for (var s = 0; s < t.length; ++s) t[s] = t[s].replace(/[=][0-9A-Fa-f]{2}/g, function(e) {
                  return String.fromCharCode(parseInt(e.slice(1), 16))
                });
                return ju(t.join("\r\n"))
              }(t.slice(a));
              break;
            default:
              throw new Error("Unsupported Content-Transfer-Encoding " + n)
          }
          var h = he(e, s.slice(i.length), r, {
            unsafe: !0
          });
          o && (h.ctype = o)
        }

        function he(e, t, i, s) {
          var n = s && s.unsafe;
          n || d(e);
          var o = !n && qd.find(e, t);
          if (!o) {
            var a = e.FullPaths[0];
            t.slice(0, a.length) == a ? a = t : ("/" != a.slice(-1) && (a += "/"), a = (a + t).replace("//", "/")), o = {
              name: r(t),
              type: 2
            }, e.FileIndex.push(o), e.FullPaths.push(a), n || qd.utils.cfb_gc(e)
          }
          return o.content = i, o.size = i ? i.length : 0, s && (s.CLSID && (o.clsid = s.CLSID), s.mt && (o.mt = s.mt), s.ct && (o.ct = s.ct)), o
        }
        return t.find = function(e, t) {
          var i = e.FullPaths.map(function(e) {
              return e.toUpperCase()
            }),
            r = i.map(function(e) {
              var t = e.split("/");
              return t[t.length - ("/" == e.slice(-1) ? 2 : 1)]
            }),
            s = !1;
          47 === t.charCodeAt(0) ? (s = !0, t = i[0].slice(0, -1) + t) : s = -1 !== t.indexOf("/");
          var n = t.toUpperCase(),
            o = !0 === s ? i.indexOf(n) : r.indexOf(n);
          if (-1 !== o) return e.FileIndex[o];
          var a = !n.match(td);
          for (n = n.replace(ed, ""), a && (n = n.replace(td, "!")), o = 0; o < i.length; ++o) {
            if ((a ? i[o].replace(td, "!") : i[o]).replace(ed, "") == n) return e.FileIndex[o];
            if ((a ? r[o].replace(td, "!") : r[o]).replace(ed, "") == n) return e.FileIndex[o]
          }
          return null
        }, t.read = function(t, i) {
          var r = i && i.type;
          switch (r || Ku && Buffer.isBuffer(t) && (r = "buffer"), r || "base64") {
            case "file":
              return function(t, i) {
                return o(), a(e.readFileSync(t), i)
              }(t, i);
            case "base64":
              return a(ju(Yu(t)), i);
            case "binary":
              return a(ju(t), i)
          }
          return a(t, i)
        }, t.parse = a, t.write = function(t, i) {
          var r = E(t, i);
          switch (i && i.type || "buffer") {
            case "file":
              return o(), e.writeFileSync(i.filename, r), r;
            case "binary":
              return "string" == typeof r ? r : A(r);
            case "base64":
              return Wu("string" == typeof r ? r : A(r));
            case "buffer":
              if (Ku) return Buffer.isBuffer(r) ? r : Xu(r);
            case "array":
              return "string" == typeof r ? ju(r) : r
          }
          return r
        }, t.writeFile = function(t, i, r) {
          o();
          var s = E(t, r);
          e.writeFileSync(i, s)
        }, t.utils = {
          cfb_new: function(e) {
            var t = {};
            return d(t, e), t
          },
          cfb_add: he,
          cfb_del: function(e, t) {
            d(e);
            var i = qd.find(e, t);
            if (i)
              for (var r = 0; r < e.FileIndex.length; ++r)
                if (e.FileIndex[r] == i) return e.FileIndex.splice(r, 1), e.FullPaths.splice(r, 1), !0;
            return !1
          },
          cfb_mov: function(e, t, i) {
            d(e);
            var s = qd.find(e, t);
            if (s)
              for (var n = 0; n < e.FileIndex.length; ++n)
                if (e.FileIndex[n] == s) return e.FileIndex[n].name = r(i), e.FullPaths[n] = i, !0;
            return !1
          },
          cfb_gc: function(e) {
            p(e, !0)
          },
          ReadShift: qE,
          CheckField: ig,
          prep_blob: rg,
          bconcat: Zu,
          use_zlib: function(e) {
            try {
              var t = new(0, e.InflateRaw);
              if (t._processChunk(new Uint8Array([3, 0]), t._finishFlushFlag), !t.bytesRead) throw new Error("zlib does not expose bytesRead");
              g = e
            } catch (e) {
              console.error("cannot use native zlib: " + (e.message || e))
            }
          },
          _deflateRaw: $,
          _inflateRaw: te,
          consts: R
        }, t
      }();
    let Qd;

    function Zd(e) {
      Qd = e
    }

    function ep(e) {
      return "string" == typeof e ? Ju(e) : Array.isArray(e) ? function(e) {
        if ("undefined" == typeof Uint8Array) throw new Error("Unsupported");
        return new Uint8Array(e)
      }(e) : e
    }

    function tp(e, t, i) {
      if (void 0 !== Qd && Qd.writeFileSync) return i ? Qd.writeFileSync(e, t, i) : Qd.writeFileSync(e, t);
      if ("undefined" != typeof Deno) {
        if (i && "string" == typeof t) switch (i) {
          case "utf8":
            t = new TextEncoder(i).encode(t);
            break;
          case "binary":
            t = Ju(t);
            break;
          default:
            throw new Error("Unsupported encoding " + i)
        }
        return Deno.writeFileSync(e, t)
      }
      var r = "utf8" == i ? oE(t) : t;
      if ("undefined" != typeof IE_SaveFile) return IE_SaveFile(r, e);
      if ("undefined" != typeof Blob) {
        var s = new Blob([ep(r)], {
          type: "application/octet-stream"
        });
        if ("undefined" != typeof navigator && navigator.msSaveBlob) return navigator.msSaveBlob(s, e);
        if ("undefined" != typeof saveAs) return saveAs(s, e);
        if ("undefined" != typeof URL && "undefined" != typeof document && document.createElement && URL.createObjectURL) {
          var n = URL.createObjectURL(s);
          if ("object" == typeof chrome && "function" == typeof(chrome.downloads || {}).download) return URL.revokeObjectURL && "undefined" != typeof setTimeout && setTimeout(function() {
            URL.revokeObjectURL(n)
          }, 6e4), chrome.downloads.download({
            url: n,
            filename: e,
            saveAs: !0
          });
          var o = document.createElement("a");
          if (null != o.download) return o.download = e, o.href = n, document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL && "undefined" != typeof setTimeout && setTimeout(function() {
            URL.revokeObjectURL(n)
          }, 6e4), n
        }
      }
      if ("undefined" != typeof $ && "undefined" != typeof File && "undefined" != typeof Folder) try {
        var a = File(e);
        return a.open("w"), a.encoding = "binary", Array.isArray(t) && (t = qu(t)), a.write(t), a.close(), t
      } catch (e) {
        if (!e.message || !e.message.match(/onstruct/)) throw e
      }
      throw new Error("cannot save file " + e)
    }

    function ip(e) {
      for (var t = Object.keys(e), i = [], r = 0; r < t.length; ++r) Object.prototype.hasOwnProperty.call(e, t[r]) && i.push(t[r]);
      return i
    }

    function rp(e, t) {
      for (var i = [], r = ip(e), s = 0; s !== r.length; ++s) null == i[e[r[s]][t]] && (i[e[r[s]][t]] = r[s]);
      return i
    }

    function sp(e) {
      for (var t = [], i = ip(e), r = 0; r !== i.length; ++r) t[e[i[r]]] = i[r];
      return t
    }

    function np(e) {
      for (var t = [], i = ip(e), r = 0; r !== i.length; ++r) t[e[i[r]]] = parseInt(i[r], 10);
      return t
    }
    var op = new Date(1899, 11, 30, 0, 0, 0);

    function ap(e, t) {
      var i = e.getTime();
      return t && (i -= 1263168e5), (i - (op.getTime() + 6e4 * (e.getTimezoneOffset() - op.getTimezoneOffset()))) / 864e5
    }
    var lp = new Date,
      cp = op.getTime() + 6e4 * (lp.getTimezoneOffset() - op.getTimezoneOffset()),
      hp = lp.getTimezoneOffset();

    function up(e) {
      var t = new Date;
      return t.setTime(24 * e * 60 * 60 * 1e3 + cp), t.getTimezoneOffset() !== hp && t.setTime(t.getTime() + 6e4 * (t.getTimezoneOffset() - hp)), t
    }

    function dp(e) {
      var t = 0,
        i = 0,
        r = !1,
        s = e.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
      if (!s) throw new Error("|" + e + "| is not an ISO8601 Duration");
      for (var n = 1; n != s.length; ++n)
        if (s[n]) {
          switch (i = 1, n > 3 && (r = !0), s[n].slice(s[n].length - 1)) {
            case "Y":
              throw new Error("Unsupported ISO Duration Field: " + s[n].slice(s[n].length - 1));
            case "D":
              i *= 24;
            case "H":
              i *= 60;
            case "M":
              if (!r) throw new Error("Unsupported ISO Duration Field: M");
              i *= 60
          }
          t += i * parseInt(s[n], 10)
        } return t
    }
    var pp = new Date("2017-02-19T19:06:09.000Z"),
      Ep = isNaN(pp.getFullYear()) ? new Date("2/19/17") : pp,
      gp = 2017 == Ep.getFullYear();

    function fp(e, t) {
      var i = new Date(e);
      if (gp) return t > 0 ? i.setTime(i.getTime() + 60 * i.getTimezoneOffset() * 1e3) : t < 0 && i.setTime(i.getTime() - 60 * i.getTimezoneOffset() * 1e3), i;
      if (e instanceof Date) return e;
      if (1917 == Ep.getFullYear() && !isNaN(i.getFullYear())) {
        var r = i.getFullYear();
        return e.indexOf("" + r) > -1 || i.setFullYear(i.getFullYear() + 100), i
      }
      var s = e.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"],
        n = new Date(+s[0], +s[1] - 1, +s[2], +s[3] || 0, +s[4] || 0, +s[5] || 0);
      return e.indexOf("Z") > -1 && (n = new Date(n.getTime() - 60 * n.getTimezoneOffset() * 1e3)), n
    }

    function Tp(e, t) {
      if (Ku && Buffer.isBuffer(e)) {
        if (t) {
          if (255 == e[0] && 254 == e[1]) return oE(e.slice(2).toString("utf16le"));
          if (254 == e[1] && 255 == e[2]) return oE(Fu(e.slice(2).toString("binary")))
        }
        return e.toString("binary")
      }
      if ("undefined" != typeof TextDecoder) try {
        if (t) {
          if (255 == e[0] && 254 == e[1]) return oE(new TextDecoder("utf-16le").decode(e.slice(2)));
          if (254 == e[0] && 255 == e[1]) return oE(new TextDecoder("utf-16be").decode(e.slice(2)))
        }
        var i = {
          "€": "",
          "‚": "",
          ƒ: "",
          "„": "",
          "…": "",
          "†": "",
          "‡": "",
          ˆ: "",
          "‰": "",
          Š: "",
          "‹": "",
          Œ: "",
          Ž: "",
          "‘": "",
          "’": "",
          "“": "",
          "”": "",
          "•": "",
          "–": "",
          "—": "",
          "˜": "",
          "™": "",
          š: "",
          "›": "",
          œ: "",
          ž: "",
          Ÿ: ""
        };
        return Array.isArray(e) && (e = new Uint8Array(e)), new TextDecoder("latin1").decode(e).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(e) {
          return i[e] || e
        })
      } catch (e) {}
      for (var r = [], s = 0; s != e.length; ++s) r.push(String.fromCharCode(e[s]));
      return r.join("")
    }

    function mp(e) {
      if ("undefined" != typeof JSON && !Array.isArray(e)) return JSON.parse(JSON.stringify(e));
      if ("object" != typeof e || null == e) return e;
      if (e instanceof Date) return new Date(e.getTime());
      var t = {};
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = mp(e[i]));
      return t
    }

    function Cp(e, t) {
      for (var i = ""; i.length < t;) i += e;
      return i
    }

    function Sp(e) {
      var t = Number(e);
      if (!isNaN(t)) return isFinite(t) ? t : NaN;
      if (!/\d/.test(e)) return t;
      var i = 1,
        r = e.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
          return i *= 100, ""
        });
      return isNaN(t = Number(r)) ? (r = r.replace(/[(](.*)[)]/, function(e, t) {
        return i = -i, t
      }), isNaN(t = Number(r)) ? t : t / i) : t / i
    }
    var Rp = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];

    function Ap(e) {
      var t = new Date(e),
        i = new Date(NaN),
        r = t.getYear(),
        s = t.getMonth(),
        n = t.getDate();
      if (isNaN(n)) return i;
      var o = e.toLowerCase();
      if (o.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
        if ((o = o.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "")).length > 3 && -1 == Rp.indexOf(o)) return i
      } else if (o.match(/[a-z]/)) return i;
      return r < 0 || r > 8099 ? i : (s > 0 || n > 1) && 101 != r ? t : e.match(/[^-0-9:,\/\\]/) ? i : t
    }
    var vp = function() {
      var e = 5 == "abacaba".split(/(:?b)/i).length;
      return function(t, i, r) {
        if (e || "string" == typeof i) return t.split(i);
        for (var s = t.split(i), n = [s[0]], o = 1; o < s.length; ++o) n.push(r), n.push(s[o]);
        return n
      }
    }();

    function Np(e) {
      return e ? e.content && e.type ? Tp(e.content, !0) : e.data ? Gu(e.data) : e.asNodeBuffer && Ku ? Gu(e.asNodeBuffer().toString("binary")) : e.asBinary ? Gu(e.asBinary()) : e._data && e._data.getContent ? Gu(Tp(Array.prototype.slice.call(e._data.getContent(), 0))) : null : null
    }

    function Ip(e) {
      if (!e) return null;
      if (e.data) return Mu(e.data);
      if (e.asNodeBuffer && Ku) return e.asNodeBuffer();
      if (e._data && e._data.getContent) {
        var t = e._data.getContent();
        return "string" == typeof t ? Mu(t) : Array.prototype.slice.call(t)
      }
      return e.content && e.type ? e.content : null
    }

    function Op(e, t) {
      for (var i = e.FullPaths || ip(e.files), r = t.toLowerCase().replace(/[\/]/g, "\\"), s = r.replace(/\\/g, "/"), n = 0; n < i.length; ++n) {
        var o = i[n].replace(/^Root Entry[\/]/, "").toLowerCase();
        if (r == o || s == o) return e.files ? e.files[i[n]] : e.FileIndex[n]
      }
      return null
    }

    function Lp(e, t) {
      var i = Op(e, t);
      if (null == i) throw new Error("Cannot find file " + t + " in zip");
      return i
    }

    function _p(e, t, i) {
      if (!i) return (r = Lp(e, t)) && ".bin" === r.name.slice(-4) ? Ip(r) : Np(r);
      var r;
      if (!t) return null;
      try {
        return _p(e, t)
      } catch (e) {
        return null
      }
    }

    function yp(e, t, i) {
      if (!i) return Np(Lp(e, t));
      if (!t) return null;
      try {
        return yp(e, t)
      } catch (e) {
        return null
      }
    }

    function wp(e, t, i) {
      if (!i) return Ip(Lp(e, t));
      if (!t) return null;
      try {
        return wp(e, t)
      } catch (e) {
        return null
      }
    }

    function Dp(e) {
      for (var t = e.FullPaths || ip(e.files), i = [], r = 0; r < t.length; ++r) "/" != t[r].slice(-1) && i.push(t[r].replace(/^Root Entry[\/]/, ""));
      return i.sort()
    }

    function Pp(e, t, i) {
      if (e.FullPaths) {
        var r;
        if ("string" == typeof i) return r = Ku ? Xu(i) : function(e) {
          for (var t = [], i = 0, r = e.length + 250, s = zu(e.length + 255), n = 0; n < e.length; ++n) {
            var o = e.charCodeAt(n);
            if (o < 128) s[i++] = o;
            else if (o < 2048) s[i++] = 192 | o >> 6 & 31, s[i++] = 128 | 63 & o;
            else if (o >= 55296 && o < 57344) {
              o = 64 + (1023 & o);
              var a = 1023 & e.charCodeAt(++n);
              s[i++] = 240 | o >> 8 & 7, s[i++] = 128 | o >> 2 & 63, s[i++] = 128 | a >> 6 & 15 | (3 & o) << 4, s[i++] = 128 | 63 & a
            } else s[i++] = 224 | o >> 12 & 15, s[i++] = 128 | o >> 6 & 63, s[i++] = 128 | 63 & o;
            i > r && (t.push(s.slice(0, i)), i = 0, s = zu(65535), r = 65530)
          }
          return t.push(s.slice(0, i)), Zu(t)
        }(i), qd.utils.cfb_add(e, t, r);
        qd.utils.cfb_add(e, t, i)
      } else e.file(t, i)
    }

    function bp() {
      return qd.utils.cfb_new()
    }

    function Mp(e, t) {
      switch (t.type) {
        case "base64":
          return qd.read(e, {
            type: "base64"
          });
        case "binary":
          return qd.read(e, {
            type: "binary"
          });
        case "buffer":
        case "array":
          return qd.read(e, {
            type: "buffer"
          })
      }
      throw new Error("Unrecognized type " + t.type)
    }

    function Fp(e, t) {
      if ("/" == e.charAt(0)) return e.slice(1);
      var i = t.split("/");
      "/" != t.slice(-1) && i.pop();
      for (var r = e.split("/"); 0 !== r.length;) {
        var s = r.shift();
        ".." === s ? i.pop() : "." !== s && i.push(s)
      }
      return i.join("/")
    }
    var xp = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n',
      Gp = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g,
      Up = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/gm,
      Hp = xp.match(Up) ? Up : /<[^>]*>/g,
      kp = /<\w*:/,
      Bp = /<(\/?)\w+:/;

    function Vp(e, t, i) {
      for (var r = {}, s = 0, n = 0; s !== e.length && (32 !== (n = e.charCodeAt(s)) && 10 !== n && 13 !== n); ++s);
      if (t || (r[0] = e.slice(0, s)), s === e.length) return r;
      var o = e.match(Gp),
        a = 0,
        l = "",
        c = 0,
        h = "",
        u = "",
        d = 1;
      if (o)
        for (c = 0; c != o.length; ++c) {
          for (u = o[c], n = 0; n != u.length && 61 !== u.charCodeAt(n); ++n);
          for (h = u.slice(0, n).trim(); 32 == u.charCodeAt(n + 1);) ++n;
          for (d = 34 == (s = u.charCodeAt(n + 1)) || 39 == s ? 1 : 0, l = u.slice(n + 1 + d, u.length - d), a = 0; a != h.length && 58 !== h.charCodeAt(a); ++a);
          if (a === h.length) h.indexOf("_") > 0 && (h = h.slice(0, h.indexOf("_"))), r[h] = l, i || (r[h.toLowerCase()] = l);
          else {
            var p = (5 === a && "xmlns" === h.slice(0, 5) ? "xmlns" : "") + h.slice(a + 1);
            if (r[p] && "ext" == h.slice(a - 3, a)) continue;
            r[p] = l, i || (r[p.toLowerCase()] = l)
          }
        }
      return r
    }

    function Wp(e) {
      return e.replace(Bp, "<$1")
    }
    var Yp = {
        "&quot;": '"',
        "&apos;": "'",
        "&gt;": ">",
        "&lt;": "<",
        "&amp;": "&"
      },
      Kp = sp(Yp),
      Xp = function() {
        var e = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/gi,
          t = /_x([\da-fA-F]{4})_/gi;
        return function i(r) {
          var s = r + "",
            n = s.indexOf("<![CDATA[");
          if (-1 == n) return s.replace(e, function(e, t) {
            return Yp[e] || String.fromCharCode(parseInt(t, e.indexOf("x") > -1 ? 16 : 10)) || e
          }).replace(t, function(e, t) {
            return String.fromCharCode(parseInt(t, 16))
          });
          var o = s.indexOf("]]>");
          return i(s.slice(0, n)) + s.slice(n + 9, o) + i(s.slice(o + 3))
        }
      }(),
      zp = /[&<>'"]/g,
      $p = /[\u0000-\u0008\u000b-\u001f]/g;

    function jp(e) {
      return (e + "").replace(zp, function(e) {
        return Kp[e]
      }).replace($p, function(e) {
        return "_x" + ("000" + e.charCodeAt(0).toString(16)).slice(-4) + "_"
      })
    }

    function Jp(e) {
      return jp(e).replace(/ /g, "_x0020_")
    }
    var qp = /[\u0000-\u001f]/g;

    function Qp(e) {
      return (e + "").replace(zp, function(e) {
        return Kp[e]
      }).replace(/\n/g, "<br/>").replace(qp, function(e) {
        return "&#x" + ("000" + e.charCodeAt(0).toString(16)).slice(-4) + ";"
      })
    }
    var Zp = function() {
      var e = /&#(\d+);/g;

      function t(e, t) {
        return String.fromCharCode(parseInt(t, 10))
      }
      return function(i) {
        return i.replace(e, t)
      }
    }();

    function eE(e) {
      switch (e) {
        case 1:
        case !0:
        case "1":
        case "true":
        case "TRUE":
          return !0;
        default:
          return !1
      }
    }

    function tE(e) {
      for (var t = "", i = 0, r = 0, s = 0, n = 0, o = 0, a = 0; i < e.length;)(r = e.charCodeAt(i++)) < 128 ? t += String.fromCharCode(r) : (s = e.charCodeAt(i++), r > 191 && r < 224 ? (o = (31 & r) << 6, o |= 63 & s, t += String.fromCharCode(o)) : (n = e.charCodeAt(i++), r < 240 ? t += String.fromCharCode((15 & r) << 12 | (63 & s) << 6 | 63 & n) : (a = ((7 & r) << 18 | (63 & s) << 12 | (63 & n) << 6 | 63 & (o = e.charCodeAt(i++))) - 65536, t += String.fromCharCode(55296 + (a >>> 10 & 1023)), t += String.fromCharCode(56320 + (1023 & a)))));
      return t
    }

    function iE(e) {
      var t, i, r, s = zu(2 * e.length),
        n = 1,
        o = 0,
        a = 0;
      for (i = 0; i < e.length; i += n) n = 1, (r = e.charCodeAt(i)) < 128 ? t = r : r < 224 ? (t = 64 * (31 & r) + (63 & e.charCodeAt(i + 1)), n = 2) : r < 240 ? (t = 4096 * (15 & r) + 64 * (63 & e.charCodeAt(i + 1)) + (63 & e.charCodeAt(i + 2)), n = 3) : (n = 4, t = 262144 * (7 & r) + 4096 * (63 & e.charCodeAt(i + 1)) + 64 * (63 & e.charCodeAt(i + 2)) + (63 & e.charCodeAt(i + 3)), a = 55296 + ((t -= 65536) >>> 10 & 1023), t = 56320 + (1023 & t)), 0 !== a && (s[o++] = 255 & a, s[o++] = a >>> 8, a = 0), s[o++] = t % 256, s[o++] = t >>> 8;
      return s.slice(0, o).toString("ucs2")
    }

    function rE(e) {
      return Xu(e, "binary").toString("utf8")
    }
    var sE = "foo bar bazâð£",
      nE = Ku && (rE(sE) == tE(sE) && rE || iE(sE) == tE(sE) && iE) || tE,
      oE = Ku ? function(e) {
        return Xu(e, "utf8").toString("binary")
      } : function(e) {
        for (var t = [], i = 0, r = 0, s = 0; i < e.length;) switch (r = e.charCodeAt(i++), !0) {
          case r < 128:
            t.push(String.fromCharCode(r));
            break;
          case r < 2048:
            t.push(String.fromCharCode(192 + (r >> 6))), t.push(String.fromCharCode(128 + (63 & r)));
            break;
          case r >= 55296 && r < 57344:
            r -= 55296, s = e.charCodeAt(i++) - 56320 + (r << 10), t.push(String.fromCharCode(240 + (s >> 18 & 7))), t.push(String.fromCharCode(144 + (s >> 12 & 63))), t.push(String.fromCharCode(128 + (s >> 6 & 63))), t.push(String.fromCharCode(128 + (63 & s)));
            break;
          default:
            t.push(String.fromCharCode(224 + (r >> 12))), t.push(String.fromCharCode(128 + (r >> 6 & 63))), t.push(String.fromCharCode(128 + (63 & r)))
        }
        return t.join("")
      },
      aE = function() {
        var e = {};
        return function(t, i) {
          var r = t + "|" + (i || "");
          return e[r] ? e[r] : e[r] = new RegExp("<(?:\\w+:)?" + t + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + t + ">", i || "")
        }
      }(),
      lE = function() {
        var e = [
          ["nbsp", " "],
          ["middot", "·"],
          ["quot", '"'],
          ["apos", "'"],
          ["gt", ">"],
          ["lt", "<"],
          ["amp", "&"]
        ].map(function(e) {
          return [new RegExp("&" + e[0] + ";", "ig"), e[1]]
        });
        return function(t) {
          for (var i = t.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, ""), r = 0; r < e.length; ++r) i = i.replace(e[r][0], e[r][1]);
          return i
        }
      }(),
      cE = function() {
        var e = {};
        return function(t) {
          return void 0 !== e[t] ? e[t] : e[t] = new RegExp("<(?:vt:)?" + t + ">([\\s\\S]*?)</(?:vt:)?" + t + ">", "g")
        }
      }(),
      hE = /<\/?(?:vt:)?variant>/g,
      uE = /<(?:vt:)([^>]*)>([\s\S]*)</;

    function dE(e, t) {
      var i = Vp(e),
        r = e.match(cE(i.baseType)) || [],
        s = [];
      if (r.length != i.size) {
        if (t.WTF) throw new Error("unexpected vector length " + r.length + " != " + i.size);
        return s
      }
      return r.forEach(function(e) {
        var t = e.replace(hE, "").match(uE);
        t && s.push({
          v: nE(t[2]),
          t: t[1]
        })
      }), s
    }
    var pE = /(^\s|\s$|\n)/;

    function EE(e, t) {
      return "<" + e + (t.match(pE) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e + ">"
    }

    function gE(e) {
      return ip(e).map(function(t) {
        return " " + t + '="' + e[t] + '"'
      }).join("")
    }

    function fE(e, t, i) {
      return "<" + e + (null != i ? gE(i) : "") + (null != t ? (t.match(pE) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e : "/") + ">"
    }

    function TE(e, t) {
      try {
        return e.toISOString().replace(/\.\d*/, "")
      } catch (e) {
        if (t) throw e
      }
      return ""
    }

    function mE(e) {
      if (Ku && Buffer.isBuffer(e)) return e.toString("utf8");
      if ("string" == typeof e) return e;
      if ("undefined" != typeof Uint8Array && e instanceof Uint8Array) return nE(qu(Qu(e)));
      throw new Error("Bad input format: expected Buffer or string")
    }
    var CE = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/gm,
      SE = {
        CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
        CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
        CT: "http://schemas.openxmlformats.org/package/2006/content-types",
        RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
        TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
        dc: "http://purl.org/dc/elements/1.1/",
        dcterms: "http://purl.org/dc/terms/",
        dcmitype: "http://purl.org/dc/dcmitype/",
        mx: "http://schemas.microsoft.com/office/mac/excel/2008/main",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        sjs: "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        xsd: "http://www.w3.org/2001/XMLSchema"
      },
      RE = ["http://schemas.openxmlformats.org/spreadsheetml/2006/main", "http://purl.oclc.org/ooxml/spreadsheetml/main", "http://schemas.microsoft.com/office/excel/2006/main", "http://schemas.microsoft.com/office/excel/2006/2"],
      AE = {
        o: "urn:schemas-microsoft-com:office:office",
        x: "urn:schemas-microsoft-com:office:excel",
        ss: "urn:schemas-microsoft-com:office:spreadsheet",
        dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
        mv: "http://macVmlSchemaUri",
        v: "urn:schemas-microsoft-com:vml",
        html: "http://www.w3.org/TR/REC-html40"
      };
    var vE = function(e) {
        for (var t = [], i = 0; i < e[0].length; ++i)
          if (e[0][i])
            for (var r = 0, s = e[0][i].length; r < s; r += 10240) t.push.apply(t, e[0][i].slice(r, r + 10240));
        return t
      },
      NE = Ku ? function(e) {
        return e[0].length > 0 && Buffer.isBuffer(e[0][0]) ? Buffer.concat(e[0].map(function(e) {
          return Buffer.isBuffer(e) ? e : Xu(e)
        })) : vE(e)
      } : vE,
      IE = function(e, t, i) {
        for (var r = [], s = t; s < i; s += 2) r.push(String.fromCharCode(XE(e, s)));
        return r.join("").replace(ed, "")
      },
      OE = Ku ? function(e, t, i) {
        return Buffer.isBuffer(e) ? e.toString("utf16le", t, i).replace(ed, "") : IE(e, t, i)
      } : IE,
      LE = function(e, t, i) {
        for (var r = [], s = t; s < t + i; ++s) r.push(("0" + e[s].toString(16)).slice(-2));
        return r.join("")
      },
      _E = Ku ? function(e, t, i) {
        return Buffer.isBuffer(e) ? e.toString("hex", t, t + i) : LE(e, t, i)
      } : LE,
      yE = function(e, t, i) {
        for (var r = [], s = t; s < i; s++) r.push(String.fromCharCode(KE(e, s)));
        return r.join("")
      },
      wE = Ku ? function(e, t, i) {
        return Buffer.isBuffer(e) ? e.toString("utf8", t, i) : yE(e, t, i)
      } : yE,
      DE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? wE(e, t + 4, t + 4 + i - 1) : ""
      },
      PE = DE,
      bE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? wE(e, t + 4, t + 4 + i - 1) : ""
      },
      ME = bE,
      FE = function(e, t) {
        var i = 2 * $E(e, t);
        return i > 0 ? wE(e, t + 4, t + 4 + i - 1) : ""
      },
      xE = FE,
      GE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? OE(e, t + 4, t + 4 + i) : ""
      },
      UE = GE,
      HE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? wE(e, t + 4, t + 4 + i) : ""
      },
      kE = HE,
      BE = function(e, t) {
        return function(e, t) {
          for (var i = 1 - 2 * (e[t + 7] >>> 7), r = ((127 & e[t + 7]) << 4) + (e[t + 6] >>> 4 & 15), s = 15 & e[t + 6], n = 5; n >= 0; --n) s = 256 * s + e[t + n];
          return 2047 == r ? 0 == s ? i * (1 / 0) : NaN : (0 == r ? r = -1022 : (r -= 1023, s += Math.pow(2, 52)), i * Math.pow(2, r - 52) * s)
        }(e, t)
      },
      VE = BE,
      WE = function(e) {
        return Array.isArray(e) || "undefined" != typeof Uint8Array && e instanceof Uint8Array
      };

    function YE() {
      OE = function(e, t, i) {
        return xu.utils.decode(1200, e.slice(t, i)).replace(ed, "")
      }, wE = function(e, t, i) {
        return xu.utils.decode(65001, e.slice(t, i))
      }, PE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? xu.utils.decode(_u, e.slice(t + 4, t + 4 + i - 1)) : ""
      }, ME = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? xu.utils.decode(Lu, e.slice(t + 4, t + 4 + i - 1)) : ""
      }, xE = function(e, t) {
        var i = 2 * $E(e, t);
        return i > 0 ? xu.utils.decode(1200, e.slice(t + 4, t + 4 + i - 1)) : ""
      }, UE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? xu.utils.decode(1200, e.slice(t + 4, t + 4 + i)) : ""
      }, kE = function(e, t) {
        var i = $E(e, t);
        return i > 0 ? xu.utils.decode(65001, e.slice(t + 4, t + 4 + i)) : ""
      }
    }
    Ku && (PE = function(e, t) {
      if (!Buffer.isBuffer(e)) return DE(e, t);
      var i = e.readUInt32LE(t);
      return i > 0 ? e.toString("utf8", t + 4, t + 4 + i - 1) : ""
    }, ME = function(e, t) {
      if (!Buffer.isBuffer(e)) return bE(e, t);
      var i = e.readUInt32LE(t);
      return i > 0 ? e.toString("utf8", t + 4, t + 4 + i - 1) : ""
    }, xE = function(e, t) {
      if (!Buffer.isBuffer(e)) return FE(e, t);
      var i = 2 * e.readUInt32LE(t);
      return e.toString("utf16le", t + 4, t + 4 + i - 1)
    }, UE = function(e, t) {
      if (!Buffer.isBuffer(e)) return GE(e, t);
      var i = e.readUInt32LE(t);
      return e.toString("utf16le", t + 4, t + 4 + i)
    }, kE = function(e, t) {
      if (!Buffer.isBuffer(e)) return HE(e, t);
      var i = e.readUInt32LE(t);
      return e.toString("utf8", t + 4, t + 4 + i)
    }, VE = function(e, t) {
      return Buffer.isBuffer(e) ? e.readDoubleLE(t) : BE(e, t)
    }, WE = function(e) {
      return Buffer.isBuffer(e) || Array.isArray(e) || "undefined" != typeof Uint8Array && e instanceof Uint8Array
    }), void 0 !== xu && YE();
    var KE = function(e, t) {
        return e[t]
      },
      XE = function(e, t) {
        return 256 * e[t + 1] + e[t]
      },
      zE = function(e, t) {
        var i = 256 * e[t + 1] + e[t];
        return i < 32768 ? i : -1 * (65535 - i + 1)
      },
      $E = function(e, t) {
        return e[t + 3] * (1 << 24) + (e[t + 2] << 16) + (e[t + 1] << 8) + e[t]
      },
      jE = function(e, t) {
        return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
      },
      JE = function(e, t) {
        return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
      };

    function qE(e, t) {
      var i, r, s, n, o, a, l = "",
        c = [];
      switch (t) {
        case "dbcs":
          if (a = this.l, Ku && Buffer.isBuffer(this)) l = this.slice(this.l, this.l + 2 * e).toString("utf16le");
          else
            for (o = 0; o < e; ++o) l += String.fromCharCode(XE(this, a)), a += 2;
          e *= 2;
          break;
        case "utf8":
          l = wE(this, this.l, this.l + e);
          break;
        case "utf16le":
          e *= 2, l = OE(this, this.l, this.l + e);
          break;
        case "wstr":
          if (void 0 === xu) return qE.call(this, e, "dbcs");
          l = xu.utils.decode(Lu, this.slice(this.l, this.l + 2 * e)), e *= 2;
          break;
        case "lpstr-ansi":
          l = PE(this, this.l), e = 4 + $E(this, this.l);
          break;
        case "lpstr-cp":
          l = ME(this, this.l), e = 4 + $E(this, this.l);
          break;
        case "lpwstr":
          l = xE(this, this.l), e = 4 + 2 * $E(this, this.l);
          break;
        case "lpp4":
          e = 4 + $E(this, this.l), l = UE(this, this.l), 2 & e && (e += 2);
          break;
        case "8lpp4":
          e = 4 + $E(this, this.l), l = kE(this, this.l), 3 & e && (e += 4 - (3 & e));
          break;
        case "cstr":
          for (e = 0, l = ""; 0 !== (s = KE(this, this.l + e++));) c.push(Uu(s));
          l = c.join("");
          break;
        case "_wstr":
          for (e = 0, l = ""; 0 !== (s = XE(this, this.l + e));) c.push(Uu(s)), e += 2;
          e += 2, l = c.join("");
          break;
        case "dbcs-cont":
          for (l = "", a = this.l, o = 0; o < e; ++o) {
            if (this.lens && -1 !== this.lens.indexOf(a)) return s = KE(this, a), this.l = a + 1, n = qE.call(this, e - o, s ? "dbcs-cont" : "sbcs-cont"), c.join("") + n;
            c.push(Uu(XE(this, a))), a += 2
          }
          l = c.join(""), e *= 2;
          break;
        case "cpstr":
          if (void 0 !== xu) {
            l = xu.utils.decode(Lu, this.slice(this.l, this.l + e));
            break
          }
          case "sbcs-cont":
            for (l = "", a = this.l, o = 0; o != e; ++o) {
              if (this.lens && -1 !== this.lens.indexOf(a)) return s = KE(this, a), this.l = a + 1, n = qE.call(this, e - o, s ? "dbcs-cont" : "sbcs-cont"), c.join("") + n;
              c.push(Uu(KE(this, a))), a += 1
            }
            l = c.join("");
            break;
          default:
            switch (e) {
              case 1:
                return i = KE(this, this.l), this.l++, i;
              case 2:
                return i = ("i" === t ? zE : XE)(this, this.l), this.l += 2, i;
              case 4:
              case -4:
                return "i" !== t && 128 & this[this.l + 3] ? (r = $E(this, this.l), this.l += 4, r) : (i = (e > 0 ? jE : JE)(this, this.l), this.l += 4, i);
              case 8:
              case -8:
                if ("f" === t) return r = 8 == e ? VE(this, this.l) : VE([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, r;
                e = 8;
              case 16:
                l = _E(this, this.l, e)
            }
      }
      return this.l += e, l
    }
    var QE = function(e, t, i) {
        e[i] = 255 & t, e[i + 1] = t >>> 8 & 255, e[i + 2] = t >>> 16 & 255, e[i + 3] = t >>> 24 & 255
      },
      ZE = function(e, t, i) {
        e[i] = 255 & t, e[i + 1] = t >> 8 & 255, e[i + 2] = t >> 16 & 255, e[i + 3] = t >> 24 & 255
      },
      eg = function(e, t, i) {
        e[i] = 255 & t, e[i + 1] = t >>> 8 & 255
      };

    function tg(e, t, i) {
      var r = 0,
        s = 0;
      if ("dbcs" === i) {
        for (s = 0; s != t.length; ++s) eg(this, t.charCodeAt(s), this.l + 2 * s);
        r = 2 * t.length
      } else if ("sbcs" === i) {
        if (void 0 !== xu && 874 == _u)
          for (s = 0; s != t.length; ++s) {
            var n = xu.utils.encode(_u, t.charAt(s));
            this[this.l + s] = n[0]
          } else
            for (t = t.replace(/[^\x00-\x7F]/g, "_"), s = 0; s != t.length; ++s) this[this.l + s] = 255 & t.charCodeAt(s);
        r = t.length
      } else {
        if ("hex" === i) {
          for (; s < e; ++s) this[this.l++] = parseInt(t.slice(2 * s, 2 * s + 2), 16) || 0;
          return this
        }
        if ("utf16le" === i) {
          var o = Math.min(this.l + e, this.length);
          for (s = 0; s < Math.min(t.length, e); ++s) {
            var a = t.charCodeAt(s);
            this[this.l++] = 255 & a, this[this.l++] = a >> 8
          }
          for (; this.l < o;) this[this.l++] = 0;
          return this
        }
        switch (e) {
          case 1:
            r = 1, this[this.l] = 255 & t;
            break;
          case 2:
            r = 2, this[this.l] = 255 & t, t >>>= 8, this[this.l + 1] = 255 & t;
            break;
          case 3:
            r = 3, this[this.l] = 255 & t, t >>>= 8, this[this.l + 1] = 255 & t, t >>>= 8, this[this.l + 2] = 255 & t;
            break;
          case 4:
            r = 4, QE(this, t, this.l);
            break;
          case 8:
            if (r = 8, "f" === i) {
              ! function(e, t, i) {
                var r = (t < 0 || 1 / t == -1 / 0 ? 1 : 0) << 7,
                  s = 0,
                  n = 0,
                  o = r ? -t : t;
                isFinite(o) ? 0 == o ? s = n = 0 : (s = Math.floor(Math.log(o) / Math.LN2), n = o * Math.pow(2, 52 - s), s <= -1023 && (!isFinite(n) || n < Math.pow(2, 52)) ? s = -1022 : (n -= Math.pow(2, 52), s += 1023)) : (s = 2047, n = isNaN(t) ? 26985 : 0);
                for (var a = 0; a <= 5; ++a, n /= 256) e[i + a] = 255 & n;
                e[i + 6] = (15 & s) << 4 | 15 & n, e[i + 7] = s >> 4 | r
              }(this, t, this.l);
              break
            }
            case 16:
              break;
            case -4:
              r = 4, ZE(this, t, this.l)
        }
      }
      return this.l += r, this
    }

    function ig(e, t) {
      var i = _E(this, this.l, e.length >> 1);
      if (i !== e) throw new Error(t + "Expected " + e + " saw " + i);
      this.l += e.length >> 1
    }

    function rg(e, t) {
      e.l = t, e.read_shift = qE, e.chk = ig, e.write_shift = tg
    }

    function sg(e, t) {
      e.l += t
    }

    function ng(e) {
      var t = zu(e);
      return rg(t, 0), t
    }

    function og(e, t, i) {
      if (e) {
        var r, s, n;
        rg(e, e.l || 0);
        for (var o = e.length, a = 0, l = 0; e.l < o;) {
          128 & (a = e.read_shift(1)) && (a = (127 & a) + ((127 & e.read_shift(1)) << 7));
          var c = vA[a] || vA[65535];
          for (n = 127 & (r = e.read_shift(1)), s = 1; s < 4 && 128 & r; ++s) n += (127 & (r = e.read_shift(1))) << 7 * s;
          l = e.l + n;
          var h = c.f && c.f(e, n, i);
          if (e.l = l, t(h, c, a)) return
        }
      }
    }

    function ag() {
      var e = [],
        t = Ku ? 256 : 2048,
        i = function(e) {
          var t = ng(e);
          return rg(t, 0), t
        },
        r = i(t),
        s = function() {
          r && (r.length > r.l && ((r = r.slice(0, r.l)).l = r.length), r.length > 0 && e.push(r), r = null)
        },
        n = function(e) {
          return r && e < r.length - r.l ? r : (s(), r = i(Math.max(e + 1, t)))
        };
      return {
        next: n,
        push: function(e) {
          s(), null == (r = e).l && (r.l = r.length), n(t)
        },
        end: function() {
          return s(), Zu(e)
        },
        _bufs: e
      }
    }

    function lg(e, t, i, r) {
      var s, n = +t;
      if (!isNaN(n)) {
        r || (r = vA[n].p || (i || []).length || 0), s = 1 + (n >= 128 ? 1 : 0) + 1, r >= 128 && ++s, r >= 16384 && ++s, r >= 2097152 && ++s;
        var o = e.next(s);
        n <= 127 ? o.write_shift(1, n) : (o.write_shift(1, 128 + (127 & n)), o.write_shift(1, n >> 7));
        for (var a = 0; 4 != a; ++a) {
          if (!(r >= 128)) {
            o.write_shift(1, r);
            break
          }
          o.write_shift(1, 128 + (127 & r)), r >>= 7
        }
        r > 0 && WE(i) && e.push(i)
      }
    }

    function cg(e, t, i) {
      var r = mp(e);
      if (t.s ? (r.cRel && (r.c += t.s.c), r.rRel && (r.r += t.s.r)) : (r.cRel && (r.c += t.c), r.rRel && (r.r += t.r)), !i || i.biff < 12) {
        for (; r.c >= 256;) r.c -= 256;
        for (; r.r >= 65536;) r.r -= 65536
      }
      return r
    }

    function hg(e, t, i) {
      var r = mp(e);
      return r.s = cg(r.s, t.s, i), r.e = cg(r.e, t.s, i), r
    }

    function ug(e, t) {
      if (e.cRel && e.c < 0)
        for (e = mp(e); e.c < 0;) e.c += t > 8 ? 16384 : 256;
      if (e.rRel && e.r < 0)
        for (e = mp(e); e.r < 0;) e.r += t > 8 ? 1048576 : t > 5 ? 65536 : 16384;
      var i = mg(e);
      return e.cRel || null == e.cRel || (i = i.replace(/^([A-Z])/, "$$$1")), e.rRel || null == e.rRel || (i = function(e) {
        return e.replace(/([A-Z]|^)(\d+)$/, "$1$$$2")
      }(i)), i
    }

    function dg(e, t) {
      return 0 != e.s.r || e.s.rRel || e.e.r != (t.biff >= 12 ? 1048575 : t.biff >= 8 ? 65536 : 16384) || e.e.rRel ? 0 != e.s.c || e.s.cRel || e.e.c != (t.biff >= 12 ? 16383 : 255) || e.e.cRel ? ug(e.s, t.biff) + ":" + ug(e.e, t.biff) : (e.s.rRel ? "" : "$") + Eg(e.s.r) + ":" + (e.e.rRel ? "" : "$") + Eg(e.e.r) : (e.s.cRel ? "" : "$") + fg(e.s.c) + ":" + (e.e.cRel ? "" : "$") + fg(e.e.c)
    }

    function pg(e) {
      return parseInt(e.replace(/\$(\d+)$/, "$1"), 10) - 1
    }

    function Eg(e) {
      return "" + (e + 1)
    }

    function gg(e) {
      for (var t = e.replace(/^\$([A-Z])/, "$1"), i = 0, r = 0; r !== t.length; ++r) i = 26 * i + t.charCodeAt(r) - 64;
      return i - 1
    }

    function fg(e) {
      if (e < 0) throw new Error("invalid column " + e);
      var t = "";
      for (++e; e; e = Math.floor((e - 1) / 26)) t = String.fromCharCode((e - 1) % 26 + 65) + t;
      return t
    }

    function Tg(e) {
      for (var t = 0, i = 0, r = 0; r < e.length; ++r) {
        var s = e.charCodeAt(r);
        s >= 48 && s <= 57 ? t = 10 * t + (s - 48) : s >= 65 && s <= 90 && (i = 26 * i + (s - 64))
      }
      return {
        c: i - 1,
        r: t - 1
      }
    }

    function mg(e) {
      for (var t = e.c + 1, i = ""; t; t = (t - 1) / 26 | 0) i = String.fromCharCode((t - 1) % 26 + 65) + i;
      return i + (e.r + 1)
    }

    function Cg(e) {
      var t = e.indexOf(":");
      return -1 == t ? {
        s: Tg(e),
        e: Tg(e)
      } : {
        s: Tg(e.slice(0, t)),
        e: Tg(e.slice(t + 1))
      }
    }

    function Sg(e, t) {
      return void 0 === t || "number" == typeof t ? Sg(e.s, e.e) : ("string" != typeof e && (e = mg(e)), "string" != typeof t && (t = mg(t)), e == t ? e : e + ":" + t)
    }

    function Rg(e) {
      var t = {
          s: {
            c: 0,
            r: 0
          },
          e: {
            c: 0,
            r: 0
          }
        },
        i = 0,
        r = 0,
        s = 0,
        n = e.length;
      for (i = 0; r < n && !((s = e.charCodeAt(r) - 64) < 1 || s > 26); ++r) i = 26 * i + s;
      for (t.s.c = --i, i = 0; r < n && !((s = e.charCodeAt(r) - 48) < 0 || s > 9); ++r) i = 10 * i + s;
      if (t.s.r = --i, r === n || 10 != s) return t.e.c = t.s.c, t.e.r = t.s.r, t;
      for (++r, i = 0; r != n && !((s = e.charCodeAt(r) - 64) < 1 || s > 26); ++r) i = 26 * i + s;
      for (t.e.c = --i, i = 0; r != n && !((s = e.charCodeAt(r) - 48) < 0 || s > 9); ++r) i = 10 * i + s;
      return t.e.r = --i, t
    }

    function Ag(e, t) {
      var i = "d" == e.t && t instanceof Date;
      if (null != e.z) try {
        return e.w = Wd(e.z, i ? ap(t) : t)
      } catch (e) {}
      try {
        return e.w = Wd((e.XF || {}).numFmtId || (i ? 14 : 0), i ? ap(t) : t)
      } catch (e) {
        return "" + t
      }
    }

    function vg(e, t, i) {
      return null == e || null == e.t || "z" == e.t ? "" : void 0 !== e.w ? e.w : ("d" == e.t && !e.z && i && i.dateNF && (e.z = i.dateNF), "e" == e.t ? pf[e.v] || e.v : Ag(e, null == t ? e.v : t))
    }

    function Ng(e, t) {
      var i = t && t.sheet ? t.sheet : "Sheet1",
        r = {};
      return r[i] = e, {
        SheetNames: [i],
        Sheets: r
      }
    }

    function Ig(e, t, i) {
      var r = i || {},
        s = e ? Array.isArray(e) : r.dense;
      null != Bu && null == s && (s = Bu);
      var n = e || (s ? [] : {}),
        o = 0,
        a = 0;
      if (n && null != r.origin) {
        if ("number" == typeof r.origin) o = r.origin;
        else {
          var l = "string" == typeof r.origin ? Tg(r.origin) : r.origin;
          o = l.r, a = l.c
        }
        n["!ref"] || (n["!ref"] = "A1:A1")
      }
      var c = {
        s: {
          c: 1e7,
          r: 1e7
        },
        e: {
          c: 0,
          r: 0
        }
      };
      if (n["!ref"]) {
        var h = Rg(n["!ref"]);
        c.s.c = h.s.c, c.s.r = h.s.r, c.e.c = Math.max(c.e.c, h.e.c), c.e.r = Math.max(c.e.r, h.e.r), -1 == o && (c.e.r = o = h.e.r + 1)
      }
      for (var u = 0; u != t.length; ++u)
        if (t[u]) {
          if (!Array.isArray(t[u])) throw new Error("aoa_to_sheet expects an array of arrays");
          for (var d = 0; d != t[u].length; ++d)
            if (void 0 !== t[u][d]) {
              var p = {
                  v: t[u][d]
                },
                E = o + u,
                g = a + d;
              if (c.s.r > E && (c.s.r = E), c.s.c > g && (c.s.c = g), c.e.r < E && (c.e.r = E), c.e.c < g && (c.e.c = g), !t[u][d] || "object" != typeof t[u][d] || Array.isArray(t[u][d]) || t[u][d] instanceof Date)
                if (Array.isArray(p.v) && (p.f = t[u][d][1], p.v = p.v[0]), null === p.v)
                  if (p.f) p.t = "n";
                  else if (r.nullError) p.t = "e", p.v = 0;
              else {
                if (!r.sheetStubs) continue;
                p.t = "z"
              } else "number" == typeof p.v ? p.t = "n" : "boolean" == typeof p.v ? p.t = "b" : p.v instanceof Date ? (p.z = r.dateNF || ud[14], r.cellDates ? (p.t = "d", p.w = Wd(p.z, ap(p.v))) : (p.t = "n", p.v = ap(p.v), p.w = Wd(p.z, p.v))) : p.t = "s";
              else p = t[u][d];
              if (s) n[E] || (n[E] = []), n[E][g] && n[E][g].z && (p.z = n[E][g].z), n[E][g] = p;
              else {
                var f = mg({
                  c: g,
                  r: E
                });
                n[f] && n[f].z && (p.z = n[f].z), n[f] = p
              }
            }
        } return c.s.c < 1e7 && (n["!ref"] = Sg(c)), n
    }

    function Og(e, t) {
      return Ig(null, e, t)
    }

    function Lg(e, t) {
      return t || (t = ng(4)), t.write_shift(4, e), t
    }

    function _g(e) {
      var t = e.read_shift(4);
      return 0 === t ? "" : e.read_shift(t, "dbcs")
    }

    function yg(e, t) {
      var i = !1;
      return null == t && (i = !0, t = ng(4 + 2 * e.length)), t.write_shift(4, e.length), e.length > 0 && t.write_shift(0, e, "dbcs"), i ? t.slice(0, t.l) : t
    }

    function wg(e) {
      return {
        ich: e.read_shift(2),
        ifnt: e.read_shift(2)
      }
    }

    function Dg(e, t) {
      var i = e.l,
        r = e.read_shift(1),
        s = _g(e),
        n = [],
        o = {
          t: s,
          h: s
        };
      if (1 & r) {
        for (var a = e.read_shift(4), l = 0; l != a; ++l) n.push(wg(e));
        o.r = n
      } else o.r = [{
        ich: 0,
        ifnt: 0
      }];
      return e.l = i + t, o
    }
    var Pg = Dg;

    function bg(e, t) {
      var i = !1;
      return null == t && (i = !0, t = ng(23 + 4 * e.t.length)), t.write_shift(1, 1), yg(e.t, t), t.write_shift(4, 1),
        function(e, t) {
          t || (t = ng(4)), t.write_shift(2, e.ich || 0), t.write_shift(2, e.ifnt || 0)
        }({
          ich: 0,
          ifnt: 0
        }, t), i ? t.slice(0, t.l) : t
    }

    function Mg(e) {
      var t = e.read_shift(4),
        i = e.read_shift(2);
      return i += e.read_shift(1) << 16, e.l++, {
        c: t,
        iStyleRef: i
      }
    }

    function Fg(e, t) {
      return null == t && (t = ng(8)), t.write_shift(-4, e.c), t.write_shift(3, e.iStyleRef || e.s), t.write_shift(1, 0), t
    }

    function xg(e) {
      var t = e.read_shift(2);
      return t += e.read_shift(1) << 16, e.l++, {
        c: -1,
        iStyleRef: t
      }
    }

    function Gg(e, t) {
      return null == t && (t = ng(4)), t.write_shift(3, e.iStyleRef || e.s), t.write_shift(1, 0), t
    }
    var Ug = _g,
      Hg = yg;

    function kg(e) {
      var t = e.read_shift(4);
      return 0 === t || 4294967295 === t ? "" : e.read_shift(t, "dbcs")
    }

    function Bg(e, t) {
      var i = !1;
      return null == t && (i = !0, t = ng(127)), t.write_shift(4, e.length > 0 ? e.length : 4294967295), e.length > 0 && t.write_shift(0, e, "dbcs"), i ? t.slice(0, t.l) : t
    }
    var Vg = _g,
      Wg = kg,
      Yg = Bg;

    function Kg(e) {
      var t = e.slice(e.l, e.l + 4),
        i = 1 & t[0],
        r = 2 & t[0];
      e.l += 4;
      var s = 0 === r ? VE([0, 0, 0, 0, 252 & t[0], t[1], t[2], t[3]], 0) : jE(t, 0) >> 2;
      return i ? s / 100 : s
    }

    function Xg(e, t) {
      null == t && (t = ng(4));
      var i = 0,
        r = 0,
        s = 100 * e;
      if (e == (0 | e) && e >= -(1 << 29) && e < 1 << 29 ? r = 1 : s == (0 | s) && s >= -(1 << 29) && s < 1 << 29 && (r = 1, i = 1), !r) throw new Error("unsupported RkNumber " + e);
      t.write_shift(-4, ((i ? s : e) << 2) + (i + 2))
    }

    function zg(e) {
      var t = {
        s: {},
        e: {}
      };
      return t.s.r = e.read_shift(4), t.e.r = e.read_shift(4), t.s.c = e.read_shift(4), t.e.c = e.read_shift(4), t
    }
    var $g = zg,
      jg = function(e, t) {
        return t || (t = ng(16)), t.write_shift(4, e.s.r), t.write_shift(4, e.e.r), t.write_shift(4, e.s.c), t.write_shift(4, e.e.c), t
      };

    function Jg(e) {
      if (e.length - e.l < 8) throw "XLS Xnum Buffer underflow";
      return e.read_shift(8, "f")
    }

    function qg(e, t) {
      return (t || ng(8)).write_shift(8, e, "f")
    }

    function Qg(e, t) {
      if (t || (t = ng(8)), !e || e.auto) return t.write_shift(4, 0), t.write_shift(4, 0), t;
      null != e.index ? (t.write_shift(1, 2), t.write_shift(1, e.index)) : null != e.theme ? (t.write_shift(1, 6), t.write_shift(1, e.theme)) : (t.write_shift(1, 5), t.write_shift(1, 0));
      var i = e.tint || 0;
      if (i > 0 ? i *= 32767 : i < 0 && (i *= 32768), t.write_shift(2, i), e.rgb && null == e.theme) {
        var r = e.rgb || "FFFFFF";
        "number" == typeof r && (r = ("000000" + r.toString(16)).slice(-6)), t.write_shift(1, parseInt(r.slice(0, 2), 16)), t.write_shift(1, parseInt(r.slice(2, 4), 16)), t.write_shift(1, parseInt(r.slice(4, 6), 16)), t.write_shift(1, 255)
      } else t.write_shift(2, 0), t.write_shift(1, 0), t.write_shift(1, 0);
      return t
    }

    function Zg(e, t) {
      var i = e.read_shift(4);
      switch (i) {
        case 0:
          return "";
        case 4294967295:
        case 4294967294:
          return {
            2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE"
          } [e.read_shift(4)] || ""
      }
      if (i > 400) throw new Error("Unsupported Clipboard: " + i.toString(16));
      return e.l -= 4, e.read_shift(0, 1 == t ? "lpstr" : "lpwstr")
    }
    var ef = 2,
      tf = 3,
      rf = 12,
      sf = 80,
      nf = 81,
      of = [sf, nf],
      af = {
        1: {
          n: "CodePage",
          t: ef
        },
        2: {
          n: "Category",
          t: sf
        },
        3: {
          n: "PresentationFormat",
          t: sf
        },
        4: {
          n: "ByteCount",
          t: tf
        },
        5: {
          n: "LineCount",
          t: tf
        },
        6: {
          n: "ParagraphCount",
          t: tf
        },
        7: {
          n: "SlideCount",
          t: tf
        },
        8: {
          n: "NoteCount",
          t: tf
        },
        9: {
          n: "HiddenCount",
          t: tf
        },
        10: {
          n: "MultimediaClipCount",
          t: tf
        },
        11: {
          n: "ScaleCrop",
          t: 11
        },
        12: {
          n: "HeadingPairs",
          t: 4108
        },
        13: {
          n: "TitlesOfParts",
          t: 4126
        },
        14: {
          n: "Manager",
          t: sf
        },
        15: {
          n: "Company",
          t: sf
        },
        16: {
          n: "LinksUpToDate",
          t: 11
        },
        17: {
          n: "CharacterCount",
          t: tf
        },
        19: {
          n: "SharedDoc",
          t: 11
        },
        22: {
          n: "HyperlinksChanged",
          t: 11
        },
        23: {
          n: "AppVersion",
          t: tf,
          p: "version"
        },
        24: {
          n: "DigSig",
          t: 65
        },
        26: {
          n: "ContentType",
          t: sf
        },
        27: {
          n: "ContentStatus",
          t: sf
        },
        28: {
          n: "Language",
          t: sf
        },
        29: {
          n: "Version",
          t: sf
        },
        255: {},
        2147483648: {
          n: "Locale",
          t: 19
        },
        2147483651: {
          n: "Behavior",
          t: 19
        },
        1919054434: {}
      },
      lf = {
        1: {
          n: "CodePage",
          t: ef
        },
        2: {
          n: "Title",
          t: sf
        },
        3: {
          n: "Subject",
          t: sf
        },
        4: {
          n: "Author",
          t: sf
        },
        5: {
          n: "Keywords",
          t: sf
        },
        6: {
          n: "Comments",
          t: sf
        },
        7: {
          n: "Template",
          t: sf
        },
        8: {
          n: "LastAuthor",
          t: sf
        },
        9: {
          n: "RevNumber",
          t: sf
        },
        10: {
          n: "EditTime",
          t: 64
        },
        11: {
          n: "LastPrinted",
          t: 64
        },
        12: {
          n: "CreatedDate",
          t: 64
        },
        13: {
          n: "ModifiedDate",
          t: 64
        },
        14: {
          n: "PageCount",
          t: tf
        },
        15: {
          n: "WordCount",
          t: tf
        },
        16: {
          n: "CharCount",
          t: tf
        },
        17: {
          n: "Thumbnail",
          t: 71
        },
        18: {
          n: "Application",
          t: sf
        },
        19: {
          n: "DocSecurity",
          t: tf
        },
        255: {},
        2147483648: {
          n: "Locale",
          t: 19
        },
        2147483651: {
          n: "Behavior",
          t: 19
        },
        1919054434: {}
      },
      cf = {
        1: "US",
        2: "CA",
        3: "",
        7: "RU",
        20: "EG",
        30: "GR",
        31: "NL",
        32: "BE",
        33: "FR",
        34: "ES",
        36: "HU",
        39: "IT",
        41: "CH",
        43: "AT",
        44: "GB",
        45: "DK",
        46: "SE",
        47: "NO",
        48: "PL",
        49: "DE",
        52: "MX",
        55: "BR",
        61: "AU",
        64: "NZ",
        66: "TH",
        81: "JP",
        82: "KR",
        84: "VN",
        86: "CN",
        90: "TR",
        105: "JS",
        213: "DZ",
        216: "MA",
        218: "LY",
        351: "PT",
        354: "IS",
        358: "FI",
        420: "CZ",
        886: "TW",
        961: "LB",
        962: "JO",
        963: "SY",
        964: "IQ",
        965: "KW",
        966: "SA",
        971: "AE",
        972: "IL",
        974: "QA",
        981: "IR",
        65535: "US"
      },
      hf = [null, "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625"];

    function uf(e) {
      return e.map(function(e) {
        return [e >> 16 & 255, e >> 8 & 255, 255 & e]
      })
    }
    var df = mp(uf([0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 8388608, 32768, 128, 8421376, 8388736, 32896, 12632256, 8421504, 10066431, 10040166, 16777164, 13434879, 6684774, 16744576, 26316, 13421823, 128, 16711935, 16776960, 65535, 8388736, 8388608, 32896, 255, 52479, 13434879, 13434828, 16777113, 10079487, 16751052, 13408767, 16764057, 3368703, 3394764, 10079232, 16763904, 16750848, 16737792, 6710937, 9868950, 13158, 3381606, 13056, 3355392, 10040064, 10040166, 3355545, 3355443, 16777215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
      pf = {
        0: "#NULL!",
        7: "#DIV/0!",
        15: "#VALUE!",
        23: "#REF!",
        29: "#NAME?",
        36: "#NUM!",
        42: "#N/A",
        43: "#GETTING_DATA",
        255: "#WTF?"
      },
      Ef = {
        "#NULL!": 0,
        "#DIV/0!": 7,
        "#VALUE!": 15,
        "#REF!": 23,
        "#NAME?": 29,
        "#NUM!": 36,
        "#N/A": 42,
        "#GETTING_DATA": 43,
        "#WTF?": 255
      },
      gf = {
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
        "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
        "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
        "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
        "application/vnd.ms-excel.worksheet": "sheets",
        "application/vnd.ms-excel.binIndexWs": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
        "application/vnd.ms-excel.chartsheet": "charts",
        "application/vnd.ms-excel.macrosheet+xml": "macros",
        "application/vnd.ms-excel.macrosheet": "macros",
        "application/vnd.ms-excel.intlmacrosheet": "TODO",
        "application/vnd.ms-excel.binIndexMs": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
        "application/vnd.ms-excel.dialogsheet": "dialogs",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
        "application/vnd.ms-excel.sharedStrings": "strs",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
        "application/vnd.ms-excel.styles": "styles",
        "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
        "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
        "application/vnd.ms-excel.comments": "comments",
        "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
        "application/vnd.ms-excel.person+xml": "people",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
        "application/vnd.ms-excel.sheetMetadata": "metadata",
        "application/vnd.ms-excel.pivotTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
        "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
        "application/vnd.ms-office.chartstyle+xml": "TODO",
        "application/vnd.ms-office.chartex+xml": "TODO",
        "application/vnd.ms-excel.calcChain": "calcchains",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
        "application/vnd.ms-office.activeX": "TODO",
        "application/vnd.ms-office.activeX+xml": "TODO",
        "application/vnd.ms-excel.attachedToolbars": "TODO",
        "application/vnd.ms-excel.connections": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
        "application/vnd.ms-excel.externalLink": "links",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
        "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
        "application/vnd.ms-excel.pivotCacheRecords": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
        "application/vnd.ms-excel.queryTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
        "application/vnd.ms-excel.userNames": "TODO",
        "application/vnd.ms-excel.revisionHeaders": "TODO",
        "application/vnd.ms-excel.revisionLog": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
        "application/vnd.ms-excel.tableSingleCells": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
        "application/vnd.ms-excel.slicer": "TODO",
        "application/vnd.ms-excel.slicerCache": "TODO",
        "application/vnd.ms-excel.slicer+xml": "TODO",
        "application/vnd.ms-excel.slicerCache+xml": "TODO",
        "application/vnd.ms-excel.wsSortMap": "TODO",
        "application/vnd.ms-excel.table": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
        "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
        "application/vnd.ms-excel.Timeline+xml": "TODO",
        "application/vnd.ms-excel.TimelineCache+xml": "TODO",
        "application/vnd.ms-office.vbaProject": "vba",
        "application/vnd.ms-office.vbaProjectSignature": "TODO",
        "application/vnd.ms-office.volatileDependencies": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
        "application/vnd.ms-excel.controlproperties+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.model+data": "TODO",
        "application/vnd.ms-excel.Survey+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
        "application/vnd.openxmlformats-package.relationships+xml": "rels",
        "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
        "image/png": "TODO",
        sheet: "js"
      },
      ff = {
        workbooks: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
          xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
          xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
          xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
          xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
        },
        strs: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
          xlsb: "application/vnd.ms-excel.sharedStrings"
        },
        comments: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
          xlsb: "application/vnd.ms-excel.comments"
        },
        sheets: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
          xlsb: "application/vnd.ms-excel.worksheet"
        },
        charts: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
          xlsb: "application/vnd.ms-excel.chartsheet"
        },
        dialogs: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
          xlsb: "application/vnd.ms-excel.dialogsheet"
        },
        macros: {
          xlsx: "application/vnd.ms-excel.macrosheet+xml",
          xlsb: "application/vnd.ms-excel.macrosheet"
        },
        metadata: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
          xlsb: "application/vnd.ms-excel.sheetMetadata"
        },
        styles: {
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
          xlsb: "application/vnd.ms-excel.styles"
        }
      };

    function Tf(e, t) {
      var i, r = function(e) {
          for (var t = [], i = ip(e), r = 0; r !== i.length; ++r) null == t[e[i[r]]] && (t[e[i[r]]] = []), t[e[i[r]]].push(i[r]);
          return t
        }(gf),
        s = [];
      s[s.length] = xp, s[s.length] = fE("Types", null, {
        xmlns: SE.CT,
        "xmlns:xsd": SE.xsd,
        "xmlns:xsi": SE.xsi
      }), s = s.concat([
        ["xml", "application/xml"],
        ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
        ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
        ["data", "application/vnd.openxmlformats-officedocument.model+data"],
        ["bmp", "image/bmp"],
        ["png", "image/png"],
        ["gif", "image/gif"],
        ["emf", "image/x-emf"],
        ["wmf", "image/x-wmf"],
        ["jpg", "image/jpeg"],
        ["jpeg", "image/jpeg"],
        ["tif", "image/tiff"],
        ["tiff", "image/tiff"],
        ["pdf", "application/pdf"],
        ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
      ].map(function(e) {
        return fE("Default", null, {
          Extension: e[0],
          ContentType: e[1]
        })
      }));
      var n = function(r) {
          e[r] && e[r].length > 0 && (i = e[r][0], s[s.length] = fE("Override", null, {
            PartName: ("/" == i[0] ? "" : "/") + i,
            ContentType: ff[r][t.bookType] || ff[r].xlsx
          }))
        },
        o = function(i) {
          (e[i] || []).forEach(function(e) {
            s[s.length] = fE("Override", null, {
              PartName: ("/" == e[0] ? "" : "/") + e,
              ContentType: ff[i][t.bookType] || ff[i].xlsx
            })
          })
        },
        a = function(t) {
          (e[t] || []).forEach(function(e) {
            s[s.length] = fE("Override", null, {
              PartName: ("/" == e[0] ? "" : "/") + e,
              ContentType: r[t][0]
            })
          })
        };
      return n("workbooks"), o("sheets"), o("charts"), a("themes"), ["strs", "styles"].forEach(n), ["coreprops", "extprops", "custprops"].forEach(a), a("vba"), a("comments"), a("threadedcomments"), a("drawings"), o("metadata"), a("people"), s.length > 2 && (s[s.length] = "</Types>", s[1] = s[1].replace("/>", ">")), s.join("")
    }
    var mf = {
      WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
      XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
      XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
      XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
      CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
      CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
      CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
      SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
      STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
      CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
      CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
      CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
      WS: ["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"],
      DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
      MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
      IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
      XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
      TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
      PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
      VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
    };

    function Cf(e) {
      var t = e.lastIndexOf("/");
      return e.slice(0, t + 1) + "_rels/" + e.slice(t + 1) + ".rels"
    }

    function Sf(e, t) {
      var i = {
        "!id": {}
      };
      if (!e) return i;
      "/" !== t.charAt(0) && (t = "/" + t);
      var r = {};
      return (e.match(Hp) || []).forEach(function(e) {
        var s = Vp(e);
        if ("<Relationship" === s[0]) {
          var n = {};
          n.Type = s.Type, n.Target = s.Target, n.Id = s.Id, s.TargetMode && (n.TargetMode = s.TargetMode);
          var o = "External" === s.TargetMode ? s.Target : Fp(s.Target, t);
          i[o] = n, r[s.Id] = n
        }
      }), i["!id"] = r, i
    }

    function Rf(e) {
      var t = [xp, fE("Relationships", null, {
        xmlns: SE.RELS
      })];
      return ip(e["!id"]).forEach(function(i) {
        t[t.length] = fE("Relationship", null, e["!id"][i])
      }), t.length > 2 && (t[t.length] = "</Relationships>", t[1] = t[1].replace("/>", ">")), t.join("")
    }

    function Af(e, t, i, r, s, n) {
      if (s || (s = {}), e["!id"] || (e["!id"] = {}), e["!idx"] || (e["!idx"] = 1), t < 0)
        for (t = e["!idx"]; e["!id"]["rId" + t]; ++t);
      if (e["!idx"] = t + 1, s.Id = "rId" + t, s.Type = r, s.Target = i, n ? s.TargetMode = n : [mf.HLINK, mf.XPATH, mf.XMISS].indexOf(s.Type) > -1 && (s.TargetMode = "External"), e["!id"][s.Id]) throw new Error("Cannot rewrite rId " + t);
      return e["!id"][s.Id] = s, e[("/" + s.Target).replace("//", "/")] = s, t
    }
    var vf = "application/vnd.oasis.opendocument.spreadsheet";

    function Nf(e, t, i) {
      return ['  <rdf:Description rdf:about="' + e + '">\n', '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (i || "odf") + "#" + t + '"/>\n', "  </rdf:Description>\n"].join("")
    }

    function If(e, t) {
      return ['  <rdf:Description rdf:about="' + e + '">\n', '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + t + '"/>\n', "  </rdf:Description>\n"].join("")
    }

    function Of() {
      return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + Ou.version + "</meta:generator></office:meta></office:document-meta>"
    }
    var Lf = [
        ["cp:category", "Category"],
        ["cp:contentStatus", "ContentStatus"],
        ["cp:keywords", "Keywords"],
        ["cp:lastModifiedBy", "LastAuthor"],
        ["cp:lastPrinted", "LastPrinted"],
        ["cp:revision", "RevNumber"],
        ["cp:version", "Version"],
        ["dc:creator", "Author"],
        ["dc:description", "Comments"],
        ["dc:identifier", "Identifier"],
        ["dc:language", "Language"],
        ["dc:subject", "Subject"],
        ["dc:title", "Title"],
        ["dcterms:created", "CreatedDate", "date"],
        ["dcterms:modified", "ModifiedDate", "date"]
      ],
      _f = function() {
        for (var e = new Array(Lf.length), t = 0; t < Lf.length; ++t) {
          var i = Lf[t],
            r = "(?:" + i[0].slice(0, i[0].indexOf(":")) + ":)" + i[0].slice(i[0].indexOf(":") + 1);
          e[t] = new RegExp("<" + r + "[^>]*>([\\s\\S]*?)</" + r + ">")
        }
        return e
      }();

    function yf(e) {
      var t = {};
      e = nE(e);
      for (var i = 0; i < Lf.length; ++i) {
        var r = Lf[i],
          s = e.match(_f[i]);
        null != s && s.length > 0 && (t[r[1]] = Xp(s[1])), "date" === r[2] && t[r[1]] && (t[r[1]] = fp(t[r[1]]))
      }
      return t
    }

    function wf(e, t, i, r, s) {
      null == s[e] && null != t && "" !== t && (s[e] = t, t = jp(t), r[r.length] = i ? fE(e, t, i) : EE(e, t))
    }

    function Df(e, t) {
      var i = t || {},
        r = [xp, fE("cp:coreProperties", null, {
          "xmlns:cp": SE.CORE_PROPS,
          "xmlns:dc": SE.dc,
          "xmlns:dcterms": SE.dcterms,
          "xmlns:dcmitype": SE.dcmitype,
          "xmlns:xsi": SE.xsi
        })],
        s = {};
      if (!e && !i.Props) return r.join("");
      e && (null != e.CreatedDate && wf("dcterms:created", "string" == typeof e.CreatedDate ? e.CreatedDate : TE(e.CreatedDate, i.WTF), {
        "xsi:type": "dcterms:W3CDTF"
      }, r, s), null != e.ModifiedDate && wf("dcterms:modified", "string" == typeof e.ModifiedDate ? e.ModifiedDate : TE(e.ModifiedDate, i.WTF), {
        "xsi:type": "dcterms:W3CDTF"
      }, r, s));
      for (var n = 0; n != Lf.length; ++n) {
        var o = Lf[n],
          a = i.Props && null != i.Props[o[1]] ? i.Props[o[1]] : e ? e[o[1]] : null;
        !0 === a ? a = "1" : !1 === a ? a = "0" : "number" == typeof a && (a = String(a)), null != a && wf(o[0], a, null, r, s)
      }
      return r.length > 2 && (r[r.length] = "</cp:coreProperties>", r[1] = r[1].replace("/>", ">")), r.join("")
    }
    var Pf = [
        ["Application", "Application", "string"],
        ["AppVersion", "AppVersion", "string"],
        ["Company", "Company", "string"],
        ["DocSecurity", "DocSecurity", "string"],
        ["Manager", "Manager", "string"],
        ["HyperlinksChanged", "HyperlinksChanged", "bool"],
        ["SharedDoc", "SharedDoc", "bool"],
        ["LinksUpToDate", "LinksUpToDate", "bool"],
        ["ScaleCrop", "ScaleCrop", "bool"],
        ["HeadingPairs", "HeadingPairs", "raw"],
        ["TitlesOfParts", "TitlesOfParts", "raw"]
      ],
      bf = ["Worksheets", "SheetNames", "NamedRanges", "DefinedNames", "Chartsheets", "ChartNames"];

    function Mf(e, t, i, r) {
      var s = [];
      if ("string" == typeof e) s = dE(e, r);
      else
        for (var n = 0; n < e.length; ++n) s = s.concat(e[n].map(function(e) {
          return {
            v: e
          }
        }));
      var o = "string" == typeof t ? dE(t, r).map(function(e) {
          return e.v
        }) : t,
        a = 0,
        l = 0;
      if (o.length > 0)
        for (var c = 0; c !== s.length; c += 2) {
          switch (l = +s[c + 1].v, s[c].v) {
            case "Worksheets":
            case "工作表":
            case "Листы":
            case "أوراق العمل":
            case "ワークシート":
            case "גליונות עבודה":
            case "Arbeitsblätter":
            case "Çalışma Sayfaları":
            case "Feuilles de calcul":
            case "Fogli di lavoro":
            case "Folhas de cálculo":
            case "Planilhas":
            case "Regneark":
            case "Hojas de cálculo":
            case "Werkbladen":
              i.Worksheets = l, i.SheetNames = o.slice(a, a + l);
              break;
            case "Named Ranges":
            case "Rangos con nombre":
            case "名前付き一覧":
            case "Benannte Bereiche":
            case "Navngivne områder":
              i.NamedRanges = l, i.DefinedNames = o.slice(a, a + l);
              break;
            case "Charts":
            case "Diagramme":
              i.Chartsheets = l, i.ChartNames = o.slice(a, a + l)
          }
          a += l
        }
    }

    function Ff(e) {
      var t = [],
        i = fE;
      return e || (e = {}), e.Application = "SheetJS", t[t.length] = xp, t[t.length] = fE("Properties", null, {
        xmlns: SE.EXT_PROPS,
        "xmlns:vt": SE.vt
      }), Pf.forEach(function(r) {
        if (void 0 !== e[r[1]]) {
          var s;
          switch (r[2]) {
            case "string":
              s = jp(String(e[r[1]]));
              break;
            case "bool":
              s = e[r[1]] ? "true" : "false"
          }
          void 0 !== s && (t[t.length] = i(r[0], s))
        }
      }), t[t.length] = i("HeadingPairs", i("vt:vector", i("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + i("vt:variant", i("vt:i4", String(e.Worksheets))), {
        size: 2,
        baseType: "variant"
      })), t[t.length] = i("TitlesOfParts", i("vt:vector", e.SheetNames.map(function(e) {
        return "<vt:lpstr>" + jp(e) + "</vt:lpstr>"
      }).join(""), {
        size: e.Worksheets,
        baseType: "lpstr"
      })), t.length > 2 && (t[t.length] = "</Properties>", t[1] = t[1].replace("/>", ">")), t.join("")
    }
    var xf = /<[^>]+>[^<]*/g;

    function Gf(e) {
      var t = [xp, fE("Properties", null, {
        xmlns: SE.CUST_PROPS,
        "xmlns:vt": SE.vt
      })];
      if (!e) return t.join("");
      var i = 1;
      return ip(e).forEach(function(r) {
        ++i, t[t.length] = fE("property", function(e, t) {
          switch (typeof e) {
            case "string":
              var i = fE("vt:lpwstr", jp(e));
              return t && (i = i.replace(/&quot;/g, "_x0022_")), i;
            case "number":
              return fE((0 | e) == e ? "vt:i4" : "vt:r8", jp(String(e)));
            case "boolean":
              return fE("vt:bool", e ? "true" : "false")
          }
          if (e instanceof Date) return fE("vt:filetime", TE(e));
          throw new Error("Unable to serialize " + e)
        }(e[r], !0), {
          fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
          pid: i,
          name: jp(r)
        })
      }), t.length > 2 && (t[t.length] = "</Properties>", t[1] = t[1].replace("/>", ">")), t.join("")
    }
    var Uf, Hf = {
      Title: "Title",
      Subject: "Subject",
      Author: "Author",
      Keywords: "Keywords",
      Comments: "Description",
      LastAuthor: "LastAuthor",
      RevNumber: "Revision",
      Application: "AppName",
      LastPrinted: "LastPrinted",
      CreatedDate: "Created",
      ModifiedDate: "LastSaved",
      Category: "Category",
      Manager: "Manager",
      Company: "Company",
      AppVersion: "Version",
      ContentStatus: "ContentStatus",
      Identifier: "Identifier",
      Language: "Language"
    };

    function kf(e, t, i) {
      Uf || (Uf = sp(Hf)), e[t = Uf[t] || t] = i
    }

    function Bf(e) {
      var t = e.read_shift(4),
        i = e.read_shift(4);
      return new Date(1e3 * (i / 1e7 * Math.pow(2, 32) + t / 1e7 - 11644473600)).toISOString().replace(/\.000/, "")
    }

    function Vf(e, t, i) {
      var r = e.l,
        s = e.read_shift(0, "lpstr-cp");
      if (i)
        for (; e.l - r & 3;) ++e.l;
      return s
    }

    function Wf(e, t, i) {
      var r = e.read_shift(0, "lpwstr");
      return i && (e.l += 4 - (r.length + 1 & 3) & 3), r
    }

    function Yf(e, t, i) {
      return 31 === t ? Wf(e) : Vf(e, 0, i)
    }

    function Kf(e, t, i) {
      return Yf(e, t, !1 === i ? 0 : 4)
    }

    function Xf(e) {
      var t = e.l,
        i = jf(e, nf);
      return 0 == e[e.l] && 0 == e[e.l + 1] && e.l - t & 2 && (e.l += 2), [i, jf(e, tf)]
    }

    function zf(e, t) {
      for (var i = e.read_shift(4), r = {}, s = 0; s != i; ++s) {
        var n = e.read_shift(4),
          o = e.read_shift(4);
        r[n] = e.read_shift(o, 1200 === t ? "utf16le" : "utf8").replace(ed, "").replace(td, "!"), 1200 === t && o % 2 && (e.l += 2)
      }
      return 3 & e.l && (e.l = e.l >> 3 << 2), r
    }

    function $f(e) {
      var t = e.read_shift(4),
        i = e.slice(e.l, e.l + t);
      return e.l += t, (3 & t) > 0 && (e.l += 4 - (3 & t) & 3), i
    }

    function jf(e, t, i) {
      var r, s = e.read_shift(2),
        n = i || {};
      if (e.l += 2, t !== rf && s !== t && -1 === of .indexOf(t) && (4126 != (65534 & t) || 4126 != (65534 & s))) throw new Error("Expected type " + t + " saw " + s);
      switch (t === rf ? s : t) {
        case 2:
          return r = e.read_shift(2, "i"), n.raw || (e.l += 2), r;
        case 3:
          return r = e.read_shift(4, "i");
        case 11:
          return 0 !== e.read_shift(4);
        case 19:
          return r = e.read_shift(4);
        case 30:
          return Vf(e, 0, 4).replace(ed, "");
        case 31:
          return Wf(e);
        case 64:
          return Bf(e);
        case 65:
          return $f(e);
        case 71:
          return function(e) {
            var t = {};
            return t.Size = e.read_shift(4), e.l += t.Size + 3 - (t.Size - 1) % 4, t
          }(e);
        case 80:
          return Kf(e, s, !n.raw).replace(ed, "");
        case 81:
          return function(e, t) {
            if (!t) throw new Error("VtUnalignedString must have positive length");
            return Yf(e, t, 0)
          }(e, s).replace(ed, "");
        case 4108:
          return function(e) {
            for (var t = e.read_shift(4), i = [], r = 0; r < t / 2; ++r) i.push(Xf(e));
            return i
          }(e);
        case 4126:
        case 4127:
          return 4127 == s ? function(e) {
            for (var t = e.read_shift(4), i = [], r = 0; r != t; ++r) {
              var s = e.l;
              i[r] = e.read_shift(0, "lpwstr").replace(ed, ""), e.l - s & 2 && (e.l += 2)
            }
            return i
          }(e) : function(e) {
            for (var t = e.read_shift(4), i = [], r = 0; r != t; ++r) i[r] = e.read_shift(0, "lpstr-cp").replace(ed, "");
            return i
          }(e);
        default:
          throw new Error("TypedPropertyValue unrecognized type " + t + " " + s)
      }
    }

    function Jf(e, t) {
      var i = ng(4),
        r = ng(4);
      switch (i.write_shift(4, 80 == e ? 31 : e), e) {
        case 3:
          r.write_shift(-4, t);
          break;
        case 5:
          (r = ng(8)).write_shift(8, t, "f");
          break;
        case 11:
          r.write_shift(4, t ? 1 : 0);
          break;
        case 64:
          r = function(e) {
            var t = ("string" == typeof e ? new Date(Date.parse(e)) : e).getTime() / 1e3 + 11644473600,
              i = t % Math.pow(2, 32),
              r = (t - i) / Math.pow(2, 32);
            r *= 1e7;
            var s = (i *= 1e7) / Math.pow(2, 32) | 0;
            s > 0 && (i %= Math.pow(2, 32), r += s);
            var n = ng(8);
            return n.write_shift(4, i), n.write_shift(4, r), n
          }(t);
          break;
        case 31:
        case 80:
          for ((r = ng(4 + 2 * (t.length + 1) + (t.length % 2 ? 0 : 2))).write_shift(4, t.length + 1), r.write_shift(0, t, "dbcs"); r.l != r.length;) r.write_shift(1, 0);
          break;
        default:
          throw new Error("TypedPropertyValue unrecognized type " + e + " " + t)
      }
      return Zu([i, r])
    }

    function qf(e, t) {
      var i = e.l,
        r = e.read_shift(4),
        s = e.read_shift(4),
        n = [],
        o = 0,
        a = 0,
        l = -1,
        c = {};
      for (o = 0; o != s; ++o) {
        var h = e.read_shift(4),
          u = e.read_shift(4);
        n[o] = [h, u + i]
      }
      n.sort(function(e, t) {
        return e[1] - t[1]
      });
      var d = {};
      for (o = 0; o != s; ++o) {
        if (e.l !== n[o][1]) {
          var p = !0;
          if (o > 0 && t) switch (t[n[o - 1][0]].t) {
            case 2:
              e.l + 2 === n[o][1] && (e.l += 2, p = !1);
              break;
            case 80:
            case 4108:
              e.l <= n[o][1] && (e.l = n[o][1], p = !1)
          }
          if ((!t || 0 == o) && e.l <= n[o][1] && (p = !1, e.l = n[o][1]), p) throw new Error("Read Error: Expected address " + n[o][1] + " at " + e.l + " :" + o)
        }
        if (t) {
          var E = t[n[o][0]];
          if (d[E.n] = jf(e, E.t, {
              raw: !0
            }), "version" === E.p && (d[E.n] = String(d[E.n] >> 16) + "." + ("0000" + String(65535 & d[E.n])).slice(-4)), "CodePage" == E.n) switch (d[E.n]) {
            case 0:
              d[E.n] = 1252;
            case 874:
            case 932:
            case 936:
            case 949:
            case 950:
            case 1250:
            case 1251:
            case 1253:
            case 1254:
            case 1255:
            case 1256:
            case 1257:
            case 1258:
            case 1e4:
            case 1200:
            case 1201:
            case 1252:
            case 65e3:
            case -536:
            case 65001:
            case -535:
              Pu(a = d[E.n] >>> 0 & 65535);
              break;
            default:
              throw new Error("Unsupported CodePage: " + d[E.n])
          }
        } else if (1 === n[o][0]) {
          if (a = d.CodePage = jf(e, ef), Pu(a), -1 !== l) {
            var g = e.l;
            e.l = n[l][1], c = zf(e, a), e.l = g
          }
        } else if (0 === n[o][0]) {
          if (0 === a) {
            l = o, e.l = n[o + 1][1];
            continue
          }
          c = zf(e, a)
        } else {
          var f, T = c[n[o][0]];
          switch (e[e.l]) {
            case 65:
              e.l += 4, f = $f(e);
              break;
            case 30:
            case 31:
              e.l += 4, f = Kf(e, e[e.l - 4]).replace(/\u0000+$/, "");
              break;
            case 3:
              e.l += 4, f = e.read_shift(4, "i");
              break;
            case 19:
              e.l += 4, f = e.read_shift(4);
              break;
            case 5:
              e.l += 4, f = e.read_shift(8, "f");
              break;
            case 11:
              e.l += 4, f = sT(e, 4);
              break;
            case 64:
              e.l += 4, f = fp(Bf(e));
              break;
            default:
              throw new Error("unparsed value: " + e[e.l])
          }
          d[T] = f
        }
      }
      return e.l = i + r, d
    }
    var Qf = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];

    function Zf(e) {
      switch (typeof e) {
        case "boolean":
          return 11;
        case "number":
          return (0 | e) == e ? 3 : 5;
        case "string":
          return 31;
        case "object":
          if (e instanceof Date) return 64
      }
      return -1
    }

    function eT(e, t, i) {
      var r = ng(8),
        s = [],
        n = [],
        o = 8,
        a = 0,
        l = ng(8),
        c = ng(8);
      if (l.write_shift(4, 2), l.write_shift(4, 1200), c.write_shift(4, 1), n.push(l), s.push(c), o += 8 + l.length, !t) {
        (c = ng(8)).write_shift(4, 0), s.unshift(c);
        var h = [ng(4)];
        for (h[0].write_shift(4, e.length), a = 0; a < e.length; ++a) {
          var u = e[a][0];
          for ((l = ng(8 + 2 * (u.length + 1) + (u.length % 2 ? 0 : 2))).write_shift(4, a + 2), l.write_shift(4, u.length + 1), l.write_shift(0, u, "dbcs"); l.l != l.length;) l.write_shift(1, 0);
          h.push(l)
        }
        l = Zu(h), n.unshift(l), o += 8 + l.length
      }
      for (a = 0; a < e.length; ++a)
        if ((!t || t[e[a][0]]) && !(Qf.indexOf(e[a][0]) > -1 || bf.indexOf(e[a][0]) > -1) && null != e[a][1]) {
          var d = e[a][1],
            p = 0;
          if (t) {
            var E = i[p = +t[e[a][0]]];
            if ("version" == E.p && "string" == typeof d) {
              var g = d.split(".");
              d = (+g[0] << 16) + (+g[1] || 0)
            }
            l = Jf(E.t, d)
          } else {
            var f = Zf(d); - 1 == f && (f = 31, d = String(d)), l = Jf(f, d)
          }
          n.push(l), (c = ng(8)).write_shift(4, t ? p : 2 + a), s.push(c), o += 8 + l.length
        } var T = 8 * (n.length + 1);
      for (a = 0; a < n.length; ++a) s[a].write_shift(4, T), T += n[a].length;
      return r.write_shift(4, o), r.write_shift(4, n.length), Zu([r].concat(s).concat(n))
    }

    function tT(e, t, i) {
      var r = e.content;
      if (!r) return {};
      rg(r, 0);
      var s, n, o, a, l = 0;
      r.chk("feff", "Byte Order: "), r.read_shift(2);
      var c = r.read_shift(4),
        h = r.read_shift(16);
      if (h !== qd.utils.consts.HEADER_CLSID && h !== i) throw new Error("Bad PropertySet CLSID " + h);
      if (1 !== (s = r.read_shift(4)) && 2 !== s) throw new Error("Unrecognized #Sets: " + s);
      if (n = r.read_shift(16), a = r.read_shift(4), 1 === s && a !== r.l) throw new Error("Length mismatch: " + a + " !== " + r.l);
      2 === s && (o = r.read_shift(16), l = r.read_shift(4));
      var u, d = qf(r, t),
        p = {
          SystemIdentifier: c
        };
      for (var E in d) p[E] = d[E];
      if (p.FMTID = n, 1 === s) return p;
      if (l - r.l == 2 && (r.l += 2), r.l !== l) throw new Error("Length mismatch 2: " + r.l + " !== " + l);
      try {
        u = qf(r, null)
      } catch (e) {}
      for (E in u) p[E] = u[E];
      return p.FMTID = [n, o], p
    }

    function iT(e, t, i, r, s, n) {
      var o = ng(s ? 68 : 48),
        a = [o];
      o.write_shift(2, 65534), o.write_shift(2, 0), o.write_shift(4, 842412599), o.write_shift(16, qd.utils.consts.HEADER_CLSID, "hex"), o.write_shift(4, s ? 2 : 1), o.write_shift(16, t, "hex"), o.write_shift(4, s ? 68 : 48);
      var l = eT(e, i, r);
      if (a.push(l), s) {
        var c = eT(s, null, null);
        o.write_shift(16, n, "hex"), o.write_shift(4, 68 + l.length), a.push(c)
      }
      return Zu(a)
    }

    function rT(e, t) {
      return e.read_shift(t), null
    }

    function sT(e, t) {
      return 1 === e.read_shift(t)
    }

    function nT(e, t) {
      return t || (t = ng(2)), t.write_shift(2, +!!e), t
    }

    function oT(e) {
      return e.read_shift(2, "u")
    }

    function aT(e, t) {
      return t || (t = ng(2)), t.write_shift(2, e), t
    }

    function lT(e, t) {
      return function(e, t, i) {
        for (var r = [], s = e.l + t; e.l < s;) r.push(i(e, s - e.l));
        if (s !== e.l) throw new Error("Slurp error");
        return r
      }(e, t, oT)
    }

    function cT(e, t, i) {
      return i || (i = ng(2)), i.write_shift(1, "e" == t ? +e : +!!e), i.write_shift(1, "e" == t ? 1 : 0), i
    }

    function hT(e, t, i) {
      var r = e.read_shift(i && i.biff >= 12 ? 2 : 1),
        s = "sbcs-cont",
        n = Lu;
      (i && i.biff >= 8 && (Lu = 1200), i && 8 != i.biff) ? 12 == i.biff && (s = "wstr"): e.read_shift(1) && (s = "dbcs-cont");
      i.biff >= 2 && i.biff <= 5 && (s = "cpstr");
      var o = r ? e.read_shift(r, s) : "";
      return Lu = n, o
    }

    function uT(e) {
      var t = Lu;
      Lu = 1200;
      var i, r = e.read_shift(2),
        s = e.read_shift(1),
        n = 4 & s,
        o = 8 & s,
        a = 1 + (1 & s),
        l = 0,
        c = {};
      o && (l = e.read_shift(2)), n && (i = e.read_shift(4));
      var h = 2 == a ? "dbcs-cont" : "sbcs-cont",
        u = 0 === r ? "" : e.read_shift(r, h);
      return o && (e.l += 4 * l), n && (e.l += i), c.t = u, o || (c.raw = "<t>" + c.t + "</t>", c.r = c.t), Lu = t, c
    }

    function dT(e) {
      var t = e.t || "",
        i = ng(3);
      i.write_shift(2, t.length), i.write_shift(1, 1);
      var r = ng(2 * t.length);
      return r.write_shift(2 * t.length, t, "utf16le"), Zu([i, r])
    }

    function pT(e, t, i) {
      if (i) {
        if (i.biff >= 2 && i.biff <= 5) return e.read_shift(t, "cpstr");
        if (i.biff >= 12) return e.read_shift(t, "dbcs-cont")
      }
      return 0 === e.read_shift(1) ? e.read_shift(t, "sbcs-cont") : e.read_shift(t, "dbcs-cont")
    }

    function ET(e, t, i) {
      var r = e.read_shift(i && 2 == i.biff ? 1 : 2);
      return 0 === r ? (e.l++, "") : pT(e, r, i)
    }

    function gT(e, t, i) {
      if (i.biff > 5) return ET(e, 0, i);
      var r = e.read_shift(1);
      return 0 === r ? (e.l++, "") : e.read_shift(r, i.biff <= 4 || !e.lens ? "cpstr" : "sbcs-cont")
    }

    function fT(e, t, i) {
      return i || (i = ng(3 + 2 * e.length)), i.write_shift(2, e.length), i.write_shift(1, 1), i.write_shift(31, e, "utf16le"), i
    }

    function TT(e, t) {
      var i = e.read_shift(16);
      switch (i) {
        case "e0c9ea79f9bace118c8200aa004ba90b":
          return function(e) {
            var t = e.read_shift(4),
              i = e.l,
              r = !1;
            t > 24 && (e.l += t - 24, "795881f43b1d7f48af2c825dc4852763" === e.read_shift(16) && (r = !0), e.l = i);
            var s = e.read_shift((r ? t - 24 : t) >> 1, "utf16le").replace(ed, "");
            return r && (e.l += 24), s
          }(e);
        case "0303000000000000c000000000000046":
          return function(e) {
            for (var t = e.read_shift(2), i = ""; t-- > 0;) i += "../";
            var r = e.read_shift(0, "lpstr-ansi");
            if (e.l += 2, 57005 != e.read_shift(2)) throw new Error("Bad FileMoniker");
            if (0 === e.read_shift(4)) return i + r.replace(/\\/g, "/");
            var s = e.read_shift(4);
            if (3 != e.read_shift(2)) throw new Error("Bad FileMoniker");
            return i + e.read_shift(s >> 1, "utf16le").replace(ed, "")
          }(e);
        default:
          throw new Error("Unsupported Moniker " + i)
      }
    }

    function mT(e) {
      var t = e.read_shift(4);
      return t > 0 ? e.read_shift(t, "utf16le").replace(ed, "") : ""
    }

    function CT(e, t) {
      t || (t = ng(6 + 2 * e.length)), t.write_shift(4, 1 + e.length);
      for (var i = 0; i < e.length; ++i) t.write_shift(2, e.charCodeAt(i));
      return t.write_shift(2, 0), t
    }

    function ST(e) {
      var t = ng(512),
        i = 0,
        r = e.Target;
      "file://" == r.slice(0, 7) && (r = r.slice(7));
      var s = r.indexOf("#"),
        n = s > -1 ? 31 : 23;
      switch (r.charAt(0)) {
        case "#":
          n = 28;
          break;
        case ".":
          n &= -3
      }
      t.write_shift(4, 2), t.write_shift(4, n);
      var o = [8, 6815827, 6619237, 4849780, 83];
      for (i = 0; i < o.length; ++i) t.write_shift(4, o[i]);
      if (28 == n) CT(r = r.slice(1), t);
      else if (2 & n) {
        for (o = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), i = 0; i < o.length; ++i) t.write_shift(1, parseInt(o[i], 16));
        var a = s > -1 ? r.slice(0, s) : r;
        for (t.write_shift(4, 2 * (a.length + 1)), i = 0; i < a.length; ++i) t.write_shift(2, a.charCodeAt(i));
        t.write_shift(2, 0), 8 & n && CT(s > -1 ? r.slice(s + 1) : "", t)
      } else {
        for (o = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" "), i = 0; i < o.length; ++i) t.write_shift(1, parseInt(o[i], 16));
        for (var l = 0;
          "../" == r.slice(3 * l, 3 * l + 3) || "..\\" == r.slice(3 * l, 3 * l + 3);) ++l;
        for (t.write_shift(2, l), t.write_shift(4, r.length - 3 * l + 1), i = 0; i < r.length - 3 * l; ++i) t.write_shift(1, 255 & r.charCodeAt(i + 3 * l));
        for (t.write_shift(1, 0), t.write_shift(2, 65535), t.write_shift(2, 57005), i = 0; i < 6; ++i) t.write_shift(4, 0)
      }
      return t.slice(0, t.l)
    }

    function RT(e) {
      return [e.read_shift(1), e.read_shift(1), e.read_shift(1), e.read_shift(1)]
    }

    function AT(e, t) {
      var i = RT(e);
      return i[3] = 0, i
    }

    function vT(e) {
      return {
        r: e.read_shift(2),
        c: e.read_shift(2),
        ixfe: e.read_shift(2)
      }
    }

    function NT(e, t, i, r) {
      return r || (r = ng(6)), r.write_shift(2, e), r.write_shift(2, t), r.write_shift(2, i || 0), r
    }

    function IT(e, t, i) {
      var r = i.biff > 8 ? 4 : 2;
      return [e.read_shift(r), e.read_shift(r, "i"), e.read_shift(r, "i")]
    }

    function OT(e) {
      return [e.read_shift(2), Kg(e)]
    }

    function LT(e) {
      var t = e.read_shift(2),
        i = e.read_shift(2);
      return {
        s: {
          c: e.read_shift(2),
          r: t
        },
        e: {
          c: e.read_shift(2),
          r: i
        }
      }
    }

    function _T(e, t) {
      return t || (t = ng(8)), t.write_shift(2, e.s.r), t.write_shift(2, e.e.r), t.write_shift(2, e.s.c), t.write_shift(2, e.e.c), t
    }

    function yT(e) {
      var t = e.read_shift(2),
        i = e.read_shift(2);
      return {
        s: {
          c: e.read_shift(1),
          r: t
        },
        e: {
          c: e.read_shift(1),
          r: i
        }
      }
    }
    var wT = yT;

    function DT(e) {
      e.l += 4;
      var t = e.read_shift(2),
        i = e.read_shift(2),
        r = e.read_shift(2);
      return e.l += 12, [i, t, r]
    }

    function PT(e) {
      e.l += 2, e.l += e.read_shift(2)
    }
    var bT = {
      0: PT,
      4: PT,
      5: PT,
      6: PT,
      7: function(e) {
        return e.l += 4, e.cf = e.read_shift(2), {}
      },
      8: PT,
      9: PT,
      10: PT,
      11: PT,
      12: PT,
      13: function(e) {
        var t = {};
        return e.l += 4, e.l += 16, t.fSharedNote = e.read_shift(2), e.l += 4, t
      },
      14: PT,
      15: PT,
      16: PT,
      17: PT,
      18: PT,
      19: PT,
      20: PT,
      21: DT
    };

    function MT(e, t) {
      var i = {
        BIFFVer: 0,
        dt: 0
      };
      switch (i.BIFFVer = e.read_shift(2), (t -= 2) >= 2 && (i.dt = e.read_shift(2), e.l -= 2), i.BIFFVer) {
        case 1536:
        case 1280:
        case 1024:
        case 768:
        case 512:
        case 2:
        case 7:
          break;
        default:
          if (t > 6) throw new Error("Unexpected BIFF Ver " + i.BIFFVer)
      }
      return e.read_shift(t), i
    }

    function FT(e, t, i) {
      var r = 1536,
        s = 16;
      switch (i.bookType) {
        case "biff8":
        case "xla":
          break;
        case "biff5":
          r = 1280, s = 8;
          break;
        case "biff4":
          r = 4, s = 6;
          break;
        case "biff3":
          r = 3, s = 6;
          break;
        case "biff2":
          r = 2, s = 4;
          break;
        default:
          throw new Error("unsupported BIFF version")
      }
      var n = ng(s);
      return n.write_shift(2, r), n.write_shift(2, t), s > 4 && n.write_shift(2, 29282), s > 6 && n.write_shift(2, 1997), s > 8 && (n.write_shift(2, 49161), n.write_shift(2, 1), n.write_shift(2, 1798), n.write_shift(2, 0)), n
    }

    function xT(e, t) {
      var i = !t || t.biff >= 8 ? 2 : 1,
        r = ng(8 + i * e.name.length);
      r.write_shift(4, e.pos), r.write_shift(1, e.hs || 0), r.write_shift(1, e.dt), r.write_shift(1, e.name.length), t.biff >= 8 && r.write_shift(1, 1), r.write_shift(i * e.name.length, e.name, t.biff < 8 ? "sbcs" : "utf16le");
      var s = r.slice(0, r.l);
      return s.l = r.l, s
    }

    function GT(e, t, i) {
      var r = 0;
      i && 2 == i.biff || (r = e.read_shift(2));
      var s = e.read_shift(2);
      return i && 2 == i.biff && (r = 1 - (s >> 15), s &= 32767), [{
        Unsynced: 1 & r,
        DyZero: (2 & r) >> 1,
        ExAsc: (4 & r) >> 2,
        ExDsc: (8 & r) >> 3
      }, s]
    }

    function UT(e, t, i, r) {
      var s = i && 5 == i.biff;
      r || (r = ng(s ? 3 + t.length : 5 + 2 * t.length)), r.write_shift(2, e), r.write_shift(s ? 1 : 2, t.length), s || r.write_shift(1, 1), r.write_shift((s ? 1 : 2) * t.length, t, s ? "sbcs" : "utf16le");
      var n = r.length > r.l ? r.slice(0, r.l) : r;
      return null == n.l && (n.l = n.length), n
    }
    var HT = gT;

    function kT(e, t, i) {
      var r = e.l + t,
        s = 8 != i.biff && i.biff ? 2 : 4,
        n = e.read_shift(s),
        o = e.read_shift(s),
        a = e.read_shift(2),
        l = e.read_shift(2);
      return e.l = r, {
        s: {
          r: n,
          c: a
        },
        e: {
          r: o,
          c: l
        }
      }
    }

    function BT(e, t, i, r) {
      var s = i && 5 == i.biff;
      r || (r = ng(s ? 16 : 20)), r.write_shift(2, 0), e.style ? (r.write_shift(2, e.numFmtId || 0), r.write_shift(2, 65524)) : (r.write_shift(2, e.numFmtId || 0), r.write_shift(2, t << 4));
      var n = 0;
      return e.numFmtId > 0 && s && (n |= 1024), r.write_shift(4, n), r.write_shift(4, 0), s || r.write_shift(4, 0), r.write_shift(2, 0), r
    }

    function VT(e, t, i) {
      var r = vT(e);
      2 != i.biff && 9 != t || ++e.l;
      var s = function(e) {
        var t = e.read_shift(1);
        return 1 === e.read_shift(1) ? t : 1 === t
      }(e);
      return r.val = s, r.t = !0 === s || !1 === s ? "b" : "e", r
    }
    var WT = function(e, t, i) {
      return 0 === t ? "" : gT(e, 0, i)
    };

    function YT(e, t, i) {
      var r, s = e.read_shift(2),
        n = {
          fBuiltIn: 1 & s,
          fWantAdvise: s >>> 1 & 1,
          fWantPict: s >>> 2 & 1,
          fOle: s >>> 3 & 1,
          fOleLink: s >>> 4 & 1,
          cf: s >>> 5 & 1023,
          fIcon: s >>> 15 & 1
        };
      return 14849 === i.sbcch && (r = function(e, t, i) {
        e.l += 4, t -= 4;
        var r = e.l + t,
          s = hT(e, 0, i),
          n = e.read_shift(2);
        if (n !== (r -= e.l)) throw new Error("Malformed AddinUdf: padding = " + r + " != " + n);
        return e.l += n, s
      }(e, t - 2, i)), n.body = r || e.read_shift(t - 2), "string" == typeof r && (n.Name = r), n
    }
    var KT = ["_xlnm.Consolidate_Area", "_xlnm.Auto_Open", "_xlnm.Auto_Close", "_xlnm.Extract", "_xlnm.Database", "_xlnm.Criteria", "_xlnm.Print_Area", "_xlnm.Print_Titles", "_xlnm.Recorder", "_xlnm.Data_Form", "_xlnm.Auto_Activate", "_xlnm.Auto_Deactivate", "_xlnm.Sheet_Title", "_xlnm._FilterDatabase"];

    function XT(e, t, i) {
      var r = e.l + t,
        s = e.read_shift(2),
        n = e.read_shift(1),
        o = e.read_shift(1),
        a = e.read_shift(i && 2 == i.biff ? 1 : 2),
        l = 0;
      (!i || i.biff >= 5) && (5 != i.biff && (e.l += 2), l = e.read_shift(2), 5 == i.biff && (e.l += 2), e.l += 4);
      var c = pT(e, o, i);
      32 & s && (c = KT[c.charCodeAt(0)]);
      var h = r - e.l;
      i && 2 == i.biff && --h;
      var u = r != e.l && 0 !== a && h > 0 ? function(e, t, i, r) {
        var s, n = e.l + t,
          o = uS(e, r, i);
        n !== e.l && (s = hS(e, n - e.l, o, i));
        return [o, s]
      }(e, h, i, a) : [];
      return {
        chKey: n,
        Name: c,
        itab: l,
        rgce: u
      }
    }

    function zT(e, t, i) {
      if (i.biff < 8) return function(e, t, i) {
        3 == e[e.l + 1] && e[e.l]++;
        var r = hT(e, 0, i);
        return 3 == r.charCodeAt(0) ? r.slice(1) : r
      }(e, 0, i);
      for (var r = [], s = e.l + t, n = e.read_shift(i.biff > 8 ? 4 : 2); 0 !== n--;) r.push(IT(e, i.biff, i));
      if (e.l != s) throw new Error("Bad ExternSheet: " + e.l + " != " + s);
      return r
    }

    function $T(e, t, i) {
      var r = wT(e, 6);
      switch (i.biff) {
        case 2:
          e.l++, t -= 7;
          break;
        case 3:
        case 4:
          e.l += 2, t -= 8;
          break;
        default:
          e.l += 6, t -= 12
      }
      return [r, TS(e, t, i)]
    }
    var jT = {
      8: function(e, t) {
        var i = e.l + t;
        e.l += 10;
        var r = e.read_shift(2);
        e.l += 4, e.l += 2, e.l += 2, e.l += 2, e.l += 4;
        var s = e.read_shift(1);
        return e.l += s, e.l = i, {
          fmt: r
        }
      }
    };

    function JT(e) {
      var t = ng(24),
        i = Tg(e[0]);
      t.write_shift(2, i.r), t.write_shift(2, i.r), t.write_shift(2, i.c), t.write_shift(2, i.c);
      for (var r = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), s = 0; s < 16; ++s) t.write_shift(1, parseInt(r[s], 16));
      return Zu([t, ST(e[1])])
    }

    function qT(e) {
      var t = e[1].Tooltip,
        i = ng(10 + 2 * (t.length + 1));
      i.write_shift(2, 2048);
      var r = Tg(e[0]);
      i.write_shift(2, r.r), i.write_shift(2, r.r), i.write_shift(2, r.c), i.write_shift(2, r.c);
      for (var s = 0; s < t.length; ++s) i.write_shift(2, t.charCodeAt(s));
      return i.write_shift(2, 0), i
    }

    function QT(e, t, i) {
      if (!i.cellStyles) return sg(e, t);
      var r = i && i.biff >= 12 ? 4 : 2,
        s = e.read_shift(r),
        n = e.read_shift(r),
        o = e.read_shift(r),
        a = e.read_shift(r),
        l = e.read_shift(2);
      2 == r && (e.l += 2);
      var c = {
        s,
        e: n,
        w: o,
        ixfe: a,
        flags: l
      };
      return (i.biff >= 5 || !i.biff) && (c.level = l >> 8 & 7), c
    }
    var ZT = vT,
      em = lT,
      tm = ET;
    var im = [2, 3, 48, 49, 131, 139, 140, 245],
      rm = function() {
        var e = {
            1: 437,
            2: 850,
            3: 1252,
            4: 1e4,
            100: 852,
            101: 866,
            102: 865,
            103: 861,
            104: 895,
            105: 620,
            106: 737,
            107: 857,
            120: 950,
            121: 949,
            122: 936,
            123: 932,
            124: 874,
            125: 1255,
            126: 1256,
            150: 10007,
            151: 10029,
            152: 10006,
            200: 1250,
            201: 1251,
            202: 1254,
            203: 1253,
            0: 20127,
            8: 865,
            9: 437,
            10: 850,
            11: 437,
            13: 437,
            14: 850,
            15: 437,
            16: 850,
            17: 437,
            18: 850,
            19: 932,
            20: 850,
            21: 437,
            22: 850,
            23: 865,
            24: 437,
            25: 437,
            26: 850,
            27: 437,
            28: 863,
            29: 850,
            31: 852,
            34: 852,
            35: 852,
            36: 860,
            37: 850,
            38: 866,
            55: 850,
            64: 852,
            77: 936,
            78: 949,
            79: 950,
            80: 874,
            87: 1252,
            88: 1252,
            89: 1252,
            108: 863,
            134: 737,
            135: 852,
            136: 857,
            204: 1257,
            255: 16969
          },
          t = sp({
            1: 437,
            2: 850,
            3: 1252,
            4: 1e4,
            100: 852,
            101: 866,
            102: 865,
            103: 861,
            104: 895,
            105: 620,
            106: 737,
            107: 857,
            120: 950,
            121: 949,
            122: 936,
            123: 932,
            124: 874,
            125: 1255,
            126: 1256,
            150: 10007,
            151: 10029,
            152: 10006,
            200: 1250,
            201: 1251,
            202: 1254,
            203: 1253,
            0: 20127
          });

        function i(t, i) {
          var r = i || {};
          r.dateNF || (r.dateNF = "yyyymmdd");
          var s = Og(function(t, i) {
            var r = [],
              s = zu(1);
            switch (i.type) {
              case "base64":
                s = ju(Yu(t));
                break;
              case "binary":
                s = ju(t);
                break;
              case "buffer":
              case "array":
                s = t
            }
            rg(s, 0);
            var n = s.read_shift(1),
              o = !!(136 & n),
              a = !1,
              l = !1;
            switch (n) {
              case 2:
              case 3:
              case 131:
              case 139:
              case 245:
                break;
              case 48:
              case 49:
                a = !0, o = !0;
                break;
              case 140:
                l = !0;
                break;
              default:
                throw new Error("DBF Unsupported Version: " + n.toString(16))
            }
            var c = 0,
              h = 521;
            2 == n && (c = s.read_shift(2)), s.l += 3, 2 != n && (c = s.read_shift(4)), c > 1048576 && (c = 1e6), 2 != n && (h = s.read_shift(2));
            var u = s.read_shift(2),
              d = i.codepage || 1252;
            2 != n && (s.l += 16, s.read_shift(1), 0 !== s[s.l] && (d = e[s[s.l]]), s.l += 1, s.l += 2), l && (s.l += 36);
            for (var p = [], E = {}, g = Math.min(s.length, 2 == n ? 521 : h - 10 - (a ? 264 : 0)), f = l ? 32 : 11; s.l < g && 13 != s[s.l];) switch ((E = {}).name = xu.utils.decode(d, s.slice(s.l, s.l + f)).replace(/[\u0000\r\n].*$/g, ""), s.l += f, E.type = String.fromCharCode(s.read_shift(1)), 2 == n || l || (E.offset = s.read_shift(4)), E.len = s.read_shift(1), 2 == n && (E.offset = s.read_shift(2)), E.dec = s.read_shift(1), E.name.length && p.push(E), 2 != n && (s.l += l ? 13 : 14), E.type) {
              case "B":
                a && 8 == E.len || !i.WTF || console.log("Skipping " + E.name + ":" + E.type);
                break;
              case "G":
              case "P":
                i.WTF && console.log("Skipping " + E.name + ":" + E.type);
                break;
              case "+":
              case "0":
              case "@":
              case "C":
              case "D":
              case "F":
              case "I":
              case "L":
              case "M":
              case "N":
              case "O":
              case "T":
              case "Y":
                break;
              default:
                throw new Error("Unknown Field Type: " + E.type)
            }
            if (13 !== s[s.l] && (s.l = h - 1), 13 !== s.read_shift(1)) throw new Error("DBF Terminator not found " + s.l + " " + s[s.l]);
            s.l = h;
            var T = 0,
              m = 0;
            for (r[0] = [], m = 0; m != p.length; ++m) r[0][m] = p[m].name;
            for (; c-- > 0;)
              if (42 !== s[s.l])
                for (++s.l, r[++T] = [], m = 0, m = 0; m != p.length; ++m) {
                  var C = s.slice(s.l, s.l + p[m].len);
                  s.l += p[m].len, rg(C, 0);
                  var S = xu.utils.decode(d, C);
                  switch (p[m].type) {
                    case "C":
                      S.trim().length && (r[T][m] = S.replace(/\s+$/, ""));
                      break;
                    case "D":
                      8 === S.length ? r[T][m] = new Date(+S.slice(0, 4), +S.slice(4, 6) - 1, +S.slice(6, 8)) : r[T][m] = S;
                      break;
                    case "F":
                      r[T][m] = parseFloat(S.trim());
                      break;
                    case "+":
                    case "I":
                      r[T][m] = l ? 2147483648 ^ C.read_shift(-4, "i") : C.read_shift(4, "i");
                      break;
                    case "L":
                      switch (S.trim().toUpperCase()) {
                        case "Y":
                        case "T":
                          r[T][m] = !0;
                          break;
                        case "N":
                        case "F":
                          r[T][m] = !1;
                          break;
                        case "":
                        case "?":
                          break;
                        default:
                          throw new Error("DBF Unrecognized L:|" + S + "|")
                      }
                      break;
                    case "M":
                      if (!o) throw new Error("DBF Unexpected MEMO for type " + n.toString(16));
                      r[T][m] = "##MEMO##" + (l ? parseInt(S.trim(), 10) : C.read_shift(4));
                      break;
                    case "N":
                      (S = S.replace(/\u0000/g, "").trim()) && "." != S && (r[T][m] = +S || 0);
                      break;
                    case "@":
                      r[T][m] = new Date(C.read_shift(-8, "f") - 621356832e5);
                      break;
                    case "T":
                      r[T][m] = new Date(864e5 * (C.read_shift(4) - 2440588) + C.read_shift(4));
                      break;
                    case "Y":
                      r[T][m] = C.read_shift(4, "i") / 1e4 + C.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
                      break;
                    case "O":
                      r[T][m] = -C.read_shift(-8, "f");
                      break;
                    case "B":
                      if (a && 8 == p[m].len) {
                        r[T][m] = C.read_shift(8, "f");
                        break
                      }
                      case "G":
                      case "P":
                        C.l += p[m].len;
                        break;
                      case "0":
                        if ("_NullFlags" === p[m].name) break;
                      default:
                        throw new Error("DBF Unsupported data type " + p[m].type)
                  }
                } else s.l += u;
            if (2 != n && s.l < s.length && 26 != s[s.l++]) throw new Error("DBF EOF Marker missing " + (s.l - 1) + " of " + s.length + " " + s[s.l - 1].toString(16));
            return i && i.sheetRows && (r = r.slice(0, i.sheetRows)), i.DBF = p, r
          }(t, r), r);
          return s["!cols"] = r.DBF.map(function(e) {
            return {
              wch: e.len,
              DBF: e
            }
          }), delete r.DBF, s
        }
        var r = {
          B: 8,
          C: 250,
          L: 1,
          D: 8,
          "?": 0,
          "": 0
        };
        return {
          to_workbook: function(e, t) {
            try {
              return Ng(i(e, t), t)
            } catch (e) {
              if (t && t.WTF) throw e
            }
            return {
              SheetNames: [],
              Sheets: {}
            }
          },
          to_sheet: i,
          from_sheet: function(e, i) {
            var s = i || {};
            if (+s.codepage >= 0 && Pu(+s.codepage), "string" == s.type) throw new Error("Cannot write DBF to JS string");
            var n = ag(),
              o = Jv(e, {
                header: 1,
                raw: !0,
                cellDates: !0
              }),
              a = o[0],
              l = o.slice(1),
              c = e["!cols"] || [],
              h = 0,
              u = 0,
              d = 0,
              p = 1;
            for (h = 0; h < a.length; ++h)
              if (((c[h] || {}).DBF || {}).name) a[h] = c[h].DBF.name, ++d;
              else if (null != a[h]) {
              if (++d, "number" == typeof a[h] && (a[h] = a[h].toString(10)), "string" != typeof a[h]) throw new Error("DBF Invalid column name " + a[h] + " |" + typeof a[h] + "|");
              if (a.indexOf(a[h]) !== h)
                for (u = 0; u < 1024; ++u)
                  if (-1 == a.indexOf(a[h] + "_" + u)) {
                    a[h] += "_" + u;
                    break
                  }
            }
            var E = Rg(e["!ref"]),
              g = [],
              f = [],
              T = [];
            for (h = 0; h <= E.e.c - E.s.c; ++h) {
              var m = "",
                C = "",
                S = 0,
                R = [];
              for (u = 0; u < l.length; ++u) null != l[u][h] && R.push(l[u][h]);
              if (0 != R.length && null != a[h]) {
                for (u = 0; u < R.length; ++u) {
                  switch (typeof R[u]) {
                    case "number":
                      C = "B";
                      break;
                    case "string":
                    default:
                      C = "C";
                      break;
                    case "boolean":
                      C = "L";
                      break;
                    case "object":
                      C = R[u] instanceof Date ? "D" : "C"
                  }
                  S = Math.max(S, String(R[u]).length), m = m && m != C ? "C" : C
                }
                S > 250 && (S = 250), "C" == (C = ((c[h] || {}).DBF || {}).type) && c[h].DBF.len > S && (S = c[h].DBF.len), "B" == m && "N" == C && (m = "N", T[h] = c[h].DBF.dec, S = c[h].DBF.len), f[h] = "C" == m || "N" == C ? S : r[m] || 0, p += f[h], g[h] = m
              } else g[h] = "?"
            }
            var A = n.next(32);
            for (A.write_shift(4, 318902576), A.write_shift(4, l.length), A.write_shift(2, 296 + 32 * d), A.write_shift(2, p), h = 0; h < 4; ++h) A.write_shift(4, 0);
            for (A.write_shift(4, (+t[_u] || 3) << 8), h = 0, u = 0; h < a.length; ++h)
              if (null != a[h]) {
                var v = n.next(32),
                  N = (a[h].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
                v.write_shift(1, N, "sbcs"), v.write_shift(1, "?" == g[h] ? "C" : g[h], "sbcs"), v.write_shift(4, u), v.write_shift(1, f[h] || r[g[h]] || 0), v.write_shift(1, T[h] || 0), v.write_shift(1, 2), v.write_shift(4, 0), v.write_shift(1, 0), v.write_shift(4, 0), v.write_shift(4, 0), u += f[h] || r[g[h]] || 0
              } var I = n.next(264);
            for (I.write_shift(4, 13), h = 0; h < 65; ++h) I.write_shift(4, 0);
            for (h = 0; h < l.length; ++h) {
              var O = n.next(p);
              for (O.write_shift(1, 0), u = 0; u < a.length; ++u)
                if (null != a[u]) switch (g[u]) {
                  case "L":
                    O.write_shift(1, null == l[h][u] ? 63 : l[h][u] ? 84 : 70);
                    break;
                  case "B":
                    O.write_shift(8, l[h][u] || 0, "f");
                    break;
                  case "N":
                    var L = "0";
                    for ("number" == typeof l[h][u] && (L = l[h][u].toFixed(T[u] || 0)), d = 0; d < f[u] - L.length; ++d) O.write_shift(1, 32);
                    O.write_shift(1, L, "sbcs");
                    break;
                  case "D":
                    l[h][u] ? (O.write_shift(4, ("0000" + l[h][u].getFullYear()).slice(-4), "sbcs"), O.write_shift(2, ("00" + (l[h][u].getMonth() + 1)).slice(-2), "sbcs"), O.write_shift(2, ("00" + l[h][u].getDate()).slice(-2), "sbcs")) : O.write_shift(8, "00000000", "sbcs");
                    break;
                  case "C":
                    var _ = String(null != l[h][u] ? l[h][u] : "").slice(0, f[u]);
                    for (O.write_shift(1, _, "sbcs"), d = 0; d < f[u] - _.length; ++d) O.write_shift(1, 32)
                }
            }
            return n.next(1).write_shift(1, 26), n.end()
          }
        }
      }(),
      sm = function() {
        var e = {
            AA: "À",
            BA: "Á",
            CA: "Â",
            DA: 195,
            HA: "Ä",
            JA: 197,
            AE: "È",
            BE: "É",
            CE: "Ê",
            HE: "Ë",
            AI: "Ì",
            BI: "Í",
            CI: "Î",
            HI: "Ï",
            AO: "Ò",
            BO: "Ó",
            CO: "Ô",
            DO: 213,
            HO: "Ö",
            AU: "Ù",
            BU: "Ú",
            CU: "Û",
            HU: "Ü",
            Aa: "à",
            Ba: "á",
            Ca: "â",
            Da: 227,
            Ha: "ä",
            Ja: 229,
            Ae: "è",
            Be: "é",
            Ce: "ê",
            He: "ë",
            Ai: "ì",
            Bi: "í",
            Ci: "î",
            Hi: "ï",
            Ao: "ò",
            Bo: "ó",
            Co: "ô",
            Do: 245,
            Ho: "ö",
            Au: "ù",
            Bu: "ú",
            Cu: "û",
            Hu: "ü",
            KC: "Ç",
            Kc: "ç",
            q: "æ",
            z: "œ",
            a: "Æ",
            j: "Œ",
            DN: 209,
            Dn: 241,
            Hy: 255,
            S: 169,
            c: 170,
            R: 174,
            "B ": 180,
            0: 176,
            1: 177,
            2: 178,
            3: 179,
            5: 181,
            6: 182,
            7: 183,
            Q: 185,
            k: 186,
            b: 208,
            i: 216,
            l: 222,
            s: 240,
            y: 248,
            "!": 161,
            '"': 162,
            "#": 163,
            "(": 164,
            "%": 165,
            "'": 167,
            "H ": 168,
            "+": 171,
            ";": 187,
            "<": 188,
            "=": 189,
            ">": 190,
            "?": 191,
            "{": 223
          },
          t = new RegExp("N(" + ip(e).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm"),
          i = function(t, i) {
            var r = e[i];
            return "number" == typeof r ? Hu(r) : r
          },
          r = function(e, t, i) {
            var r = t.charCodeAt(0) - 32 << 4 | i.charCodeAt(0) - 48;
            return 59 == r ? e : Hu(r)
          };

        function s(e, s) {
          var n, o = e.split(/[\n\r]+/),
            a = -1,
            l = -1,
            c = 0,
            h = 0,
            u = [],
            d = [],
            p = null,
            E = {},
            g = [],
            f = [],
            T = [],
            m = 0;
          for (+s.codepage >= 0 && Pu(+s.codepage); c !== o.length; ++c) {
            m = 0;
            var C, S = o[c].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, r).replace(t, i),
              R = S.replace(/;;/g, "\0").split(";").map(function(e) {
                return e.replace(/\u0000/g, ";")
              }),
              A = R[0];
            if (S.length > 0) switch (A) {
              case "ID":
              case "E":
              case "B":
              case "O":
              case "W":
                break;
              case "P":
                "P" == R[1].charAt(0) && d.push(S.slice(3).replace(/;;/g, ";"));
                break;
              case "C":
                var v = !1,
                  N = !1,
                  I = !1,
                  O = !1,
                  L = -1,
                  _ = -1;
                for (h = 1; h < R.length; ++h) switch (R[h].charAt(0)) {
                  case "A":
                  case "G":
                    break;
                  case "X":
                    l = parseInt(R[h].slice(1)) - 1, N = !0;
                    break;
                  case "Y":
                    for (a = parseInt(R[h].slice(1)) - 1, N || (l = 0), n = u.length; n <= a; ++n) u[n] = [];
                    break;
                  case "K":
                    '"' === (C = R[h].slice(1)).charAt(0) ? C = C.slice(1, C.length - 1) : "TRUE" === C ? C = !0 : "FALSE" === C ? C = !1 : isNaN(Sp(C)) ? isNaN(Ap(C).getDate()) || (C = fp(C)) : (C = Sp(C), null !== p && Hd(p) && (C = up(C))), void 0 !== xu && "string" == typeof C && "string" != (s || {}).type && (s || {}).codepage && (C = xu.utils.decode(s.codepage, C)), v = !0;
                    break;
                  case "E":
                    O = !0;
                    var y = HC(R[h].slice(1), {
                      r: a,
                      c: l
                    });
                    u[a][l] = [u[a][l], y];
                    break;
                  case "S":
                    I = !0, u[a][l] = [u[a][l], "S5S"];
                    break;
                  case "R":
                    L = parseInt(R[h].slice(1)) - 1;
                    break;
                  case "C":
                    _ = parseInt(R[h].slice(1)) - 1;
                    break;
                  default:
                    if (s && s.WTF) throw new Error("SYLK bad record " + S)
                }
                if (v && (u[a][l] && 2 == u[a][l].length ? u[a][l][0] = C : u[a][l] = C, p = null), I) {
                  if (O) throw new Error("SYLK shared formula cannot have own formula");
                  var w = L > -1 && u[L][_];
                  if (!w || !w[1]) throw new Error("SYLK shared formula cannot find base");
                  u[a][l][1] = VC(w[1], {
                    r: a - L,
                    c: l - _
                  })
                }
                break;
              case "F":
                var D = 0;
                for (h = 1; h < R.length; ++h) switch (R[h].charAt(0)) {
                  case "X":
                    l = parseInt(R[h].slice(1)) - 1, ++D;
                    break;
                  case "Y":
                    for (a = parseInt(R[h].slice(1)) - 1, n = u.length; n <= a; ++n) u[n] = [];
                    break;
                  case "M":
                    m = parseInt(R[h].slice(1)) / 20;
                    break;
                  case "F":
                  case "G":
                  case "S":
                  case "D":
                  case "N":
                    break;
                  case "P":
                    p = d[parseInt(R[h].slice(1))];
                    break;
                  case "W":
                    for (T = R[h].slice(1).split(" "), n = parseInt(T[0], 10); n <= parseInt(T[1], 10); ++n) m = parseInt(T[2], 10), f[n - 1] = 0 === m ? {
                      hidden: !0
                    } : {
                      wch: m
                    }, zm(f[n - 1]);
                    break;
                  case "C":
                    f[l = parseInt(R[h].slice(1)) - 1] || (f[l] = {});
                    break;
                  case "R":
                    g[a = parseInt(R[h].slice(1)) - 1] || (g[a] = {}), m > 0 ? (g[a].hpt = m, g[a].hpx = Jm(m)) : 0 === m && (g[a].hidden = !0);
                    break;
                  default:
                    if (s && s.WTF) throw new Error("SYLK bad record " + S)
                }
                D < 1 && (p = null);
                break;
              default:
                if (s && s.WTF) throw new Error("SYLK bad record " + S)
            }
          }
          return g.length > 0 && (E["!rows"] = g), f.length > 0 && (E["!cols"] = f), s && s.sheetRows && (u = u.slice(0, s.sheetRows)), [u, E]
        }

        function n(e, t) {
          var i = function(e, t) {
              switch (t.type) {
                case "base64":
                  return s(Yu(e), t);
                case "binary":
                  return s(e, t);
                case "buffer":
                  return s(Ku && Buffer.isBuffer(e) ? e.toString("binary") : qu(e), t);
                case "array":
                  return s(Tp(e), t)
              }
              throw new Error("Unrecognized type " + t.type)
            }(e, t),
            r = i[0],
            n = i[1],
            o = Og(r, t);
          return ip(n).forEach(function(e) {
            o[e] = n[e]
          }), o
        }

        function o(e, t, i, r) {
          var s = "C;Y" + (i + 1) + ";X" + (r + 1) + ";K";
          switch (e.t) {
            case "n":
              s += e.v || 0, e.f && !e.F && (s += ";E" + BC(e.f, {
                r: i,
                c: r
              }));
              break;
            case "b":
              s += e.v ? "TRUE" : "FALSE";
              break;
            case "e":
              s += e.w || e.v;
              break;
            case "d":
              s += '"' + (e.w || e.v) + '"';
              break;
            case "s":
              s += '"' + e.v.replace(/"/g, "").replace(/;/g, ";;") + '"'
          }
          return s
        }
        return e["|"] = 254, {
          to_workbook: function(e, t) {
            return Ng(n(e, t), t)
          },
          to_sheet: n,
          from_sheet: function(e, t) {
            var i, r, s = ["ID;PWXL;N;E"],
              n = [],
              a = Rg(e["!ref"]),
              l = Array.isArray(e),
              c = "\r\n";
            s.push("P;PGeneral"), s.push("F;P0;DG0G8;M255"), e["!cols"] && (r = s, e["!cols"].forEach(function(e, t) {
              var i = "F;W" + (t + 1) + " " + (t + 1) + " ";
              e.hidden ? i += "0" : ("number" != typeof e.width || e.wpx || (e.wpx = Vm(e.width)), "number" != typeof e.wpx || e.wch || (e.wch = Wm(e.wpx)), "number" == typeof e.wch && (i += Math.round(e.wch))), " " != i.charAt(i.length - 1) && r.push(i)
            })), e["!rows"] && function(e, t) {
              t.forEach(function(t, i) {
                var r = "F;";
                t.hidden ? r += "M0;" : t.hpt ? r += "M" + 20 * t.hpt + ";" : t.hpx && (r += "M" + 20 * jm(t.hpx) + ";"), r.length > 2 && e.push(r + "R" + (i + 1))
              })
            }(s, e["!rows"]), s.push("B;Y" + (a.e.r - a.s.r + 1) + ";X" + (a.e.c - a.s.c + 1) + ";D" + [a.s.c, a.s.r, a.e.c, a.e.r].join(" "));
            for (var h = a.s.r; h <= a.e.r; ++h)
              for (var u = a.s.c; u <= a.e.c; ++u) {
                var d = mg({
                  r: h,
                  c: u
                });
                (i = l ? (e[h] || [])[u] : e[d]) && (null != i.v || i.f && !i.F) && n.push(o(i, 0, h, u))
              }
            return s.join(c) + c + n.join(c) + c + "E" + c
          }
        }
      }(),
      nm = function() {
        function e(e, t) {
          for (var i = e.split("\n"), r = -1, s = -1, n = 0, o = []; n !== i.length; ++n)
            if ("BOT" !== i[n].trim()) {
              if (!(r < 0)) {
                for (var a = i[n].trim().split(","), l = a[0], c = a[1], h = i[++n] || ""; 1 & (h.match(/["]/g) || []).length && n < i.length - 1;) h += "\n" + i[++n];
                switch (h = h.trim(), +l) {
                  case -1:
                    if ("BOT" === h) {
                      o[++r] = [], s = 0;
                      continue
                    }
                    if ("EOD" !== h) throw new Error("Unrecognized DIF special command " + h);
                    break;
                  case 0:
                    "TRUE" === h ? o[r][s] = !0 : "FALSE" === h ? o[r][s] = !1 : isNaN(Sp(c)) ? isNaN(Ap(c).getDate()) ? o[r][s] = c : o[r][s] = fp(c) : o[r][s] = Sp(c), ++s;
                    break;
                  case 1:
                    (h = (h = h.slice(1, h.length - 1)).replace(/""/g, '"')) && h.match(/^=".*"$/) && (h = h.slice(2, -1)), o[r][s++] = "" !== h ? h : null
                }
                if ("EOD" === h) break
              }
            } else o[++r] = [], s = 0;
          return t && t.sheetRows && (o = o.slice(0, t.sheetRows)), o
        }

        function t(t, i) {
          return Og(function(t, i) {
            switch (i.type) {
              case "base64":
                return e(Yu(t), i);
              case "binary":
                return e(t, i);
              case "buffer":
                return e(Ku && Buffer.isBuffer(t) ? t.toString("binary") : qu(t), i);
              case "array":
                return e(Tp(t), i)
            }
            throw new Error("Unrecognized type " + i.type)
          }(t, i), i)
        }
        return {
          to_workbook: function(e, i) {
            return Ng(t(e, i), i)
          },
          to_sheet: t,
          from_sheet: function() {
            var e = function(e, t, i, r, s) {
                e.push(t), e.push(i + "," + r), e.push('"' + s.replace(/"/g, '""') + '"')
              },
              t = function(e, t, i, r) {
                e.push(t + "," + i), e.push(1 == t ? '"' + r.replace(/"/g, '""') + '"' : r)
              };
            return function(i) {
              var r, s = [],
                n = Rg(i["!ref"]),
                o = Array.isArray(i);
              e(s, "TABLE", 0, 1, "sheetjs"), e(s, "VECTORS", 0, n.e.r - n.s.r + 1, ""), e(s, "TUPLES", 0, n.e.c - n.s.c + 1, ""), e(s, "DATA", 0, 0, "");
              for (var a = n.s.r; a <= n.e.r; ++a) {
                t(s, -1, 0, "BOT");
                for (var l = n.s.c; l <= n.e.c; ++l) {
                  var c = mg({
                    r: a,
                    c: l
                  });
                  if (r = o ? (i[a] || [])[l] : i[c]) switch (r.t) {
                    case "n":
                      var h = r.w;
                      h || null == r.v || (h = r.v), null == h ? r.f && !r.F ? t(s, 1, 0, "=" + r.f) : t(s, 1, 0, "") : t(s, 0, h, "V");
                      break;
                    case "b":
                      t(s, 0, r.v ? 1 : 0, r.v ? "TRUE" : "FALSE");
                      break;
                    case "s":
                      t(s, 1, 0, isNaN(r.v) ? r.v : '="' + r.v + '"');
                      break;
                    case "d":
                      r.w || (r.w = Wd(r.z || ud[14], ap(fp(r.v)))), t(s, 0, r.w, "V");
                      break;
                    default:
                      t(s, 1, 0, "")
                  } else t(s, 1, 0, "")
                }
              }
              t(s, -1, 0, "EOD");
              return s.join("\r\n")
            }
          }()
        }
      }(),
      om = function() {
        function e(e) {
          return e.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n")
        }

        function t(e) {
          return e.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n")
        }

        function i(t, i) {
          return Og(function(t, i) {
            for (var r = t.split("\n"), s = -1, n = -1, o = 0, a = []; o !== r.length; ++o) {
              var l = r[o].trim().split(":");
              if ("cell" === l[0]) {
                var c = Tg(l[1]);
                if (a.length <= c.r)
                  for (s = a.length; s <= c.r; ++s) a[s] || (a[s] = []);
                switch (s = c.r, n = c.c, l[2]) {
                  case "t":
                    a[s][n] = e(l[3]);
                    break;
                  case "v":
                    a[s][n] = +l[3];
                    break;
                  case "vtf":
                    var h = l[l.length - 1];
                  case "vtc":
                    "nl" === l[3] ? a[s][n] = !!+l[4] : a[s][n] = +l[4], "vtf" == l[2] && (a[s][n] = [a[s][n], h])
                }
              }
            }
            return i && i.sheetRows && (a = a.slice(0, i.sheetRows)), a
          }(t, i), i)
        }
        var r = ["socialcalc:version:1.5", "MIME-Version: 1.0", "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"].join("\n"),
          s = ["--SocialCalcSpreadsheetControlSave", "Content-type: text/plain; charset=UTF-8"].join("\n") + "\n",
          n = ["# SocialCalc Spreadsheet Control Save", "part:sheet"].join("\n"),
          o = "--SocialCalcSpreadsheetControlSave--";

        function a(e) {
          if (!e || !e["!ref"]) return "";
          for (var i, r = [], s = [], n = "", o = Cg(e["!ref"]), a = Array.isArray(e), l = o.s.r; l <= o.e.r; ++l)
            for (var c = o.s.c; c <= o.e.c; ++c)
              if (n = mg({
                  r: l,
                  c
                }), (i = a ? (e[l] || [])[c] : e[n]) && null != i.v && "z" !== i.t) {
                switch (s = ["cell", n, "t"], i.t) {
                  case "s":
                  case "str":
                    s.push(t(i.v));
                    break;
                  case "n":
                    i.f ? (s[2] = "vtf", s[3] = "n", s[4] = i.v, s[5] = t(i.f)) : (s[2] = "v", s[3] = i.v);
                    break;
                  case "b":
                    s[2] = "vt" + (i.f ? "f" : "c"), s[3] = "nl", s[4] = i.v ? "1" : "0", s[5] = t(i.f || (i.v ? "TRUE" : "FALSE"));
                    break;
                  case "d":
                    var h = ap(fp(i.v));
                    s[2] = "vtc", s[3] = "nd", s[4] = "" + h, s[5] = i.w || Wd(i.z || ud[14], h);
                    break;
                  case "e":
                    continue
                }
                r.push(s.join(":"))
              } return r.push("sheet:c:" + (o.e.c - o.s.c + 1) + ":r:" + (o.e.r - o.s.r + 1) + ":tvf:1"), r.push("valueformat:1:text-wiki"), r.join("\n")
        }
        return {
          to_workbook: function(e, t) {
            return Ng(i(e, t), t)
          },
          to_sheet: i,
          from_sheet: function(e) {
            return [r, s, n, s, a(e), o].join("\n")
          }
        }
      }(),
      am = function() {
        function e(e, t, i, r, s) {
          s.raw ? t[i][r] = e : "" === e || ("TRUE" === e ? t[i][r] = !0 : "FALSE" === e ? t[i][r] = !1 : isNaN(Sp(e)) ? isNaN(Ap(e).getDate()) ? t[i][r] = e : t[i][r] = fp(e) : t[i][r] = Sp(e))
        }
        var t = {
            44: ",",
            9: "\t",
            59: ";",
            124: "|"
          },
          i = {
            44: 3,
            9: 2,
            59: 1,
            124: 0
          };

        function r(e) {
          for (var r = {}, s = !1, n = 0, o = 0; n < e.length; ++n) 34 == (o = e.charCodeAt(n)) ? s = !s : !s && o in t && (r[o] = (r[o] || 0) + 1);
          for (n in o = [], r) Object.prototype.hasOwnProperty.call(r, n) && o.push([r[n], n]);
          if (!o.length)
            for (n in r = i) Object.prototype.hasOwnProperty.call(r, n) && o.push([r[n], n]);
          return o.sort(function(e, t) {
            return e[0] - t[0] || i[e[1]] - i[t[1]]
          }), t[o.pop()[1]] || 44
        }

        function s(e, t) {
          var i = t || {},
            s = "";
          null != Bu && null == i.dense && (i.dense = Bu);
          var n = i.dense ? [] : {},
            o = {
              s: {
                c: 0,
                r: 0
              },
              e: {
                c: 0,
                r: 0
              }
            };
          "sep=" == e.slice(0, 4) ? 13 == e.charCodeAt(5) && 10 == e.charCodeAt(6) ? (s = e.charAt(4), e = e.slice(7)) : 13 == e.charCodeAt(5) || 10 == e.charCodeAt(5) ? (s = e.charAt(4), e = e.slice(6)) : s = r(e.slice(0, 1024)) : s = i && i.FS ? i.FS : r(e.slice(0, 1024));
          var a = 0,
            l = 0,
            c = 0,
            h = 0,
            u = 0,
            d = s.charCodeAt(0),
            p = !1,
            E = 0,
            g = e.charCodeAt(0);
          e = e.replace(/\r\n/gm, "\n");
          var f, T, m = null != i.dateNF ? (f = i.dateNF, T = (T = "number" == typeof f ? ud[f] : f).replace(jd, "(\\d+)"), new RegExp("^" + T + "$")) : null;

          function C() {
            var t = e.slice(h, u),
              r = {};
            if ('"' == t.charAt(0) && '"' == t.charAt(t.length - 1) && (t = t.slice(1, -1).replace(/""/g, '"')), 0 === t.length) r.t = "z";
            else if (i.raw) r.t = "s", r.v = t;
            else if (0 === t.trim().length) r.t = "s", r.v = t;
            else if (61 == t.charCodeAt(0)) 34 == t.charCodeAt(1) && 34 == t.charCodeAt(t.length - 1) ? (r.t = "s", r.v = t.slice(2, -1).replace(/""/g, '"')) : 1 != t.length ? (r.t = "n", r.f = t.slice(1)) : (r.t = "s", r.v = t);
            else if ("TRUE" == t) r.t = "b", r.v = !0;
            else if ("FALSE" == t) r.t = "b", r.v = !1;
            else if (isNaN(c = Sp(t)))
              if (!isNaN(Ap(t).getDate()) || m && t.match(m)) {
                r.z = i.dateNF || ud[14];
                var s = 0;
                m && t.match(m) && (t = function(e, t, i) {
                  var r = -1,
                    s = -1,
                    n = -1,
                    o = -1,
                    a = -1,
                    l = -1;
                  (t.match(jd) || []).forEach(function(e, t) {
                    var c = parseInt(i[t + 1], 10);
                    switch (e.toLowerCase().charAt(0)) {
                      case "y":
                        r = c;
                        break;
                      case "d":
                        n = c;
                        break;
                      case "h":
                        o = c;
                        break;
                      case "s":
                        l = c;
                        break;
                      case "m":
                        o >= 0 ? a = c : s = c
                    }
                  }), l >= 0 && -1 == a && s >= 0 && (a = s, s = -1);
                  var c = ("" + (r >= 0 ? r : (new Date).getFullYear())).slice(-4) + "-" + ("00" + (s >= 1 ? s : 1)).slice(-2) + "-" + ("00" + (n >= 1 ? n : 1)).slice(-2);
                  7 == c.length && (c = "0" + c), 8 == c.length && (c = "20" + c);
                  var h = ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (a >= 0 ? a : 0)).slice(-2) + ":" + ("00" + (l >= 0 ? l : 0)).slice(-2);
                  return -1 == o && -1 == a && -1 == l ? c : -1 == r && -1 == s && -1 == n ? h : c + "T" + h
                }(0, i.dateNF, t.match(m) || []), s = 1), i.cellDates ? (r.t = "d", r.v = fp(t, s)) : (r.t = "n", r.v = ap(fp(t, s))), !1 !== i.cellText && (r.w = Wd(r.z, r.v instanceof Date ? ap(r.v) : r.v)), i.cellNF || delete r.z
              } else r.t = "s", r.v = t;
            else r.t = "n", !1 !== i.cellText && (r.w = t), r.v = c;
            if ("z" == r.t || (i.dense ? (n[a] || (n[a] = []), n[a][l] = r) : n[mg({
                c: l,
                r: a
              })] = r), h = u + 1, g = e.charCodeAt(h), o.e.c < l && (o.e.c = l), o.e.r < a && (o.e.r = a), E == d) ++l;
            else if (l = 0, ++a, i.sheetRows && i.sheetRows <= a) return !0
          }
          e: for (; u < e.length; ++u) switch (E = e.charCodeAt(u)) {
            case 34:
              34 === g && (p = !p);
              break;
            case d:
            case 10:
            case 13:
              if (!p && C()) break e
          }
          return u - h > 0 && C(), n["!ref"] = Sg(o), n
        }

        function n(t, i) {
          return i && i.PRN ? i.FS || "sep=" == t.slice(0, 4) || t.indexOf("\t") >= 0 || t.indexOf(",") >= 0 || t.indexOf(";") >= 0 ? s(t, i) : Og(function(t, i) {
            var r = i || {},
              s = [];
            if (!t || 0 === t.length) return s;
            for (var n = t.split(/[\r\n]/), o = n.length - 1; o >= 0 && 0 === n[o].length;) --o;
            for (var a = 10, l = 0, c = 0; c <= o; ++c) - 1 == (l = n[c].indexOf(" ")) ? l = n[c].length : l++, a = Math.max(a, l);
            for (c = 0; c <= o; ++c) {
              s[c] = [];
              var h = 0;
              for (e(n[c].slice(0, a).trim(), s, c, h, r), h = 1; h <= (n[c].length - a) / 10 + 1; ++h) e(n[c].slice(a + 10 * (h - 1), a + 10 * h).trim(), s, c, h, r)
            }
            return r.sheetRows && (s = s.slice(0, r.sheetRows)), s
          }(t, i), i) : s(t, i)
        }

        function o(e, t) {
          var i = "",
            r = "string" == t.type ? [0, 0, 0, 0] : Mv(e, t);
          switch (t.type) {
            case "base64":
              i = Yu(e);
              break;
            case "binary":
            case "string":
              i = e;
              break;
            case "buffer":
              i = 65001 == t.codepage ? e.toString("utf8") : t.codepage && void 0 !== xu ? xu.utils.decode(t.codepage, e) : Ku && Buffer.isBuffer(e) ? e.toString("binary") : qu(e);
              break;
            case "array":
              i = Tp(e);
              break;
            default:
              throw new Error("Unrecognized type " + t.type)
          }
          return 239 == r[0] && 187 == r[1] && 191 == r[2] ? i = nE(i.slice(3)) : "string" != t.type && "buffer" != t.type && 65001 == t.codepage ? i = nE(i) : "binary" == t.type && void 0 !== xu && t.codepage && (i = xu.utils.decode(t.codepage, xu.utils.encode(28591, i))), "socialcalc:version:" == i.slice(0, 19) ? om.to_sheet("string" == t.type ? i : nE(i), t) : n(i, t)
        }
        return {
          to_workbook: function(e, t) {
            return Ng(o(e, t), t)
          },
          to_sheet: o,
          from_sheet: function(e) {
            for (var t, i = [], r = Rg(e["!ref"]), s = Array.isArray(e), n = r.s.r; n <= r.e.r; ++n) {
              for (var o = [], a = r.s.c; a <= r.e.c; ++a) {
                var l = mg({
                  r: n,
                  c: a
                });
                if ((t = s ? (e[n] || [])[a] : e[l]) && null != t.v) {
                  for (var c = (t.w || (vg(t), t.w) || "").slice(0, 10); c.length < 10;) c += " ";
                  o.push(c + (0 === a ? " " : ""))
                } else o.push("          ")
              }
              i.push(o.join(""))
            }
            return i.join("\n")
          }
        }
      }();
    var lm = function() {
      function e(e, t, i) {
        if (e) {
          rg(e, e.l || 0);
          for (var r = i.Enum || T; e.l < e.length;) {
            var s = e.read_shift(2),
              n = r[s] || r[65535],
              o = e.read_shift(2),
              a = e.l + o,
              l = n.f && n.f(e, o, i);
            if (e.l = a, t(l, n, s)) return
          }
        }
      }

      function t(t, i) {
        if (!t) return t;
        var r = i || {};
        null != Bu && null == r.dense && (r.dense = Bu);
        var s = r.dense ? [] : {},
          n = "Sheet1",
          o = "",
          a = 0,
          l = {},
          c = [],
          h = [],
          u = {
            s: {
              r: 0,
              c: 0
            },
            e: {
              r: 0,
              c: 0
            }
          },
          d = r.sheetRows || 0;
        if (0 == t[2] && (8 == t[3] || 9 == t[3]) && t.length >= 16 && 5 == t[14] && 108 === t[15]) throw new Error("Unsupported Works 3 for Mac file");
        if (2 == t[2]) r.Enum = T, e(t, function(e, t, i) {
          switch (i) {
            case 0:
              r.vers = e, e >= 4096 && (r.qpro = !0);
              break;
            case 6:
              u = e;
              break;
            case 204:
              e && (o = e);
              break;
            case 222:
              o = e;
              break;
            case 15:
            case 51:
              r.qpro || (e[1].v = e[1].v.slice(1));
            case 13:
            case 14:
            case 16:
              14 == i && !(112 & ~e[2]) && (15 & e[2]) > 1 && (15 & e[2]) < 15 && (e[1].z = r.dateNF || ud[14], r.cellDates && (e[1].t = "d", e[1].v = up(e[1].v))), r.qpro && e[3] > a && (s["!ref"] = Sg(u), l[n] = s, c.push(n), s = r.dense ? [] : {}, u = {
                s: {
                  r: 0,
                  c: 0
                },
                e: {
                  r: 0,
                  c: 0
                }
              }, a = e[3], n = o || "Sheet" + (a + 1), o = "");
              var h = r.dense ? (s[e[0].r] || [])[e[0].c] : s[mg(e[0])];
              if (h) {
                h.t = e[1].t, h.v = e[1].v, null != e[1].z && (h.z = e[1].z), null != e[1].f && (h.f = e[1].f);
                break
              }
              r.dense ? (s[e[0].r] || (s[e[0].r] = []), s[e[0].r][e[0].c] = e[1]) : s[mg(e[0])] = e[1]
          }
        }, r);
        else {
          if (26 != t[2] && 14 != t[2]) throw new Error("Unrecognized LOTUS BOF " + t[2]);
          r.Enum = m, 14 == t[2] && (r.qpro = !0, t.l = 0), e(t, function(e, t, i) {
            switch (i) {
              case 204:
                n = e;
                break;
              case 22:
                e[1].v = e[1].v.slice(1);
              case 23:
              case 24:
              case 25:
              case 37:
              case 39:
              case 40:
                if (e[3] > a && (s["!ref"] = Sg(u), l[n] = s, c.push(n), s = r.dense ? [] : {}, u = {
                    s: {
                      r: 0,
                      c: 0
                    },
                    e: {
                      r: 0,
                      c: 0
                    }
                  }, a = e[3], n = "Sheet" + (a + 1)), d > 0 && e[0].r >= d) break;
                r.dense ? (s[e[0].r] || (s[e[0].r] = []), s[e[0].r][e[0].c] = e[1]) : s[mg(e[0])] = e[1], u.e.c < e[0].c && (u.e.c = e[0].c), u.e.r < e[0].r && (u.e.r = e[0].r);
                break;
              case 27:
                e[14e3] && (h[e[14e3][0]] = e[14e3][1]);
                break;
              case 1537:
                h[e[0]] = e[1], e[0] == a && (n = e[1])
            }
          }, r)
        }
        if (s["!ref"] = Sg(u), l[o || n] = s, c.push(o || n), !h.length) return {
          SheetNames: c,
          Sheets: l
        };
        for (var p = {}, E = [], g = 0; g < h.length; ++g) l[c[g]] ? (E.push(h[g] || c[g]), p[h[g]] = l[h[g]] || l[c[g]]) : (E.push(h[g]), p[h[g]] = {
          "!ref": "A1"
        });
        return {
          SheetNames: E,
          Sheets: p
        }
      }

      function i(e, t, i) {
        var r = [{
          c: 0,
          r: 0
        }, {
          t: "n",
          v: 0
        }, 0, 0];
        return i.qpro && 20768 != i.vers ? (r[0].c = e.read_shift(1), r[3] = e.read_shift(1), r[0].r = e.read_shift(2), e.l += 2) : (r[2] = e.read_shift(1), r[0].c = e.read_shift(2), r[0].r = e.read_shift(2)), r
      }

      function r(e, t, r) {
        var s = e.l + t,
          n = i(e, 0, r);
        if (n[1].t = "s", 20768 == r.vers) {
          e.l++;
          var o = e.read_shift(1);
          return n[1].v = e.read_shift(o, "utf8"), n
        }
        return r.qpro && e.l++, n[1].v = e.read_shift(s - e.l, "cstr"), n
      }

      function s(e, t, i) {
        var r = ng(7 + i.length);
        r.write_shift(1, 255), r.write_shift(2, t), r.write_shift(2, e), r.write_shift(1, 39);
        for (var s = 0; s < r.length; ++s) {
          var n = i.charCodeAt(s);
          r.write_shift(1, n >= 128 ? 95 : n)
        }
        return r.write_shift(1, 0), r
      }

      function n(e, t, i) {
        var r = ng(7);
        return r.write_shift(1, 255), r.write_shift(2, t), r.write_shift(2, e), r.write_shift(2, i, "i"), r
      }

      function o(e, t, i) {
        var r = ng(13);
        return r.write_shift(1, 255), r.write_shift(2, t), r.write_shift(2, e), r.write_shift(8, i, "f"), r
      }

      function a(e, t, i) {
        var r = 32768 & t;
        return t = (r ? e : 0) + ((t &= -32769) >= 8192 ? t - 16384 : t), (r ? "" : "$") + (i ? fg(t) : Eg(t))
      }
      var l = {
          51: ["FALSE", 0],
          52: ["TRUE", 0],
          70: ["LEN", 1],
          80: ["SUM", 69],
          81: ["AVERAGEA", 69],
          82: ["COUNTA", 69],
          83: ["MINA", 69],
          84: ["MAXA", 69],
          111: ["T", 1]
        },
        c = ["", "", "", "", "", "", "", "", "", "+", "-", "*", "/", "^", "=", "<>", "<=", ">=", "<", ">", "", "", "", "", "&", "", "", "", "", "", "", ""];

      function h(e) {
        var t = [{
          c: 0,
          r: 0
        }, {
          t: "n",
          v: 0
        }, 0];
        return t[0].r = e.read_shift(2), t[3] = e[e.l++], t[0].c = e[e.l++], t
      }

      function u(e, t, i, r) {
        var s = ng(6 + r.length);
        s.write_shift(2, e), s.write_shift(1, i), s.write_shift(1, t), s.write_shift(1, 39);
        for (var n = 0; n < r.length; ++n) {
          var o = r.charCodeAt(n);
          s.write_shift(1, o >= 128 ? 95 : o)
        }
        return s.write_shift(1, 0), s
      }

      function d(e, t) {
        var i = h(e),
          r = e.read_shift(4),
          s = e.read_shift(4),
          n = e.read_shift(2);
        if (65535 == n) return 0 === r && 3221225472 === s ? (i[1].t = "e", i[1].v = 15) : 0 === r && 3489660928 === s ? (i[1].t = "e", i[1].v = 42) : i[1].v = 0, i;
        var o = 32768 & n;
        return n = (32767 & n) - 16446, i[1].v = (1 - 2 * o) * (s * Math.pow(2, n + 32) + r * Math.pow(2, n)), i
      }

      function p(e, t, i, r) {
        var s = ng(14);
        if (s.write_shift(2, e), s.write_shift(1, i), s.write_shift(1, t), 0 == r) return s.write_shift(4, 0), s.write_shift(4, 0), s.write_shift(2, 65535), s;
        var n, o = 0,
          a = 0,
          l = 0;
        return r < 0 && (o = 1, r = -r), a = 0 | Math.log2(r), 2147483648 & (l = (r /= Math.pow(2, a - 31)) >>> 0) || (++a, l = (r /= 2) >>> 0), r -= l, l |= 2147483648, l >>>= 0, n = (r *= Math.pow(2, 32)) >>> 0, s.write_shift(4, n), s.write_shift(4, l), a += 16383 + (o ? 32768 : 0), s.write_shift(2, a), s
      }

      function E(e, t) {
        var i = h(e),
          r = e.read_shift(8, "f");
        return i[1].v = r, i
      }

      function g(e, t) {
        return 0 == e[e.l + t - 1] ? e.read_shift(t, "cstr") : ""
      }

      function f(e, t) {
        var i = ng(5 + e.length);
        i.write_shift(2, 14e3), i.write_shift(2, t);
        for (var r = 0; r < e.length; ++r) {
          var s = e.charCodeAt(r);
          i[i.l++] = s > 127 ? 95 : s
        }
        return i[i.l++] = 0, i
      }
      var T = {
          0: {
            n: "BOF",
            f: oT
          },
          1: {
            n: "EOF"
          },
          2: {
            n: "CALCMODE"
          },
          3: {
            n: "CALCORDER"
          },
          4: {
            n: "SPLIT"
          },
          5: {
            n: "SYNC"
          },
          6: {
            n: "RANGE",
            f: function(e, t, i) {
              var r = {
                s: {
                  c: 0,
                  r: 0
                },
                e: {
                  c: 0,
                  r: 0
                }
              };
              return 8 == t && i.qpro ? (r.s.c = e.read_shift(1), e.l++, r.s.r = e.read_shift(2), r.e.c = e.read_shift(1), e.l++, r.e.r = e.read_shift(2), r) : (r.s.c = e.read_shift(2), r.s.r = e.read_shift(2), 12 == t && i.qpro && (e.l += 2), r.e.c = e.read_shift(2), r.e.r = e.read_shift(2), 12 == t && i.qpro && (e.l += 2), 65535 == r.s.c && (r.s.c = r.e.c = r.s.r = r.e.r = 0), r)
            }
          },
          7: {
            n: "WINDOW1"
          },
          8: {
            n: "COLW1"
          },
          9: {
            n: "WINTWO"
          },
          10: {
            n: "COLW2"
          },
          11: {
            n: "NAME"
          },
          12: {
            n: "BLANK"
          },
          13: {
            n: "INTEGER",
            f: function(e, t, r) {
              var s = i(e, 0, r);
              return s[1].v = e.read_shift(2, "i"), s
            }
          },
          14: {
            n: "NUMBER",
            f: function(e, t, r) {
              var s = i(e, 0, r);
              return s[1].v = e.read_shift(8, "f"), s
            }
          },
          15: {
            n: "LABEL",
            f: r
          },
          16: {
            n: "FORMULA",
            f: function(e, t, r) {
              var s = e.l + t,
                n = i(e, 0, r);
              if (n[1].v = e.read_shift(8, "f"), r.qpro) e.l = s;
              else {
                var o = e.read_shift(2);
                ! function(e, t) {
                  rg(e, 0);
                  var i = [],
                    r = 0,
                    s = "",
                    n = "",
                    o = "",
                    h = "";
                  for (; e.l < e.length;) {
                    var u = e[e.l++];
                    switch (u) {
                      case 0:
                        i.push(e.read_shift(8, "f"));
                        break;
                      case 1:
                        n = a(t[0].c, e.read_shift(2), !0), s = a(t[0].r, e.read_shift(2), !1), i.push(n + s);
                        break;
                      case 2:
                        var d = a(t[0].c, e.read_shift(2), !0),
                          p = a(t[0].r, e.read_shift(2), !1);
                        n = a(t[0].c, e.read_shift(2), !0), s = a(t[0].r, e.read_shift(2), !1), i.push(d + p + ":" + n + s);
                        break;
                      case 3:
                        if (e.l < e.length) return void console.error("WK1 premature formula end");
                        break;
                      case 4:
                        i.push("(" + i.pop() + ")");
                        break;
                      case 5:
                        i.push(e.read_shift(2));
                        break;
                      case 6:
                        for (var E = ""; u = e[e.l++];) E += String.fromCharCode(u);
                        i.push('"' + E.replace(/"/g, '""') + '"');
                        break;
                      case 8:
                        i.push("-" + i.pop());
                        break;
                      case 23:
                        i.push("+" + i.pop());
                        break;
                      case 22:
                        i.push("NOT(" + i.pop() + ")");
                        break;
                      case 20:
                      case 21:
                        h = i.pop(), o = i.pop(), i.push(["AND", "OR"][u - 20] + "(" + o + "," + h + ")");
                        break;
                      default:
                        if (u < 32 && c[u]) h = i.pop(), o = i.pop(), i.push(o + c[u] + h);
                        else {
                          if (!l[u]) return u <= 7 ? console.error("WK1 invalid opcode " + u.toString(16)) : u <= 24 ? console.error("WK1 unsupported op " + u.toString(16)) : u <= 30 ? console.error("WK1 invalid opcode " + u.toString(16)) : u <= 115 ? console.error("WK1 unsupported function opcode " + u.toString(16)) : console.error("WK1 unrecognized opcode " + u.toString(16));
                          if (69 == (r = l[u][1]) && (r = e[e.l++]), r > i.length) return void console.error("WK1 bad formula parse 0x" + u.toString(16) + ":|" + i.join("|") + "|");
                          var g = i.slice(-r);
                          i.length -= r, i.push(l[u][0] + "(" + g.join(",") + ")")
                        }
                    }
                  }
                  1 == i.length ? t[1].f = "" + i[0] : console.error("WK1 bad formula parse |" + i.join("|") + "|")
                }(e.slice(e.l, e.l + o), n), e.l += o
              }
              return n
            }
          },
          24: {
            n: "TABLE"
          },
          25: {
            n: "ORANGE"
          },
          26: {
            n: "PRANGE"
          },
          27: {
            n: "SRANGE"
          },
          28: {
            n: "FRANGE"
          },
          29: {
            n: "KRANGE1"
          },
          32: {
            n: "HRANGE"
          },
          35: {
            n: "KRANGE2"
          },
          36: {
            n: "PROTEC"
          },
          37: {
            n: "FOOTER"
          },
          38: {
            n: "HEADER"
          },
          39: {
            n: "SETUP"
          },
          40: {
            n: "MARGINS"
          },
          41: {
            n: "LABELFMT"
          },
          42: {
            n: "TITLES"
          },
          43: {
            n: "SHEETJS"
          },
          45: {
            n: "GRAPH"
          },
          46: {
            n: "NGRAPH"
          },
          47: {
            n: "CALCCOUNT"
          },
          48: {
            n: "UNFORMATTED"
          },
          49: {
            n: "CURSORW12"
          },
          50: {
            n: "WINDOW"
          },
          51: {
            n: "STRING",
            f: r
          },
          55: {
            n: "PASSWORD"
          },
          56: {
            n: "LOCKED"
          },
          60: {
            n: "QUERY"
          },
          61: {
            n: "QUERYNAME"
          },
          62: {
            n: "PRINT"
          },
          63: {
            n: "PRINTNAME"
          },
          64: {
            n: "GRAPH2"
          },
          65: {
            n: "GRAPHNAME"
          },
          66: {
            n: "ZOOM"
          },
          67: {
            n: "SYMSPLIT"
          },
          68: {
            n: "NSROWS"
          },
          69: {
            n: "NSCOLS"
          },
          70: {
            n: "RULER"
          },
          71: {
            n: "NNAME"
          },
          72: {
            n: "ACOMM"
          },
          73: {
            n: "AMACRO"
          },
          74: {
            n: "PARSE"
          },
          102: {
            n: "PRANGES??"
          },
          103: {
            n: "RRANGES??"
          },
          104: {
            n: "FNAME??"
          },
          105: {
            n: "MRANGES??"
          },
          204: {
            n: "SHEETNAMECS",
            f: g
          },
          222: {
            n: "SHEETNAMELP",
            f: function(e, t) {
              var i = e[e.l++];
              i > t - 1 && (i = t - 1);
              for (var r = ""; r.length < i;) r += String.fromCharCode(e[e.l++]);
              return r
            }
          },
          65535: {
            n: ""
          }
        },
        m = {
          0: {
            n: "BOF"
          },
          1: {
            n: "EOF"
          },
          2: {
            n: "PASSWORD"
          },
          3: {
            n: "CALCSET"
          },
          4: {
            n: "WINDOWSET"
          },
          5: {
            n: "SHEETCELLPTR"
          },
          6: {
            n: "SHEETLAYOUT"
          },
          7: {
            n: "COLUMNWIDTH"
          },
          8: {
            n: "HIDDENCOLUMN"
          },
          9: {
            n: "USERRANGE"
          },
          10: {
            n: "SYSTEMRANGE"
          },
          11: {
            n: "ZEROFORCE"
          },
          12: {
            n: "SORTKEYDIR"
          },
          13: {
            n: "FILESEAL"
          },
          14: {
            n: "DATAFILLNUMS"
          },
          15: {
            n: "PRINTMAIN"
          },
          16: {
            n: "PRINTSTRING"
          },
          17: {
            n: "GRAPHMAIN"
          },
          18: {
            n: "GRAPHSTRING"
          },
          19: {
            n: "??"
          },
          20: {
            n: "ERRCELL"
          },
          21: {
            n: "NACELL"
          },
          22: {
            n: "LABEL16",
            f: function(e, t) {
              var i = h(e);
              return i[1].t = "s", i[1].v = e.read_shift(t - 4, "cstr"), i
            }
          },
          23: {
            n: "NUMBER17",
            f: d
          },
          24: {
            n: "NUMBER18",
            f: function(e, t) {
              var i = h(e);
              i[1].v = e.read_shift(2);
              var r = i[1].v >> 1;
              if (1 & i[1].v) switch (7 & r) {
                case 0:
                  r = 5e3 * (r >> 3);
                  break;
                case 1:
                  r = 500 * (r >> 3);
                  break;
                case 2:
                  r = (r >> 3) / 20;
                  break;
                case 3:
                  r = (r >> 3) / 200;
                  break;
                case 4:
                  r = (r >> 3) / 2e3;
                  break;
                case 5:
                  r = (r >> 3) / 2e4;
                  break;
                case 6:
                  r = (r >> 3) / 16;
                  break;
                case 7:
                  r = (r >> 3) / 64
              }
              return i[1].v = r, i
            }
          },
          25: {
            n: "FORMULA19",
            f: function(e, t) {
              var i = d(e);
              return e.l += t - 14, i
            }
          },
          26: {
            n: "FORMULA1A"
          },
          27: {
            n: "XFORMAT",
            f: function(e, t) {
              for (var i = {}, r = e.l + t; e.l < r;) {
                var s = e.read_shift(2);
                if (14e3 == s) {
                  for (i[s] = [0, ""], i[s][0] = e.read_shift(2); e[e.l];) i[s][1] += String.fromCharCode(e[e.l]), e.l++;
                  e.l++
                }
              }
              return i
            }
          },
          28: {
            n: "DTLABELMISC"
          },
          29: {
            n: "DTLABELCELL"
          },
          30: {
            n: "GRAPHWINDOW"
          },
          31: {
            n: "CPA"
          },
          32: {
            n: "LPLAUTO"
          },
          33: {
            n: "QUERY"
          },
          34: {
            n: "HIDDENSHEET"
          },
          35: {
            n: "??"
          },
          37: {
            n: "NUMBER25",
            f: function(e, t) {
              var i = h(e),
                r = e.read_shift(4);
              return i[1].v = r >> 6, i
            }
          },
          38: {
            n: "??"
          },
          39: {
            n: "NUMBER27",
            f: E
          },
          40: {
            n: "FORMULA28",
            f: function(e, t) {
              var i = E(e);
              return e.l += t - 10, i
            }
          },
          142: {
            n: "??"
          },
          147: {
            n: "??"
          },
          150: {
            n: "??"
          },
          151: {
            n: "??"
          },
          152: {
            n: "??"
          },
          153: {
            n: "??"
          },
          154: {
            n: "??"
          },
          155: {
            n: "??"
          },
          156: {
            n: "??"
          },
          163: {
            n: "??"
          },
          174: {
            n: "??"
          },
          175: {
            n: "??"
          },
          176: {
            n: "??"
          },
          177: {
            n: "??"
          },
          184: {
            n: "??"
          },
          185: {
            n: "??"
          },
          186: {
            n: "??"
          },
          187: {
            n: "??"
          },
          188: {
            n: "??"
          },
          195: {
            n: "??"
          },
          201: {
            n: "??"
          },
          204: {
            n: "SHEETNAMECS",
            f: g
          },
          205: {
            n: "??"
          },
          206: {
            n: "??"
          },
          207: {
            n: "??"
          },
          208: {
            n: "??"
          },
          256: {
            n: "??"
          },
          259: {
            n: "??"
          },
          260: {
            n: "??"
          },
          261: {
            n: "??"
          },
          262: {
            n: "??"
          },
          263: {
            n: "??"
          },
          265: {
            n: "??"
          },
          266: {
            n: "??"
          },
          267: {
            n: "??"
          },
          268: {
            n: "??"
          },
          270: {
            n: "??"
          },
          271: {
            n: "??"
          },
          384: {
            n: "??"
          },
          389: {
            n: "??"
          },
          390: {
            n: "??"
          },
          393: {
            n: "??"
          },
          396: {
            n: "??"
          },
          512: {
            n: "??"
          },
          514: {
            n: "??"
          },
          513: {
            n: "??"
          },
          516: {
            n: "??"
          },
          517: {
            n: "??"
          },
          640: {
            n: "??"
          },
          641: {
            n: "??"
          },
          642: {
            n: "??"
          },
          643: {
            n: "??"
          },
          644: {
            n: "??"
          },
          645: {
            n: "??"
          },
          646: {
            n: "??"
          },
          647: {
            n: "??"
          },
          648: {
            n: "??"
          },
          658: {
            n: "??"
          },
          659: {
            n: "??"
          },
          660: {
            n: "??"
          },
          661: {
            n: "??"
          },
          662: {
            n: "??"
          },
          665: {
            n: "??"
          },
          666: {
            n: "??"
          },
          768: {
            n: "??"
          },
          772: {
            n: "??"
          },
          1537: {
            n: "SHEETINFOQP",
            f: function(e, t, i) {
              if (i.qpro && !(t < 21)) {
                var r = e.read_shift(1);
                return e.l += 17, e.l += 1, e.l += 2, [r, e.read_shift(t - 21, "cstr")]
              }
            }
          },
          1600: {
            n: "??"
          },
          1602: {
            n: "??"
          },
          1793: {
            n: "??"
          },
          1794: {
            n: "??"
          },
          1795: {
            n: "??"
          },
          1796: {
            n: "??"
          },
          1920: {
            n: "??"
          },
          2048: {
            n: "??"
          },
          2049: {
            n: "??"
          },
          2052: {
            n: "??"
          },
          2688: {
            n: "??"
          },
          10998: {
            n: "??"
          },
          12849: {
            n: "??"
          },
          28233: {
            n: "??"
          },
          28484: {
            n: "??"
          },
          65535: {
            n: ""
          }
        };
      return {
        sheet_to_wk1: function(e, t) {
          var i = t || {};
          if (+i.codepage >= 0 && Pu(+i.codepage), "string" == i.type) throw new Error("Cannot write WK1 to JS string");
          var r, a, l = ag(),
            c = Rg(e["!ref"]),
            h = Array.isArray(e),
            u = [];
          IA(l, 0, (r = 1030, (a = ng(2)).write_shift(2, r), a)), IA(l, 6, function(e) {
            var t = ng(8);
            return t.write_shift(2, e.s.c), t.write_shift(2, e.s.r), t.write_shift(2, e.e.c), t.write_shift(2, e.e.r), t
          }(c));
          for (var d = Math.min(c.e.r, 8191), p = c.s.r; p <= d; ++p)
            for (var E = Eg(p), g = c.s.c; g <= c.e.c; ++g) {
              p === c.s.r && (u[g] = fg(g));
              var f = u[g] + E,
                T = h ? (e[p] || [])[g] : e[f];
              if (T && "z" != T.t)
                if ("n" == T.t)(0 | T.v) == T.v && T.v >= -32768 && T.v <= 32767 ? IA(l, 13, n(p, g, T.v)) : IA(l, 14, o(p, g, T.v));
                else IA(l, 15, s(p, g, vg(T).slice(0, 239)))
            }
          return IA(l, 1), l.end()
        },
        book_to_wk3: function(e, t) {
          var i = t || {};
          if (+i.codepage >= 0 && Pu(+i.codepage), "string" == i.type) throw new Error("Cannot write WK3 to JS string");
          var r = ag();
          IA(r, 0, function(e) {
            var t = ng(26);
            t.write_shift(2, 4096), t.write_shift(2, 4), t.write_shift(4, 0);
            for (var i = 0, r = 0, s = 0, n = 0; n < e.SheetNames.length; ++n) {
              var o = e.SheetNames[n],
                a = e.Sheets[o];
              if (a && a["!ref"]) {
                ++s;
                var l = Cg(a["!ref"]);
                i < l.e.r && (i = l.e.r), r < l.e.c && (r = l.e.c)
              }
            }
            i > 8191 && (i = 8191);
            return t.write_shift(2, i), t.write_shift(1, s), t.write_shift(1, r), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(1, 1), t.write_shift(1, 2), t.write_shift(4, 0), t.write_shift(4, 0), t
          }(e));
          for (var s = 0, n = 0; s < e.SheetNames.length; ++s)(e.Sheets[e.SheetNames[s]] || {})["!ref"] && IA(r, 27, f(e.SheetNames[s], n++));
          var o = 0;
          for (s = 0; s < e.SheetNames.length; ++s) {
            var a = e.Sheets[e.SheetNames[s]];
            if (a && a["!ref"]) {
              for (var l = Rg(a["!ref"]), c = Array.isArray(a), h = [], d = Math.min(l.e.r, 8191), E = l.s.r; E <= d; ++E)
                for (var g = Eg(E), T = l.s.c; T <= l.e.c; ++T) {
                  E === l.s.r && (h[T] = fg(T));
                  var m = h[T] + g,
                    C = c ? (a[E] || [])[T] : a[m];
                  if (C && "z" != C.t)
                    if ("n" == C.t) IA(r, 23, p(E, T, o, C.v));
                    else IA(r, 22, u(E, T, o, vg(C).slice(0, 239)))
                }++o
            }
          }
          return IA(r, 1), r.end()
        },
        to_workbook: function(e, i) {
          switch (i.type) {
            case "base64":
              return t(ju(Yu(e)), i);
            case "binary":
              return t(ju(e), i);
            case "buffer":
            case "array":
              return t(e, i)
          }
          throw "Unsupported type " + i.type
        }
      }
    }();
    var cm = function() {
        var e = aE("t"),
          t = aE("rPr");

        function i(i) {
          var r = i.match(e);
          if (!r) return {
            t: "s",
            v: ""
          };
          var s = {
              t: "s",
              v: Xp(r[1])
            },
            n = i.match(t);
          return n && (s.s = function(e) {
            var t = {},
              i = e.match(Hp),
              r = 0,
              s = !1;
            if (i)
              for (; r != i.length; ++r) {
                var n = Vp(i[r]);
                switch (n[0].replace(/\w*:/g, "")) {
                  case "<condense":
                  case "<extend":
                    break;
                  case "<shadow":
                    if (!n.val) break;
                  case "<shadow>":
                  case "<shadow/>":
                    t.shadow = 1;
                    break;
                  case "</shadow>":
                    break;
                  case "<charset":
                    if ("1" == n.val) break;
                    t.cp = wu[parseInt(n.val, 10)];
                    break;
                  case "<outline":
                    if (!n.val) break;
                  case "<outline>":
                  case "<outline/>":
                    t.outline = 1;
                    break;
                  case "</outline>":
                    break;
                  case "<rFont":
                    t.name = n.val;
                    break;
                  case "<sz":
                    t.sz = n.val;
                    break;
                  case "<strike":
                    if (!n.val) break;
                  case "<strike>":
                  case "<strike/>":
                    t.strike = 1;
                    break;
                  case "</strike>":
                    break;
                  case "<u":
                    if (!n.val) break;
                    switch (n.val) {
                      case "double":
                        t.uval = "double";
                        break;
                      case "singleAccounting":
                        t.uval = "single-accounting";
                        break;
                      case "doubleAccounting":
                        t.uval = "double-accounting"
                    }
                    case "<u>":
                    case "<u/>":
                      t.u = 1;
                      break;
                    case "</u>":
                      break;
                    case "<b":
                      if ("0" == n.val) break;
                    case "<b>":
                    case "<b/>":
                      t.b = 1;
                      break;
                    case "</b>":
                      break;
                    case "<i":
                      if ("0" == n.val) break;
                    case "<i>":
                    case "<i/>":
                      t.i = 1;
                      break;
                    case "</i>":
                      break;
                    case "<color":
                      n.rgb && (t.color = n.rgb.slice(2, 8));
                      break;
                    case "<color>":
                    case "<color/>":
                    case "</color>":
                      break;
                    case "<family":
                      t.family = n.val;
                      break;
                    case "<family>":
                    case "<family/>":
                    case "</family>":
                      break;
                    case "<vertAlign":
                      t.valign = n.val;
                      break;
                    case "<vertAlign>":
                    case "<vertAlign/>":
                    case "</vertAlign>":
                    case "<scheme":
                    case "<scheme>":
                    case "<scheme/>":
                    case "</scheme>":
                    case "<extLst":
                    case "<extLst>":
                    case "</extLst>":
                      break;
                    case "<ext":
                      s = !0;
                      break;
                    case "</ext>":
                      s = !1;
                      break;
                    default:
                      if (47 !== n[0].charCodeAt(1) && !s) throw new Error("Unrecognized rich format " + n[0])
                }
              }
            return t
          }(n[1])), s
        }
        var r = /<(?:\w+:)?r>/g,
          s = /<\/(?:\w+:)?r>/;
        return function(e) {
          return e.replace(r, "").split(s).map(i).filter(function(e) {
            return e.v
          })
        }
      }(),
      hm = function() {
        var e = /(\r\n|\n)/g;

        function t(t) {
          var i = [
            [], t.v, []
          ];
          return t.v ? (t.s && function(e, t, i) {
            var r = [];
            e.u && r.push("text-decoration: underline;"), e.uval && r.push("text-underline-style:" + e.uval + ";"), e.sz && r.push("font-size:" + e.sz + "pt;"), e.outline && r.push("text-effect: outline;"), e.shadow && r.push("text-shadow: auto;"), t.push('<span style="' + r.join("") + '">'), e.b && (t.push("<b>"), i.push("</b>")), e.i && (t.push("<i>"), i.push("</i>")), e.strike && (t.push("<s>"), i.push("</s>"));
            var s = e.valign || "";
            "superscript" == s || "super" == s ? s = "sup" : "subscript" == s && (s = "sub"), "" != s && (t.push("<" + s + ">"), i.push("</" + s + ">")), i.push("</span>")
          }(t.s, i[0], i[2]), i[0].join("") + i[1].replace(e, "<br/>") + i[2].join("")) : ""
        }
        return function(e) {
          return e.map(t).join("")
        }
      }(),
      um = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g,
      dm = /<(?:\w+:)?r>/,
      pm = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;

    function Em(e, t) {
      var i = !t || t.cellHTML,
        r = {};
      return e ? (e.match(/^\s*<(?:\w+:)?t[^>]*>/) ? (r.t = Xp(nE(e.slice(e.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || "")), r.r = nE(e), i && (r.h = Qp(r.t))) : e.match(dm) && (r.r = nE(e), r.t = Xp(nE((e.replace(pm, "").match(um) || []).join("").replace(Hp, ""))), i && (r.h = hm(cm(r.r)))), r) : {
        t: ""
      }
    }
    var gm = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/,
      fm = /<(?:\w+:)?(?:si|sstItem)>/g,
      Tm = /<\/(?:\w+:)?(?:si|sstItem)>/;
    var mm = /^\s|\s$|[\t\n\r]/;

    function Cm(e, t) {
      if (!t.bookSST) return "";
      var i = [xp];
      i[i.length] = fE("sst", null, {
        xmlns: RE[0],
        count: e.Count,
        uniqueCount: e.Unique
      });
      for (var r = 0; r != e.length; ++r)
        if (null != e[r]) {
          var s = e[r],
            n = "<si>";
          s.r ? n += s.r : (n += "<t", s.t || (s.t = ""), s.t.match(mm) && (n += ' xml:space="preserve"'), n += ">" + jp(s.t) + "</t>"), n += "</si>", i[i.length] = n
        } return i.length > 2 && (i[i.length] = "</sst>", i[1] = i[1].replace("/>", ">")), i.join("")
    }
    var Sm = function(e, t) {
      var i = !1;
      return null == t && (i = !0, t = ng(15 + 4 * e.t.length)), t.write_shift(1, 0), yg(e.t, t), i ? t.slice(0, t.l) : t
    };

    function Rm(e) {
      var t = ag();
      lg(t, 159, function(e, t) {
        return t || (t = ng(8)), t.write_shift(4, e.Count), t.write_shift(4, e.Unique), t
      }(e));
      for (var i = 0; i < e.length; ++i) lg(t, 19, Sm(e[i]));
      return lg(t, 160), t.end()
    }

    function Am(e) {
      if (void 0 !== xu) return xu.utils.encode(_u, e);
      for (var t = [], i = e.split(""), r = 0; r < i.length; ++r) t[r] = i[r].charCodeAt(0);
      return t
    }

    function vm(e, t) {
      var i = {};
      return i.Major = e.read_shift(2), i.Minor = e.read_shift(2), t >= 4 && (e.l += t - 4), i
    }

    function Nm(e) {
      for (var t = e.read_shift(4), i = e.l + t - 4, r = {}, s = e.read_shift(4), n = []; s-- > 0;) n.push({
        t: e.read_shift(4),
        v: e.read_shift(0, "lpp4")
      });
      if (r.name = e.read_shift(0, "lpp4"), r.comps = n, e.l != i) throw new Error("Bad DataSpaceMapEntry: " + e.l + " != " + i);
      return r
    }

    function Im(e) {
      var t = function(e) {
        var t = {};
        return e.read_shift(4), e.l += 4, t.id = e.read_shift(0, "lpp4"), t.name = e.read_shift(0, "lpp4"), t.R = vm(e, 4), t.U = vm(e, 4), t.W = vm(e, 4), t
      }(e);
      if (t.ename = e.read_shift(0, "8lpp4"), t.blksz = e.read_shift(4), t.cmode = e.read_shift(4), 4 != e.read_shift(4)) throw new Error("Bad !Primary record");
      return t
    }

    function Om(e, t) {
      var i = e.l + t,
        r = {};
      r.Flags = 63 & e.read_shift(4), e.l += 4, r.AlgID = e.read_shift(4);
      var s = !1;
      switch (r.AlgID) {
        case 26126:
        case 26127:
        case 26128:
          s = 36 == r.Flags;
          break;
        case 26625:
          s = 4 == r.Flags;
          break;
        case 0:
          s = 16 == r.Flags || 4 == r.Flags || 36 == r.Flags;
          break;
        default:
          throw "Unrecognized encryption algorithm: " + r.AlgID
      }
      if (!s) throw new Error("Encryption Flags/AlgID mismatch");
      return r.AlgIDHash = e.read_shift(4), r.KeySize = e.read_shift(4), r.ProviderType = e.read_shift(4), e.l += 8, r.CSPName = e.read_shift(i - e.l >> 1, "utf16le"), e.l = i, r
    }

    function Lm(e, t) {
      var i = {},
        r = e.l + t;
      return e.l += 4, i.Salt = e.slice(e.l, e.l + 16), e.l += 16, i.Verifier = e.slice(e.l, e.l + 16), e.l += 16, e.read_shift(4), i.VerifierHash = e.slice(e.l, r), e.l = r, i
    }

    function _m(e) {
      if (36 != (63 & e.read_shift(4))) throw new Error("EncryptionInfo mismatch");
      var t = e.read_shift(4);
      return {
        t: "Std",
        h: Om(e, t),
        v: Lm(e, e.length - e.l)
      }
    }

    function ym() {
      throw new Error("File is password-protected: ECMA-376 Extensible")
    }

    function wm(e) {
      var t = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
      e.l += 4;
      var i = e.read_shift(e.length - e.l, "utf8"),
        r = {};
      return i.replace(Hp, function(e) {
        var i = Vp(e);
        switch (Wp(i[0])) {
          case "<?xml":
          case "<encryption":
          case "</encryption>":
          case "</keyEncryptors>":
          case "</keyEncryptor>":
            break;
          case "<keyData":
            t.forEach(function(e) {
              r[e] = i[e]
            });
            break;
          case "<dataIntegrity":
            r.encryptedHmacKey = i.encryptedHmacKey, r.encryptedHmacValue = i.encryptedHmacValue;
            break;
          case "<keyEncryptors>":
          case "<keyEncryptors":
            r.encs = [];
            break;
          case "<keyEncryptor":
            r.uri = i.uri;
            break;
          case "<encryptedKey":
            r.encs.push(i);
            break;
          default:
            throw i[0]
        }
      }), r
    }

    function Dm(e) {
      var t, i, r = 0,
        s = Am(e),
        n = s.length + 1;
      for ((t = zu(n))[0] = s.length, i = 1; i != n; ++i) t[i] = s[i - 1];
      for (i = n - 1; i >= 0; --i) r = ((16384 & r ? 1 : 0) | r << 1 & 32767) ^ t[i];
      return 52811 ^ r
    }
    var Pm = function() {
        var e = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0],
          t = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163],
          i = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628],
          r = function(e, t) {
            return 255 & ((i = e ^ t) / 2 | 128 * i);
            var i
          };
        return function(s) {
          for (var n, o, a, l = Am(s), c = function(e) {
              for (var r = t[e.length - 1], s = 104, n = e.length - 1; n >= 0; --n)
                for (var o = e[n], a = 0; 7 != a; ++a) 64 & o && (r ^= i[s]), o *= 2, --s;
              return r
            }(l), h = l.length, u = zu(16), d = 0; 16 != d; ++d) u[d] = 0;
          for (1 & ~h || (n = c >> 8, u[h] = r(e[0], n), --h, n = 255 & c, o = l[l.length - 1], u[h] = r(o, n)); h > 0;) n = c >> 8, u[--h] = r(l[h], n), n = 255 & c, u[--h] = r(l[h], n);
          for (h = 15, a = 15 - l.length; a > 0;) n = c >> 8, u[h] = r(e[a], n), --a, n = 255 & c, u[--h] = r(l[h], n), --h, --a;
          return u
        }
      }(),
      bm = function(e) {
        var t = 0,
          i = Pm(e);
        return function(e) {
          var r = function(e, t, i, r, s) {
            var n, o;
            for (s || (s = t), r || (r = Pm(e)), n = 0; n != t.length; ++n) o = t[n], o = 255 & ((o ^= r[i]) >> 5 | o << 3), s[n] = o, ++i;
            return [s, i, r]
          }("", e, t, i);
          return t = r[1], r[0]
        }
      };

    function Mm(e, t, i) {
      var r = i || {};
      return r.Info = e.read_shift(2), e.l -= 2, 1 === r.Info ? r.Data = function(e) {
        var t = {},
          i = t.EncryptionVersionInfo = vm(e, 4);
        if (1 != i.Major || 1 != i.Minor) throw "unrecognized version code " + i.Major + " : " + i.Minor;
        return t.Salt = e.read_shift(16), t.EncryptedVerifier = e.read_shift(16), t.EncryptedVerifierHash = e.read_shift(16), t
      }(e) : r.Data = function(e, t) {
        var i = {},
          r = i.EncryptionVersionInfo = vm(e, 4);
        if (t -= 4, 2 != r.Minor) throw new Error("unrecognized minor version code: " + r.Minor);
        if (r.Major > 4 || r.Major < 2) throw new Error("unrecognized major version code: " + r.Major);
        i.Flags = e.read_shift(4), t -= 4;
        var s = e.read_shift(4);
        return t -= 4, i.EncryptionHeader = Om(e, s), t -= s, i.EncryptionVerifier = Lm(e, t), i
      }(e, t), r
    }
    var Fm = function() {
      function e(e, i) {
        switch (i.type) {
          case "base64":
            return t(Yu(e), i);
          case "binary":
            return t(e, i);
          case "buffer":
            return t(Ku && Buffer.isBuffer(e) ? e.toString("binary") : qu(e), i);
          case "array":
            return t(Tp(e), i)
        }
        throw new Error("Unrecognized type " + i.type)
      }

      function t(e, t) {
        var i = (t || {}).dense ? [] : {},
          r = e.match(/\\trowd.*?\\row\b/g);
        if (!r.length) throw new Error("RTF missing table");
        var s = {
          s: {
            c: 0,
            r: 0
          },
          e: {
            c: 0,
            r: r.length - 1
          }
        };
        return r.forEach(function(e, t) {
          Array.isArray(i) && (i[t] = []);
          for (var r, n = /\\\w+\b/g, o = 0, a = -1; r = n.exec(e);) {
            if ("\\cell" === r[0]) {
              var l = e.slice(o, n.lastIndex - r[0].length);
              if (" " == l[0] && (l = l.slice(1)), ++a, l.length) {
                var c = {
                  v: l,
                  t: "s"
                };
                Array.isArray(i) ? i[t][a] = c : i[mg({
                  r: t,
                  c: a
                })] = c
              }
            }
            o = n.lastIndex
          }
          a > s.e.c && (s.e.c = a)
        }), i["!ref"] = Sg(s), i
      }
      return {
        to_workbook: function(t, i) {
          return Ng(e(t, i), i)
        },
        to_sheet: e,
        from_sheet: function(e) {
          for (var t, i = ["{\\rtf1\\ansi"], r = Rg(e["!ref"]), s = Array.isArray(e), n = r.s.r; n <= r.e.r; ++n) {
            i.push("\\trowd\\trautofit1");
            for (var o = r.s.c; o <= r.e.c; ++o) i.push("\\cellx" + (o + 1));
            for (i.push("\\pard\\intbl"), o = r.s.c; o <= r.e.c; ++o) {
              var a = mg({
                r: n,
                c: o
              });
              (t = s ? (e[n] || [])[o] : e[a]) && (null != t.v || t.f && !t.F) && (i.push(" " + (t.w || (vg(t), t.w))), i.push("\\cell"))
            }
            i.push("\\pard\\intbl\\row")
          }
          return i.join("") + "}"
        }
      }
    }();

    function xm(e) {
      for (var t = 0, i = 1; 3 != t; ++t) i = 256 * i + (e[t] > 255 ? 255 : e[t] < 0 ? 0 : e[t]);
      return i.toString(16).toUpperCase().slice(1)
    }

    function Gm(e, t) {
      if (0 === t) return e;
      var i, r, s = function(e) {
        var t = e[0] / 255,
          i = e[1] / 255,
          r = e[2] / 255,
          s = Math.max(t, i, r),
          n = Math.min(t, i, r),
          o = s - n;
        if (0 === o) return [0, 0, t];
        var a, l = 0,
          c = s + n;
        switch (a = o / (c > 1 ? 2 - c : c), s) {
          case t:
            l = ((i - r) / o + 6) % 6;
            break;
          case i:
            l = (r - t) / o + 2;
            break;
          case r:
            l = (t - i) / o + 4
        }
        return [l / 6, a, c / 2]
      }((r = (i = e).slice("#" === i[0] ? 1 : 0).slice(0, 6), [parseInt(r.slice(0, 2), 16), parseInt(r.slice(2, 4), 16), parseInt(r.slice(4, 6), 16)]));
      return s[2] = t < 0 ? s[2] * (1 + t) : 1 - (1 - s[2]) * (1 - t), xm(function(e) {
        var t, i = e[0],
          r = e[1],
          s = e[2],
          n = 2 * r * (s < .5 ? s : 1 - s),
          o = s - n / 2,
          a = [o, o, o],
          l = 6 * i;
        if (0 !== r) switch (0 | l) {
          case 0:
          case 6:
            t = n * l, a[0] += n, a[1] += t;
            break;
          case 1:
            t = n * (2 - l), a[0] += t, a[1] += n;
            break;
          case 2:
            t = n * (l - 2), a[1] += n, a[2] += t;
            break;
          case 3:
            t = n * (4 - l), a[1] += t, a[2] += n;
            break;
          case 4:
            t = n * (l - 4), a[2] += n, a[0] += t;
            break;
          case 5:
            t = n * (6 - l), a[2] += t, a[0] += n
        }
        for (var c = 0; 3 != c; ++c) a[c] = Math.round(255 * a[c]);
        return a
      }(s))
    }
    var Um = 6,
      Hm = 15,
      km = 1,
      Bm = Um;

    function Vm(e) {
      return Math.floor((e + Math.round(128 / Bm) / 256) * Bm)
    }

    function Wm(e) {
      return Math.floor((e - 5) / Bm * 100 + .5) / 100
    }

    function Ym(e) {
      return Math.round((e * Bm + 5) / Bm * 256) / 256
    }

    function Km(e) {
      return Ym(Wm(Vm(e)))
    }

    function Xm(e) {
      var t = Math.abs(e - Km(e)),
        i = Bm;
      if (t > .005)
        for (Bm = km; Bm < Hm; ++Bm) Math.abs(e - Km(e)) <= t && (t = Math.abs(e - Km(e)), i = Bm);
      Bm = i
    }

    function zm(e) {
      e.width ? (e.wpx = Vm(e.width), e.wch = Wm(e.wpx), e.MDW = Bm) : e.wpx ? (e.wch = Wm(e.wpx), e.width = Ym(e.wch), e.MDW = Bm) : "number" == typeof e.wch && (e.width = Ym(e.wch), e.wpx = Vm(e.width), e.MDW = Bm), e.customWidth && delete e.customWidth
    }
    var $m = 96;

    function jm(e) {
      return 96 * e / $m
    }

    function Jm(e) {
      return e * $m / 96
    }
    var qm = {
      None: "none",
      Solid: "solid",
      Gray50: "mediumGray",
      Gray75: "darkGray",
      Gray25: "lightGray",
      HorzStripe: "darkHorizontal",
      VertStripe: "darkVertical",
      ReverseDiagStripe: "darkDown",
      DiagStripe: "darkUp",
      DiagCross: "darkGrid",
      ThickDiagCross: "darkTrellis",
      ThinHorzStripe: "lightHorizontal",
      ThinVertStripe: "lightVertical",
      ThinReverseDiagStripe: "lightDown",
      ThinHorzCross: "lightGrid"
    };
    var Qm = ["numFmtId", "fillId", "fontId", "borderId", "xfId"],
      Zm = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
    var eC = function() {
      var e = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/,
        t = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/,
        i = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/,
        r = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/,
        s = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
      return function(n, o, a) {
        var l, c = {};
        return n ? ((l = (n = n.replace(/<!--([\s\S]*?)-->/gm, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "")).match(e)) && function(e, t, i) {
          t.NumberFmt = [];
          for (var r = ip(ud), s = 0; s < r.length; ++s) t.NumberFmt[r[s]] = ud[r[s]];
          var n = e[0].match(Hp);
          if (n)
            for (s = 0; s < n.length; ++s) {
              var o = Vp(n[s]);
              switch (Wp(o[0])) {
                case "<numFmts":
                case "</numFmts>":
                case "<numFmts/>":
                case "<numFmts>":
                case "</numFmt>":
                  break;
                case "<numFmt":
                  var a = Xp(nE(o.formatCode)),
                    l = parseInt(o.numFmtId, 10);
                  if (t.NumberFmt[l] = a, l > 0) {
                    if (l > 392) {
                      for (l = 392; l > 60 && null != t.NumberFmt[l]; --l);
                      t.NumberFmt[l] = a
                    }
                    Yd(a, l)
                  }
                  break;
                default:
                  if (i.WTF) throw new Error("unrecognized " + o[0] + " in numFmts")
              }
            }
        }(l, c, a), (l = n.match(r)) && function(e, t, i, r) {
          t.Fonts = [];
          var s = {},
            n = !1;
          (e[0].match(Hp) || []).forEach(function(e) {
            var o = Vp(e);
            switch (Wp(o[0])) {
              case "<fonts":
              case "<fonts>":
              case "</fonts>":
              case "<font":
              case "<font>":
              case "<name/>":
              case "</name>":
              case "<sz/>":
              case "</sz>":
              case "<vertAlign/>":
              case "</vertAlign>":
              case "<family/>":
              case "</family>":
              case "<scheme/>":
              case "</scheme>":
              case "<color/>":
              case "</color>":
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;
              case "</font>":
              case "<font/>":
                t.Fonts.push(s), s = {};
                break;
              case "<name":
                o.val && (s.name = nE(o.val));
                break;
              case "<b":
                s.bold = o.val ? eE(o.val) : 1;
                break;
              case "<b/>":
                s.bold = 1;
                break;
              case "<i":
                s.italic = o.val ? eE(o.val) : 1;
                break;
              case "<i/>":
                s.italic = 1;
                break;
              case "<u":
                switch (o.val) {
                  case "none":
                    s.underline = 0;
                    break;
                  case "single":
                    s.underline = 1;
                    break;
                  case "double":
                    s.underline = 2;
                    break;
                  case "singleAccounting":
                    s.underline = 33;
                    break;
                  case "doubleAccounting":
                    s.underline = 34
                }
                break;
              case "<u/>":
                s.underline = 1;
                break;
              case "<strike":
                s.strike = o.val ? eE(o.val) : 1;
                break;
              case "<strike/>":
                s.strike = 1;
                break;
              case "<outline":
                s.outline = o.val ? eE(o.val) : 1;
                break;
              case "<outline/>":
                s.outline = 1;
                break;
              case "<shadow":
                s.shadow = o.val ? eE(o.val) : 1;
                break;
              case "<shadow/>":
                s.shadow = 1;
                break;
              case "<condense":
                s.condense = o.val ? eE(o.val) : 1;
                break;
              case "<condense/>":
                s.condense = 1;
                break;
              case "<extend":
                s.extend = o.val ? eE(o.val) : 1;
                break;
              case "<extend/>":
                s.extend = 1;
                break;
              case "<sz":
                o.val && (s.sz = +o.val);
                break;
              case "<vertAlign":
                o.val && (s.vertAlign = o.val);
                break;
              case "<family":
                o.val && (s.family = parseInt(o.val, 10));
                break;
              case "<scheme":
                o.val && (s.scheme = o.val);
                break;
              case "<charset":
                if ("1" == o.val) break;
                o.codepage = wu[parseInt(o.val, 10)];
                break;
              case "<color":
                if (s.color || (s.color = {}), o.auto && (s.color.auto = eE(o.auto)), o.rgb) s.color.rgb = o.rgb.slice(-6);
                else if (o.indexed) {
                  s.color.index = parseInt(o.indexed, 10);
                  var a = df[s.color.index];
                  81 == s.color.index && (a = df[1]), a || (a = df[1]), s.color.rgb = a[0].toString(16) + a[1].toString(16) + a[2].toString(16)
                } else o.theme && (s.color.theme = parseInt(o.theme, 10), o.tint && (s.color.tint = parseFloat(o.tint)), o.theme && i.themeElements && i.themeElements.clrScheme && (s.color.rgb = Gm(i.themeElements.clrScheme[s.color.theme].rgb, s.color.tint || 0)));
                break;
              case "<AlternateContent":
              case "<ext":
                n = !0;
                break;
              case "</AlternateContent>":
              case "</ext>":
                n = !1;
                break;
              default:
                if (r && r.WTF && !n) throw new Error("unrecognized " + o[0] + " in fonts")
            }
          })
        }(l, c, o, a), (l = n.match(i)) && function(e, t, i, r) {
          t.Fills = [];
          var s = {},
            n = !1;
          (e[0].match(Hp) || []).forEach(function(e) {
            var i = Vp(e);
            switch (Wp(i[0])) {
              case "<fills":
              case "<fills>":
              case "</fills>":
              case "</fill>":
              case "<gradientFill>":
              case "<patternFill/>":
              case "</patternFill>":
              case "<bgColor/>":
              case "</bgColor>":
              case "<fgColor/>":
              case "</fgColor>":
              case "<stop":
              case "<stop/>":
              case "</stop>":
              case "<color":
              case "<color/>":
              case "</color>":
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;
              case "<fill>":
              case "<fill":
              case "<fill/>":
                s = {}, t.Fills.push(s);
                break;
              case "<gradientFill":
              case "</gradientFill>":
                t.Fills.push(s), s = {};
                break;
              case "<patternFill":
              case "<patternFill>":
                i.patternType && (s.patternType = i.patternType);
                break;
              case "<bgColor":
                s.bgColor || (s.bgColor = {}), i.indexed && (s.bgColor.indexed = parseInt(i.indexed, 10)), i.theme && (s.bgColor.theme = parseInt(i.theme, 10)), i.tint && (s.bgColor.tint = parseFloat(i.tint)), i.rgb && (s.bgColor.rgb = i.rgb.slice(-6));
                break;
              case "<fgColor":
                s.fgColor || (s.fgColor = {}), i.theme && (s.fgColor.theme = parseInt(i.theme, 10)), i.tint && (s.fgColor.tint = parseFloat(i.tint)), null != i.rgb && (s.fgColor.rgb = i.rgb.slice(-6));
                break;
              case "<ext":
                n = !0;
                break;
              case "</ext>":
                n = !1;
                break;
              default:
                if (r && r.WTF && !n) throw new Error("unrecognized " + i[0] + " in fills")
            }
          })
        }(l, c, 0, a), (l = n.match(s)) && function(e, t, i, r) {
          t.Borders = [];
          var s = {},
            n = !1;
          (e[0].match(Hp) || []).forEach(function(e) {
            var i = Vp(e);
            switch (Wp(i[0])) {
              case "<borders":
              case "<borders>":
              case "</borders>":
              case "</border>":
              case "<left/>":
              case "<left":
              case "<left>":
              case "</left>":
              case "<right/>":
              case "<right":
              case "<right>":
              case "</right>":
              case "<top/>":
              case "<top":
              case "<top>":
              case "</top>":
              case "<bottom/>":
              case "<bottom":
              case "<bottom>":
              case "</bottom>":
              case "<diagonal":
              case "<diagonal>":
              case "<diagonal/>":
              case "</diagonal>":
              case "<horizontal":
              case "<horizontal>":
              case "<horizontal/>":
              case "</horizontal>":
              case "<vertical":
              case "<vertical>":
              case "<vertical/>":
              case "</vertical>":
              case "<start":
              case "<start>":
              case "<start/>":
              case "</start>":
              case "<end":
              case "<end>":
              case "<end/>":
              case "</end>":
              case "<color":
              case "<color>":
              case "<color/>":
              case "</color>":
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;
              case "<border":
              case "<border>":
              case "<border/>":
                s = {}, i.diagonalUp && (s.diagonalUp = eE(i.diagonalUp)), i.diagonalDown && (s.diagonalDown = eE(i.diagonalDown)), t.Borders.push(s);
                break;
              case "<ext":
                n = !0;
                break;
              case "</ext>":
                n = !1;
                break;
              default:
                if (r && r.WTF && !n) throw new Error("unrecognized " + i[0] + " in borders")
            }
          })
        }(l, c, 0, a), (l = n.match(t)) && function(e, t, i) {
          var r;
          t.CellXf = [];
          var s = !1;
          (e[0].match(Hp) || []).forEach(function(e) {
            var n = Vp(e),
              o = 0;
            switch (Wp(n[0])) {
              case "<cellXfs":
              case "<cellXfs>":
              case "<cellXfs/>":
              case "</cellXfs>":
              case "</xf>":
              case "</alignment>":
              case "<protection":
              case "</protection>":
              case "<protection/>":
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;
              case "<xf":
              case "<xf/>":
                for (delete(r = n)[0], o = 0; o < Qm.length; ++o) r[Qm[o]] && (r[Qm[o]] = parseInt(r[Qm[o]], 10));
                for (o = 0; o < Zm.length; ++o) r[Zm[o]] && (r[Zm[o]] = eE(r[Zm[o]]));
                if (t.NumberFmt && r.numFmtId > 392)
                  for (o = 392; o > 60; --o)
                    if (t.NumberFmt[r.numFmtId] == t.NumberFmt[o]) {
                      r.numFmtId = o;
                      break
                    } t.CellXf.push(r);
                break;
              case "<alignment":
              case "<alignment/>":
                var a = {};
                n.vertical && (a.vertical = n.vertical), n.horizontal && (a.horizontal = n.horizontal), null != n.textRotation && (a.textRotation = n.textRotation), n.indent && (a.indent = n.indent), n.wrapText && (a.wrapText = eE(n.wrapText)), r.alignment = a;
                break;
              case "<AlternateContent":
              case "<ext":
                s = !0;
                break;
              case "</AlternateContent>":
              case "</ext>":
                s = !1;
                break;
              default:
                if (i && i.WTF && !s) throw new Error("unrecognized " + n[0] + " in cellXfs")
            }
          })
        }(l, c, a), c) : c
      }
    }();

    function tC(e, t) {
      var i, r = [xp, fE("styleSheet", null, {
        xmlns: RE[0],
        "xmlns:vt": SE.vt
      })];
      return e.SSF && null != (i = function(e) {
        var t = ["<numFmts>"];
        return [
          [5, 8],
          [23, 26],
          [41, 44],
          [50, 392]
        ].forEach(function(i) {
          for (var r = i[0]; r <= i[1]; ++r) null != e[r] && (t[t.length] = fE("numFmt", null, {
            numFmtId: r,
            formatCode: jp(e[r])
          }))
        }), 1 === t.length ? "" : (t[t.length] = "</numFmts>", t[0] = fE("numFmts", null, {
          count: t.length - 2
        }).replace("/>", ">"), t.join(""))
      }(e.SSF)) && (r[r.length] = i), r[r.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>', r[r.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>', r[r.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>', r[r.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>', (i = function(e) {
        var t = [];
        return t[t.length] = fE("cellXfs", null), e.forEach(function(e) {
          t[t.length] = fE("xf", null, e)
        }), t[t.length] = "</cellXfs>", 2 === t.length ? "" : (t[0] = fE("cellXfs", null, {
          count: t.length - 2
        }).replace("/>", ">"), t.join(""))
      }(t.cellXfs)) && (r[r.length] = i), r[r.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>', r[r.length] = '<dxfs count="0"/>', r[r.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>', r.length > 2 && (r[r.length] = "</styleSheet>", r[1] = r[1].replace("/>", ">")), r.join("")
    }

    function iC(e, t, i) {
      i || (i = ng(6 + 4 * t.length)), i.write_shift(2, e), yg(t, i);
      var r = i.length > i.l ? i.slice(0, i.l) : i;
      return null == i.l && (i.l = i.length), r
    }

    function rC(e, t) {
      t || (t = ng(153)), t.write_shift(2, 20 * e.sz),
        function(e, t) {
          t || (t = ng(2));
          var i = (e.italic ? 2 : 0) | (e.strike ? 8 : 0) | (e.outline ? 16 : 0) | (e.shadow ? 32 : 0) | (e.condense ? 64 : 0) | (e.extend ? 128 : 0);
          t.write_shift(1, i), t.write_shift(1, 0)
        }(e, t), t.write_shift(2, e.bold ? 700 : 400);
      var i = 0;
      "superscript" == e.vertAlign ? i = 1 : "subscript" == e.vertAlign && (i = 2), t.write_shift(2, i), t.write_shift(1, e.underline || 0), t.write_shift(1, e.family || 0), t.write_shift(1, e.charset || 0), t.write_shift(1, 0), Qg(e.color, t);
      var r = 0;
      return "major" == e.scheme && (r = 1), "minor" == e.scheme && (r = 2), t.write_shift(1, r), yg(e.name, t), t.length > t.l ? t.slice(0, t.l) : t
    }
    var sC, nC = ["none", "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625"],
      oC = sg;

    function aC(e, t) {
      t || (t = ng(84)), sC || (sC = sp(nC));
      var i = sC[e.patternType];
      null == i && (i = 40), t.write_shift(4, i);
      var r = 0;
      if (40 != i)
        for (Qg({
            auto: 1
          }, t), Qg({
            auto: 1
          }, t); r < 12; ++r) t.write_shift(4, 0);
      else {
        for (; r < 4; ++r) t.write_shift(4, 0);
        for (; r < 12; ++r) t.write_shift(4, 0)
      }
      return t.length > t.l ? t.slice(0, t.l) : t
    }

    function lC(e, t, i) {
      i || (i = ng(16)), i.write_shift(2, t || 0), i.write_shift(2, e.numFmtId || 0), i.write_shift(2, 0), i.write_shift(2, 0), i.write_shift(2, 0), i.write_shift(1, 0), i.write_shift(1, 0);
      return i.write_shift(1, 0), i.write_shift(1, 0), i.write_shift(1, 0), i.write_shift(1, 0), i
    }

    function cC(e, t) {
      return t || (t = ng(10)), t.write_shift(1, 0), t.write_shift(1, 0), t.write_shift(4, 0), t.write_shift(4, 0), t
    }
    var hC = sg;

    function uC(e) {
      var t;
      lg(e, 613, Lg(1)), lg(e, 46, (t || (t = ng(51)), t.write_shift(1, 0), cC(0, t), cC(0, t), cC(0, t), cC(0, t), cC(0, t), t.length > t.l ? t.slice(0, t.l) : t)), lg(e, 614)
    }

    function dC(e) {
      var t, i;
      lg(e, 619, Lg(1)), lg(e, 48, (t = {
        xfId: 0,
        builtinId: 0,
        name: "Normal"
      }, i || (i = ng(52)), i.write_shift(4, t.xfId), i.write_shift(2, 1), i.write_shift(1, +t.builtinId), i.write_shift(1, 0), Bg(t.name || "", i), i.length > i.l ? i.slice(0, i.l) : i)), lg(e, 620)
    }

    function pC(e) {
      lg(e, 508, function(e, t, i) {
        var r = ng(2052);
        return r.write_shift(4, e), Bg(t, r), Bg(i, r), r.length > r.l ? r.slice(0, r.l) : r
      }(0, "TableStyleMedium9", "PivotStyleMedium4")), lg(e, 509)
    }

    function EC(e, t) {
      var i = ag();
      return lg(i, 278),
        function(e, t) {
          if (t) {
            var i = 0;
            [
              [5, 8],
              [23, 26],
              [41, 44],
              [50, 392]
            ].forEach(function(e) {
              for (var r = e[0]; r <= e[1]; ++r) null != t[r] && ++i
            }), 0 != i && (lg(e, 615, Lg(i)), [
              [5, 8],
              [23, 26],
              [41, 44],
              [50, 392]
            ].forEach(function(i) {
              for (var r = i[0]; r <= i[1]; ++r) null != t[r] && lg(e, 44, iC(r, t[r]))
            }), lg(e, 616))
          }
        }(i, e.SSF),
        function(e) {
          lg(e, 611, Lg(1)), lg(e, 43, rC({
            sz: 12,
            color: {
              theme: 1
            },
            name: "Calibri",
            family: 2,
            scheme: "minor"
          })), lg(e, 612)
        }(i),
        function(e) {
          lg(e, 603, Lg(2)), lg(e, 45, aC({
            patternType: "none"
          })), lg(e, 45, aC({
            patternType: "gray125"
          })), lg(e, 604)
        }(i), uC(i),
        function(e) {
          lg(e, 626, Lg(1)), lg(e, 47, lC({
            numFmtId: 0,
            fontId: 0,
            fillId: 0,
            borderId: 0
          }, 65535)), lg(e, 627)
        }(i),
        function(e, t) {
          lg(e, 617, Lg(t.length)), t.forEach(function(t) {
            lg(e, 47, lC(t, 0))
          }), lg(e, 618)
        }(i, t.cellXfs), dC(i),
        function(e) {
          lg(e, 505, Lg(0)), lg(e, 506)
        }(i), pC(i), lg(i, 279), i.end()
    }
    var gC = ["</a:lt1>", "</a:dk1>", "</a:lt2>", "</a:dk2>", "</a:accent1>", "</a:accent2>", "</a:accent3>", "</a:accent4>", "</a:accent5>", "</a:accent6>", "</a:hlink>", "</a:folHlink>"];

    function fC(e, t, i) {
      t.themeElements.clrScheme = [];
      var r = {};
      (e[0].match(Hp) || []).forEach(function(e) {
        var s = Vp(e);
        switch (s[0]) {
          case "<a:clrScheme":
          case "</a:clrScheme>":
            break;
          case "<a:srgbClr":
            r.rgb = s.val;
            break;
          case "<a:sysClr":
            r.rgb = s.lastClr;
            break;
          case "<a:dk1>":
          case "</a:dk1>":
          case "<a:lt1>":
          case "</a:lt1>":
          case "<a:dk2>":
          case "</a:dk2>":
          case "<a:lt2>":
          case "</a:lt2>":
          case "<a:accent1>":
          case "</a:accent1>":
          case "<a:accent2>":
          case "</a:accent2>":
          case "<a:accent3>":
          case "</a:accent3>":
          case "<a:accent4>":
          case "</a:accent4>":
          case "<a:accent5>":
          case "</a:accent5>":
          case "<a:accent6>":
          case "</a:accent6>":
          case "<a:hlink>":
          case "</a:hlink>":
          case "<a:folHlink>":
          case "</a:folHlink>":
            "/" === s[0].charAt(1) ? (t.themeElements.clrScheme[gC.indexOf(s[0])] = r, r = {}) : r.name = s[0].slice(3, s[0].length - 1);
            break;
          default:
            if (i && i.WTF) throw new Error("Unrecognized " + s[0] + " in clrScheme")
        }
      })
    }

    function TC() {}

    function mC() {}
    var CC = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/,
      SC = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/,
      RC = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
    var AC = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;

    function vC(e, t) {
      var i;
      e && 0 !== e.length || (e = NC());
      var r = {};
      if (!(i = e.match(AC))) throw new Error("themeElements not found in theme");
      return function(e, t, i) {
        var r;
        t.themeElements = {}, [
          ["clrScheme", CC, fC],
          ["fontScheme", SC, TC],
          ["fmtScheme", RC, mC]
        ].forEach(function(s) {
          if (!(r = e.match(s[1]))) throw new Error(s[0] + " not found in themeElements");
          s[2](r, t, i)
        })
      }(i[0], r, t), r.raw = e, r
    }

    function NC(e, t) {
      if (t && t.themeXLSX) return t.themeXLSX;
      if (e && "string" == typeof e.raw) return e.raw;
      var i = [xp];
      return i[i.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', i[i.length] = "<a:themeElements>", i[i.length] = '<a:clrScheme name="Office">', i[i.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', i[i.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', i[i.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', i[i.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', i[i.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', i[i.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', i[i.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', i[i.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', i[i.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', i[i.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', i[i.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', i[i.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', i[i.length] = "</a:clrScheme>", i[i.length] = '<a:fontScheme name="Office">', i[i.length] = "<a:majorFont>", i[i.length] = '<a:latin typeface="Cambria"/>', i[i.length] = '<a:ea typeface=""/>', i[i.length] = '<a:cs typeface=""/>', i[i.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', i[i.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', i[i.length] = '<a:font script="Hans" typeface="宋体"/>', i[i.length] = '<a:font script="Hant" typeface="新細明體"/>', i[i.length] = '<a:font script="Arab" typeface="Times New Roman"/>', i[i.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', i[i.length] = '<a:font script="Thai" typeface="Tahoma"/>', i[i.length] = '<a:font script="Ethi" typeface="Nyala"/>', i[i.length] = '<a:font script="Beng" typeface="Vrinda"/>', i[i.length] = '<a:font script="Gujr" typeface="Shruti"/>', i[i.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', i[i.length] = '<a:font script="Knda" typeface="Tunga"/>', i[i.length] = '<a:font script="Guru" typeface="Raavi"/>', i[i.length] = '<a:font script="Cans" typeface="Euphemia"/>', i[i.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', i[i.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', i[i.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', i[i.length] = '<a:font script="Thaa" typeface="MV Boli"/>', i[i.length] = '<a:font script="Deva" typeface="Mangal"/>', i[i.length] = '<a:font script="Telu" typeface="Gautami"/>', i[i.length] = '<a:font script="Taml" typeface="Latha"/>', i[i.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', i[i.length] = '<a:font script="Orya" typeface="Kalinga"/>', i[i.length] = '<a:font script="Mlym" typeface="Kartika"/>', i[i.length] = '<a:font script="Laoo" typeface="DokChampa"/>', i[i.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', i[i.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', i[i.length] = '<a:font script="Viet" typeface="Times New Roman"/>', i[i.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', i[i.length] = '<a:font script="Geor" typeface="Sylfaen"/>', i[i.length] = "</a:majorFont>", i[i.length] = "<a:minorFont>", i[i.length] = '<a:latin typeface="Calibri"/>', i[i.length] = '<a:ea typeface=""/>', i[i.length] = '<a:cs typeface=""/>', i[i.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', i[i.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', i[i.length] = '<a:font script="Hans" typeface="宋体"/>', i[i.length] = '<a:font script="Hant" typeface="新細明體"/>', i[i.length] = '<a:font script="Arab" typeface="Arial"/>', i[i.length] = '<a:font script="Hebr" typeface="Arial"/>', i[i.length] = '<a:font script="Thai" typeface="Tahoma"/>', i[i.length] = '<a:font script="Ethi" typeface="Nyala"/>', i[i.length] = '<a:font script="Beng" typeface="Vrinda"/>', i[i.length] = '<a:font script="Gujr" typeface="Shruti"/>', i[i.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', i[i.length] = '<a:font script="Knda" typeface="Tunga"/>', i[i.length] = '<a:font script="Guru" typeface="Raavi"/>', i[i.length] = '<a:font script="Cans" typeface="Euphemia"/>', i[i.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', i[i.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', i[i.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', i[i.length] = '<a:font script="Thaa" typeface="MV Boli"/>', i[i.length] = '<a:font script="Deva" typeface="Mangal"/>', i[i.length] = '<a:font script="Telu" typeface="Gautami"/>', i[i.length] = '<a:font script="Taml" typeface="Latha"/>', i[i.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', i[i.length] = '<a:font script="Orya" typeface="Kalinga"/>', i[i.length] = '<a:font script="Mlym" typeface="Kartika"/>', i[i.length] = '<a:font script="Laoo" typeface="DokChampa"/>', i[i.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', i[i.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', i[i.length] = '<a:font script="Viet" typeface="Arial"/>', i[i.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', i[i.length] = '<a:font script="Geor" typeface="Sylfaen"/>', i[i.length] = "</a:minorFont>", i[i.length] = "</a:fontScheme>", i[i.length] = '<a:fmtScheme name="Office">', i[i.length] = "<a:fillStyleLst>", i[i.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', i[i.length] = '<a:gradFill rotWithShape="1">', i[i.length] = "<a:gsLst>", i[i.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', i[i.length] = "</a:gsLst>", i[i.length] = '<a:lin ang="16200000" scaled="1"/>', i[i.length] = "</a:gradFill>", i[i.length] = '<a:gradFill rotWithShape="1">', i[i.length] = "<a:gsLst>", i[i.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', i[i.length] = "</a:gsLst>", i[i.length] = '<a:lin ang="16200000" scaled="0"/>', i[i.length] = "</a:gradFill>", i[i.length] = "</a:fillStyleLst>", i[i.length] = "<a:lnStyleLst>", i[i.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', i[i.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', i[i.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', i[i.length] = "</a:lnStyleLst>", i[i.length] = "<a:effectStyleLst>", i[i.length] = "<a:effectStyle>", i[i.length] = "<a:effectLst>", i[i.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', i[i.length] = "</a:effectLst>", i[i.length] = "</a:effectStyle>", i[i.length] = "<a:effectStyle>", i[i.length] = "<a:effectLst>", i[i.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', i[i.length] = "</a:effectLst>", i[i.length] = "</a:effectStyle>", i[i.length] = "<a:effectStyle>", i[i.length] = "<a:effectLst>", i[i.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', i[i.length] = "</a:effectLst>", i[i.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', i[i.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', i[i.length] = "</a:effectStyle>", i[i.length] = "</a:effectStyleLst>", i[i.length] = "<a:bgFillStyleLst>", i[i.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', i[i.length] = '<a:gradFill rotWithShape="1">', i[i.length] = "<a:gsLst>", i[i.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', i[i.length] = "</a:gsLst>", i[i.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', i[i.length] = "</a:gradFill>", i[i.length] = '<a:gradFill rotWithShape="1">', i[i.length] = "<a:gsLst>", i[i.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', i[i.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', i[i.length] = "</a:gsLst>", i[i.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', i[i.length] = "</a:gradFill>", i[i.length] = "</a:bgFillStyleLst>", i[i.length] = "</a:fmtScheme>", i[i.length] = "</a:themeElements>", i[i.length] = "<a:objectDefaults>", i[i.length] = "<a:spDef>", i[i.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', i[i.length] = "</a:spDef>", i[i.length] = "<a:lnDef>", i[i.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', i[i.length] = "</a:lnDef>", i[i.length] = "</a:objectDefaults>", i[i.length] = "<a:extraClrSchemeLst/>", i[i.length] = "</a:theme>", i.join("")
    }

    function IC(e) {
      var t = {};
      switch (t.xclrType = e.read_shift(2), t.nTintShade = e.read_shift(2), t.xclrType) {
        case 0:
        case 4:
          e.l += 4;
          break;
        case 1:
          t.xclrValue = function(e, t) {
            return sg(e, t)
          }(e, 4);
          break;
        case 2:
          t.xclrValue = RT(e);
          break;
        case 3:
          t.xclrValue = function(e) {
            return e.read_shift(4)
          }(e)
      }
      return e.l += 8, t
    }

    function OC(e) {
      var t = e.read_shift(2),
        i = e.read_shift(2) - 4,
        r = [t];
      switch (t) {
        case 4:
        case 5:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 13:
          r[1] = IC(e);
          break;
        case 6:
          r[1] = function(e, t) {
            return sg(e, t)
          }(e, i);
          break;
        case 14:
        case 15:
          r[1] = e.read_shift(1 === i ? 1 : 2);
          break;
        default:
          throw new Error("Unrecognized ExtProp type: " + t + " " + i)
      }
      return r
    }

    function LC(e, t) {
      t.forEach(function(e) {
        e[0]
      })
    }

    function _C() {
      var e, t, i = ag();
      return lg(i, 332), lg(i, 334, Lg(1)), lg(i, 335, ((t = ng(12 + 2 * (e = {
        name: "XLDAPR",
        version: 12e4,
        flags: 3496657072
      }).name.length)).write_shift(4, e.flags), t.write_shift(4, e.version), yg(e.name, t), t.slice(0, t.l))), lg(i, 336), lg(i, 339, function(e, t) {
        var i = ng(8 + 2 * t.length);
        return i.write_shift(4, e), yg(t, i), i.slice(0, i.l)
      }(1, "XLDAPR")), lg(i, 52), lg(i, 35, Lg(514)), lg(i, 4096, Lg(0)), lg(i, 4097, aT(1)), lg(i, 36), lg(i, 53), lg(i, 340), lg(i, 337, function(e, t) {
        var i = ng(8);
        return i.write_shift(4, e), i.write_shift(4, t ? 1 : 0), i
      }(1, !0)), lg(i, 51, function(e) {
        var t = ng(4 + 8 * e.length);
        t.write_shift(4, e.length);
        for (var i = 0; i < e.length; ++i) t.write_shift(4, e[i][0]), t.write_shift(4, e[i][1]);
        return t
      }([
        [1, 0]
      ])), lg(i, 338), lg(i, 333), i.end()
    }

    function yC() {
      var e = [xp];
      return e.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>'), e.join("")
    }
    var wC = 1024;

    function DC(e, t) {
      for (var i = [21600, 21600], r = ["m0,0l0", i[1], i[0], i[1], i[0], "0xe"].join(","), s = [fE("xml", null, {
          "xmlns:v": AE.v,
          "xmlns:o": AE.o,
          "xmlns:x": AE.x,
          "xmlns:mv": AE.mv
        }).replace(/\/>/, ">"), fE("o:shapelayout", fE("o:idmap", null, {
          "v:ext": "edit",
          data: e
        }), {
          "v:ext": "edit"
        }), fE("v:shapetype", [fE("v:stroke", null, {
          joinstyle: "miter"
        }), fE("v:path", null, {
          gradientshapeok: "t",
          "o:connecttype": "rect"
        })].join(""), {
          id: "_x0000_t202",
          "o:spt": 202,
          coordsize: i.join(","),
          path: r
        })]; wC < 1e3 * e;) wC += 1e3;
      return t.forEach(function(e) {
        var t = Tg(e[0]),
          i = {
            color2: "#BEFF82",
            type: "gradient"
          };
        "gradient" == i.type && (i.angle = "-180");
        var r = "gradient" == i.type ? fE("o:fill", null, {
            type: "gradientUnscaled",
            "v:ext": "view"
          }) : null,
          n = fE("v:fill", r, i);
        ++wC, s = s.concat(["<v:shape" + gE({
          id: "_x0000_s" + wC,
          type: "#_x0000_t202",
          style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (e[1].hidden ? ";visibility:hidden" : ""),
          fillcolor: "#ECFAD4",
          strokecolor: "#edeaa1"
        }) + ">", n, fE("v:shadow", null, {
          on: "t",
          obscured: "t"
        }), fE("v:path", null, {
          "o:connecttype": "none"
        }), '<v:textbox><div style="text-align:left"></div></v:textbox>', '<x:ClientData ObjectType="Note">', "<x:MoveWithCells/>", "<x:SizeWithCells/>", EE("x:Anchor", [t.c + 1, 0, t.r + 1, 0, t.c + 3, 20, t.r + 5, 20].join(",")), EE("x:AutoFill", "False"), EE("x:Row", String(t.r)), EE("x:Column", String(t.c)), e[1].hidden ? "" : "<x:Visible/>", "</x:ClientData>", "</v:shape>"])
      }), s.push("</xml>"), s.join("")
    }

    function PC(e, t, i, r) {
      var s, n = Array.isArray(e);
      t.forEach(function(t) {
        var o = Tg(t.ref);
        if (n ? (e[o.r] || (e[o.r] = []), s = e[o.r][o.c]) : s = e[t.ref], !s) {
          s = {
            t: "z"
          }, n ? e[o.r][o.c] = s : e[t.ref] = s;
          var a = Rg(e["!ref"] || "BDWGO1000001:A1");
          a.s.r > o.r && (a.s.r = o.r), a.e.r < o.r && (a.e.r = o.r), a.s.c > o.c && (a.s.c = o.c), a.e.c < o.c && (a.e.c = o.c);
          var l = Sg(a);
          l !== e["!ref"] && (e["!ref"] = l)
        }
        s.c || (s.c = []);
        var c = {
          a: t.author,
          t: t.t,
          r: t.r,
          T: i
        };
        t.h && (c.h = t.h);
        for (var h = s.c.length - 1; h >= 0; --h) {
          if (!i && s.c[h].T) return;
          i && !s.c[h].T && s.c.splice(h, 1)
        }
        if (i && r)
          for (h = 0; h < r.length; ++h)
            if (c.a == r[h].id) {
              c.a = r[h].name || c.a;
              break
            } s.c.push(c)
      })
    }

    function bC(e) {
      var t = [xp, fE("comments", null, {
          xmlns: RE[0]
        })],
        i = [];
      return t.push("<authors>"), e.forEach(function(e) {
        e[1].forEach(function(e) {
          var r = jp(e.a); - 1 == i.indexOf(r) && (i.push(r), t.push("<author>" + r + "</author>")), e.T && e.ID && -1 == i.indexOf("tc=" + e.ID) && (i.push("tc=" + e.ID), t.push("<author>tc=" + e.ID + "</author>"))
        })
      }), 0 == i.length && (i.push("SheetJ5"), t.push("<author>SheetJ5</author>")), t.push("</authors>"), t.push("<commentList>"), e.forEach(function(e) {
        var r = 0,
          s = [];
        if (e[1][0] && e[1][0].T && e[1][0].ID ? r = i.indexOf("tc=" + e[1][0].ID) : e[1].forEach(function(e) {
            e.a && (r = i.indexOf(jp(e.a))), s.push(e.t || "")
          }), t.push('<comment ref="' + e[0] + '" authorId="' + r + '"><text>'), s.length <= 1) t.push(EE("t", jp(s[0] || "")));
        else {
          for (var n = "Comment:\n    " + s[0] + "\n", o = 1; o < s.length; ++o) n += "Reply:\n    " + s[o] + "\n";
          t.push(EE("t", jp(n)))
        }
        t.push("</text></comment>")
      }), t.push("</commentList>"), t.length > 2 && (t[t.length] = "</comments>", t[1] = t[1].replace("/>", ">")), t.join("")
    }

    function MC(e, t, i) {
      var r = [xp, fE("ThreadedComments", null, {
        xmlns: SE.TCMNT
      }).replace(/[\/]>/, ">")];
      return e.forEach(function(e) {
        var s = "";
        (e[1] || []).forEach(function(n, o) {
          if (n.T) {
            n.a && -1 == t.indexOf(n.a) && t.push(n.a);
            var a = {
              ref: e[0],
              id: "{54EE7951-7262-4200-6969-" + ("000000000000" + i.tcid++).slice(-12) + "}"
            };
            0 == o ? s = a.id : a.parentId = s, n.ID = a.id, n.a && (a.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + t.indexOf(n.a)).slice(-12) + "}"), r.push(fE("threadedComment", EE("text", n.t || ""), a))
          } else delete n.ID
        })
      }), r.push("</ThreadedComments>"), r.join("")
    }
    var FC = _g;

    function xC(e) {
      var t = ag(),
        i = [];
      return lg(t, 628), lg(t, 630), e.forEach(function(e) {
        e[1].forEach(function(e) {
          i.indexOf(e.a) > -1 || (i.push(e.a.slice(0, 54)), lg(t, 632, function(e) {
            return yg(e.slice(0, 54))
          }(e.a)))
        })
      }), lg(t, 631), lg(t, 633), e.forEach(function(e) {
        e[1].forEach(function(r) {
          r.iauthor = i.indexOf(r.a);
          var s = {
            s: Tg(e[0]),
            e: Tg(e[0])
          };
          lg(t, 635, function(e, t) {
            return null == t && (t = ng(36)), t.write_shift(4, e[1].iauthor), jg(e[0], t), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(4, 0), t
          }([s, r])), r.t && r.t.length > 0 && lg(t, 637, bg(r)), lg(t, 636), delete r.iauthor
        })
      }), lg(t, 634), lg(t, 629), t.end()
    }
    var GC = "application/vnd.ms-office.vbaProject";
    var UC = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
    var HC = function() {
        var e = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g,
          t = {
            r: 0,
            c: 0
          };

        function i(e, i, r, s) {
          var n = !1,
            o = !1;
          0 == r.length ? o = !0 : "[" == r.charAt(0) && (o = !0, r = r.slice(1, -1)), 0 == s.length ? n = !0 : "[" == s.charAt(0) && (n = !0, s = s.slice(1, -1));
          var a = r.length > 0 ? 0 | parseInt(r, 10) : 0,
            l = s.length > 0 ? 0 | parseInt(s, 10) : 0;
          return n ? l += t.c : --l, o ? a += t.r : --a, i + (n ? "" : "$") + fg(l) + (o ? "" : "$") + Eg(a)
        }
        return function(r, s) {
          return t = s, r.replace(e, i)
        }
      }(),
      kC = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g,
      BC = function() {
        return function(e, t) {
          return e.replace(kC, function(e, i, r, s, n, o) {
            var a = gg(s) - (r ? 0 : t.c),
              l = pg(o) - (n ? 0 : t.r);
            return i + "R" + (0 == l ? "" : n ? l + 1 : "[" + l + "]") + "C" + (0 == a ? "" : r ? a + 1 : "[" + a + "]")
          })
        }
      }();

    function VC(e, t) {
      return e.replace(kC, function(e, i, r, s, n, o) {
        return i + ("$" == r ? r + s : fg(gg(s) + t.c)) + ("$" == n ? n + o : Eg(pg(o) + t.r))
      })
    }

    function WC(e, t, i) {
      var r = Cg(t).s,
        s = Tg(i);
      return VC(e, {
        r: s.r - r.r,
        c: s.c - r.c
      })
    }

    function YC(e) {
      return e.replace(/_xlfn\./g, "")
    }

    function KC(e) {
      e.l += 1
    }

    function XC(e, t) {
      var i = e.read_shift(1 == t ? 1 : 2);
      return [16383 & i, i >> 14 & 1, i >> 15 & 1]
    }

    function zC(e, t, i) {
      var r = 2;
      if (i) {
        if (i.biff >= 2 && i.biff <= 5) return $C(e);
        12 == i.biff && (r = 4)
      }
      var s = e.read_shift(r),
        n = e.read_shift(r),
        o = XC(e, 2),
        a = XC(e, 2);
      return {
        s: {
          r: s,
          c: o[0],
          cRel: o[1],
          rRel: o[2]
        },
        e: {
          r: n,
          c: a[0],
          cRel: a[1],
          rRel: a[2]
        }
      }
    }

    function $C(e) {
      var t = XC(e, 2),
        i = XC(e, 2),
        r = e.read_shift(1),
        s = e.read_shift(1);
      return {
        s: {
          r: t[0],
          c: r,
          cRel: t[1],
          rRel: t[2]
        },
        e: {
          r: i[0],
          c: s,
          cRel: i[1],
          rRel: i[2]
        }
      }
    }

    function jC(e, t, i) {
      if (i && i.biff >= 2 && i.biff <= 5) return function(e) {
        var t = XC(e, 2),
          i = e.read_shift(1);
        return {
          r: t[0],
          c: i,
          cRel: t[1],
          rRel: t[2]
        }
      }(e);
      var r = e.read_shift(i && 12 == i.biff ? 4 : 2),
        s = XC(e, 2);
      return {
        r,
        c: s[0],
        cRel: s[1],
        rRel: s[2]
      }
    }

    function JC(e) {
      var t = e.read_shift(2),
        i = e.read_shift(2);
      return {
        r: t,
        c: 255 & i,
        fQuoted: !!(16384 & i),
        cRel: i >> 15,
        rRel: i >> 15
      }
    }

    function qC(e) {
      var t = 1 & e[e.l + 1];
      return e.l += 4, [t, 1]
    }

    function QC(e) {
      return [e.read_shift(1), e.read_shift(1)]
    }

    function ZC(e, t) {
      var i = [e.read_shift(1)];
      if (12 == t) switch (i[0]) {
        case 2:
          i[0] = 4;
          break;
        case 4:
          i[0] = 16;
          break;
        case 0:
          i[0] = 1;
          break;
        case 1:
          i[0] = 2
      }
      switch (i[0]) {
        case 4:
          i[1] = sT(e, 1) ? "TRUE" : "FALSE", 12 != t && (e.l += 7);
          break;
        case 37:
        case 16:
          i[1] = pf[e[e.l]], e.l += 12 == t ? 4 : 8;
          break;
        case 0:
          e.l += 8;
          break;
        case 1:
          i[1] = Jg(e);
          break;
        case 2:
          i[1] = gT(e, 0, {
            biff: t > 0 && t < 8 ? 2 : t
          });
          break;
        default:
          throw new Error("Bad SerAr: " + i[0])
      }
      return i
    }

    function eS(e, t, i) {
      for (var r = e.read_shift(12 == i.biff ? 4 : 2), s = [], n = 0; n != r; ++n) s.push((12 == i.biff ? $g : LT)(e, 8));
      return s
    }

    function tS(e, t, i) {
      var r = 0,
        s = 0;
      12 == i.biff ? (r = e.read_shift(4), s = e.read_shift(4)) : (s = 1 + e.read_shift(1), r = 1 + e.read_shift(2)), i.biff >= 2 && i.biff < 8 && (--r, 0 == --s && (s = 256));
      for (var n = 0, o = []; n != r && (o[n] = []); ++n)
        for (var a = 0; a != s; ++a) o[n][a] = ZC(e, i.biff);
      return o
    }

    function iS(e, t, i) {
      return e.l += 2, [JC(e)]
    }

    function rS(e) {
      return e.l += 6, []
    }

    function sS(e) {
      return e.l += 2, [oT(e), 1 & e.read_shift(2)]
    }
    var nS = ["Data", "All", "Headers", "??", "?Data2", "??", "?DataHeaders", "??", "Totals", "??", "??", "??", "?DataTotals", "??", "??", "??", "?Current"];
    var oS = {
        1: {
          n: "PtgExp",
          f: function(e, t, i) {
            return e.l++, i && 12 == i.biff ? [e.read_shift(4, "i"), 0] : [e.read_shift(2), e.read_shift(i && 2 == i.biff ? 1 : 2)]
          }
        },
        2: {
          n: "PtgTbl",
          f: sg
        },
        3: {
          n: "PtgAdd",
          f: KC
        },
        4: {
          n: "PtgSub",
          f: KC
        },
        5: {
          n: "PtgMul",
          f: KC
        },
        6: {
          n: "PtgDiv",
          f: KC
        },
        7: {
          n: "PtgPower",
          f: KC
        },
        8: {
          n: "PtgConcat",
          f: KC
        },
        9: {
          n: "PtgLt",
          f: KC
        },
        10: {
          n: "PtgLe",
          f: KC
        },
        11: {
          n: "PtgEq",
          f: KC
        },
        12: {
          n: "PtgGe",
          f: KC
        },
        13: {
          n: "PtgGt",
          f: KC
        },
        14: {
          n: "PtgNe",
          f: KC
        },
        15: {
          n: "PtgIsect",
          f: KC
        },
        16: {
          n: "PtgUnion",
          f: KC
        },
        17: {
          n: "PtgRange",
          f: KC
        },
        18: {
          n: "PtgUplus",
          f: KC
        },
        19: {
          n: "PtgUminus",
          f: KC
        },
        20: {
          n: "PtgPercent",
          f: KC
        },
        21: {
          n: "PtgParen",
          f: KC
        },
        22: {
          n: "PtgMissArg",
          f: KC
        },
        23: {
          n: "PtgStr",
          f: function(e, t, i) {
            return e.l++, hT(e, 0, i)
          }
        },
        26: {
          n: "PtgSheet",
          f: function(e, t, i) {
            return e.l += 5, e.l += 2, e.l += 2 == i.biff ? 1 : 4, ["PTGSHEET"]
          }
        },
        27: {
          n: "PtgEndSheet",
          f: function(e, t, i) {
            return e.l += 2 == i.biff ? 4 : 5, ["PTGENDSHEET"]
          }
        },
        28: {
          n: "PtgErr",
          f: function(e) {
            return e.l++, pf[e.read_shift(1)]
          }
        },
        29: {
          n: "PtgBool",
          f: function(e) {
            return e.l++, 0 !== e.read_shift(1)
          }
        },
        30: {
          n: "PtgInt",
          f: function(e) {
            return e.l++, e.read_shift(2)
          }
        },
        31: {
          n: "PtgNum",
          f: function(e) {
            return e.l++, Jg(e)
          }
        },
        32: {
          n: "PtgArray",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5;
            return e.l += 2 == i.biff ? 6 : 12 == i.biff ? 14 : 7, [r]
          }
        },
        33: {
          n: "PtgFunc",
          f: function(e, t, i) {
            var r = (96 & e[e.l]) >> 5;
            e.l += 1;
            var s = e.read_shift(i && i.biff <= 3 ? 1 : 2);
            return [_S[s], LS[s], r]
          }
        },
        34: {
          n: "PtgFuncVar",
          f: function(e, t, i) {
            var r = e[e.l++],
              s = e.read_shift(1),
              n = i && i.biff <= 3 ? [88 == r ? -1 : 0, e.read_shift(1)] : function(e) {
                return [e[e.l + 1] >> 7, 32767 & e.read_shift(2)]
              }(e);
            return [s, (0 === n[0] ? LS : OS)[n[1]]]
          }
        },
        35: {
          n: "PtgName",
          f: function(e, t, i) {
            var r = e.read_shift(1) >>> 5 & 3,
              s = !i || i.biff >= 8 ? 4 : 2,
              n = e.read_shift(s);
            switch (i.biff) {
              case 2:
                e.l += 5;
                break;
              case 3:
              case 4:
                e.l += 8;
                break;
              case 5:
                e.l += 12
            }
            return [r, 0, n]
          }
        },
        36: {
          n: "PtgRef",
          f: function(e, t, i) {
            var r = (96 & e[e.l]) >> 5;
            return e.l += 1, [r, jC(e, 0, i)]
          }
        },
        37: {
          n: "PtgArea",
          f: function(e, t, i) {
            return [(96 & e[e.l++]) >> 5, zC(e, i.biff >= 2 && i.biff, i)]
          }
        },
        38: {
          n: "PtgMemArea",
          f: function(e, t, i) {
            var r = e.read_shift(1) >>> 5 & 3;
            return e.l += i && 2 == i.biff ? 3 : 4, [r, e.read_shift(i && 2 == i.biff ? 1 : 2)]
          }
        },
        39: {
          n: "PtgMemErr",
          f: sg
        },
        40: {
          n: "PtgMemNoMem",
          f: sg
        },
        41: {
          n: "PtgMemFunc",
          f: function(e, t, i) {
            return [e.read_shift(1) >>> 5 & 3, e.read_shift(i && 2 == i.biff ? 1 : 2)]
          }
        },
        42: {
          n: "PtgRefErr",
          f: function(e, t, i) {
            var r = e.read_shift(1) >>> 5 & 3;
            return e.l += 4, i.biff < 8 && e.l--, 12 == i.biff && (e.l += 2), [r]
          }
        },
        43: {
          n: "PtgAreaErr",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5;
            return e.l += i && i.biff > 8 ? 12 : i.biff < 8 ? 6 : 8, [r]
          }
        },
        44: {
          n: "PtgRefN",
          f: function(e, t, i) {
            var r = (96 & e[e.l]) >> 5;
            e.l += 1;
            var s = function(e, t, i) {
              var r = i && i.biff ? i.biff : 8;
              if (r >= 2 && r <= 5) return function(e) {
                var t = e.read_shift(2),
                  i = e.read_shift(1),
                  r = (32768 & t) >> 15,
                  s = (16384 & t) >> 14;
                return t &= 16383, 1 == r && t >= 8192 && (t -= 16384), 1 == s && i >= 128 && (i -= 256), {
                  r: t,
                  c: i,
                  cRel: s,
                  rRel: r
                }
              }(e);
              var s = e.read_shift(r >= 12 ? 4 : 2),
                n = e.read_shift(2),
                o = (16384 & n) >> 14,
                a = (32768 & n) >> 15;
              if (n &= 16383, 1 == a)
                for (; s > 524287;) s -= 1048576;
              if (1 == o)
                for (; n > 8191;) n -= 16384;
              return {
                r: s,
                c: n,
                cRel: o,
                rRel: a
              }
            }(e, 0, i);
            return [r, s]
          }
        },
        45: {
          n: "PtgAreaN",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5,
              s = function(e, t, i) {
                if (i.biff < 8) return $C(e);
                var r = e.read_shift(12 == i.biff ? 4 : 2),
                  s = e.read_shift(12 == i.biff ? 4 : 2),
                  n = XC(e, 2),
                  o = XC(e, 2);
                return {
                  s: {
                    r,
                    c: n[0],
                    cRel: n[1],
                    rRel: n[2]
                  },
                  e: {
                    r: s,
                    c: o[0],
                    cRel: o[1],
                    rRel: o[2]
                  }
                }
              }(e, 0, i);
            return [r, s]
          }
        },
        46: {
          n: "PtgMemAreaN",
          f: function(e) {
            return [e.read_shift(1) >>> 5 & 3, e.read_shift(2)]
          }
        },
        47: {
          n: "PtgMemNoMemN",
          f: function(e) {
            return [e.read_shift(1) >>> 5 & 3, e.read_shift(2)]
          }
        },
        57: {
          n: "PtgNameX",
          f: function(e, t, i) {
            return 5 == i.biff ? function(e) {
              var t = e.read_shift(1) >>> 5 & 3,
                i = e.read_shift(2, "i");
              e.l += 8;
              var r = e.read_shift(2);
              return e.l += 12, [t, i, r]
            }(e) : [e.read_shift(1) >>> 5 & 3, e.read_shift(2), e.read_shift(4)]
          }
        },
        58: {
          n: "PtgRef3d",
          f: function(e, t, i) {
            var r = (96 & e[e.l]) >> 5;
            e.l += 1;
            var s = e.read_shift(2);
            return i && 5 == i.biff && (e.l += 12), [r, s, jC(e, 0, i)]
          }
        },
        59: {
          n: "PtgArea3d",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5,
              s = e.read_shift(2, "i");
            if (i) switch (i.biff) {
              case 5:
                e.l += 12;
                break;
              case 12:
                0
            }
            return [r, s, zC(e, 0, i)]
          }
        },
        60: {
          n: "PtgRefErr3d",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5,
              s = e.read_shift(2),
              n = 4;
            if (i) switch (i.biff) {
              case 5:
                n = 15;
                break;
              case 12:
                n = 6
            }
            return e.l += n, [r, s]
          }
        },
        61: {
          n: "PtgAreaErr3d",
          f: function(e, t, i) {
            var r = (96 & e[e.l++]) >> 5,
              s = e.read_shift(2),
              n = 8;
            if (i) switch (i.biff) {
              case 5:
                e.l += 12, n = 6;
                break;
              case 12:
                n = 12
            }
            return e.l += n, [r, s]
          }
        },
        255: {}
      },
      aS = {
        64: 32,
        96: 32,
        65: 33,
        97: 33,
        66: 34,
        98: 34,
        67: 35,
        99: 35,
        68: 36,
        100: 36,
        69: 37,
        101: 37,
        70: 38,
        102: 38,
        71: 39,
        103: 39,
        72: 40,
        104: 40,
        73: 41,
        105: 41,
        74: 42,
        106: 42,
        75: 43,
        107: 43,
        76: 44,
        108: 44,
        77: 45,
        109: 45,
        78: 46,
        110: 46,
        79: 47,
        111: 47,
        88: 34,
        120: 34,
        89: 57,
        121: 57,
        90: 58,
        122: 58,
        91: 59,
        123: 59,
        92: 60,
        124: 60,
        93: 61,
        125: 61
      },
      lS = {
        1: {
          n: "PtgElfLel",
          f: sS
        },
        2: {
          n: "PtgElfRw",
          f: iS
        },
        3: {
          n: "PtgElfCol",
          f: iS
        },
        6: {
          n: "PtgElfRwV",
          f: iS
        },
        7: {
          n: "PtgElfColV",
          f: iS
        },
        10: {
          n: "PtgElfRadical",
          f: iS
        },
        11: {
          n: "PtgElfRadicalS",
          f: rS
        },
        13: {
          n: "PtgElfColS",
          f: rS
        },
        15: {
          n: "PtgElfColSV",
          f: rS
        },
        16: {
          n: "PtgElfRadicalLel",
          f: sS
        },
        25: {
          n: "PtgList",
          f: function(e) {
            e.l += 2;
            var t = e.read_shift(2),
              i = e.read_shift(2),
              r = e.read_shift(4),
              s = e.read_shift(2),
              n = e.read_shift(2);
            return {
              ixti: t,
              coltype: 3 & i,
              rt: nS[i >> 2 & 31],
              idx: r,
              c: s,
              C: n
            }
          }
        },
        29: {
          n: "PtgSxName",
          f: function(e) {
            return e.l += 2, [e.read_shift(4)]
          }
        },
        255: {}
      },
      cS = {
        0: {
          n: "PtgAttrNoop",
          f: function(e) {
            return e.l += 4, [0, 0]
          }
        },
        1: {
          n: "PtgAttrSemi",
          f: function(e, t, i) {
            var r = 255 & e[e.l + 1] ? 1 : 0;
            return e.l += i && 2 == i.biff ? 3 : 4, [r]
          }
        },
        2: {
          n: "PtgAttrIf",
          f: function(e, t, i) {
            var r = 255 & e[e.l + 1] ? 1 : 0;
            return e.l += 2, [r, e.read_shift(i && 2 == i.biff ? 1 : 2)]
          }
        },
        4: {
          n: "PtgAttrChoose",
          f: function(e, t, i) {
            e.l += 2;
            for (var r = e.read_shift(i && 2 == i.biff ? 1 : 2), s = [], n = 0; n <= r; ++n) s.push(e.read_shift(i && 2 == i.biff ? 1 : 2));
            return s
          }
        },
        8: {
          n: "PtgAttrGoto",
          f: function(e, t, i) {
            var r = 255 & e[e.l + 1] ? 1 : 0;
            return e.l += 2, [r, e.read_shift(i && 2 == i.biff ? 1 : 2)]
          }
        },
        16: {
          n: "PtgAttrSum",
          f: function(e, t, i) {
            e.l += i && 2 == i.biff ? 3 : 4
          }
        },
        32: {
          n: "PtgAttrBaxcel",
          f: qC
        },
        33: {
          n: "PtgAttrBaxcel",
          f: qC
        },
        64: {
          n: "PtgAttrSpace",
          f: function(e) {
            return e.read_shift(2), QC(e)
          }
        },
        65: {
          n: "PtgAttrSpaceSemi",
          f: function(e) {
            return e.read_shift(2), QC(e)
          }
        },
        128: {
          n: "PtgAttrIfError",
          f: function(e) {
            var t = 255 & e[e.l + 1] ? 1 : 0;
            return e.l += 2, [t, e.read_shift(2)]
          }
        },
        255: {}
      };

    function hS(e, t, i, r) {
      if (r.biff < 8) return sg(e, t);
      for (var s = e.l + t, n = [], o = 0; o !== i.length; ++o) switch (i[o][0]) {
        case "PtgArray":
          i[o][1] = tS(e, 0, r), n.push(i[o][1]);
          break;
        case "PtgMemArea":
          i[o][2] = eS(e, i[o][1], r), n.push(i[o][2]);
          break;
        case "PtgExp":
          r && 12 == r.biff && (i[o][1][1] = e.read_shift(4), n.push(i[o][1]));
          break;
        case "PtgList":
        case "PtgElfRadicalS":
        case "PtgElfColS":
        case "PtgElfColSV":
          throw "Unsupported " + i[o][0]
      }
      return 0 !== (t = s - e.l) && n.push(sg(e, t)), n
    }

    function uS(e, t, i) {
      for (var r, s, n = e.l + t, o = []; n != e.l;) t = n - e.l, s = e[e.l], r = oS[s] || oS[aS[s]], 24 !== s && 25 !== s || (r = (24 === s ? lS : cS)[e[e.l + 1]]), r && r.f ? o.push([r.n, r.f(e, t, i)]) : sg(e, t);
      return o
    }

    function dS(e) {
      for (var t = [], i = 0; i < e.length; ++i) {
        for (var r = e[i], s = [], n = 0; n < r.length; ++n) {
          var o = r[n];
          if (o)
            if (2 === o[0]) s.push('"' + o[1].replace(/"/g, '""') + '"');
            else s.push(o[1]);
          else s.push("")
        }
        t.push(s.join(","))
      }
      return t.join(";")
    }
    var pS = {
      PtgAdd: "+",
      PtgConcat: "&",
      PtgDiv: "/",
      PtgEq: "=",
      PtgGe: ">=",
      PtgGt: ">",
      PtgLe: "<=",
      PtgLt: "<",
      PtgMul: "*",
      PtgNe: "<>",
      PtgPower: "^",
      PtgSub: "-"
    };

    function ES(e, t, i) {
      if (!e) return "SH33TJSERR0";
      if (i.biff > 8 && (!e.XTI || !e.XTI[t])) return e.SheetNames[t];
      if (!e.XTI) return "SH33TJSERR6";
      var r = e.XTI[t];
      if (i.biff < 8) return t > 1e4 && (t -= 65536), t < 0 && (t = -t), 0 == t ? "" : e.XTI[t - 1];
      if (!r) return "SH33TJSERR1";
      var s = "";
      if (i.biff > 8) switch (e[r[0]][0]) {
        case 357:
          return s = -1 == r[1] ? "#REF" : e.SheetNames[r[1]], r[1] == r[2] ? s : s + ":" + e.SheetNames[r[2]];
        case 358:
          return null != i.SID ? e.SheetNames[i.SID] : "SH33TJSSAME" + e[r[0]][0];
        default:
          return "SH33TJSSRC" + e[r[0]][0]
      }
      switch (e[r[0]][0][0]) {
        case 1025:
          return s = -1 == r[1] ? "#REF" : e.SheetNames[r[1]] || "SH33TJSERR3", r[1] == r[2] ? s : s + ":" + e.SheetNames[r[2]];
        case 14849:
          return e[r[0]].slice(1).map(function(e) {
            return e.Name
          }).join(";;");
        default:
          return e[r[0]][0][3] ? (s = -1 == r[1] ? "#REF" : e[r[0]][0][3][r[1]] || "SH33TJSERR4", r[1] == r[2] ? s : s + ":" + e[r[0]][0][3][r[2]]) : "SH33TJSERR2"
      }
    }

    function gS(e, t, i) {
      var r = ES(e, t, i);
      return "#REF" == r ? r : function(e, t) {
        if (!(e || t && t.biff <= 5 && t.biff >= 2)) throw new Error("empty sheet name");
        return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(e) ? "'" + e + "'" : e
      }(r, i)
    }

    function fS(e, t, i, r, s) {
      var n, o, a, l, c = s && s.biff || 8,
        h = {
          s: {
            c: 0,
            r: 0
          },
          e: {
            c: 0,
            r: 0
          }
        },
        u = [],
        d = 0,
        p = 0,
        E = "";
      if (!e[0] || !e[0][0]) return "";
      for (var g = -1, f = "", T = 0, m = e[0].length; T < m; ++T) {
        var C = e[0][T];
        switch (C[0]) {
          case "PtgUminus":
            u.push("-" + u.pop());
            break;
          case "PtgUplus":
            u.push("+" + u.pop());
            break;
          case "PtgPercent":
            u.push(u.pop() + "%");
            break;
          case "PtgAdd":
          case "PtgConcat":
          case "PtgDiv":
          case "PtgEq":
          case "PtgGe":
          case "PtgGt":
          case "PtgLe":
          case "PtgLt":
          case "PtgMul":
          case "PtgNe":
          case "PtgPower":
          case "PtgSub":
            if (n = u.pop(), o = u.pop(), g >= 0) {
              switch (e[0][g][1][0]) {
                case 0:
                  f = Cp(" ", e[0][g][1][1]);
                  break;
                case 1:
                  f = Cp("\r", e[0][g][1][1]);
                  break;
                default:
                  if (f = "", s.WTF) throw new Error("Unexpected PtgAttrSpaceType " + e[0][g][1][0])
              }
              o += f, g = -1
            }
            u.push(o + pS[C[0]] + n);
            break;
          case "PtgIsect":
            n = u.pop(), o = u.pop(), u.push(o + " " + n);
            break;
          case "PtgUnion":
            n = u.pop(), o = u.pop(), u.push(o + "," + n);
            break;
          case "PtgRange":
            n = u.pop(), o = u.pop(), u.push(o + ":" + n);
            break;
          case "PtgAttrChoose":
          case "PtgAttrGoto":
          case "PtgAttrIf":
          case "PtgAttrIfError":
          case "PtgAttrBaxcel":
          case "PtgAttrSemi":
          case "PtgMemArea":
          case "PtgTbl":
          case "PtgMemErr":
          case "PtgMemAreaN":
          case "PtgMemNoMemN":
          case "PtgAttrNoop":
          case "PtgSheet":
          case "PtgEndSheet":
          case "PtgMemFunc":
          case "PtgMemNoMem":
            break;
          case "PtgRef":
            a = cg(C[1][1], h, s), u.push(ug(a, c));
            break;
          case "PtgRefN":
            a = i ? cg(C[1][1], i, s) : C[1][1], u.push(ug(a, c));
            break;
          case "PtgRef3d":
            d = C[1][1], a = cg(C[1][2], h, s);
            E = gS(r, d, s);
            u.push(E + "!" + ug(a, c));
            break;
          case "PtgFunc":
          case "PtgFuncVar":
            var S = C[1][0],
              R = C[1][1];
            S || (S = 0);
            var A = 0 == (S &= 127) ? [] : u.slice(-S);
            u.length -= S, "User" === R && (R = A.shift()), u.push(R + "(" + A.join(",") + ")");
            break;
          case "PtgBool":
            u.push(C[1] ? "TRUE" : "FALSE");
            break;
          case "PtgInt":
          case "PtgErr":
            u.push(C[1]);
            break;
          case "PtgNum":
            u.push(String(C[1]));
            break;
          case "PtgStr":
            u.push('"' + C[1].replace(/"/g, '""') + '"');
            break;
          case "PtgAreaN":
            l = hg(C[1][1], i ? {
              s: i
            } : h, s), u.push(dg(l, s));
            break;
          case "PtgArea":
            l = hg(C[1][1], h, s), u.push(dg(l, s));
            break;
          case "PtgArea3d":
            d = C[1][1], l = C[1][2], E = gS(r, d, s), u.push(E + "!" + dg(l, s));
            break;
          case "PtgAttrSum":
            u.push("SUM(" + u.pop() + ")");
            break;
          case "PtgName":
            p = C[1][2];
            var v = (r.names || [])[p - 1] || (r[0] || [])[p],
              N = v ? v.Name : "SH33TJSNAME" + String(p);
            N && "_xlfn." == N.slice(0, 6) && !s.xlfn && (N = N.slice(6)), u.push(N);
            break;
          case "PtgNameX":
            var I, O = C[1][1];
            if (p = C[1][2], !(s.biff <= 5)) {
              var L = "";
              if (14849 == ((r[O] || [])[0] || [])[0] || (1025 == ((r[O] || [])[0] || [])[0] ? r[O][p] && r[O][p].itab > 0 && (L = r.SheetNames[r[O][p].itab - 1] + "!") : L = r.SheetNames[p - 1] + "!"), r[O] && r[O][p]) L += r[O][p].Name;
              else if (r[0] && r[0][p]) L += r[0][p].Name;
              else {
                var _ = (ES(r, O, s) || "").split(";;");
                _[p - 1] ? L = _[p - 1] : L += "SH33TJSERRX"
              }
              u.push(L);
              break
            }
            O < 0 && (O = -O), r[O] && (I = r[O][p]), I || (I = {
              Name: "SH33TJSERRY"
            }), u.push(I.Name);
            break;
          case "PtgParen":
            var y = "(",
              w = ")";
            if (g >= 0) {
              switch (f = "", e[0][g][1][0]) {
                case 2:
                  y = Cp(" ", e[0][g][1][1]) + y;
                  break;
                case 3:
                  y = Cp("\r", e[0][g][1][1]) + y;
                  break;
                case 4:
                  w = Cp(" ", e[0][g][1][1]) + w;
                  break;
                case 5:
                  w = Cp("\r", e[0][g][1][1]) + w;
                  break;
                default:
                  if (s.WTF) throw new Error("Unexpected PtgAttrSpaceType " + e[0][g][1][0])
              }
              g = -1
            }
            u.push(y + u.pop() + w);
            break;
          case "PtgRefErr":
          case "PtgRefErr3d":
          case "PtgAreaErr":
          case "PtgAreaErr3d":
            u.push("#REF!");
            break;
          case "PtgExp":
            a = {
              c: C[1][1],
              r: C[1][0]
            };
            var D = {
              c: i.c,
              r: i.r
            };
            if (r.sharedf[mg(a)]) {
              var P = r.sharedf[mg(a)];
              u.push(fS(P, h, D, r, s))
            } else {
              var b = !1;
              for (n = 0; n != r.arrayf.length; ++n)
                if (o = r.arrayf[n], !(a.c < o[0].s.c || a.c > o[0].e.c || a.r < o[0].s.r || a.r > o[0].e.r)) {
                  u.push(fS(o[1], h, D, r, s)), b = !0;
                  break
                } b || u.push(C[1])
            }
            break;
          case "PtgArray":
            u.push("{" + dS(C[1]) + "}");
            break;
          case "PtgAttrSpace":
          case "PtgAttrSpaceSemi":
            g = T;
            break;
          case "PtgMissArg":
            u.push("");
            break;
          case "PtgList":
            u.push("Table" + C[1].idx + "[#" + C[1].rt + "]");
            break;
          case "PtgElfCol":
          case "PtgElfColS":
          case "PtgElfColSV":
          case "PtgElfColV":
          case "PtgElfLel":
          case "PtgElfRadical":
          case "PtgElfRadicalLel":
          case "PtgElfRadicalS":
          case "PtgElfRw":
          case "PtgElfRwV":
            throw new Error("Unsupported ELFs");
          default:
            throw new Error("Unrecognized Formula Token: " + String(C))
        }
        if (3 != s.biff && g >= 0 && -1 == ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"].indexOf(e[0][T][0])) {
          var M = !0;
          switch ((C = e[0][g])[1][0]) {
            case 4:
              M = !1;
            case 0:
              f = Cp(" ", C[1][1]);
              break;
            case 5:
              M = !1;
            case 1:
              f = Cp("\r", C[1][1]);
              break;
            default:
              if (f = "", s.WTF) throw new Error("Unexpected PtgAttrSpaceType " + C[1][0])
          }
          u.push((M ? f : "") + u.pop() + (M ? "" : f)), g = -1
        }
      }
      if (u.length > 1 && s.WTF) throw new Error("bad formula stack");
      return u[0]
    }

    function TS(e, t, i) {
      var r, s = e.l + t,
        n = 2 == i.biff ? 1 : 2,
        o = e.read_shift(n);
      if (65535 == o) return [
        [], sg(e, t - 2)
      ];
      var a = uS(e, o, i);
      return t !== o + n && (r = hS(e, t - o - n, a, i)), e.l = s, [a, r]
    }

    function mS(e, t, i) {
      var r, s = e.l + t,
        n = e.read_shift(2),
        o = uS(e, n, i);
      return 65535 == n ? [
        [], sg(e, t - 2)
      ] : (t !== n + 2 && (r = hS(e, s - n - 2, o, i)), [o, r])
    }

    function CS(e, t, i) {
      var r = e.l + t,
        s = vT(e);
      2 == i.biff && ++e.l;
      var n = function(e) {
          var t;
          if (65535 !== XE(e, e.l + 6)) return [Jg(e), "n"];
          switch (e[e.l]) {
            case 0:
              return e.l += 8, ["String", "s"];
            case 1:
              return t = 1 === e[e.l + 2], e.l += 8, [t, "b"];
            case 2:
              return t = e[e.l + 2], e.l += 8, [t, "e"];
            case 3:
              return e.l += 8, ["", "s"]
          }
          return []
        }(e),
        o = e.read_shift(1);
      2 != i.biff && (e.read_shift(1), i.biff >= 5 && e.read_shift(4));
      var a = function(e, t, i) {
        var r, s = e.l + t,
          n = 2 == i.biff ? 1 : 2,
          o = e.read_shift(n);
        if (65535 == o) return [
          [], sg(e, t - 2)
        ];
        var a = uS(e, o, i);
        return t !== o + n && (r = hS(e, t - o - n, a, i)), e.l = s, [a, r]
      }(e, r - e.l, i);
      return {
        cell: s,
        val: n[0],
        formula: a,
        shared: o >> 3 & 1,
        tt: n[1]
      }
    }

    function SS(e, t, i, r, s) {
      var n = NT(t, i, s),
        o = function(e) {
          if (null == e) {
            var t = ng(8);
            return t.write_shift(1, 3), t.write_shift(1, 0), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(2, 65535), t
          }
          return qg("number" == typeof e ? e : 0)
        }(e.v),
        a = ng(6);
      a.write_shift(2, 33), a.write_shift(4, 0);
      for (var l = ng(e.bf.length), c = 0; c < e.bf.length; ++c) l[c] = e.bf[c];
      return Zu([n, o, a, l])
    }

    function RS(e, t, i) {
      var r = e.read_shift(4),
        s = uS(e, r, i),
        n = e.read_shift(4);
      return [s, n > 0 ? hS(e, n, s, i) : null]
    }
    var AS = RS,
      vS = RS,
      NS = RS,
      IS = RS,
      OS = {
        0: "BEEP",
        1: "OPEN",
        2: "OPEN.LINKS",
        3: "CLOSE.ALL",
        4: "SAVE",
        5: "SAVE.AS",
        6: "FILE.DELETE",
        7: "PAGE.SETUP",
        8: "PRINT",
        9: "PRINTER.SETUP",
        10: "QUIT",
        11: "NEW.WINDOW",
        12: "ARRANGE.ALL",
        13: "WINDOW.SIZE",
        14: "WINDOW.MOVE",
        15: "FULL",
        16: "CLOSE",
        17: "RUN",
        22: "SET.PRINT.AREA",
        23: "SET.PRINT.TITLES",
        24: "SET.PAGE.BREAK",
        25: "REMOVE.PAGE.BREAK",
        26: "FONT",
        27: "DISPLAY",
        28: "PROTECT.DOCUMENT",
        29: "PRECISION",
        30: "A1.R1C1",
        31: "CALCULATE.NOW",
        32: "CALCULATION",
        34: "DATA.FIND",
        35: "EXTRACT",
        36: "DATA.DELETE",
        37: "SET.DATABASE",
        38: "SET.CRITERIA",
        39: "SORT",
        40: "DATA.SERIES",
        41: "TABLE",
        42: "FORMAT.NUMBER",
        43: "ALIGNMENT",
        44: "STYLE",
        45: "BORDER",
        46: "CELL.PROTECTION",
        47: "COLUMN.WIDTH",
        48: "UNDO",
        49: "CUT",
        50: "COPY",
        51: "PASTE",
        52: "CLEAR",
        53: "PASTE.SPECIAL",
        54: "EDIT.DELETE",
        55: "INSERT",
        56: "FILL.RIGHT",
        57: "FILL.DOWN",
        61: "DEFINE.NAME",
        62: "CREATE.NAMES",
        63: "FORMULA.GOTO",
        64: "FORMULA.FIND",
        65: "SELECT.LAST.CELL",
        66: "SHOW.ACTIVE.CELL",
        67: "GALLERY.AREA",
        68: "GALLERY.BAR",
        69: "GALLERY.COLUMN",
        70: "GALLERY.LINE",
        71: "GALLERY.PIE",
        72: "GALLERY.SCATTER",
        73: "COMBINATION",
        74: "PREFERRED",
        75: "ADD.OVERLAY",
        76: "GRIDLINES",
        77: "SET.PREFERRED",
        78: "AXES",
        79: "LEGEND",
        80: "ATTACH.TEXT",
        81: "ADD.ARROW",
        82: "SELECT.CHART",
        83: "SELECT.PLOT.AREA",
        84: "PATTERNS",
        85: "MAIN.CHART",
        86: "OVERLAY",
        87: "SCALE",
        88: "FORMAT.LEGEND",
        89: "FORMAT.TEXT",
        90: "EDIT.REPEAT",
        91: "PARSE",
        92: "JUSTIFY",
        93: "HIDE",
        94: "UNHIDE",
        95: "WORKSPACE",
        96: "FORMULA",
        97: "FORMULA.FILL",
        98: "FORMULA.ARRAY",
        99: "DATA.FIND.NEXT",
        100: "DATA.FIND.PREV",
        101: "FORMULA.FIND.NEXT",
        102: "FORMULA.FIND.PREV",
        103: "ACTIVATE",
        104: "ACTIVATE.NEXT",
        105: "ACTIVATE.PREV",
        106: "UNLOCKED.NEXT",
        107: "UNLOCKED.PREV",
        108: "COPY.PICTURE",
        109: "SELECT",
        110: "DELETE.NAME",
        111: "DELETE.FORMAT",
        112: "VLINE",
        113: "HLINE",
        114: "VPAGE",
        115: "HPAGE",
        116: "VSCROLL",
        117: "HSCROLL",
        118: "ALERT",
        119: "NEW",
        120: "CANCEL.COPY",
        121: "SHOW.CLIPBOARD",
        122: "MESSAGE",
        124: "PASTE.LINK",
        125: "APP.ACTIVATE",
        126: "DELETE.ARROW",
        127: "ROW.HEIGHT",
        128: "FORMAT.MOVE",
        129: "FORMAT.SIZE",
        130: "FORMULA.REPLACE",
        131: "SEND.KEYS",
        132: "SELECT.SPECIAL",
        133: "APPLY.NAMES",
        134: "REPLACE.FONT",
        135: "FREEZE.PANES",
        136: "SHOW.INFO",
        137: "SPLIT",
        138: "ON.WINDOW",
        139: "ON.DATA",
        140: "DISABLE.INPUT",
        142: "OUTLINE",
        143: "LIST.NAMES",
        144: "FILE.CLOSE",
        145: "SAVE.WORKBOOK",
        146: "DATA.FORM",
        147: "COPY.CHART",
        148: "ON.TIME",
        149: "WAIT",
        150: "FORMAT.FONT",
        151: "FILL.UP",
        152: "FILL.LEFT",
        153: "DELETE.OVERLAY",
        155: "SHORT.MENUS",
        159: "SET.UPDATE.STATUS",
        161: "COLOR.PALETTE",
        162: "DELETE.STYLE",
        163: "WINDOW.RESTORE",
        164: "WINDOW.MAXIMIZE",
        166: "CHANGE.LINK",
        167: "CALCULATE.DOCUMENT",
        168: "ON.KEY",
        169: "APP.RESTORE",
        170: "APP.MOVE",
        171: "APP.SIZE",
        172: "APP.MINIMIZE",
        173: "APP.MAXIMIZE",
        174: "BRING.TO.FRONT",
        175: "SEND.TO.BACK",
        185: "MAIN.CHART.TYPE",
        186: "OVERLAY.CHART.TYPE",
        187: "SELECT.END",
        188: "OPEN.MAIL",
        189: "SEND.MAIL",
        190: "STANDARD.FONT",
        191: "CONSOLIDATE",
        192: "SORT.SPECIAL",
        193: "GALLERY.3D.AREA",
        194: "GALLERY.3D.COLUMN",
        195: "GALLERY.3D.LINE",
        196: "GALLERY.3D.PIE",
        197: "VIEW.3D",
        198: "GOAL.SEEK",
        199: "WORKGROUP",
        200: "FILL.GROUP",
        201: "UPDATE.LINK",
        202: "PROMOTE",
        203: "DEMOTE",
        204: "SHOW.DETAIL",
        206: "UNGROUP",
        207: "OBJECT.PROPERTIES",
        208: "SAVE.NEW.OBJECT",
        209: "SHARE",
        210: "SHARE.NAME",
        211: "DUPLICATE",
        212: "APPLY.STYLE",
        213: "ASSIGN.TO.OBJECT",
        214: "OBJECT.PROTECTION",
        215: "HIDE.OBJECT",
        216: "SET.EXTRACT",
        217: "CREATE.PUBLISHER",
        218: "SUBSCRIBE.TO",
        219: "ATTRIBUTES",
        220: "SHOW.TOOLBAR",
        222: "PRINT.PREVIEW",
        223: "EDIT.COLOR",
        224: "SHOW.LEVELS",
        225: "FORMAT.MAIN",
        226: "FORMAT.OVERLAY",
        227: "ON.RECALC",
        228: "EDIT.SERIES",
        229: "DEFINE.STYLE",
        240: "LINE.PRINT",
        243: "ENTER.DATA",
        249: "GALLERY.RADAR",
        250: "MERGE.STYLES",
        251: "EDITION.OPTIONS",
        252: "PASTE.PICTURE",
        253: "PASTE.PICTURE.LINK",
        254: "SPELLING",
        256: "ZOOM",
        259: "INSERT.OBJECT",
        260: "WINDOW.MINIMIZE",
        265: "SOUND.NOTE",
        266: "SOUND.PLAY",
        267: "FORMAT.SHAPE",
        268: "EXTEND.POLYGON",
        269: "FORMAT.AUTO",
        272: "GALLERY.3D.BAR",
        273: "GALLERY.3D.SURFACE",
        274: "FILL.AUTO",
        276: "CUSTOMIZE.TOOLBAR",
        277: "ADD.TOOL",
        278: "EDIT.OBJECT",
        279: "ON.DOUBLECLICK",
        280: "ON.ENTRY",
        281: "WORKBOOK.ADD",
        282: "WORKBOOK.MOVE",
        283: "WORKBOOK.COPY",
        284: "WORKBOOK.OPTIONS",
        285: "SAVE.WORKSPACE",
        288: "CHART.WIZARD",
        289: "DELETE.TOOL",
        290: "MOVE.TOOL",
        291: "WORKBOOK.SELECT",
        292: "WORKBOOK.ACTIVATE",
        293: "ASSIGN.TO.TOOL",
        295: "COPY.TOOL",
        296: "RESET.TOOL",
        297: "CONSTRAIN.NUMERIC",
        298: "PASTE.TOOL",
        302: "WORKBOOK.NEW",
        305: "SCENARIO.CELLS",
        306: "SCENARIO.DELETE",
        307: "SCENARIO.ADD",
        308: "SCENARIO.EDIT",
        309: "SCENARIO.SHOW",
        310: "SCENARIO.SHOW.NEXT",
        311: "SCENARIO.SUMMARY",
        312: "PIVOT.TABLE.WIZARD",
        313: "PIVOT.FIELD.PROPERTIES",
        314: "PIVOT.FIELD",
        315: "PIVOT.ITEM",
        316: "PIVOT.ADD.FIELDS",
        318: "OPTIONS.CALCULATION",
        319: "OPTIONS.EDIT",
        320: "OPTIONS.VIEW",
        321: "ADDIN.MANAGER",
        322: "MENU.EDITOR",
        323: "ATTACH.TOOLBARS",
        324: "VBAActivate",
        325: "OPTIONS.CHART",
        328: "VBA.INSERT.FILE",
        330: "VBA.PROCEDURE.DEFINITION",
        336: "ROUTING.SLIP",
        338: "ROUTE.DOCUMENT",
        339: "MAIL.LOGON",
        342: "INSERT.PICTURE",
        343: "EDIT.TOOL",
        344: "GALLERY.DOUGHNUT",
        350: "CHART.TREND",
        352: "PIVOT.ITEM.PROPERTIES",
        354: "WORKBOOK.INSERT",
        355: "OPTIONS.TRANSITION",
        356: "OPTIONS.GENERAL",
        370: "FILTER.ADVANCED",
        373: "MAIL.ADD.MAILER",
        374: "MAIL.DELETE.MAILER",
        375: "MAIL.REPLY",
        376: "MAIL.REPLY.ALL",
        377: "MAIL.FORWARD",
        378: "MAIL.NEXT.LETTER",
        379: "DATA.LABEL",
        380: "INSERT.TITLE",
        381: "FONT.PROPERTIES",
        382: "MACRO.OPTIONS",
        383: "WORKBOOK.HIDE",
        384: "WORKBOOK.UNHIDE",
        385: "WORKBOOK.DELETE",
        386: "WORKBOOK.NAME",
        388: "GALLERY.CUSTOM",
        390: "ADD.CHART.AUTOFORMAT",
        391: "DELETE.CHART.AUTOFORMAT",
        392: "CHART.ADD.DATA",
        393: "AUTO.OUTLINE",
        394: "TAB.ORDER",
        395: "SHOW.DIALOG",
        396: "SELECT.ALL",
        397: "UNGROUP.SHEETS",
        398: "SUBTOTAL.CREATE",
        399: "SUBTOTAL.REMOVE",
        400: "RENAME.OBJECT",
        412: "WORKBOOK.SCROLL",
        413: "WORKBOOK.NEXT",
        414: "WORKBOOK.PREV",
        415: "WORKBOOK.TAB.SPLIT",
        416: "FULL.SCREEN",
        417: "WORKBOOK.PROTECT",
        420: "SCROLLBAR.PROPERTIES",
        421: "PIVOT.SHOW.PAGES",
        422: "TEXT.TO.COLUMNS",
        423: "FORMAT.CHARTTYPE",
        424: "LINK.FORMAT",
        425: "TRACER.DISPLAY",
        430: "TRACER.NAVIGATE",
        431: "TRACER.CLEAR",
        432: "TRACER.ERROR",
        433: "PIVOT.FIELD.GROUP",
        434: "PIVOT.FIELD.UNGROUP",
        435: "CHECKBOX.PROPERTIES",
        436: "LABEL.PROPERTIES",
        437: "LISTBOX.PROPERTIES",
        438: "EDITBOX.PROPERTIES",
        439: "PIVOT.REFRESH",
        440: "LINK.COMBO",
        441: "OPEN.TEXT",
        442: "HIDE.DIALOG",
        443: "SET.DIALOG.FOCUS",
        444: "ENABLE.OBJECT",
        445: "PUSHBUTTON.PROPERTIES",
        446: "SET.DIALOG.DEFAULT",
        447: "FILTER",
        448: "FILTER.SHOW.ALL",
        449: "CLEAR.OUTLINE",
        450: "FUNCTION.WIZARD",
        451: "ADD.LIST.ITEM",
        452: "SET.LIST.ITEM",
        453: "REMOVE.LIST.ITEM",
        454: "SELECT.LIST.ITEM",
        455: "SET.CONTROL.VALUE",
        456: "SAVE.COPY.AS",
        458: "OPTIONS.LISTS.ADD",
        459: "OPTIONS.LISTS.DELETE",
        460: "SERIES.AXES",
        461: "SERIES.X",
        462: "SERIES.Y",
        463: "ERRORBAR.X",
        464: "ERRORBAR.Y",
        465: "FORMAT.CHART",
        466: "SERIES.ORDER",
        467: "MAIL.LOGOFF",
        468: "CLEAR.ROUTING.SLIP",
        469: "APP.ACTIVATE.MICROSOFT",
        470: "MAIL.EDIT.MAILER",
        471: "ON.SHEET",
        472: "STANDARD.WIDTH",
        473: "SCENARIO.MERGE",
        474: "SUMMARY.INFO",
        475: "FIND.FILE",
        476: "ACTIVE.CELL.FONT",
        477: "ENABLE.TIPWIZARD",
        478: "VBA.MAKE.ADDIN",
        480: "INSERTDATATABLE",
        481: "WORKGROUP.OPTIONS",
        482: "MAIL.SEND.MAILER",
        485: "AUTOCORRECT",
        489: "POST.DOCUMENT",
        491: "PICKLIST",
        493: "VIEW.SHOW",
        494: "VIEW.DEFINE",
        495: "VIEW.DELETE",
        509: "SHEET.BACKGROUND",
        510: "INSERT.MAP.OBJECT",
        511: "OPTIONS.MENONO",
        517: "MSOCHECKS",
        518: "NORMAL",
        519: "LAYOUT",
        520: "RM.PRINT.AREA",
        521: "CLEAR.PRINT.AREA",
        522: "ADD.PRINT.AREA",
        523: "MOVE.BRK",
        545: "HIDECURR.NOTE",
        546: "HIDEALL.NOTES",
        547: "DELETE.NOTE",
        548: "TRAVERSE.NOTES",
        549: "ACTIVATE.NOTES",
        620: "PROTECT.REVISIONS",
        621: "UNPROTECT.REVISIONS",
        647: "OPTIONS.ME",
        653: "WEB.PUBLISH",
        667: "NEWWEBQUERY",
        673: "PIVOT.TABLE.CHART",
        753: "OPTIONS.SAVE",
        755: "OPTIONS.SPELL",
        808: "HIDEALL.INKANNOTS"
      },
      LS = {
        0: "COUNT",
        1: "IF",
        2: "ISNA",
        3: "ISERROR",
        4: "SUM",
        5: "AVERAGE",
        6: "MIN",
        7: "MAX",
        8: "ROW",
        9: "COLUMN",
        10: "NA",
        11: "NPV",
        12: "STDEV",
        13: "DOLLAR",
        14: "FIXED",
        15: "SIN",
        16: "COS",
        17: "TAN",
        18: "ATAN",
        19: "PI",
        20: "SQRT",
        21: "EXP",
        22: "LN",
        23: "LOG10",
        24: "ABS",
        25: "INT",
        26: "SIGN",
        27: "ROUND",
        28: "LOOKUP",
        29: "INDEX",
        30: "REPT",
        31: "MID",
        32: "LEN",
        33: "VALUE",
        34: "TRUE",
        35: "FALSE",
        36: "AND",
        37: "OR",
        38: "NOT",
        39: "MOD",
        40: "DCOUNT",
        41: "DSUM",
        42: "DAVERAGE",
        43: "DMIN",
        44: "DMAX",
        45: "DSTDEV",
        46: "VAR",
        47: "DVAR",
        48: "TEXT",
        49: "LINEST",
        50: "TREND",
        51: "LOGEST",
        52: "GROWTH",
        53: "GOTO",
        54: "HALT",
        55: "RETURN",
        56: "PV",
        57: "FV",
        58: "NPER",
        59: "PMT",
        60: "RATE",
        61: "MIRR",
        62: "IRR",
        63: "RAND",
        64: "MATCH",
        65: "DATE",
        66: "TIME",
        67: "DAY",
        68: "MONTH",
        69: "YEAR",
        70: "WEEKDAY",
        71: "HOUR",
        72: "MINUTE",
        73: "SECOND",
        74: "NOW",
        75: "AREAS",
        76: "ROWS",
        77: "COLUMNS",
        78: "OFFSET",
        79: "ABSREF",
        80: "RELREF",
        81: "ARGUMENT",
        82: "SEARCH",
        83: "TRANSPOSE",
        84: "ERROR",
        85: "STEP",
        86: "TYPE",
        87: "ECHO",
        88: "SET.NAME",
        89: "CALLER",
        90: "DEREF",
        91: "WINDOWS",
        92: "SERIES",
        93: "DOCUMENTS",
        94: "ACTIVE.CELL",
        95: "SELECTION",
        96: "RESULT",
        97: "ATAN2",
        98: "ASIN",
        99: "ACOS",
        100: "CHOOSE",
        101: "HLOOKUP",
        102: "VLOOKUP",
        103: "LINKS",
        104: "INPUT",
        105: "ISREF",
        106: "GET.FORMULA",
        107: "GET.NAME",
        108: "SET.VALUE",
        109: "LOG",
        110: "EXEC",
        111: "CHAR",
        112: "LOWER",
        113: "UPPER",
        114: "PROPER",
        115: "LEFT",
        116: "RIGHT",
        117: "EXACT",
        118: "TRIM",
        119: "REPLACE",
        120: "SUBSTITUTE",
        121: "CODE",
        122: "NAMES",
        123: "DIRECTORY",
        124: "FIND",
        125: "CELL",
        126: "ISERR",
        127: "ISTEXT",
        128: "ISNUMBER",
        129: "ISBLANK",
        130: "T",
        131: "N",
        132: "FOPEN",
        133: "FCLOSE",
        134: "FSIZE",
        135: "FREADLN",
        136: "FREAD",
        137: "FWRITELN",
        138: "FWRITE",
        139: "FPOS",
        140: "DATEVALUE",
        141: "TIMEVALUE",
        142: "SLN",
        143: "SYD",
        144: "DDB",
        145: "GET.DEF",
        146: "REFTEXT",
        147: "TEXTREF",
        148: "INDIRECT",
        149: "REGISTER",
        150: "CALL",
        151: "ADD.BAR",
        152: "ADD.MENU",
        153: "ADD.COMMAND",
        154: "ENABLE.COMMAND",
        155: "CHECK.COMMAND",
        156: "RENAME.COMMAND",
        157: "SHOW.BAR",
        158: "DELETE.MENU",
        159: "DELETE.COMMAND",
        160: "GET.CHART.ITEM",
        161: "DIALOG.BOX",
        162: "CLEAN",
        163: "MDETERM",
        164: "MINVERSE",
        165: "MMULT",
        166: "FILES",
        167: "IPMT",
        168: "PPMT",
        169: "COUNTA",
        170: "CANCEL.KEY",
        171: "FOR",
        172: "WHILE",
        173: "BREAK",
        174: "NEXT",
        175: "INITIATE",
        176: "REQUEST",
        177: "POKE",
        178: "EXECUTE",
        179: "TERMINATE",
        180: "RESTART",
        181: "HELP",
        182: "GET.BAR",
        183: "PRODUCT",
        184: "FACT",
        185: "GET.CELL",
        186: "GET.WORKSPACE",
        187: "GET.WINDOW",
        188: "GET.DOCUMENT",
        189: "DPRODUCT",
        190: "ISNONTEXT",
        191: "GET.NOTE",
        192: "NOTE",
        193: "STDEVP",
        194: "VARP",
        195: "DSTDEVP",
        196: "DVARP",
        197: "TRUNC",
        198: "ISLOGICAL",
        199: "DCOUNTA",
        200: "DELETE.BAR",
        201: "UNREGISTER",
        204: "USDOLLAR",
        205: "FINDB",
        206: "SEARCHB",
        207: "REPLACEB",
        208: "LEFTB",
        209: "RIGHTB",
        210: "MIDB",
        211: "LENB",
        212: "ROUNDUP",
        213: "ROUNDDOWN",
        214: "ASC",
        215: "DBCS",
        216: "RANK",
        219: "ADDRESS",
        220: "DAYS360",
        221: "TODAY",
        222: "VDB",
        223: "ELSE",
        224: "ELSE.IF",
        225: "END.IF",
        226: "FOR.CELL",
        227: "MEDIAN",
        228: "SUMPRODUCT",
        229: "SINH",
        230: "COSH",
        231: "TANH",
        232: "ASINH",
        233: "ACOSH",
        234: "ATANH",
        235: "DGET",
        236: "CREATE.OBJECT",
        237: "VOLATILE",
        238: "LAST.ERROR",
        239: "CUSTOM.UNDO",
        240: "CUSTOM.REPEAT",
        241: "FORMULA.CONVERT",
        242: "GET.LINK.INFO",
        243: "TEXT.BOX",
        244: "INFO",
        245: "GROUP",
        246: "GET.OBJECT",
        247: "DB",
        248: "PAUSE",
        251: "RESUME",
        252: "FREQUENCY",
        253: "ADD.TOOLBAR",
        254: "DELETE.TOOLBAR",
        255: "User",
        256: "RESET.TOOLBAR",
        257: "EVALUATE",
        258: "GET.TOOLBAR",
        259: "GET.TOOL",
        260: "SPELLING.CHECK",
        261: "ERROR.TYPE",
        262: "APP.TITLE",
        263: "WINDOW.TITLE",
        264: "SAVE.TOOLBAR",
        265: "ENABLE.TOOL",
        266: "PRESS.TOOL",
        267: "REGISTER.ID",
        268: "GET.WORKBOOK",
        269: "AVEDEV",
        270: "BETADIST",
        271: "GAMMALN",
        272: "BETAINV",
        273: "BINOMDIST",
        274: "CHIDIST",
        275: "CHIINV",
        276: "COMBIN",
        277: "CONFIDENCE",
        278: "CRITBINOM",
        279: "EVEN",
        280: "EXPONDIST",
        281: "FDIST",
        282: "FINV",
        283: "FISHER",
        284: "FISHERINV",
        285: "FLOOR",
        286: "GAMMADIST",
        287: "GAMMAINV",
        288: "CEILING",
        289: "HYPGEOMDIST",
        290: "LOGNORMDIST",
        291: "LOGINV",
        292: "NEGBINOMDIST",
        293: "NORMDIST",
        294: "NORMSDIST",
        295: "NORMINV",
        296: "NORMSINV",
        297: "STANDARDIZE",
        298: "ODD",
        299: "PERMUT",
        300: "POISSON",
        301: "TDIST",
        302: "WEIBULL",
        303: "SUMXMY2",
        304: "SUMX2MY2",
        305: "SUMX2PY2",
        306: "CHITEST",
        307: "CORREL",
        308: "COVAR",
        309: "FORECAST",
        310: "FTEST",
        311: "INTERCEPT",
        312: "PEARSON",
        313: "RSQ",
        314: "STEYX",
        315: "SLOPE",
        316: "TTEST",
        317: "PROB",
        318: "DEVSQ",
        319: "GEOMEAN",
        320: "HARMEAN",
        321: "SUMSQ",
        322: "KURT",
        323: "SKEW",
        324: "ZTEST",
        325: "LARGE",
        326: "SMALL",
        327: "QUARTILE",
        328: "PERCENTILE",
        329: "PERCENTRANK",
        330: "MODE",
        331: "TRIMMEAN",
        332: "TINV",
        334: "MOVIE.COMMAND",
        335: "GET.MOVIE",
        336: "CONCATENATE",
        337: "POWER",
        338: "PIVOT.ADD.DATA",
        339: "GET.PIVOT.TABLE",
        340: "GET.PIVOT.FIELD",
        341: "GET.PIVOT.ITEM",
        342: "RADIANS",
        343: "DEGREES",
        344: "SUBTOTAL",
        345: "SUMIF",
        346: "COUNTIF",
        347: "COUNTBLANK",
        348: "SCENARIO.GET",
        349: "OPTIONS.LISTS.GET",
        350: "ISPMT",
        351: "DATEDIF",
        352: "DATESTRING",
        353: "NUMBERSTRING",
        354: "ROMAN",
        355: "OPEN.DIALOG",
        356: "SAVE.DIALOG",
        357: "VIEW.GET",
        358: "GETPIVOTDATA",
        359: "HYPERLINK",
        360: "PHONETIC",
        361: "AVERAGEA",
        362: "MAXA",
        363: "MINA",
        364: "STDEVPA",
        365: "VARPA",
        366: "STDEVA",
        367: "VARA",
        368: "BAHTTEXT",
        369: "THAIDAYOFWEEK",
        370: "THAIDIGIT",
        371: "THAIMONTHOFYEAR",
        372: "THAINUMSOUND",
        373: "THAINUMSTRING",
        374: "THAISTRINGLENGTH",
        375: "ISTHAIDIGIT",
        376: "ROUNDBAHTDOWN",
        377: "ROUNDBAHTUP",
        378: "THAIYEAR",
        379: "RTD",
        380: "CUBEVALUE",
        381: "CUBEMEMBER",
        382: "CUBEMEMBERPROPERTY",
        383: "CUBERANKEDMEMBER",
        384: "HEX2BIN",
        385: "HEX2DEC",
        386: "HEX2OCT",
        387: "DEC2BIN",
        388: "DEC2HEX",
        389: "DEC2OCT",
        390: "OCT2BIN",
        391: "OCT2HEX",
        392: "OCT2DEC",
        393: "BIN2DEC",
        394: "BIN2OCT",
        395: "BIN2HEX",
        396: "IMSUB",
        397: "IMDIV",
        398: "IMPOWER",
        399: "IMABS",
        400: "IMSQRT",
        401: "IMLN",
        402: "IMLOG2",
        403: "IMLOG10",
        404: "IMSIN",
        405: "IMCOS",
        406: "IMEXP",
        407: "IMARGUMENT",
        408: "IMCONJUGATE",
        409: "IMAGINARY",
        410: "IMREAL",
        411: "COMPLEX",
        412: "IMSUM",
        413: "IMPRODUCT",
        414: "SERIESSUM",
        415: "FACTDOUBLE",
        416: "SQRTPI",
        417: "QUOTIENT",
        418: "DELTA",
        419: "GESTEP",
        420: "ISEVEN",
        421: "ISODD",
        422: "MROUND",
        423: "ERF",
        424: "ERFC",
        425: "BESSELJ",
        426: "BESSELK",
        427: "BESSELY",
        428: "BESSELI",
        429: "XIRR",
        430: "XNPV",
        431: "PRICEMAT",
        432: "YIELDMAT",
        433: "INTRATE",
        434: "RECEIVED",
        435: "DISC",
        436: "PRICEDISC",
        437: "YIELDDISC",
        438: "TBILLEQ",
        439: "TBILLPRICE",
        440: "TBILLYIELD",
        441: "PRICE",
        442: "YIELD",
        443: "DOLLARDE",
        444: "DOLLARFR",
        445: "NOMINAL",
        446: "EFFECT",
        447: "CUMPRINC",
        448: "CUMIPMT",
        449: "EDATE",
        450: "EOMONTH",
        451: "YEARFRAC",
        452: "COUPDAYBS",
        453: "COUPDAYS",
        454: "COUPDAYSNC",
        455: "COUPNCD",
        456: "COUPNUM",
        457: "COUPPCD",
        458: "DURATION",
        459: "MDURATION",
        460: "ODDLPRICE",
        461: "ODDLYIELD",
        462: "ODDFPRICE",
        463: "ODDFYIELD",
        464: "RANDBETWEEN",
        465: "WEEKNUM",
        466: "AMORDEGRC",
        467: "AMORLINC",
        468: "CONVERT",
        724: "SHEETJS",
        469: "ACCRINT",
        470: "ACCRINTM",
        471: "WORKDAY",
        472: "NETWORKDAYS",
        473: "GCD",
        474: "MULTINOMIAL",
        475: "LCM",
        476: "FVSCHEDULE",
        477: "CUBEKPIMEMBER",
        478: "CUBESET",
        479: "CUBESETCOUNT",
        480: "IFERROR",
        481: "COUNTIFS",
        482: "SUMIFS",
        483: "AVERAGEIF",
        484: "AVERAGEIFS"
      },
      _S = {
        2: 1,
        3: 1,
        10: 0,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 0,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 2,
        30: 2,
        31: 3,
        32: 1,
        33: 1,
        34: 0,
        35: 0,
        38: 1,
        39: 2,
        40: 3,
        41: 3,
        42: 3,
        43: 3,
        44: 3,
        45: 3,
        47: 3,
        48: 2,
        53: 1,
        61: 3,
        63: 0,
        65: 3,
        66: 3,
        67: 1,
        68: 1,
        69: 1,
        70: 1,
        71: 1,
        72: 1,
        73: 1,
        74: 0,
        75: 1,
        76: 1,
        77: 1,
        79: 2,
        80: 2,
        83: 1,
        85: 0,
        86: 1,
        89: 0,
        90: 1,
        94: 0,
        95: 0,
        97: 2,
        98: 1,
        99: 1,
        101: 3,
        102: 3,
        105: 1,
        106: 1,
        108: 2,
        111: 1,
        112: 1,
        113: 1,
        114: 1,
        117: 2,
        118: 1,
        119: 4,
        121: 1,
        126: 1,
        127: 1,
        128: 1,
        129: 1,
        130: 1,
        131: 1,
        133: 1,
        134: 1,
        135: 1,
        136: 2,
        137: 2,
        138: 2,
        140: 1,
        141: 1,
        142: 3,
        143: 4,
        144: 4,
        161: 1,
        162: 1,
        163: 1,
        164: 1,
        165: 2,
        172: 1,
        175: 2,
        176: 2,
        177: 3,
        178: 2,
        179: 1,
        184: 1,
        186: 1,
        189: 3,
        190: 1,
        195: 3,
        196: 3,
        197: 1,
        198: 1,
        199: 3,
        201: 1,
        207: 4,
        210: 3,
        211: 1,
        212: 2,
        213: 2,
        214: 1,
        215: 1,
        225: 0,
        229: 1,
        230: 1,
        231: 1,
        232: 1,
        233: 1,
        234: 1,
        235: 3,
        244: 1,
        247: 4,
        252: 2,
        257: 1,
        261: 1,
        271: 1,
        273: 4,
        274: 2,
        275: 2,
        276: 2,
        277: 3,
        278: 3,
        279: 1,
        280: 3,
        281: 3,
        282: 3,
        283: 1,
        284: 1,
        285: 2,
        286: 4,
        287: 3,
        288: 2,
        289: 4,
        290: 3,
        291: 3,
        292: 3,
        293: 4,
        294: 1,
        295: 3,
        296: 1,
        297: 3,
        298: 1,
        299: 2,
        300: 3,
        301: 3,
        302: 4,
        303: 2,
        304: 2,
        305: 2,
        306: 2,
        307: 2,
        308: 2,
        309: 3,
        310: 2,
        311: 2,
        312: 2,
        313: 2,
        314: 2,
        315: 2,
        316: 4,
        325: 2,
        326: 2,
        327: 2,
        328: 2,
        331: 2,
        332: 2,
        337: 2,
        342: 1,
        343: 1,
        346: 2,
        347: 1,
        350: 4,
        351: 3,
        352: 1,
        353: 2,
        360: 1,
        368: 1,
        369: 1,
        370: 1,
        371: 1,
        372: 1,
        373: 1,
        374: 1,
        375: 1,
        376: 1,
        377: 1,
        378: 1,
        382: 3,
        385: 1,
        392: 1,
        393: 1,
        396: 2,
        397: 2,
        398: 2,
        399: 1,
        400: 1,
        401: 1,
        402: 1,
        403: 1,
        404: 1,
        405: 1,
        406: 1,
        407: 1,
        408: 1,
        409: 1,
        410: 1,
        414: 4,
        415: 1,
        416: 1,
        417: 2,
        420: 1,
        421: 1,
        422: 2,
        424: 1,
        425: 2,
        426: 2,
        427: 2,
        428: 2,
        430: 3,
        438: 3,
        439: 3,
        440: 3,
        443: 2,
        444: 2,
        445: 2,
        446: 2,
        447: 6,
        448: 6,
        449: 2,
        450: 2,
        464: 2,
        468: 3,
        476: 2,
        479: 1,
        480: 2,
        65535: 0
      };

    function yS(e) {
      return "of:" == e.slice(0, 3) && (e = e.slice(3)), 61 == e.charCodeAt(0) && 61 == (e = e.slice(1)).charCodeAt(0) && (e = e.slice(1)), (e = (e = (e = e.replace(/COM\.MICROSOFT\./g, "")).replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function(e, t) {
        return t.replace(/\./g, "")
      })).replace(/\[.(#[A-Z]*[?!])\]/g, "$1")).replace(/[;~]/g, ",").replace(/\|/g, ";")
    }

    function wS(e) {
      return ("of:=" + e.replace(kC, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":")).replace(/;/g, "|").replace(/,/g, ";")
    }

    function DS(e) {
      var t = e.split(":");
      return [t[0].split(".")[0], t[0].split(".")[1] + (t.length > 1 ? ":" + (t[1].split(".")[1] || t[1].split(".")[0]) : "")]
    }

    function PS(e) {
      return e.replace(/\./, "!")
    }
    var bS = {},
      MS = {},
      FS = "undefined" != typeof Map;

    function xS(e, t, i) {
      var r = 0,
        s = e.length;
      if (i) {
        if (FS ? i.has(t) : Object.prototype.hasOwnProperty.call(i, t))
          for (var n = FS ? i.get(t) : i[t]; r < n.length; ++r)
            if (e[n[r]].t === t) return e.Count++, n[r]
      } else
        for (; r < s; ++r)
          if (e[r].t === t) return e.Count++, r;
      return e[s] = {
        t
      }, e.Count++, e.Unique++, i && (FS ? (i.has(t) || i.set(t, []), i.get(t).push(s)) : (Object.prototype.hasOwnProperty.call(i, t) || (i[t] = []), i[t].push(s))), s
    }

    function GS(e, t) {
      var i = {
          min: e + 1,
          max: e + 1
        },
        r = -1;
      return t.MDW && (Bm = t.MDW), null != t.width ? i.customWidth = 1 : null != t.wpx ? r = Wm(t.wpx) : null != t.wch && (r = t.wch), r > -1 ? (i.width = Ym(r), i.customWidth = 1) : null != t.width && (i.width = t.width), t.hidden && (i.hidden = !0), null != t.level && (i.outlineLevel = i.level = t.level), i
    }

    function US(e, t) {
      if (e) {
        var i = [.7, .7, .75, .75, .3, .3];
        "xlml" == t && (i = [1, 1, 1, 1, .5, .5]), null == e.left && (e.left = i[0]), null == e.right && (e.right = i[1]), null == e.top && (e.top = i[2]), null == e.bottom && (e.bottom = i[3]), null == e.header && (e.header = i[4]), null == e.footer && (e.footer = i[5])
      }
    }

    function HS(e, t, i) {
      var r = i.revssf[null != t.z ? t.z : "General"],
        s = 60,
        n = e.length;
      if (null == r && i.ssf)
        for (; s < 392; ++s)
          if (null == i.ssf[s]) {
            Yd(t.z, s), i.ssf[s] = t.z, i.revssf[t.z] = r = s;
            break
          } for (s = 0; s != n; ++s)
        if (e[s].numFmtId === r) return s;
      return e[n] = {
        numFmtId: r,
        fontId: 0,
        fillId: 0,
        borderId: 0,
        xfId: 0,
        applyNumberFormat: 1
      }, n
    }

    function kS(e, t, i, r, s, n) {
      try {
        r.cellNF && (e.z = ud[t])
      } catch (e) {
        if (r.WTF) throw e
      }
      if ("z" !== e.t || r.cellStyles) {
        if ("d" === e.t && "string" == typeof e.v && (e.v = fp(e.v)), (!r || !1 !== r.cellText) && "z" !== e.t) try {
          if (null == ud[t] && Yd($d[t] || "General", t), "e" === e.t) e.w = e.w || pf[e.v];
          else if (0 === t)
            if ("n" === e.t)(0 | e.v) === e.v ? e.w = e.v.toString(10) : e.w = Rd(e.v);
            else if ("d" === e.t) {
            var o = ap(e.v);
            e.w = (0 | o) === o ? o.toString(10) : Rd(o)
          } else {
            if (void 0 === e.v) return "";
            e.w = Ad(e.v, MS)
          } else "d" === e.t ? e.w = Wd(t, ap(e.v), MS) : e.w = Wd(t, e.v, MS)
        } catch (e) {
          if (r.WTF) throw e
        }
        if (r.cellStyles && null != i) try {
          e.s = n.Fills[i], e.s.fgColor && e.s.fgColor.theme && !e.s.fgColor.rgb && (e.s.fgColor.rgb = Gm(s.themeElements.clrScheme[e.s.fgColor.theme].rgb, e.s.fgColor.tint || 0), r.WTF && (e.s.fgColor.raw_rgb = s.themeElements.clrScheme[e.s.fgColor.theme].rgb)), e.s.bgColor && e.s.bgColor.theme && (e.s.bgColor.rgb = Gm(s.themeElements.clrScheme[e.s.bgColor.theme].rgb, e.s.bgColor.tint || 0), r.WTF && (e.s.bgColor.raw_rgb = s.themeElements.clrScheme[e.s.bgColor.theme].rgb))
        } catch (e) {
          if (r.WTF && n.Fills) throw e
        }
      }
    }

    function BS(e, t, i) {
      if (e && e["!ref"]) {
        var r = Rg(e["!ref"]);
        if (r.e.c < r.s.c || r.e.r < r.s.r) throw new Error("Bad range (" + i + "): " + e["!ref"])
      }
    }
    var VS = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g,
      WS = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/,
      YS = /<(?:\w:)?hyperlink [^>]*>/gm,
      KS = /"(\w*:\w*)"/,
      XS = /<(?:\w:)?col\b[^>]*[\/]?>/g,
      zS = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g,
      $S = /<(?:\w:)?pageMargins[^>]*\/>/g,
      jS = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/,
      JS = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/,
      qS = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;

    function QS(e, t, i, r, s, n, o) {
      if (!e) return e;
      r || (r = {
        "!id": {}
      }), null != Bu && null == t.dense && (t.dense = Bu);
      var a = t.dense ? [] : {},
        l = {
          s: {
            r: 2e6,
            c: 2e6
          },
          e: {
            r: 0,
            c: 0
          }
        },
        c = "",
        h = "",
        u = e.match(WS);
      u ? (c = e.slice(0, u.index), h = e.slice(u.index + u[0].length)) : c = h = e;
      var d = c.match(jS);
      d ? ZS(d[0], a, s, i) : (d = c.match(JS)) && function(e, t, i, r, s) {
        ZS(e.slice(0, e.indexOf(">")), i, r, s)
      }(d[0], d[1], a, s, i);
      var p = (c.match(/<(?:\w*:)?dimension/) || {
        index: -1
      }).index;
      if (p > 0) {
        var E = c.slice(p, p + 50).match(KS);
        E && function(e, t) {
          var i = Rg(t);
          i.s.r <= i.e.r && i.s.c <= i.e.c && i.s.r >= 0 && i.s.c >= 0 && (e["!ref"] = Sg(i))
        }(a, E[1])
      }
      var g = c.match(qS);
      g && g[1] && function(e, t) {
        t.Views || (t.Views = [{}]);
        (e.match(iR) || []).forEach(function(e, i) {
          var r = Vp(e);
          t.Views[i] || (t.Views[i] = {}), +r.zoomScale && (t.Views[i].zoom = +r.zoomScale), eE(r.rightToLeft) && (t.Views[i].RTL = !0)
        })
      }(g[1], s);
      var f = [];
      if (t.cellStyles) {
        var T = c.match(XS);
        T && function(e, t) {
          for (var i = !1, r = 0; r != t.length; ++r) {
            var s = Vp(t[r], !0);
            s.hidden && (s.hidden = eE(s.hidden));
            var n = parseInt(s.min, 10) - 1,
              o = parseInt(s.max, 10) - 1;
            for (s.outlineLevel && (s.level = +s.outlineLevel || 0), delete s.min, delete s.max, s.width = +s.width, !i && s.width && (i = !0, Xm(s.width)), zm(s); n <= o;) e[n++] = mp(s)
          }
        }(f, T)
      }
      u && sR(u[1], a, t, l, n, o);
      var m = h.match(zS);
      m && (a["!autofilter"] = function(e) {
        var t = {
          ref: (e.match(/ref="([^"]*)"/) || [])[1]
        };
        return t
      }(m[0]));
      var C = [],
        S = h.match(VS);
      if (S)
        for (p = 0; p != S.length; ++p) C[p] = Rg(S[p].slice(S[p].indexOf('"') + 1));
      var R = h.match(YS);
      R && function(e, t, i) {
        for (var r = Array.isArray(e), s = 0; s != t.length; ++s) {
          var n = Vp(nE(t[s]), !0);
          if (!n.ref) return;
          var o = ((i || {})["!id"] || [])[n.id];
          o ? (n.Target = o.Target, n.location && (n.Target += "#" + Xp(n.location))) : (n.Target = "#" + Xp(n.location), o = {
            Target: n.Target,
            TargetMode: "Internal"
          }), n.Rel = o, n.tooltip && (n.Tooltip = n.tooltip, delete n.tooltip);
          for (var a = Rg(n.ref), l = a.s.r; l <= a.e.r; ++l)
            for (var c = a.s.c; c <= a.e.c; ++c) {
              var h = mg({
                c,
                r: l
              });
              r ? (e[l] || (e[l] = []), e[l][c] || (e[l][c] = {
                t: "z",
                v: void 0
              }), e[l][c].l = n) : (e[h] || (e[h] = {
                t: "z",
                v: void 0
              }), e[h].l = n)
            }
        }
      }(a, R, r);
      var A, v, N = h.match($S);
      if (N && (a["!margins"] = (A = Vp(N[0]), v = {}, ["left", "right", "top", "bottom", "header", "footer"].forEach(function(e) {
          A[e] && (v[e] = parseFloat(A[e]))
        }), v)), !a["!ref"] && l.e.c >= l.s.c && l.e.r >= l.s.r && (a["!ref"] = Sg(l)), t.sheetRows > 0 && a["!ref"]) {
        var I = Rg(a["!ref"]);
        t.sheetRows <= +I.e.r && (I.e.r = t.sheetRows - 1, I.e.r > l.e.r && (I.e.r = l.e.r), I.e.r < I.s.r && (I.s.r = I.e.r), I.e.c > l.e.c && (I.e.c = l.e.c), I.e.c < I.s.c && (I.s.c = I.e.c), a["!fullref"] = a["!ref"], a["!ref"] = Sg(I))
      }
      return f.length > 0 && (a["!cols"] = f), C.length > 0 && (a["!merges"] = C), a
    }

    function ZS(e, t, i, r) {
      var s = Vp(e);
      i.Sheets[r] || (i.Sheets[r] = {}), s.codeName && (i.Sheets[r].CodeName = Xp(nE(s.codeName)))
    }
    var eR = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"],
      tR = ["formatColumns", "formatRows", "formatCells", "insertColumns", "insertRows", "insertHyperlinks", "deleteColumns", "deleteRows", "sort", "autoFilter", "pivotTables"];
    var iR = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;

    function rR(e, t, i, r) {
      if (e.c && i["!comments"].push([t, e.c]), void 0 === e.v && "string" != typeof e.f || "z" === e.t && !e.f) return "";
      var s = "",
        n = e.t,
        o = e.v;
      if ("z" !== e.t) switch (e.t) {
        case "b":
          s = e.v ? "1" : "0";
          break;
        case "n":
          s = "" + e.v;
          break;
        case "e":
          s = pf[e.v];
          break;
        case "d":
          r && r.cellDates ? s = fp(e.v, -1).toISOString() : ((e = mp(e)).t = "n", s = "" + (e.v = ap(fp(e.v)))), void 0 === e.z && (e.z = ud[14]);
          break;
        default:
          s = e.v
      }
      var a = EE("v", jp(s)),
        l = {
          r: t
        },
        c = HS(r.cellXfs, e, r);
      switch (0 !== c && (l.s = c), e.t) {
        case "n":
        case "z":
          break;
        case "d":
          l.t = "d";
          break;
        case "b":
          l.t = "b";
          break;
        case "e":
          l.t = "e";
          break;
        default:
          if (null == e.v) {
            delete e.t;
            break
          }
          if (e.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
          if (r && r.bookSST) {
            a = EE("v", "" + xS(r.Strings, e.v, r.revStrings)), l.t = "s";
            break
          }
          l.t = "str"
      }
      if (e.t != n && (e.t = n, e.v = o), "string" == typeof e.f && e.f) {
        var h = e.F && e.F.slice(0, t.length) == t ? {
          t: "array",
          ref: e.F
        } : null;
        a = fE("f", jp(e.f), h) + (null != e.v ? a : "")
      }
      return e.l && i["!links"].push([t, e.l]), e.D && (l.cm = 1), fE("c", a, l)
    }
    var sR = function() {
      var e = /<(?:\w+:)?c[ \/>]/,
        t = /<\/(?:\w+:)?row>/,
        i = /r=["']([^"']*)["']/,
        r = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/,
        s = /ref=["']([^"']*)["']/,
        n = aE("v"),
        o = aE("f");
      return function(a, l, c, h, u, d) {
        for (var p, E, g, f, T, m = 0, C = "", S = [], R = [], A = 0, v = 0, N = 0, I = "", O = 0, L = 0, _ = 0, y = 0, w = Array.isArray(d.CellXf), D = [], P = [], b = Array.isArray(l), M = [], F = {}, x = !1, G = !!c.sheetStubs, U = a.split(t), H = 0, k = U.length; H != k; ++H) {
          var B = (C = U[H].trim()).length;
          if (0 !== B) {
            var V = 0;
            e: for (m = 0; m < B; ++m) switch (C[m]) {
              case ">":
                if ("/" != C[m - 1]) {
                  ++m;
                  break e
                }
                if (c && c.cellStyles) {
                  if (O = null != (E = Vp(C.slice(V, m), !0)).r ? parseInt(E.r, 10) : O + 1, L = -1, c.sheetRows && c.sheetRows < O) continue;
                  F = {}, x = !1, E.ht && (x = !0, F.hpt = parseFloat(E.ht), F.hpx = Jm(F.hpt)), "1" == E.hidden && (x = !0, F.hidden = !0), null != E.outlineLevel && (x = !0, F.level = +E.outlineLevel), x && (M[O - 1] = F)
                }
                break;
              case "<":
                V = m
            }
            if (V >= m) break;
            if (O = null != (E = Vp(C.slice(V, m), !0)).r ? parseInt(E.r, 10) : O + 1, L = -1, !(c.sheetRows && c.sheetRows < O)) {
              h.s.r > O - 1 && (h.s.r = O - 1), h.e.r < O - 1 && (h.e.r = O - 1), c && c.cellStyles && (F = {}, x = !1, E.ht && (x = !0, F.hpt = parseFloat(E.ht), F.hpx = Jm(F.hpt)), "1" == E.hidden && (x = !0, F.hidden = !0), null != E.outlineLevel && (x = !0, F.level = +E.outlineLevel), x && (M[O - 1] = F)), S = C.slice(m).split(e);
              for (var W = 0; W != S.length && "<" == S[W].trim().charAt(0); ++W);
              for (S = S.slice(W), m = 0; m != S.length; ++m)
                if (0 !== (C = S[m].trim()).length) {
                  if (R = C.match(i), A = m, v = 0, N = 0, C = "<c " + ("<" == C.slice(0, 1) ? ">" : "") + C, null != R && 2 === R.length) {
                    for (A = 0, I = R[1], v = 0; v != I.length && !((N = I.charCodeAt(v) - 64) < 1 || N > 26); ++v) A = 26 * A + N;
                    L = --A
                  } else ++L;
                  for (v = 0; v != C.length && 62 !== C.charCodeAt(v); ++v);
                  if (++v, (E = Vp(C.slice(0, v), !0)).r || (E.r = mg({
                      r: O - 1,
                      c: L
                    })), p = {
                      t: ""
                    }, null != (R = (I = C.slice(v)).match(n)) && "" !== R[1] && (p.v = Xp(R[1])), c.cellFormula) {
                    if (null != (R = I.match(o)) && "" !== R[1]) {
                      if (p.f = Xp(nE(R[1])).replace(/\r\n/g, "\n"), c.xlfn || (p.f = YC(p.f)), R[0].indexOf('t="array"') > -1) p.F = (I.match(s) || [])[1], p.F.indexOf(":") > -1 && D.push([Rg(p.F), p.F]);
                      else if (R[0].indexOf('t="shared"') > -1) {
                        f = Vp(R[0]);
                        var Y = Xp(nE(R[1]));
                        c.xlfn || (Y = YC(Y)), P[parseInt(f.si, 10)] = [f, Y, E.r]
                      }
                    } else(R = I.match(/<f[^>]*\/>/)) && P[(f = Vp(R[0])).si] && (p.f = WC(P[f.si][1], P[f.si][2], E.r));
                    var K = Tg(E.r);
                    for (v = 0; v < D.length; ++v) K.r >= D[v][0].s.r && K.r <= D[v][0].e.r && K.c >= D[v][0].s.c && K.c <= D[v][0].e.c && (p.F = D[v][1])
                  }
                  if (null == E.t && void 0 === p.v)
                    if (p.f || p.F) p.v = 0, p.t = "n";
                    else {
                      if (!G) continue;
                      p.t = "z"
                    }
                  else p.t = E.t || "n";
                  switch (h.s.c > L && (h.s.c = L), h.e.c < L && (h.e.c = L), p.t) {
                    case "n":
                      if ("" == p.v || null == p.v) {
                        if (!G) continue;
                        p.t = "z"
                      } else p.v = parseFloat(p.v);
                      break;
                    case "s":
                      if (void 0 === p.v) {
                        if (!G) continue;
                        p.t = "z"
                      } else g = bS[parseInt(p.v, 10)], p.v = g.t, p.r = g.r, c.cellHTML && (p.h = g.h);
                      break;
                    case "str":
                      p.t = "s", p.v = null != p.v ? nE(p.v) : "", c.cellHTML && (p.h = Qp(p.v));
                      break;
                    case "inlineStr":
                      R = I.match(r), p.t = "s", null != R && (g = Em(R[1])) ? (p.v = g.t, c.cellHTML && (p.h = g.h)) : p.v = "";
                      break;
                    case "b":
                      p.v = eE(p.v);
                      break;
                    case "d":
                      c.cellDates ? p.v = fp(p.v, 1) : (p.v = ap(fp(p.v, 1)), p.t = "n");
                      break;
                    case "e":
                      c && !1 === c.cellText || (p.w = p.v), p.v = Ef[p.v]
                  }
                  if (_ = y = 0, T = null, w && void 0 !== E.s && null != (T = d.CellXf[E.s]) && (null != T.numFmtId && (_ = T.numFmtId), c.cellStyles && null != T.fillId && (y = T.fillId)), kS(p, _, y, c, u, d), c.cellDates && w && "n" == p.t && Hd(ud[_]) && (p.t = "d", p.v = up(p.v)), E.cm && c.xlmeta) {
                    var X = (c.xlmeta.Cell || [])[+E.cm - 1];
                    X && "XLDAPR" == X.type && (p.D = !0)
                  }
                  if (b) {
                    var z = Tg(E.r);
                    l[z.r] || (l[z.r] = []), l[z.r][z.c] = p
                  } else l[E.r] = p
                }
            }
          }
        }
        M.length > 0 && (l["!rows"] = M)
      }
    }();

    function nR(e, t, i, r) {
      var s, n = [xp, fE("worksheet", null, {
          xmlns: RE[0],
          "xmlns:r": SE.r
        })],
        o = i.SheetNames[e],
        a = "",
        l = i.Sheets[o];
      null == l && (l = {});
      var c = l["!ref"] || "A1",
        h = Rg(c);
      if (h.e.c > 16383 || h.e.r > 1048575) {
        if (t.WTF) throw new Error("Range " + c + " exceeds format limit A1:XFD1048576");
        h.e.c = Math.min(h.e.c, 16383), h.e.r = Math.min(h.e.c, 1048575), c = Sg(h)
      }
      r || (r = {}), l["!comments"] = [];
      var u = [];
      ! function(e, t, i, r, s) {
        var n = !1,
          o = {},
          a = null;
        if ("xlsx" !== r.bookType && t.vbaraw) {
          var l = t.SheetNames[i];
          try {
            t.Workbook && (l = t.Workbook.Sheets[i].CodeName || l)
          } catch (e) {}
          n = !0, o.codeName = oE(jp(l))
        }
        if (e && e["!outline"]) {
          var c = {
            summaryBelow: 1,
            summaryRight: 1
          };
          e["!outline"].above && (c.summaryBelow = 0), e["!outline"].left && (c.summaryRight = 0), a = (a || "") + fE("outlinePr", null, c)
        }(n || a) && (s[s.length] = fE("sheetPr", a, o))
      }(l, i, e, t, n), n[n.length] = fE("dimension", null, {
        ref: c
      }), n[n.length] = function(e, t, i, r) {
        var s = {
          workbookViewId: "0"
        };
        return (((r || {}).Workbook || {}).Views || [])[0] && (s.rightToLeft = r.Workbook.Views[0].RTL ? "1" : "0"), fE("sheetViews", fE("sheetView", null, s), {})
      }(0, 0, 0, i), t.sheetFormat && (n[n.length] = fE("sheetFormatPr", null, {
        defaultRowHeight: t.sheetFormat.defaultRowHeight || "16",
        baseColWidth: t.sheetFormat.baseColWidth || "10",
        outlineLevelRow: t.sheetFormat.outlineLevelRow || "7"
      })), null != l["!cols"] && l["!cols"].length > 0 && (n[n.length] = function(e, t) {
        for (var i, r = ["<cols>"], s = 0; s != t.length; ++s)(i = t[s]) && (r[r.length] = fE("col", null, GS(s, i)));
        return r[r.length] = "</cols>", r.join("")
      }(0, l["!cols"])), n[s = n.length] = "<sheetData/>", l["!links"] = [], null != l["!ref"] && (a = function(e, t) {
        var i, r, s = [],
          n = [],
          o = Rg(e["!ref"]),
          a = "",
          l = "",
          c = [],
          h = 0,
          u = 0,
          d = e["!rows"],
          p = Array.isArray(e),
          E = {
            r: l
          },
          g = -1;
        for (u = o.s.c; u <= o.e.c; ++u) c[u] = fg(u);
        for (h = o.s.r; h <= o.e.r; ++h) {
          for (n = [], l = Eg(h), u = o.s.c; u <= o.e.c; ++u) {
            i = c[u] + l;
            var f = p ? (e[h] || [])[u] : e[i];
            void 0 !== f && null != (a = rR(f, i, e, t)) && n.push(a)
          }(n.length > 0 || d && d[h]) && (E = {
            r: l
          }, d && d[h] && ((r = d[h]).hidden && (E.hidden = 1), g = -1, r.hpx ? g = jm(r.hpx) : r.hpt && (g = r.hpt), g > -1 && (E.ht = g, E.customHeight = 1), r.level && (E.outlineLevel = r.level)), s[s.length] = fE("row", n.join(""), E))
        }
        if (d)
          for (; h < d.length; ++h) d && d[h] && (E = {
            r: h + 1
          }, (r = d[h]).hidden && (E.hidden = 1), g = -1, r.hpx ? g = jm(r.hpx) : r.hpt && (g = r.hpt), g > -1 && (E.ht = g, E.customHeight = 1), r.level && (E.outlineLevel = r.level), s[s.length] = fE("row", "", E));
        return s.join("")
      }(l, t, 0, 0), a.length > 0 && (n[n.length] = a)), n.length > s + 1 && (n[n.length] = "</sheetData>", n[s] = n[s].replace("/>", ">")), l["!protect"] && (n[n.length] = function(e) {
        var t = {
          sheet: 1
        };
        return eR.forEach(function(i) {
          null != e[i] && e[i] && (t[i] = "1")
        }), tR.forEach(function(i) {
          null == e[i] || e[i] || (t[i] = "0")
        }), e.password && (t.password = Dm(e.password).toString(16).toUpperCase()), fE("sheetProtection", null, t)
      }(l["!protect"])), null != l["!autofilter"] && (n[n.length] = function(e, t, i, r) {
        var s = "string" == typeof e.ref ? e.ref : Sg(e.ref);
        i.Workbook || (i.Workbook = {
          Sheets: []
        }), i.Workbook.Names || (i.Workbook.Names = []);
        var n = i.Workbook.Names,
          o = Cg(s);
        o.s.r == o.e.r && (o.e.r = Cg(t["!ref"]).e.r, s = Sg(o));
        for (var a = 0; a < n.length; ++a) {
          var l = n[a];
          if ("_xlnm._FilterDatabase" == l.Name && l.Sheet == r) {
            l.Ref = "'" + i.SheetNames[r] + "'!" + s;
            break
          }
        }
        return a == n.length && n.push({
          Name: "_xlnm._FilterDatabase",
          Sheet: r,
          Ref: "'" + i.SheetNames[r] + "'!" + s
        }), fE("autoFilter", null, {
          ref: s
        })
      }(l["!autofilter"], l, i, e)), null != l["!merges"] && l["!merges"].length > 0 && (n[n.length] = function(e) {
        if (0 === e.length) return "";
        for (var t = '<mergeCells count="' + e.length + '">', i = 0; i != e.length; ++i) t += '<mergeCell ref="' + Sg(e[i]) + '"/>';
        return t + "</mergeCells>"
      }(l["!merges"]));
      var d, p, E = -1,
        g = -1;
      return l["!links"].length > 0 && (n[n.length] = "<hyperlinks>", l["!links"].forEach(function(e) {
        e[1].Target && (d = {
          ref: e[0]
        }, "#" != e[1].Target.charAt(0) && (g = Af(r, -1, jp(e[1].Target).replace(/#.*$/, ""), mf.HLINK), d["r:id"] = "rId" + g), (E = e[1].Target.indexOf("#")) > -1 && (d.location = jp(e[1].Target.slice(E + 1))), e[1].Tooltip && (d.tooltip = jp(e[1].Tooltip)), n[n.length] = fE("hyperlink", null, d))
      }), n[n.length] = "</hyperlinks>"), delete l["!links"], null != l["!margins"] && (n[n.length] = (US(p = l["!margins"]), fE("pageMargins", null, p))), t && !t.ignoreEC && null != t.ignoreEC || (n[n.length] = EE("ignoredErrors", fE("ignoredError", null, {
        numberStoredAsText: 1,
        sqref: c
      }))), u.length > 0 && (g = Af(r, -1, "../drawings/drawing" + (e + 1) + ".xml", mf.DRAW), n[n.length] = fE("drawing", null, {
        "r:id": "rId" + g
      }), l["!drawing"] = u), l["!comments"].length > 0 && (g = Af(r, -1, "../drawings/vmlDrawing" + (e + 1) + ".vml", mf.VML), n[n.length] = fE("legacyDrawing", null, {
        "r:id": "rId" + g
      }), l["!legacy"] = g), n.length > 1 && (n[n.length] = "</worksheet>", n[1] = n[1].replace("/>", ">")), n.join("")
    }

    function oR(e, t, i, r) {
      var s = function(e, t, i) {
        var r = ng(145),
          s = (i["!rows"] || [])[e] || {};
        r.write_shift(4, e), r.write_shift(4, 0);
        var n = 320;
        s.hpx ? n = 20 * jm(s.hpx) : s.hpt && (n = 20 * s.hpt), r.write_shift(2, n), r.write_shift(1, 0);
        var o = 0;
        s.level && (o |= s.level), s.hidden && (o |= 16), (s.hpx || s.hpt) && (o |= 32), r.write_shift(1, o), r.write_shift(1, 0);
        var a = 0,
          l = r.l;
        r.l += 4;
        for (var c = {
            r: e,
            c: 0
          }, h = 0; h < 16; ++h)
          if (!(t.s.c > h + 1 << 10 || t.e.c < h << 10)) {
            for (var u = -1, d = -1, p = h << 10; p < h + 1 << 10; ++p) c.c = p, (Array.isArray(i) ? (i[c.r] || [])[c.c] : i[mg(c)]) && (u < 0 && (u = p), d = p);
            u < 0 || (++a, r.write_shift(4, u), r.write_shift(4, d))
          } var E = r.l;
        return r.l = l, r.write_shift(4, a), r.l = E, r.length > r.l ? r.slice(0, r.l) : r
      }(r, i, t);
      (s.length > 17 || (t["!rows"] || [])[r]) && lg(e, 0, s)
    }
    var aR = $g,
      lR = jg;

    function cR(e) {
      return [xg(e), Jg(e), "n"]
    }
    var hR = $g,
      uR = jg;
    var dR = ["left", "right", "top", "bottom", "header", "footer"];

    function pR(e, t, i, r, s, n, o) {
      if (void 0 === t.v) return !1;
      var a = "";
      switch (t.t) {
        case "b":
          a = t.v ? "1" : "0";
          break;
        case "d":
          (t = mp(t)).z = t.z || ud[14], t.v = ap(fp(t.v)), t.t = "n";
          break;
        case "n":
        case "e":
          a = "" + t.v;
          break;
        default:
          a = t.v
      }
      var l = {
        r: i,
        c: r
      };
      switch (l.s = HS(s.cellXfs, t, s), t.l && n["!links"].push([mg(l), t.l]), t.c && n["!comments"].push([mg(l), t.c]), t.t) {
        case "s":
        case "str":
          return s.bookSST ? (a = xS(s.Strings, t.v, s.revStrings), l.t = "s", l.v = a, o ? lg(e, 18, function(e, t, i) {
            return null == i && (i = ng(8)), Gg(t, i), i.write_shift(4, t.v), i
          }(0, l)) : lg(e, 7, function(e, t, i) {
            return null == i && (i = ng(12)), Fg(t, i), i.write_shift(4, t.v), i
          }(0, l))) : (l.t = "str", o ? lg(e, 17, function(e, t, i) {
            return null == i && (i = ng(8 + 4 * e.v.length)), Gg(t, i), yg(e.v, i), i.length > i.l ? i.slice(0, i.l) : i
          }(t, l)) : lg(e, 6, function(e, t, i) {
            return null == i && (i = ng(12 + 4 * e.v.length)), Fg(t, i), yg(e.v, i), i.length > i.l ? i.slice(0, i.l) : i
          }(t, l))), !0;
        case "n":
          return t.v == (0 | t.v) && t.v > -1e3 && t.v < 1e3 ? o ? lg(e, 13, function(e, t, i) {
            return null == i && (i = ng(8)), Gg(t, i), Xg(e.v, i), i
          }(t, l)) : lg(e, 2, function(e, t, i) {
            return null == i && (i = ng(12)), Fg(t, i), Xg(e.v, i), i
          }(t, l)) : o ? lg(e, 16, function(e, t, i) {
            return null == i && (i = ng(12)), Gg(t, i), qg(e.v, i), i
          }(t, l)) : lg(e, 5, function(e, t, i) {
            return null == i && (i = ng(16)), Fg(t, i), qg(e.v, i), i
          }(t, l)), !0;
        case "b":
          return l.t = "b", o ? lg(e, 15, function(e, t, i) {
            return null == i && (i = ng(5)), Gg(t, i), i.write_shift(1, e.v ? 1 : 0), i
          }(t, l)) : lg(e, 4, function(e, t, i) {
            return null == i && (i = ng(9)), Fg(t, i), i.write_shift(1, e.v ? 1 : 0), i
          }(t, l)), !0;
        case "e":
          return l.t = "e", o ? lg(e, 14, function(e, t, i) {
            return null == i && (i = ng(8)), Gg(t, i), i.write_shift(1, e.v), i.write_shift(2, 0), i.write_shift(1, 0), i
          }(t, l)) : lg(e, 3, function(e, t, i) {
            return null == i && (i = ng(9)), Fg(t, i), i.write_shift(1, e.v), i
          }(t, l)), !0
      }
      return o ? lg(e, 12, function(e, t, i) {
        return null == i && (i = ng(4)), Gg(t, i)
      }(0, l)) : lg(e, 1, function(e, t, i) {
        return null == i && (i = ng(8)), Fg(t, i)
      }(0, l)), !0
    }

    function ER(e, t) {
      var i, r;
      t && t["!merges"] && (lg(e, 177, (i = t["!merges"].length, null == r && (r = ng(4)), r.write_shift(4, i), r)), t["!merges"].forEach(function(t) {
        lg(e, 176, uR(t))
      }), lg(e, 178))
    }

    function gR(e, t) {
      t && t["!cols"] && (lg(e, 390), t["!cols"].forEach(function(t, i) {
        t && lg(e, 60, function(e, t, i) {
          null == i && (i = ng(18));
          var r = GS(e, t);
          i.write_shift(-4, e), i.write_shift(-4, e), i.write_shift(4, 256 * (r.width || 10)), i.write_shift(4, 0);
          var s = 0;
          return t.hidden && (s |= 1), "number" == typeof r.width && (s |= 2), t.level && (s |= t.level << 8), i.write_shift(2, s), i
        }(i, t))
      }), lg(e, 391))
    }

    function fR(e, t) {
      var i, r;
      t && t["!ref"] && (lg(e, 648), lg(e, 649, (i = Rg(t["!ref"]), (r = ng(24)).write_shift(4, 4), r.write_shift(4, 1), jg(i, r), r)), lg(e, 650))
    }

    function TR(e, t, i) {
      t["!links"].forEach(function(t) {
        if (t[1].Target) {
          var r = Af(i, -1, t[1].Target.replace(/#.*$/, ""), mf.HLINK);
          lg(e, 494, function(e, t) {
            var i = ng(50 + 4 * (e[1].Target.length + (e[1].Tooltip || "").length));
            jg({
              s: Tg(e[0]),
              e: Tg(e[0])
            }, i), Yg("rId" + t, i);
            var r = e[1].Target.indexOf("#");
            return yg((-1 == r ? "" : e[1].Target.slice(r + 1)) || "", i), yg(e[1].Tooltip || "", i), yg("", i), i.slice(0, i.l)
          }(t, r))
        }
      }), delete t["!links"]
    }

    function mR(e, t, i) {
      lg(e, 133), lg(e, 137, function(e, t, i) {
        null == i && (i = ng(30));
        var r = 924;
        return (((t || {}).Views || [])[0] || {}).RTL && (r |= 32), i.write_shift(2, r), i.write_shift(4, 0), i.write_shift(4, 0), i.write_shift(4, 0), i.write_shift(1, 0), i.write_shift(1, 0), i.write_shift(2, 0), i.write_shift(2, 100), i.write_shift(2, 0), i.write_shift(2, 0), i.write_shift(2, 0), i.write_shift(4, 0), i
      }(0, i)), lg(e, 138), lg(e, 134)
    }

    function CR(e, t) {
      var i, r;
      t["!protect"] && lg(e, 535, (i = t["!protect"], null == r && (r = ng(66)), r.write_shift(2, i.password ? Dm(i.password) : 0), r.write_shift(4, 1), [
        ["objects", !1],
        ["scenarios", !1],
        ["formatCells", !0],
        ["formatColumns", !0],
        ["formatRows", !0],
        ["insertColumns", !0],
        ["insertRows", !0],
        ["insertHyperlinks", !0],
        ["deleteColumns", !0],
        ["deleteRows", !0],
        ["selectLockedCells", !1],
        ["sort", !0],
        ["autoFilter", !0],
        ["pivotTables", !0],
        ["selectUnlockedCells", !1]
      ].forEach(function(e) {
        e[1] ? r.write_shift(4, null == i[e[0]] || i[e[0]] ? 0 : 1) : r.write_shift(4, null != i[e[0]] && i[e[0]] ? 0 : 1)
      }), r))
    }

    function SR(e, t, i, r) {
      var s = ag(),
        n = i.SheetNames[e],
        o = i.Sheets[n] || {},
        a = n;
      try {
        i && i.Workbook && (a = i.Workbook.Sheets[e].CodeName || a)
      } catch (e) {}
      var l, c, h = Rg(o["!ref"] || "A1");
      if (h.e.c > 16383 || h.e.r > 1048575) {
        if (t.WTF) throw new Error("Range " + (o["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
        h.e.c = Math.min(h.e.c, 16383), h.e.r = Math.min(h.e.c, 1048575)
      }
      return o["!links"] = [], o["!comments"] = [], lg(s, 129), (i.vbaraw || o["!outline"]) && lg(s, 147, function(e, t, i) {
          null == i && (i = ng(84 + 4 * e.length));
          var r = 192;
          t && (t.above && (r &= -65), t.left && (r &= -129)), i.write_shift(1, r);
          for (var s = 1; s < 3; ++s) i.write_shift(1, 0);
          return Qg({
            auto: 1
          }, i), i.write_shift(-4, -1), i.write_shift(-4, -1), Hg(e, i), i.slice(0, i.l)
        }(a, o["!outline"])), lg(s, 148, lR(h)), mR(s, 0, i.Workbook), gR(s, o),
        function(e, t, i, r) {
          var s, n = Rg(t["!ref"] || "A1"),
            o = "",
            a = [];
          lg(e, 145);
          var l = Array.isArray(t),
            c = n.e.r;
          t["!rows"] && (c = Math.max(n.e.r, t["!rows"].length - 1));
          for (var h = n.s.r; h <= c; ++h) {
            o = Eg(h), oR(e, t, n, h);
            var u = !1;
            if (h <= n.e.r)
              for (var d = n.s.c; d <= n.e.c; ++d) {
                h === n.s.r && (a[d] = fg(d)), s = a[d] + o;
                var p = l ? (t[h] || [])[d] : t[s];
                u = !!p && pR(e, p, h, d, r, t, u)
              }
          }
          lg(e, 146)
        }(s, o, 0, t), CR(s, o),
        function(e, t, i, r) {
          if (t["!autofilter"]) {
            var s = t["!autofilter"],
              n = "string" == typeof s.ref ? s.ref : Sg(s.ref);
            i.Workbook || (i.Workbook = {
              Sheets: []
            }), i.Workbook.Names || (i.Workbook.Names = []);
            var o = i.Workbook.Names,
              a = Cg(n);
            a.s.r == a.e.r && (a.e.r = Cg(t["!ref"]).e.r, n = Sg(a));
            for (var l = 0; l < o.length; ++l) {
              var c = o[l];
              if ("_xlnm._FilterDatabase" == c.Name && c.Sheet == r) {
                c.Ref = "'" + i.SheetNames[r] + "'!" + n;
                break
              }
            }
            l == o.length && o.push({
              Name: "_xlnm._FilterDatabase",
              Sheet: r,
              Ref: "'" + i.SheetNames[r] + "'!" + n
            }), lg(e, 161, jg(Rg(n))), lg(e, 162)
          }
        }(s, o, i, e), ER(s, o), TR(s, o, r), o["!margins"] && lg(s, 476, (l = o["!margins"], null == c && (c = ng(48)), US(l), dR.forEach(function(e) {
          qg(l[e], c)
        }), c)), t && !t.ignoreEC && null != t.ignoreEC || fR(s, o),
        function(e, t, i, r) {
          if (t["!comments"].length > 0) {
            var s = Af(r, -1, "../drawings/vmlDrawing" + (i + 1) + ".vml", mf.VML);
            lg(e, 551, Yg("rId" + s)), t["!legacy"] = s
          }
        }(s, o, e, r), lg(s, 130), s.end()
    }

    function RR(e, t, i, r, s, n) {
      var o = n || {
        "!type": "chart"
      };
      if (!e) return n;
      var a = 0,
        l = 0,
        c = "A",
        h = {
          s: {
            r: 2e6,
            c: 2e6
          },
          e: {
            r: 0,
            c: 0
          }
        };
      return (e.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(e) {
        var t = function(e) {
          var t, i = [],
            r = e.match(/^<c:numCache>/);
          (e.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/gm) || []).forEach(function(e) {
            var t = e.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
            t && (i[+t[1]] = r ? +t[2] : t[2])
          });
          var s = Xp((e.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
          return (e.match(/<c:f>(.*?)<\/c:f>/gm) || []).forEach(function(e) {
            t = e.replace(/<.*?>/g, "")
          }), [i, s, t]
        }(e);
        h.s.r = h.s.c = 0, h.e.c = a, c = fg(a), t[0].forEach(function(e, i) {
          o[c + Eg(i)] = {
            t: "n",
            v: e,
            z: t[1]
          }, l = i
        }), h.e.r < l && (h.e.r = l), ++a
      }), a > 0 && (o["!ref"] = Sg(h)), o
    }
    var AR = [
        ["allowRefreshQuery", !1, "bool"],
        ["autoCompressPictures", !0, "bool"],
        ["backupFile", !1, "bool"],
        ["checkCompatibility", !1, "bool"],
        ["CodeName", ""],
        ["date1904", !1, "bool"],
        ["defaultThemeVersion", 0, "int"],
        ["filterPrivacy", !1, "bool"],
        ["hidePivotFieldList", !1, "bool"],
        ["promptedSolutions", !1, "bool"],
        ["publishItems", !1, "bool"],
        ["refreshAllConnections", !1, "bool"],
        ["saveExternalLinkValues", !0, "bool"],
        ["showBorderUnselectedTables", !0, "bool"],
        ["showInkAnnotation", !0, "bool"],
        ["showObjects", "all"],
        ["showPivotChartFilter", !1, "bool"],
        ["updateLinks", "userSet"]
      ],
      vR = [
        ["activeTab", 0, "int"],
        ["autoFilterDateGrouping", !0, "bool"],
        ["firstSheet", 0, "int"],
        ["minimized", !1, "bool"],
        ["showHorizontalScroll", !0, "bool"],
        ["showSheetTabs", !0, "bool"],
        ["showVerticalScroll", !0, "bool"],
        ["tabRatio", 600, "int"],
        ["visibility", "visible"]
      ],
      NR = [],
      IR = [
        ["calcCompleted", "true"],
        ["calcMode", "auto"],
        ["calcOnSave", "true"],
        ["concurrentCalc", "true"],
        ["fullCalcOnLoad", "false"],
        ["fullPrecision", "true"],
        ["iterate", "false"],
        ["iterateCount", "100"],
        ["iterateDelta", "0.001"],
        ["refMode", "A1"]
      ];

    function LR(e, t) {
      for (var i = 0; i != e.length; ++i)
        for (var r = e[i], s = 0; s != t.length; ++s) {
          var n = t[s];
          if (null == r[n[0]]) r[n[0]] = n[1];
          else switch (n[2]) {
            case "bool":
              "string" == typeof r[n[0]] && (r[n[0]] = eE(r[n[0]]));
              break;
            case "int":
              "string" == typeof r[n[0]] && (r[n[0]] = parseInt(r[n[0]], 10))
          }
        }
    }

    function _R(e, t) {
      for (var i = 0; i != t.length; ++i) {
        var r = t[i];
        if (null == e[r[0]]) e[r[0]] = r[1];
        else switch (r[2]) {
          case "bool":
            "string" == typeof e[r[0]] && (e[r[0]] = eE(e[r[0]]));
            break;
          case "int":
            "string" == typeof e[r[0]] && (e[r[0]] = parseInt(e[r[0]], 10))
        }
      }
    }

    function yR(e) {
      _R(e.WBProps, AR), _R(e.CalcPr, IR), LR(e.WBView, vR), LR(e.Sheets, NR), MS.date1904 = eE(e.WBProps.date1904)
    }
    var wR = "][*?/\\".split("");

    function DR(e, t) {
      if (e.length > 31) {
        if (t) return !1;
        throw new Error("Sheet names cannot exceed 31 chars")
      }
      var i = !0;
      return wR.forEach(function(r) {
        if (-1 != e.indexOf(r)) {
          if (!t) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
          i = !1
        }
      }), i
    }

    function PR(e) {
      if (!e || !e.SheetNames || !e.Sheets) throw new Error("Invalid Workbook");
      if (!e.SheetNames.length) throw new Error("Workbook is empty");
      var t, i, r, s = e.Workbook && e.Workbook.Sheets || [];
      t = e.SheetNames, i = s, r = !!e.vbaraw, t.forEach(function(e, s) {
        DR(e);
        for (var n = 0; n < s; ++n)
          if (e == t[n]) throw new Error("Duplicate Sheet Name: " + e);
        if (r) {
          var o = i && i[s] && i[s].CodeName || e;
          if (95 == o.charCodeAt(0) && o.length > 22) throw new Error("Bad Code Name: Worksheet" + o)
        }
      });
      for (var n = 0; n < e.SheetNames.length; ++n) BS(e.Sheets[e.SheetNames[n]], e.SheetNames[n], n)
    }
    var bR = /<\w+:workbook/;

    function MR(e) {
      var t = [xp];
      t[t.length] = fE("workbook", null, {
        xmlns: RE[0],
        "xmlns:r": SE.r
      });
      var i = e.Workbook && (e.Workbook.Names || []).length > 0,
        r = {
          codeName: "ThisWorkbook"
        };
      e.Workbook && e.Workbook.WBProps && (AR.forEach(function(t) {
        null != e.Workbook.WBProps[t[0]] && e.Workbook.WBProps[t[0]] != t[1] && (r[t[0]] = e.Workbook.WBProps[t[0]])
      }), e.Workbook.WBProps.CodeName && (r.codeName = e.Workbook.WBProps.CodeName, delete r.CodeName)), t[t.length] = fE("workbookPr", null, r);
      var s = e.Workbook && e.Workbook.Sheets || [],
        n = 0;
      if (s && s[0] && s[0].Hidden) {
        for (t[t.length] = "<bookViews>", n = 0; n != e.SheetNames.length && s[n] && s[n].Hidden; ++n);
        n == e.SheetNames.length && (n = 0), t[t.length] = '<workbookView firstSheet="' + n + '" activeTab="' + n + '"/>', t[t.length] = "</bookViews>"
      }
      for (t[t.length] = "<sheets>", n = 0; n != e.SheetNames.length; ++n) {
        var o = {
          name: jp(e.SheetNames[n].slice(0, 31))
        };
        if (o.sheetId = "" + (n + 1), o["r:id"] = "rId" + (n + 1), s[n]) switch (s[n].Hidden) {
          case 1:
            o.state = "hidden";
            break;
          case 2:
            o.state = "veryHidden"
        }
        t[t.length] = fE("sheet", null, o)
      }
      return t[t.length] = "</sheets>", i && (t[t.length] = "<definedNames>", e.Workbook && e.Workbook.Names && e.Workbook.Names.forEach(function(e) {
        var i = {
          name: e.Name
        };
        e.Comment && (i.comment = e.Comment), null != e.Sheet && (i.localSheetId = "" + e.Sheet), e.Hidden && (i.hidden = "1"), e.Ref && (t[t.length] = fE("definedName", jp(e.Ref), i))
      }), t[t.length] = "</definedNames>"), t.length > 2 && (t[t.length] = "</workbook>", t[1] = t[1].replace("/>", ">")), t.join("")
    }

    function FR(e, t) {
      return t || (t = ng(127)), t.write_shift(4, e.Hidden), t.write_shift(4, e.iTabID), Yg(e.strRelID, t), yg(e.name.slice(0, 31), t), t.length > t.l ? t.slice(0, t.l) : t
    }

    function xR(e, t) {
      var i = {};
      return e.read_shift(4), i.ArchID = e.read_shift(4), e.l += t - 8, i
    }

    function GR(e, t) {
      if (t.Workbook && t.Workbook.Sheets) {
        for (var i, r, s = t.Workbook.Sheets, n = 0, o = -1, a = -1; n < s.length; ++n) !s[n] || !s[n].Hidden && -1 == o ? o = n : 1 == s[n].Hidden && -1 == a && (a = n);
        if (!(a > o)) lg(e, 135), lg(e, 158, (i = o, r || (r = ng(29)), r.write_shift(-4, 0), r.write_shift(-4, 460), r.write_shift(4, 28800), r.write_shift(4, 17600), r.write_shift(4, 500), r.write_shift(4, i), r.write_shift(4, i), r.write_shift(1, 120), r.length > r.l ? r.slice(0, r.l) : r)), lg(e, 136)
      }
    }

    function UR(e, t) {
      var i = ag();
      return lg(i, 131), lg(i, 128, function(e, t) {
          t || (t = ng(127));
          for (var i = 0; 4 != i; ++i) t.write_shift(4, 0);
          return yg("SheetJS", t), yg(Ou.version, t), yg(Ou.version, t), yg("7262", t), t.length > t.l ? t.slice(0, t.l) : t
        }()), lg(i, 153, function(e, t) {
          t || (t = ng(72));
          var i = 0;
          return e && e.filterPrivacy && (i |= 8), t.write_shift(4, i), t.write_shift(4, 0), Hg(e && e.CodeName || "ThisWorkbook", t), t.slice(0, t.l)
        }(e.Workbook && e.Workbook.WBProps || null)), GR(i, e),
        function(e, t) {
          lg(e, 143);
          for (var i = 0; i != t.SheetNames.length; ++i) lg(e, 156, FR({
            Hidden: t.Workbook && t.Workbook.Sheets && t.Workbook.Sheets[i] && t.Workbook.Sheets[i].Hidden || 0,
            iTabID: i + 1,
            strRelID: "rId" + (i + 1),
            name: t.SheetNames[i]
          }));
          lg(e, 144)
        }(i, e), lg(i, 132), i.end()
    }

    function HR(e, t, i) {
      return ".bin" === t.slice(-4) ? function(e, t) {
        var i = {
            AppVersion: {},
            WBProps: {},
            WBView: [],
            Sheets: [],
            CalcPr: {},
            xmlns: ""
          },
          r = [],
          s = !1;
        t || (t = {}), t.biff = 12;
        var n = [],
          o = [
            []
          ];
        return o.SheetNames = [], o.XTI = [], vA[16] = {
          n: "BrtFRTArchID$",
          f: xR
        }, og(e, function(e, a, l) {
          switch (l) {
            case 156:
              o.SheetNames.push(e.name), i.Sheets.push(e);
              break;
            case 153:
              i.WBProps = e;
              break;
            case 39:
              null != e.Sheet && (t.SID = e.Sheet), e.Ref = fS(e.Ptg, 0, null, o, t), delete t.SID, delete e.Ptg, n.push(e);
              break;
            case 1036:
            case 361:
            case 2071:
            case 158:
            case 143:
            case 664:
            case 353:
            case 3072:
            case 3073:
            case 534:
            case 677:
            case 157:
            case 610:
            case 2050:
            case 155:
            case 548:
            case 676:
            case 128:
            case 665:
            case 2128:
            case 2125:
            case 549:
            case 2053:
            case 596:
            case 2076:
            case 2075:
            case 2082:
            case 397:
            case 154:
            case 1117:
            case 553:
            case 2091:
            case 16:
              break;
            case 357:
            case 358:
            case 355:
            case 667:
              o[0].length ? o.push([l, e]) : o[0] = [l, e], o[o.length - 1].XTI = [];
              break;
            case 362:
              0 === o.length && (o[0] = [], o[0].XTI = []), o[o.length - 1].XTI = o[o.length - 1].XTI.concat(e), o.XTI = o.XTI.concat(e);
              break;
            case 35:
            case 37:
              r.push(l), s = !0;
              break;
            case 36:
            case 38:
              r.pop(), s = !1;
              break;
            default:
              if (a.T);
              else if (!s || t.WTF && 37 != r[r.length - 1] && 35 != r[r.length - 1]) throw new Error("Unexpected record 0x" + l.toString(16))
          }
        }, t), yR(i), i.Names = n, i.supbooks = o, i
      }(e, i) : function(e, t) {
        if (!e) throw new Error("Could not find file");
        var i = {
            AppVersion: {},
            WBProps: {},
            WBView: [],
            Sheets: [],
            CalcPr: {},
            Names: [],
            xmlns: ""
          },
          r = !1,
          s = "xmlns",
          n = {},
          o = 0;
        if (e.replace(Hp, function(a, l) {
            var c = Vp(a);
            switch (Wp(c[0])) {
              case "<?xml":
              case "</workbook>":
              case "<fileVersion/>":
              case "</fileVersion>":
              case "<fileSharing":
              case "<fileSharing/>":
              case "</workbookPr>":
              case "<workbookProtection":
              case "<workbookProtection/>":
              case "<bookViews":
              case "<bookViews>":
              case "</bookViews>":
              case "</workbookView>":
              case "<sheets":
              case "<sheets>":
              case "</sheets>":
              case "</sheet>":
              case "<functionGroups":
              case "<functionGroups/>":
              case "<functionGroup":
              case "<externalReferences":
              case "</externalReferences>":
              case "<externalReferences>":
              case "<externalReference":
              case "<definedNames/>":
              case "<definedName/>":
              case "</calcPr>":
              case "<oleSize":
              case "<customWorkbookViews>":
              case "</customWorkbookViews>":
              case "<customWorkbookViews":
              case "<customWorkbookView":
              case "</customWorkbookView>":
              case "<pivotCaches>":
              case "</pivotCaches>":
              case "<pivotCaches":
              case "<pivotCache":
              case "<smartTagPr":
              case "<smartTagPr/>":
              case "<smartTagTypes":
              case "<smartTagTypes>":
              case "</smartTagTypes>":
              case "<smartTagType":
              case "<webPublishing":
              case "<webPublishing/>":
              case "<fileRecoveryPr":
              case "<fileRecoveryPr/>":
              case "<webPublishObjects>":
              case "<webPublishObjects":
              case "</webPublishObjects>":
              case "<webPublishObject":
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
              case "<extLst/>":
              case "<ArchID":
              case "<revisionPtr":
                break;
              case "<workbook":
                a.match(bR) && (s = "xmlns" + a.match(/<(\w+):/)[1]), i.xmlns = c[s];
                break;
              case "<fileVersion":
                delete c[0], i.AppVersion = c;
                break;
              case "<workbookPr":
              case "<workbookPr/>":
                AR.forEach(function(e) {
                  if (null != c[e[0]]) switch (e[2]) {
                    case "bool":
                      i.WBProps[e[0]] = eE(c[e[0]]);
                      break;
                    case "int":
                      i.WBProps[e[0]] = parseInt(c[e[0]], 10);
                      break;
                    default:
                      i.WBProps[e[0]] = c[e[0]]
                  }
                }), c.codeName && (i.WBProps.CodeName = nE(c.codeName));
                break;
              case "<workbookView":
              case "<workbookView/>":
                delete c[0], i.WBView.push(c);
                break;
              case "<sheet":
                switch (c.state) {
                  case "hidden":
                    c.Hidden = 1;
                    break;
                  case "veryHidden":
                    c.Hidden = 2;
                    break;
                  default:
                    c.Hidden = 0
                }
                delete c.state, c.name = Xp(nE(c.name)), delete c[0], i.Sheets.push(c);
                break;
              case "<definedNames>":
              case "<definedNames":
              case "<ext":
              case "<AlternateContent":
              case "<AlternateContent>":
                r = !0;
                break;
              case "</definedNames>":
              case "</ext>":
              case "</AlternateContent>":
                r = !1;
                break;
              case "<definedName":
                (n = {}).Name = nE(c.name), c.comment && (n.Comment = c.comment), c.localSheetId && (n.Sheet = +c.localSheetId), eE(c.hidden || "0") && (n.Hidden = !0), o = l + a.length;
                break;
              case "</definedName>":
                n.Ref = Xp(nE(e.slice(o, l))), i.Names.push(n);
                break;
              case "<calcPr":
              case "<calcPr/>":
                delete c[0], i.CalcPr = c;
                break;
              default:
                if (!r && t.WTF) throw new Error("unrecognized " + c[0] + " in workbook")
            }
            return a
          }), -1 === RE.indexOf(i.xmlns)) throw new Error("Unknown Namespace: " + i.xmlns);
        return yR(i), i
      }(e, i)
    }

    function kR(e, t, i, r, s, n, o, a) {
      return ".bin" === t.slice(-4) ? function(e, t, i, r, s, n, o) {
        if (!e) return e;
        var a = t || {};
        r || (r = {
          "!id": {}
        }), null != Bu && null == a.dense && (a.dense = Bu);
        var l, c, h, u, d, p, E, g, f, T, m = a.dense ? [] : {},
          C = {
            s: {
              r: 2e6,
              c: 2e6
            },
            e: {
              r: 0,
              c: 0
            }
          },
          S = [],
          R = !1,
          A = !1,
          v = [];
        a.biff = 12, a["!row"] = 0;
        var N = 0,
          I = !1,
          O = [],
          L = {},
          _ = a.supbooks || s.supbooks || [
            []
          ];
        if (_.sharedf = L, _.arrayf = O, _.SheetNames = s.SheetNames || s.Sheets.map(function(e) {
            return e.name
          }), !a.supbooks && (a.supbooks = _, s.Names))
          for (var y = 0; y < s.Names.length; ++y) _[0][y + 1] = s.Names[y];
        var w, D, P = [],
          b = [],
          M = !1;
        if (vA[16] = {
            n: "BrtShortReal",
            f: cR
          }, og(e, function(e, t, y) {
            if (!A) switch (y) {
              case 148:
                l = e;
                break;
              case 0:
                c = e, a.sheetRows && a.sheetRows <= c.r && (A = !0), f = Eg(d = c.r), a["!row"] = c.r, (e.hidden || e.hpt || null != e.level) && (e.hpt && (e.hpx = Jm(e.hpt)), b[e.r] = e);
                break;
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 62:
                switch (h = {
                    t: e[2]
                  }, e[2]) {
                  case "n":
                    h.v = e[1];
                    break;
                  case "s":
                    g = bS[e[1]], h.v = g.t, h.r = g.r;
                    break;
                  case "b":
                    h.v = !!e[1];
                    break;
                  case "e":
                    h.v = e[1], !1 !== a.cellText && (h.w = pf[h.v]);
                    break;
                  case "str":
                    h.t = "s", h.v = e[1];
                    break;
                  case "is":
                    h.t = "s", h.v = e[1].t
                }
                if ((u = o.CellXf[e[0].iStyleRef]) && kS(h, u.numFmtId, null, a, n, o), p = -1 == e[0].c ? p + 1 : e[0].c, a.dense ? (m[d] || (m[d] = []), m[d][p] = h) : m[fg(p) + f] = h, a.cellFormula) {
                  for (I = !1, N = 0; N < O.length; ++N) {
                    var F = O[N];
                    c.r >= F[0].s.r && c.r <= F[0].e.r && p >= F[0].s.c && p <= F[0].e.c && (h.F = Sg(F[0]), I = !0)
                  }!I && e.length > 3 && (h.f = e[3])
                }
                if (C.s.r > c.r && (C.s.r = c.r), C.s.c > p && (C.s.c = p), C.e.r < c.r && (C.e.r = c.r), C.e.c < p && (C.e.c = p), a.cellDates && u && "n" == h.t && Hd(ud[u.numFmtId])) {
                  var x = gd(h.v);
                  x && (h.t = "d", h.v = new Date(x.y, x.m - 1, x.d, x.H, x.M, x.S, x.u))
                }
                w && ("XLDAPR" == w.type && (h.D = !0), w = void 0), D && (D = void 0);
                break;
              case 1:
              case 12:
                if (!a.sheetStubs || R) break;
                h = {
                  t: "z",
                  v: void 0
                }, p = -1 == e[0].c ? p + 1 : e[0].c, a.dense ? (m[d] || (m[d] = []), m[d][p] = h) : m[fg(p) + f] = h, C.s.r > c.r && (C.s.r = c.r), C.s.c > p && (C.s.c = p), C.e.r < c.r && (C.e.r = c.r), C.e.c < p && (C.e.c = p), w && ("XLDAPR" == w.type && (h.D = !0), w = void 0), D && (D = void 0);
                break;
              case 176:
                v.push(e);
                break;
              case 49:
                w = ((a.xlmeta || {}).Cell || [])[e - 1];
                break;
              case 494:
                var G = r["!id"][e.relId];
                for (G ? (e.Target = G.Target, e.loc && (e.Target += "#" + e.loc), e.Rel = G) : "" == e.relId && (e.Target = "#" + e.loc), d = e.rfx.s.r; d <= e.rfx.e.r; ++d)
                  for (p = e.rfx.s.c; p <= e.rfx.e.c; ++p) a.dense ? (m[d] || (m[d] = []), m[d][p] || (m[d][p] = {
                    t: "z",
                    v: void 0
                  }), m[d][p].l = e) : (E = mg({
                    c: p,
                    r: d
                  }), m[E] || (m[E] = {
                    t: "z",
                    v: void 0
                  }), m[E].l = e);
                break;
              case 426:
                if (!a.cellFormula) break;
                O.push(e), (T = a.dense ? m[d][p] : m[fg(p) + f]).f = fS(e[1], 0, {
                  r: c.r,
                  c: p
                }, _, a), T.F = Sg(e[0]);
                break;
              case 427:
                if (!a.cellFormula) break;
                L[mg(e[0].s)] = e[1], (T = a.dense ? m[d][p] : m[fg(p) + f]).f = fS(e[1], 0, {
                  r: c.r,
                  c: p
                }, _, a);
                break;
              case 60:
                if (!a.cellStyles) break;
                for (; e.e >= e.s;) P[e.e--] = {
                  width: e.w / 256,
                  hidden: !!(1 & e.flags),
                  level: e.level
                }, M || (M = !0, Xm(e.w / 256)), zm(P[e.e + 1]);
                break;
              case 161:
                m["!autofilter"] = {
                  ref: Sg(e)
                };
                break;
              case 476:
                m["!margins"] = e;
                break;
              case 147:
                s.Sheets[i] || (s.Sheets[i] = {}), e.name && (s.Sheets[i].CodeName = e.name), (e.above || e.left) && (m["!outline"] = {
                  above: e.above,
                  left: e.left
                });
                break;
              case 137:
                s.Views || (s.Views = [{}]), s.Views[0] || (s.Views[0] = {}), e.RTL && (s.Views[0].RTL = !0);
                break;
              case 485:
              case 64:
              case 1053:
              case 151:
              case 152:
              case 175:
              case 644:
              case 625:
              case 562:
              case 396:
              case 1112:
              case 1146:
              case 471:
              case 1050:
              case 649:
              case 1105:
              case 589:
              case 607:
              case 564:
              case 1055:
              case 168:
              case 174:
              case 1180:
              case 499:
              case 507:
              case 550:
              case 171:
              case 167:
              case 1177:
              case 169:
              case 1181:
              case 551:
              case 552:
              case 661:
              case 639:
              case 478:
              case 537:
              case 477:
              case 536:
              case 1103:
              case 680:
              case 1104:
              case 1024:
              case 663:
              case 535:
              case 678:
              case 504:
              case 1043:
              case 428:
              case 170:
              case 3072:
              case 50:
              case 2070:
              case 1045:
                break;
              case 35:
                R = !0;
                break;
              case 36:
                R = !1;
                break;
              case 37:
                S.push(y), R = !0;
                break;
              case 38:
                S.pop(), R = !1;
                break;
              default:
                if (t.T);
                else if (!R || a.WTF) throw new Error("Unexpected record 0x" + y.toString(16))
            }
          }, a), delete a.supbooks, delete a["!row"], !m["!ref"] && (C.s.r < 2e6 || l && (l.e.r > 0 || l.e.c > 0 || l.s.r > 0 || l.s.c > 0)) && (m["!ref"] = Sg(l || C)), a.sheetRows && m["!ref"]) {
          var F = Rg(m["!ref"]);
          a.sheetRows <= +F.e.r && (F.e.r = a.sheetRows - 1, F.e.r > C.e.r && (F.e.r = C.e.r), F.e.r < F.s.r && (F.s.r = F.e.r), F.e.c > C.e.c && (F.e.c = C.e.c), F.e.c < F.s.c && (F.s.c = F.e.c), m["!fullref"] = m["!ref"], m["!ref"] = Sg(F))
        }
        return v.length > 0 && (m["!merges"] = v), P.length > 0 && (m["!cols"] = P), b.length > 0 && (m["!rows"] = b), m
      }(e, r, i, s, n, o, a) : QS(e, r, i, s, n, o, a)
    }

    function BR(e, t, i, r, s, n, o, a) {
      return ".bin" === t.slice(-4) ? function(e, t, i, r, s) {
        if (!e) return e;
        r || (r = {
          "!id": {}
        });
        var n = {
            "!type": "chart",
            "!drawel": null,
            "!rel": ""
          },
          o = [],
          a = !1;
        return og(e, function(e, r, l) {
          switch (l) {
            case 550:
              n["!rel"] = e;
              break;
            case 651:
              s.Sheets[i] || (s.Sheets[i] = {}), e.name && (s.Sheets[i].CodeName = e.name);
              break;
            case 562:
            case 652:
            case 669:
            case 679:
            case 551:
            case 552:
            case 476:
            case 3072:
              break;
            case 35:
              a = !0;
              break;
            case 36:
              a = !1;
              break;
            case 37:
              o.push(l);
              break;
            case 38:
              o.pop();
              break;
            default:
              if (r.T > 0) o.push(l);
              else if (r.T < 0) o.pop();
              else if (!a || t.WTF) throw new Error("Unexpected record 0x" + l.toString(16))
          }
        }, t), r["!id"][n["!rel"]] && (n["!drawel"] = r["!id"][n["!rel"]]), n
      }(e, r, i, s, n) : function(e, t, i, r, s) {
        if (!e) return e;
        r || (r = {
          "!id": {}
        });
        var n, o = {
            "!type": "chart",
            "!drawel": null,
            "!rel": ""
          },
          a = e.match(jS);
        return a && ZS(a[0], 0, s, i), (n = e.match(/drawing r:id="(.*?)"/)) && (o["!rel"] = n[1]), r["!id"][o["!rel"]] && (o["!drawel"] = r["!id"][o["!rel"]]), o
      }(e, 0, i, s, n)
    }

    function VR(e, t, i, r) {
      return ".bin" === t.slice(-4) ? function(e, t, i) {
        var r = {
          NumberFmt: []
        };
        for (var s in ud) r.NumberFmt[s] = ud[s];
        r.CellXf = [], r.Fonts = [];
        var n = [],
          o = !1;
        return og(e, function(e, s, a) {
          switch (a) {
            case 44:
              r.NumberFmt[e[0]] = e[1], Yd(e[1], e[0]);
              break;
            case 43:
              r.Fonts.push(e), null != e.color.theme && t && t.themeElements && t.themeElements.clrScheme && (e.color.rgb = Gm(t.themeElements.clrScheme[e.color.theme].rgb, e.color.tint || 0));
              break;
            case 1025:
            case 45:
            case 46:
            case 48:
            case 507:
            case 572:
            case 475:
            case 1171:
            case 2102:
            case 1130:
            case 512:
            case 2095:
            case 3072:
              break;
            case 47:
              617 == n[n.length - 1] && r.CellXf.push(e);
              break;
            case 35:
              o = !0;
              break;
            case 36:
              o = !1;
              break;
            case 37:
              n.push(a), o = !0;
              break;
            case 38:
              n.pop(), o = !1;
              break;
            default:
              if (s.T > 0) n.push(a);
              else if (s.T < 0) n.pop();
              else if (!o || i.WTF && 37 != n[n.length - 1]) throw new Error("Unexpected record 0x" + a.toString(16))
          }
        }), r
      }(e, i, r) : eC(e, i, r)
    }

    function WR(e, t, i) {
      return ".bin" === t.slice(-4) ? function(e, t) {
        var i = [],
          r = !1;
        return og(e, function(e, s, n) {
          switch (n) {
            case 159:
              i.Count = e[0], i.Unique = e[1];
              break;
            case 19:
              i.push(e);
              break;
            case 160:
              return !0;
            case 35:
              r = !0;
              break;
            case 36:
              r = !1;
              break;
            default:
              if (s.T, !r || t.WTF) throw new Error("Unexpected record 0x" + n.toString(16))
          }
        }), i
      }(e, i) : function(e, t) {
        var i = [],
          r = "";
        if (!e) return i;
        var s = e.match(gm);
        if (s) {
          r = s[2].replace(fm, "").split(Tm);
          for (var n = 0; n != r.length; ++n) {
            var o = Em(r[n].trim(), t);
            null != o && (i[i.length] = o)
          }
          s = Vp(s[1]), i.Count = s.count, i.Unique = s.uniqueCount
        }
        return i
      }(e, i)
    }

    function YR(e, t, i) {
      return ".bin" === t.slice(-4) ? function(e, t) {
        var i = [],
          r = [],
          s = {},
          n = !1;
        return og(e, function(e, o, a) {
          switch (a) {
            case 632:
              r.push(e);
              break;
            case 635:
              s = e;
              break;
            case 637:
              s.t = e.t, s.h = e.h, s.r = e.r;
              break;
            case 636:
              if (s.author = r[s.iauthor], delete s.iauthor, t.sheetRows && s.rfx && t.sheetRows <= s.rfx.r) break;
              s.t || (s.t = ""), delete s.rfx, i.push(s);
              break;
            case 3072:
            case 37:
            case 38:
              break;
            case 35:
              n = !0;
              break;
            case 36:
              n = !1;
              break;
            default:
              if (o.T);
              else if (!n || t.WTF) throw new Error("Unexpected record 0x" + a.toString(16))
          }
        }), i
      }(e, i) : function(e, t) {
        if (e.match(/<(?:\w+:)?comments *\/>/)) return [];
        var i = [],
          r = [],
          s = e.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
        s && s[1] && s[1].split(/<\/\w*:?author>/).forEach(function(e) {
          if ("" !== e && "" !== e.trim()) {
            var t = e.match(/<(?:\w+:)?author[^>]*>(.*)/);
            t && i.push(t[1])
          }
        });
        var n = e.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
        return n && n[1] && n[1].split(/<\/\w*:?comment>/).forEach(function(e) {
          if ("" !== e && "" !== e.trim()) {
            var s = e.match(/<(?:\w+:)?comment[^>]*>/);
            if (s) {
              var n = Vp(s[0]),
                o = {
                  author: n.authorId && i[n.authorId] || "sheetjsghost",
                  ref: n.ref,
                  guid: n.guid
                },
                a = Tg(n.ref);
              if (!(t.sheetRows && t.sheetRows <= a.r)) {
                var l = e.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/),
                  c = !!l && !!l[1] && Em(l[1]) || {
                    r: "",
                    t: "",
                    h: ""
                  };
                o.r = c.r, "<t></t>" == c.r && (c.t = c.h = ""), o.t = (c.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"), t.cellHTML && (o.h = c.h), r.push(o)
              }
            }
          }
        }), r
      }(e, i)
    }

    function KR(e, t, i) {
      return ".bin" === t.slice(-4) ? function(e) {
        var t = [];
        return og(e, function(e, i, r) {
          if (63 === r) t.push(e);
          else if (!i.T) throw new Error("Unexpected record 0x" + r.toString(16))
        }), t
      }(e) : function(e) {
        var t = [];
        if (!e) return t;
        var i = 1;
        return (e.match(Hp) || []).forEach(function(e) {
          var r = Vp(e);
          switch (r[0]) {
            case "<?xml":
            case "<calcChain":
            case "<calcChain>":
            case "</calcChain>":
              break;
            case "<c":
              delete r[0], r.i ? i = r.i : r.i = i, t.push(r)
          }
        }), t
      }(e)
    }

    function XR(e, t, i, r) {
      if (".bin" === i.slice(-4)) return function(e, t, i, r) {
        if (!e) return e;
        var s = r || {},
          n = !1;
        og(e, function(e, t, i) {
          switch (i) {
            case 359:
            case 363:
            case 364:
            case 366:
            case 367:
            case 368:
            case 369:
            case 370:
            case 371:
            case 472:
            case 577:
            case 578:
            case 579:
            case 580:
            case 581:
            case 582:
            case 583:
            case 584:
            case 585:
            case 586:
            case 587:
              break;
            case 35:
              n = !0;
              break;
            case 36:
              n = !1;
              break;
            default:
              if (t.T);
              else if (!n || s.WTF) throw new Error("Unexpected record 0x" + i.toString(16))
          }
        }, s)
      }(e, 0, 0, r)
    }

    function zR(e, t, i) {
      return ".bin" === t.slice(-4) ? function(e, t, i) {
        var r = {
            Types: [],
            Cell: [],
            Value: []
          },
          s = i || {},
          n = [],
          o = !1,
          a = 2;
        return og(e, function(e, t, i) {
          switch (i) {
            case 335:
              r.Types.push({
                name: e.name
              });
              break;
            case 51:
              e.forEach(function(e) {
                1 == a ? r.Cell.push({
                  type: r.Types[e[0] - 1].name,
                  index: e[1]
                }) : 0 == a && r.Value.push({
                  type: r.Types[e[0] - 1].name,
                  index: e[1]
                })
              });
              break;
            case 337:
              a = e ? 1 : 0;
              break;
            case 338:
              a = 2;
              break;
            case 35:
              n.push(i), o = !0;
              break;
            case 36:
              n.pop(), o = !1;
              break;
            default:
              if (t.T);
              else if (!o || s.WTF && 35 != n[n.length - 1]) throw new Error("Unexpected record 0x" + i.toString(16))
          }
        }), r
      }(e, 0, i) : function(e, t, i) {
        var r = {
          Types: [],
          Cell: [],
          Value: []
        };
        if (!e) return r;
        var s, n = !1,
          o = 2;
        return e.replace(Hp, function(e) {
          var t = Vp(e);
          switch (Wp(t[0])) {
            case "<?xml":
            case "<metadata":
            case "</metadata>":
            case "<metadataTypes":
            case "</metadataTypes>":
            case "</metadataType>":
            case "</futureMetadata>":
            case "<bk>":
            case "</bk>":
            case "</rc>":
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<metadataType":
              r.Types.push({
                name: t.name
              });
              break;
            case "<futureMetadata":
              for (var a = 0; a < r.Types.length; ++a) r.Types[a].name == t.name && (s = r.Types[a]);
              break;
            case "<rc":
              1 == o ? r.Cell.push({
                type: r.Types[t.t - 1].name,
                index: +t.v
              }) : 0 == o && r.Value.push({
                type: r.Types[t.t - 1].name,
                index: +t.v
              });
              break;
            case "<cellMetadata":
              o = 1;
              break;
            case "</cellMetadata>":
            case "</valueMetadata>":
              o = 2;
              break;
            case "<valueMetadata":
              o = 0;
              break;
            case "<ext":
              n = !0;
              break;
            case "</ext>":
              n = !1;
              break;
            case "<rvb":
              if (!s) break;
              s.offsets || (s.offsets = []), s.offsets.push(+t.i);
              break;
            default:
              if (!n && i.WTF) throw new Error("unrecognized " + t[0] + " in metadata")
          }
          return e
        }), r
      }(e, 0, i)
    }

    function $R(e, t, i, r, s) {
      return (".bin" === t.slice(-4) ? SR : nR)(e, i, r, s)
    }

    function jR(e, t, i) {
      return (".bin" === t.slice(-4) ? xC : bC)(e, i)
    }
    var JR, qR = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g,
      QR = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;

    function ZR(e, t) {
      var i = e.split(/\s+/),
        r = [];
      if (t || (r[0] = i[0]), 1 === i.length) return r;
      var s, n, o, a = e.match(qR);
      if (a)
        for (o = 0; o != a.length; ++o) - 1 === (n = (s = a[o].match(QR))[1].indexOf(":")) ? r[s[1]] = s[2].slice(1, s[2].length - 1) : r["xmlns:" === s[1].slice(0, 6) ? "xmlns" + s[1].slice(6) : s[1].slice(n + 1)] = s[2].slice(1, s[2].length - 1);
      return r
    }

    function eA(e) {
      var t = {};
      if (1 === e.split(/\s+/).length) return t;
      var i, r, s, n = e.match(qR);
      if (n)
        for (s = 0; s != n.length; ++s) - 1 === (r = (i = n[s].match(QR))[1].indexOf(":")) ? t[i[1]] = i[2].slice(1, i[2].length - 1) : t["xmlns:" === i[1].slice(0, 6) ? "xmlns" + i[1].slice(6) : i[1].slice(r + 1)] = i[2].slice(1, i[2].length - 1);
      return t
    }

    function tA(e, t, i, r) {
      var s = r;
      switch ((i[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
        case "boolean":
          s = eE(r);
          break;
        case "i2":
        case "int":
          s = parseInt(r, 10);
          break;
        case "r4":
        case "float":
          s = parseFloat(r);
          break;
        case "date":
        case "dateTime.tz":
          s = fp(r);
          break;
        case "i8":
        case "string":
        case "fixed":
        case "uuid":
        case "bin.base64":
          break;
        default:
          throw new Error("bad custprop:" + i[0])
      }
      e[Xp(t)] = s
    }

    function iA(e, t, i) {
      if ("z" !== e.t) {
        if (!i || !1 !== i.cellText) try {
          "e" === e.t ? e.w = e.w || pf[e.v] : "General" === t ? "n" === e.t ? (0 | e.v) === e.v ? e.w = e.v.toString(10) : e.w = Rd(e.v) : e.w = Ad(e.v) : e.w = function(e, t) {
            var i = JR[e] || Xp(e);
            return "General" === i ? Ad(t) : Wd(i, t)
          }(t || "General", e.v)
        } catch (e) {
          if (i.WTF) throw e
        }
        try {
          var r = JR[t] || t || "General";
          if (i.cellNF && (e.z = r), i.cellDates && "n" == e.t && Hd(r)) {
            var s = gd(e.v);
            s && (e.t = "d", e.v = new Date(s.y, s.m - 1, s.d, s.H, s.M, s.S, s.u))
          }
        } catch (e) {
          if (i.WTF) throw e
        }
      }
    }

    function rA(e, t, i) {
      if (i.cellStyles && t.Interior) {
        var r = t.Interior;
        r.Pattern && (r.patternType = qm[r.Pattern] || r.Pattern)
      }
      e[t.ID] = t
    }

    function sA(e, t, i, r, s, n, o, a, l, c) {
      var h = "General",
        u = r.StyleID,
        d = {};
      c = c || {};
      var p = [],
        E = 0;
      for (void 0 === u && a && (u = a.StyleID), void 0 === u && o && (u = o.StyleID); void 0 !== n[u] && (n[u].nf && (h = n[u].nf), n[u].Interior && p.push(n[u].Interior), n[u].Parent);) u = n[u].Parent;
      switch (i.Type) {
        case "Boolean":
          r.t = "b", r.v = eE(e);
          break;
        case "String":
          r.t = "s", r.r = Zp(Xp(e)), r.v = e.indexOf("<") > -1 ? Xp(t || e).replace(/<.*?>/g, "") : r.r;
          break;
        case "DateTime":
          "Z" != e.slice(-1) && (e += "Z"), r.v = (fp(e) - new Date(Date.UTC(1899, 11, 30))) / 864e5, r.v != r.v ? r.v = Xp(e) : r.v < 60 && (r.v = r.v - 1), h && "General" != h || (h = "yyyy-mm-dd");
        case "Number":
          void 0 === r.v && (r.v = +e), r.t || (r.t = "n");
          break;
        case "Error":
          r.t = "e", r.v = Ef[e], !1 !== c.cellText && (r.w = e);
          break;
        default:
          "" == e && "" == t ? r.t = "z" : (r.t = "s", r.v = Zp(t || e))
      }
      if (iA(r, h, c), !1 !== c.cellFormula)
        if (r.Formula) {
          var g = Xp(r.Formula);
          61 == g.charCodeAt(0) && (g = g.slice(1)), r.f = HC(g, s), delete r.Formula, "RC" == r.ArrayRange ? r.F = HC("RC:RC", s) : r.ArrayRange && (r.F = HC(r.ArrayRange, s), l.push([Rg(r.F), r.F]))
        } else
          for (E = 0; E < l.length; ++E) s.r >= l[E][0].s.r && s.r <= l[E][0].e.r && s.c >= l[E][0].s.c && s.c <= l[E][0].e.c && (r.F = l[E][1]);
      c.cellStyles && (p.forEach(function(e) {
        !d.patternType && e.patternType && (d.patternType = e.patternType)
      }), r.s = d), void 0 !== r.StyleID && (r.ixfe = r.StyleID)
    }

    function nA(e) {
      e.t = e.v || "", e.t = e.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), e.v = e.w = e.ixfe = void 0
    }

    function oA(e, t) {
      var i = t || {};
      Xd();
      var r = Gu(mE(e));
      "binary" != i.type && "array" != i.type && "base64" != i.type || (r = void 0 !== xu ? xu.utils.decode(65001, Mu(r)) : nE(r));
      var s, n = r.slice(0, 1024).toLowerCase(),
        o = !1;
      if ((1023 & (n = n.replace(/".*?"/g, "")).indexOf(">")) > Math.min(1023 & n.indexOf(","), 1023 & n.indexOf(";"))) {
        var a = mp(i);
        return a.type = "string", am.to_workbook(r, a)
      }
      if (-1 == n.indexOf("<?xml") && ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(e) {
          n.indexOf("<" + e) >= 0 && (o = !0)
        }), o) return function(e, t) {
        var i = e.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
        if (!i || 0 == i.length) throw new Error("Invalid HTML: could not find <table>");
        if (1 == i.length) return Ng(FA(i[0], t), t);
        var r = {
          SheetNames: [],
          Sheets: {}
        };
        return i.forEach(function(e, i) {
          sN(r, FA(e, t), "Sheet" + (i + 1))
        }), r
      }(r, i);
      JR = {
        "General Number": "General",
        "General Date": ud[22],
        "Long Date": "dddd, mmmm dd, yyyy",
        "Medium Date": ud[15],
        "Short Date": ud[14],
        "Long Time": ud[19],
        "Medium Time": ud[18],
        "Short Time": ud[20],
        Currency: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        Fixed: ud[2],
        Standard: ud[4],
        Percent: ud[10],
        Scientific: ud[11],
        "Yes/No": '"Yes";"Yes";"No";@',
        "True/False": '"True";"True";"False";@',
        "On/Off": '"Yes";"Yes";"No";@'
      };
      var l, c = [];
      null != Bu && null == i.dense && (i.dense = Bu);
      var h, u = {},
        d = [],
        p = i.dense ? [] : {},
        E = "",
        g = {},
        f = {},
        T = ZR('<Data ss:Type="String">'),
        m = 0,
        C = 0,
        S = 0,
        R = {
          s: {
            r: 2e6,
            c: 2e6
          },
          e: {
            r: 0,
            c: 0
          }
        },
        A = {},
        v = {},
        N = "",
        I = 0,
        O = [],
        L = {},
        _ = {},
        y = 0,
        w = [],
        D = [],
        P = {},
        b = [],
        M = !1,
        F = [],
        x = [],
        G = {},
        U = 0,
        H = 0,
        k = {
          Sheets: [],
          WBProps: {
            date1904: !1
          }
        },
        B = {};
      CE.lastIndex = 0, r = r.replace(/<!--([\s\S]*?)-->/gm, "");
      for (var V = ""; s = CE.exec(r);) switch (s[3] = (V = s[3]).toLowerCase()) {
        case "data":
          if ("data" == V) {
            if ("/" === s[1]) {
              if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
            } else "/" !== s[0].charAt(s[0].length - 2) && c.push([s[3], !0]);
            break
          }
          if (c[c.length - 1][1]) break;
          "/" === s[1] ? sA(r.slice(m, s.index), N, T, "comment" == c[c.length - 1][0] ? P : g, {
            c: C,
            r: S
          }, A, b[C], f, F, i) : (N = "", T = ZR(s[0]), m = s.index + s[0].length);
          break;
        case "cell":
          if ("/" === s[1])
            if (D.length > 0 && (g.c = D), (!i.sheetRows || i.sheetRows > S) && void 0 !== g.v && (i.dense ? (p[S] || (p[S] = []), p[S][C] = g) : p[fg(C) + Eg(S)] = g), g.HRef && (g.l = {
                Target: Xp(g.HRef)
              }, g.HRefScreenTip && (g.l.Tooltip = g.HRefScreenTip), delete g.HRef, delete g.HRefScreenTip), (g.MergeAcross || g.MergeDown) && (U = C + (0 | parseInt(g.MergeAcross, 10)), H = S + (0 | parseInt(g.MergeDown, 10)), O.push({
                s: {
                  c: C,
                  r: S
                },
                e: {
                  c: U,
                  r: H
                }
              })), i.sheetStubs)
              if (g.MergeAcross || g.MergeDown) {
                for (var W = C; W <= U; ++W)
                  for (var Y = S; Y <= H; ++Y)(W > C || Y > S) && (i.dense ? (p[Y] || (p[Y] = []), p[Y][W] = {
                    t: "z"
                  }) : p[fg(W) + Eg(Y)] = {
                    t: "z"
                  });
                C = U + 1
              } else ++C;
          else g.MergeAcross ? C = U + 1 : ++C;
          else(g = eA(s[0])).Index && (C = +g.Index - 1), C < R.s.c && (R.s.c = C), C > R.e.c && (R.e.c = C), "/>" === s[0].slice(-2) && ++C, D = [];
          break;
        case "row":
          "/" === s[1] || "/>" === s[0].slice(-2) ? (S < R.s.r && (R.s.r = S), S > R.e.r && (R.e.r = S), "/>" === s[0].slice(-2) && (f = ZR(s[0])).Index && (S = +f.Index - 1), C = 0, ++S) : ((f = ZR(s[0])).Index && (S = +f.Index - 1), G = {}, ("0" == f.AutoFitHeight || f.Height) && (G.hpx = parseInt(f.Height, 10), G.hpt = jm(G.hpx), x[S] = G), "1" == f.Hidden && (G.hidden = !0, x[S] = G));
          break;
        case "worksheet":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"));
            d.push(E), R.s.r <= R.e.r && R.s.c <= R.e.c && (p["!ref"] = Sg(R), i.sheetRows && i.sheetRows <= R.e.r && (p["!fullref"] = p["!ref"], R.e.r = i.sheetRows - 1, p["!ref"] = Sg(R))), O.length && (p["!merges"] = O), b.length > 0 && (p["!cols"] = b), x.length > 0 && (p["!rows"] = x), u[E] = p
          } else R = {
            s: {
              r: 2e6,
              c: 2e6
            },
            e: {
              r: 0,
              c: 0
            }
          }, S = C = 0, c.push([s[3], !1]), l = ZR(s[0]), E = Xp(l.Name), p = i.dense ? [] : {}, O = [], F = [], x = [], B = {
            name: E,
            Hidden: 0
          }, k.Sheets.push(B);
          break;
        case "table":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
          } else {
            if ("/>" == s[0].slice(-2)) break;
            c.push([s[3], !1]), b = [], M = !1
          }
          break;
        case "style":
          "/" === s[1] ? rA(A, v, i) : v = ZR(s[0]);
          break;
        case "numberformat":
          v.nf = Xp(ZR(s[0]).Format || "General"), JR[v.nf] && (v.nf = JR[v.nf]);
          for (var K = 0; 392 != K && ud[K] != v.nf; ++K);
          if (392 == K)
            for (K = 57; 392 != K; ++K)
              if (null == ud[K]) {
                Yd(v.nf, K);
                break
              } break;
        case "column":
          if ("table" !== c[c.length - 1][0]) break;
          if ((h = ZR(s[0])).Hidden && (h.hidden = !0, delete h.Hidden), h.Width && (h.wpx = parseInt(h.Width, 10)), !M && h.wpx > 10) {
            M = !0, Bm = Um;
            for (var X = 0; X < b.length; ++X) b[X] && zm(b[X])
          }
          M && zm(h), b[h.Index - 1 || b.length] = h;
          for (var z = 0; z < +h.Span; ++z) b[b.length] = mp(h);
          break;
        case "namedrange":
          if ("/" === s[1]) break;
          k.Names || (k.Names = []);
          var $ = Vp(s[0]),
            j = {
              Name: $.Name,
              Ref: HC($.RefersTo.slice(1), {
                r: 0,
                c: 0
              })
            };
          k.Sheets.length > 0 && (j.Sheet = k.Sheets.length - 1), k.Names.push(j);
          break;
        case "namedcell":
        case "b":
        case "i":
        case "u":
        case "s":
        case "em":
        case "h2":
        case "h3":
        case "sub":
        case "sup":
        case "span":
        case "alignment":
        case "borders":
        case "border":
        case "protection":
        case "paragraphs":
        case "name":
        case "pixelsperinch":
        case "null":
          break;
        case "font":
          if ("/>" === s[0].slice(-2)) break;
          "/" === s[1] ? N += r.slice(I, s.index) : I = s.index + s[0].length;
          break;
        case "interior":
          if (!i.cellStyles) break;
          v.Interior = ZR(s[0]);
          break;
        case "author":
        case "title":
        case "description":
        case "created":
        case "keywords":
        case "subject":
        case "category":
        case "company":
        case "lastauthor":
        case "lastsaved":
        case "lastprinted":
        case "version":
        case "revision":
        case "totaltime":
        case "hyperlinkbase":
        case "manager":
        case "contentstatus":
        case "identifier":
        case "language":
        case "appname":
          if ("/>" === s[0].slice(-2)) break;
          "/" === s[1] ? kf(L, V, r.slice(y, s.index)) : y = s.index + s[0].length;
          break;
        case "styles":
        case "workbook":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
          } else c.push([s[3], !1]);
          break;
        case "comment":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"));
            nA(P), D.push(P)
          } else c.push([s[3], !1]), P = {
            a: (l = ZR(s[0])).Author
          };
          break;
        case "autofilter":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
          } else if ("/" !== s[0].charAt(s[0].length - 2)) {
            var J = ZR(s[0]);
            p["!autofilter"] = {
              ref: HC(J.Range).replace(/\$/g, "")
            }, c.push([s[3], !0])
          }
          break;
        case "datavalidation":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
          } else "/" !== s[0].charAt(s[0].length - 2) && c.push([s[3], !0]);
          break;
        case "componentoptions":
        case "documentproperties":
        case "customdocumentproperties":
        case "officedocumentsettings":
        case "pivottable":
        case "pivotcache":
        case "names":
        case "mapinfo":
        case "pagebreaks":
        case "querytable":
        case "sorting":
        case "schema":
        case "conditionalformatting":
        case "smarttagtype":
        case "smarttags":
        case "excelworkbook":
        case "workbookoptions":
        case "worksheetoptions":
          if ("/" === s[1]) {
            if ((l = c.pop())[0] !== s[3]) throw new Error("Bad state: " + l.join("|"))
          } else "/" !== s[0].charAt(s[0].length - 2) && c.push([s[3], !0]);
          break;
        default:
          if (0 == c.length && "document" == s[3]) return $A(r, i);
          if (0 == c.length && "uof" == s[3]) return $A(r, i);
          var q = !0;
          switch (c[c.length - 1][0]) {
            case "officedocumentsettings":
              switch (s[3]) {
                case "allowpng":
                case "removepersonalinformation":
                case "downloadcomponents":
                case "locationofcomponents":
                case "colors":
                case "color":
                case "index":
                case "rgb":
                case "targetscreensize":
                case "readonlyrecommended":
                  break;
                default:
                  q = !1
              }
              break;
            case "componentoptions":
              switch (s[3]) {
                case "toolbar":
                case "hideofficelogo":
                case "spreadsheetautofit":
                case "label":
                case "caption":
                case "maxheight":
                case "maxwidth":
                case "nextsheetnumber":
                  break;
                default:
                  q = !1
              }
              break;
            case "excelworkbook":
              switch (s[3]) {
                case "date1904":
                  k.WBProps.date1904 = !0;
                  break;
                case "windowheight":
                case "windowwidth":
                case "windowtopx":
                case "windowtopy":
                case "tabratio":
                case "protectstructure":
                case "protectwindow":
                case "protectwindows":
                case "activesheet":
                case "displayinknotes":
                case "firstvisiblesheet":
                case "supbook":
                case "sheetname":
                case "sheetindex":
                case "sheetindexfirst":
                case "sheetindexlast":
                case "dll":
                case "acceptlabelsinformulas":
                case "donotsavelinkvalues":
                case "iteration":
                case "maxiterations":
                case "maxchange":
                case "path":
                case "xct":
                case "count":
                case "selectedsheets":
                case "calculation":
                case "uncalced":
                case "startupprompt":
                case "crn":
                case "externname":
                case "formula":
                case "colfirst":
                case "collast":
                case "wantadvise":
                case "boolean":
                case "error":
                case "text":
                case "ole":
                case "noautorecover":
                case "publishobjects":
                case "donotcalculatebeforesave":
                case "number":
                case "refmoder1c1":
                case "embedsavesmarttags":
                  break;
                default:
                  q = !1
              }
              break;
            case "workbookoptions":
              switch (s[3]) {
                case "owcversion":
                case "height":
                case "width":
                  break;
                default:
                  q = !1
              }
              break;
            case "worksheetoptions":
              switch (s[3]) {
                case "visible":
                  if ("/>" === s[0].slice(-2));
                  else if ("/" === s[1]) switch (r.slice(y, s.index)) {
                    case "SheetHidden":
                      B.Hidden = 1;
                      break;
                    case "SheetVeryHidden":
                      B.Hidden = 2
                  } else y = s.index + s[0].length;
                  break;
                case "header":
                  p["!margins"] || US(p["!margins"] = {}, "xlml"), isNaN(+Vp(s[0]).Margin) || (p["!margins"].header = +Vp(s[0]).Margin);
                  break;
                case "footer":
                  p["!margins"] || US(p["!margins"] = {}, "xlml"), isNaN(+Vp(s[0]).Margin) || (p["!margins"].footer = +Vp(s[0]).Margin);
                  break;
                case "pagemargins":
                  var Q = Vp(s[0]);
                  p["!margins"] || US(p["!margins"] = {}, "xlml"), isNaN(+Q.Top) || (p["!margins"].top = +Q.Top), isNaN(+Q.Left) || (p["!margins"].left = +Q.Left), isNaN(+Q.Right) || (p["!margins"].right = +Q.Right), isNaN(+Q.Bottom) || (p["!margins"].bottom = +Q.Bottom);
                  break;
                case "displayrighttoleft":
                  k.Views || (k.Views = []), k.Views[0] || (k.Views[0] = {}), k.Views[0].RTL = !0;
                  break;
                case "freezepanes":
                case "frozennosplit":
                case "splithorizontal":
                case "splitvertical":
                case "donotdisplaygridlines":
                case "activerow":
                case "activecol":
                case "toprowbottompane":
                case "leftcolumnrightpane":
                case "unsynced":
                case "print":
                case "printerrors":
                case "panes":
                case "scale":
                case "pane":
                case "number":
                case "layout":
                case "pagesetup":
                case "selected":
                case "protectobjects":
                case "enableselection":
                case "protectscenarios":
                case "validprinterinfo":
                case "horizontalresolution":
                case "verticalresolution":
                case "numberofcopies":
                case "activepane":
                case "toprowvisible":
                case "leftcolumnvisible":
                case "fittopage":
                case "rangeselection":
                case "papersizeindex":
                case "pagelayoutzoom":
                case "pagebreakzoom":
                case "filteron":
                case "fitwidth":
                case "fitheight":
                case "commentslayout":
                case "zoom":
                case "lefttoright":
                case "gridlines":
                case "allowsort":
                case "allowfilter":
                case "allowinsertrows":
                case "allowdeleterows":
                case "allowinsertcols":
                case "allowdeletecols":
                case "allowinserthyperlinks":
                case "allowformatcells":
                case "allowsizecols":
                case "allowsizerows":
                case "tabcolorindex":
                case "donotdisplayheadings":
                case "showpagelayoutzoom":
                case "blackandwhite":
                case "donotdisplayzeros":
                case "displaypagebreak":
                case "rowcolheadings":
                case "donotdisplayoutline":
                case "noorientation":
                case "allowusepivottables":
                case "zeroheight":
                case "viewablerange":
                case "selection":
                case "protectcontents":
                  break;
                case "nosummaryrowsbelowdetail":
                  p["!outline"] || (p["!outline"] = {}), p["!outline"].above = !0;
                  break;
                case "nosummarycolumnsrightdetail":
                  p["!outline"] || (p["!outline"] = {}), p["!outline"].left = !0;
                  break;
                default:
                  q = !1
              }
              break;
            case "pivottable":
            case "pivotcache":
              switch (s[3]) {
                case "immediateitemsondrop":
                case "showpagemultipleitemlabel":
                case "compactrowindent":
                case "location":
                case "pivotfield":
                case "orientation":
                case "layoutform":
                case "layoutsubtotallocation":
                case "layoutcompactrow":
                case "position":
                case "pivotitem":
                case "datatype":
                case "datafield":
                case "sourcename":
                case "parentfield":
                case "ptlineitems":
                case "ptlineitem":
                case "countofsameitems":
                case "item":
                case "itemtype":
                case "ptsource":
                case "cacheindex":
                case "consolidationreference":
                case "filename":
                case "reference":
                case "nocolumngrand":
                case "norowgrand":
                case "blanklineafteritems":
                case "hidden":
                case "subtotal":
                case "basefield":
                case "mapchilditems":
                case "function":
                case "refreshonfileopen":
                case "printsettitles":
                case "mergelabels":
                case "defaultversion":
                case "refreshname":
                case "refreshdate":
                case "refreshdatecopy":
                case "versionlastrefresh":
                case "versionlastupdate":
                case "versionupdateablemin":
                case "versionrefreshablemin":
                case "calculation":
                  break;
                default:
                  q = !1
              }
              break;
            case "pagebreaks":
              switch (s[3]) {
                case "colbreaks":
                case "colbreak":
                case "rowbreaks":
                case "rowbreak":
                case "colstart":
                case "colend":
                case "rowend":
                  break;
                default:
                  q = !1
              }
              break;
            case "autofilter":
              switch (s[3]) {
                case "autofiltercolumn":
                case "autofiltercondition":
                case "autofilterand":
                case "autofilteror":
                  break;
                default:
                  q = !1
              }
              break;
            case "querytable":
              switch (s[3]) {
                case "id":
                case "autoformatfont":
                case "autoformatpattern":
                case "querysource":
                case "querytype":
                case "enableredirections":
                case "refreshedinxl9":
                case "urlstring":
                case "htmltables":
                case "connection":
                case "commandtext":
                case "refreshinfo":
                case "notitles":
                case "nextid":
                case "columninfo":
                case "overwritecells":
                case "donotpromptforfile":
                case "textwizardsettings":
                case "source":
                case "number":
                case "decimal":
                case "thousandseparator":
                case "trailingminusnumbers":
                case "formatsettings":
                case "fieldtype":
                case "delimiters":
                case "tab":
                case "comma":
                case "autoformatname":
                case "versionlastedit":
                case "versionlastrefresh":
                  break;
                default:
                  q = !1
              }
              break;
            case "datavalidation":
              switch (s[3]) {
                case "range":
                case "type":
                case "min":
                case "max":
                case "sort":
                case "descending":
                case "order":
                case "casesensitive":
                case "value":
                case "errorstyle":
                case "errormessage":
                case "errortitle":
                case "inputmessage":
                case "inputtitle":
                case "combohide":
                case "inputhide":
                case "condition":
                case "qualifier":
                case "useblank":
                case "value1":
                case "value2":
                case "format":
                case "cellrangelist":
                  break;
                default:
                  q = !1
              }
              break;
            case "sorting":
            case "conditionalformatting":
              switch (s[3]) {
                case "range":
                case "type":
                case "min":
                case "max":
                case "sort":
                case "descending":
                case "order":
                case "casesensitive":
                case "value":
                case "errorstyle":
                case "errormessage":
                case "errortitle":
                case "cellrangelist":
                case "inputmessage":
                case "inputtitle":
                case "combohide":
                case "inputhide":
                case "condition":
                case "qualifier":
                case "useblank":
                case "value1":
                case "value2":
                case "format":
                  break;
                default:
                  q = !1
              }
              break;
            case "mapinfo":
            case "schema":
            case "data":
              switch (s[3]) {
                case "map":
                case "entry":
                case "range":
                case "xpath":
                case "field":
                case "xsdtype":
                case "filteron":
                case "aggregate":
                case "elementtype":
                case "attributetype":
                case "schema":
                case "element":
                case "complextype":
                case "datatype":
                case "all":
                case "attribute":
                case "extends":
                case "row":
                  break;
                default:
                  q = !1
              }
              break;
            case "smarttags":
              break;
            default:
              q = !1
          }
          if (q) break;
          if (s[3].match(/!\[CDATA/)) break;
          if (!c[c.length - 1][1]) throw "Unrecognized tag: " + s[3] + "|" + c.join("|");
          if ("customdocumentproperties" === c[c.length - 1][0]) {
            if ("/>" === s[0].slice(-2)) break;
            "/" === s[1] ? tA(_, V, w, r.slice(y, s.index)) : (w = s, y = s.index + s[0].length);
            break
          }
          if (i.WTF) throw "Unrecognized tag: " + s[3] + "|" + c.join("|")
      }
      var Z = {};
      return i.bookSheets || i.bookProps || (Z.Sheets = u), Z.SheetNames = d, Z.Workbook = k, Z.SSF = mp(ud), Z.Props = L, Z.Custprops = _, Z
    }

    function aA(e, t) {
      switch (Ov(t = t || {}), t.type || "base64") {
        case "base64":
          return oA(Yu(e), t);
        case "binary":
        case "buffer":
        case "file":
          return oA(e, t);
        case "array":
          return oA(qu(e), t)
      }
    }

    function lA(e, t) {
      var i = [];
      return e.Props && i.push(function(e, t) {
        var i = [];
        return ip(Hf).map(function(e) {
          for (var t = 0; t < Lf.length; ++t)
            if (Lf[t][1] == e) return Lf[t];
          for (t = 0; t < Pf.length; ++t)
            if (Pf[t][1] == e) return Pf[t];
          throw e
        }).forEach(function(r) {
          if (null != e[r[1]]) {
            var s = t && t.Props && null != t.Props[r[1]] ? t.Props[r[1]] : e[r[1]];
            "date" === r[2] && (s = new Date(s).toISOString().replace(/\.\d*Z/, "Z")), "number" == typeof s ? s = String(s) : !0 === s || !1 === s ? s = s ? "1" : "0" : s instanceof Date && (s = new Date(s).toISOString().replace(/\.\d*Z/, "")), i.push(EE(Hf[r[1]] || r[1], s))
          }
        }), fE("DocumentProperties", i.join(""), {
          xmlns: AE.o
        })
      }(e.Props, t)), e.Custprops && i.push(function(e, t) {
        var i = ["Worksheets", "SheetNames"],
          r = "CustomDocumentProperties",
          s = [];
        return e && ip(e).forEach(function(t) {
          if (Object.prototype.hasOwnProperty.call(e, t)) {
            for (var r = 0; r < Lf.length; ++r)
              if (t == Lf[r][1]) return;
            for (r = 0; r < Pf.length; ++r)
              if (t == Pf[r][1]) return;
            for (r = 0; r < i.length; ++r)
              if (t == i[r]) return;
            var n = e[t],
              o = "string";
            "number" == typeof n ? (o = "float", n = String(n)) : !0 === n || !1 === n ? (o = "boolean", n = n ? "1" : "0") : n = String(n), s.push(fE(Jp(t), n, {
              "dt:dt": o
            }))
          }
        }), t && ip(t).forEach(function(i) {
          if (Object.prototype.hasOwnProperty.call(t, i) && (!e || !Object.prototype.hasOwnProperty.call(e, i))) {
            var r = t[i],
              n = "string";
            "number" == typeof r ? (n = "float", r = String(r)) : !0 === r || !1 === r ? (n = "boolean", r = r ? "1" : "0") : r instanceof Date ? (n = "dateTime.tz", r = r.toISOString()) : r = String(r), s.push(fE(Jp(i), r, {
              "dt:dt": n
            }))
          }
        }), "<" + r + ' xmlns="' + AE.o + '">' + s.join("") + "</" + r + ">"
      }(e.Props, e.Custprops)), i.join("")
    }

    function cA(e) {
      return fE("NamedRange", null, {
        "ss:Name": e.Name,
        "ss:RefersTo": "=" + BC(e.Ref, {
          r: 0,
          c: 0
        })
      })
    }

    function hA(e, t, i, r, s, n, o) {
      if (!e || null == e.v && null == e.f) return "";
      var a = {};
      if (e.f && (a["ss:Formula"] = "=" + jp(BC(e.f, o))), e.F && e.F.slice(0, t.length) == t) {
        var l = Tg(e.F.slice(t.length + 1));
        a["ss:ArrayRange"] = "RC:R" + (l.r == o.r ? "" : "[" + (l.r - o.r) + "]") + "C" + (l.c == o.c ? "" : "[" + (l.c - o.c) + "]")
      }
      if (e.l && e.l.Target && (a["ss:HRef"] = jp(e.l.Target), e.l.Tooltip && (a["x:HRefScreenTip"] = jp(e.l.Tooltip))), i["!merges"])
        for (var c = i["!merges"], h = 0; h != c.length; ++h) c[h].s.c == o.c && c[h].s.r == o.r && (c[h].e.c > c[h].s.c && (a["ss:MergeAcross"] = c[h].e.c - c[h].s.c), c[h].e.r > c[h].s.r && (a["ss:MergeDown"] = c[h].e.r - c[h].s.r));
      var u = "",
        d = "";
      switch (e.t) {
        case "z":
          if (!r.sheetStubs) return "";
          break;
        case "n":
          u = "Number", d = String(e.v);
          break;
        case "b":
          u = "Boolean", d = e.v ? "1" : "0";
          break;
        case "e":
          u = "Error", d = pf[e.v];
          break;
        case "d":
          u = "DateTime", d = new Date(e.v).toISOString(), null == e.z && (e.z = e.z || ud[14]);
          break;
        case "s":
          u = "String", d = ((e.v || "") + "").replace(zp, function(e) {
            return Kp[e]
          }).replace(qp, function(e) {
            return "&#x" + e.charCodeAt(0).toString(16).toUpperCase() + ";"
          })
      }
      var p = HS(r.cellXfs, e, r);
      a["ss:StyleID"] = "s" + (21 + p), a["ss:Index"] = o.c + 1;
      var E = null != e.v ? d : "",
        g = "z" == e.t ? "" : '<Data ss:Type="' + u + '">' + E + "</Data>";
      return (e.c || []).length > 0 && (g += e.c.map(function(e) {
        var t = fE("ss:Data", (e.t || "").replace(/(\r\n|[\r\n])/g, "&#10;"), {
          xmlns: "http://www.w3.org/TR/REC-html40"
        });
        return fE("Comment", t, {
          "ss:Author": e.a
        })
      }).join("")), fE("Cell", g, a)
    }

    function uA(e, t) {
      var i = '<Row ss:Index="' + (e + 1) + '"';
      return t && (t.hpt && !t.hpx && (t.hpx = Jm(t.hpt)), t.hpx && (i += ' ss:AutoFitHeight="0" ss:Height="' + t.hpx + '"'), t.hidden && (i += ' ss:Hidden="1"')), i + ">"
    }

    function dA(e, t, i) {
      var r = [],
        s = i.SheetNames[e],
        n = i.Sheets[s],
        o = n ? function(e, t, i, r) {
          if (!e) return "";
          if (!((r || {}).Workbook || {}).Names) return "";
          for (var s = r.Workbook.Names, n = [], o = 0; o < s.length; ++o) {
            var a = s[o];
            a.Sheet == i && (a.Name.match(/^_xlfn\./) || n.push(cA(a)))
          }
          return n.join("")
        }(n, 0, e, i) : "";
      return o.length > 0 && r.push("<Names>" + o + "</Names>"), o = n ? function(e, t) {
        if (!e["!ref"]) return "";
        var i = Rg(e["!ref"]),
          r = e["!merges"] || [],
          s = 0,
          n = [];
        e["!cols"] && e["!cols"].forEach(function(e, t) {
          zm(e);
          var i = !!e.width,
            r = GS(t, e),
            s = {
              "ss:Index": t + 1
            };
          i && (s["ss:Width"] = Vm(r.width)), e.hidden && (s["ss:Hidden"] = "1"), n.push(fE("Column", null, s))
        });
        for (var o = Array.isArray(e), a = i.s.r; a <= i.e.r; ++a) {
          for (var l = [uA(a, (e["!rows"] || [])[a])], c = i.s.c; c <= i.e.c; ++c) {
            var h = !1;
            for (s = 0; s != r.length; ++s)
              if (!(r[s].s.c > c || r[s].s.r > a || r[s].e.c < c || r[s].e.r < a)) {
                r[s].s.c == c && r[s].s.r == a || (h = !0);
                break
              } if (!h) {
              var u = {
                  r: a,
                  c
                },
                d = mg(u),
                p = o ? (e[a] || [])[c] : e[d];
              l.push(hA(p, d, e, t, 0, 0, u))
            }
          }
          l.push("</Row>"), l.length > 2 && n.push(l.join(""))
        }
        return n.join("")
      }(n, t) : "", o.length > 0 && r.push("<Table>" + o + "</Table>"), r.push(function(e, t, i, r) {
        if (!e) return "";
        var s = [];
        if (e["!margins"] && (s.push("<PageSetup>"), e["!margins"].header && s.push(fE("Header", null, {
            "x:Margin": e["!margins"].header
          })), e["!margins"].footer && s.push(fE("Footer", null, {
            "x:Margin": e["!margins"].footer
          })), s.push(fE("PageMargins", null, {
            "x:Bottom": e["!margins"].bottom || "0.75",
            "x:Left": e["!margins"].left || "0.7",
            "x:Right": e["!margins"].right || "0.7",
            "x:Top": e["!margins"].top || "0.75"
          })), s.push("</PageSetup>")), r && r.Workbook && r.Workbook.Sheets && r.Workbook.Sheets[i])
          if (r.Workbook.Sheets[i].Hidden) s.push(fE("Visible", 1 == r.Workbook.Sheets[i].Hidden ? "SheetHidden" : "SheetVeryHidden", {}));
          else {
            for (var n = 0; n < i && (!r.Workbook.Sheets[n] || r.Workbook.Sheets[n].Hidden); ++n);
            n == i && s.push("<Selected/>")
          } return ((((r || {}).Workbook || {}).Views || [])[0] || {}).RTL && s.push("<DisplayRightToLeft/>"), e["!protect"] && (s.push(EE("ProtectContents", "True")), e["!protect"].objects && s.push(EE("ProtectObjects", "True")), e["!protect"].scenarios && s.push(EE("ProtectScenarios", "True")), null == e["!protect"].selectLockedCells || e["!protect"].selectLockedCells ? null == e["!protect"].selectUnlockedCells || e["!protect"].selectUnlockedCells || s.push(EE("EnableSelection", "UnlockedCells")) : s.push(EE("EnableSelection", "NoSelection")), [
          ["formatCells", "AllowFormatCells"],
          ["formatColumns", "AllowSizeCols"],
          ["formatRows", "AllowSizeRows"],
          ["insertColumns", "AllowInsertCols"],
          ["insertRows", "AllowInsertRows"],
          ["insertHyperlinks", "AllowInsertHyperlinks"],
          ["deleteColumns", "AllowDeleteCols"],
          ["deleteRows", "AllowDeleteRows"],
          ["sort", "AllowSort"],
          ["autoFilter", "AllowFilter"],
          ["pivotTables", "AllowUsePivotTables"]
        ].forEach(function(t) {
          e["!protect"][t[0]] && s.push("<" + t[1] + "/>")
        })), 0 == s.length ? "" : fE("WorksheetOptions", s.join(""), {
          xmlns: AE.x
        })
      }(n, 0, e, i)), r.join("")
    }

    function pA(e, t) {
      t || (t = {}), e.SSF || (e.SSF = mp(ud)), e.SSF && (Xd(), Kd(e.SSF), t.revssf = np(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF, t.cellXfs = [], HS(t.cellXfs, {}, {
        revssf: {
          General: 0
        }
      }));
      var i = [];
      i.push(lA(e, t)), i.push(""), i.push(""), i.push("");
      for (var r = 0; r < e.SheetNames.length; ++r) i.push(fE("Worksheet", dA(r, t, e), {
        "ss:Name": jp(e.SheetNames[r])
      }));
      return i[2] = function(e, t) {
        var i = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
        return t.cellXfs.forEach(function(e, t) {
          var r = [];
          r.push(fE("NumberFormat", null, {
            "ss:Format": jp(ud[e.numFmtId])
          }));
          var s = {
            "ss:ID": "s" + (21 + t)
          };
          i.push(fE("Style", r.join(""), s))
        }), fE("Styles", i.join(""))
      }(0, t), i[3] = function(e) {
        if (!((e || {}).Workbook || {}).Names) return "";
        for (var t = e.Workbook.Names, i = [], r = 0; r < t.length; ++r) {
          var s = t[r];
          null == s.Sheet && (s.Name.match(/^_xlfn\./) || i.push(cA(s)))
        }
        return fE("Names", i.join(""))
      }(e), xp + fE("Workbook", i.join(""), {
        xmlns: AE.ss,
        "xmlns:o": AE.o,
        "xmlns:x": AE.x,
        "xmlns:ss": AE.ss,
        "xmlns:dt": AE.dt,
        "xmlns:html": AE.html
      })
    }

    function EA(e) {
      var t = {},
        i = e.content;
      if (i.l = 28, t.AnsiUserType = i.read_shift(0, "lpstr-ansi"), t.AnsiClipboardFormat = function(e) {
          return Zg(e, 1)
        }(i), i.length - i.l <= 4) return t;
      var r = i.read_shift(4);
      return 0 == r || r > 40 ? t : (i.l -= 4, t.Reserved1 = i.read_shift(0, "lpstr-ansi"), i.length - i.l <= 4 || 1907505652 !== (r = i.read_shift(4)) ? t : (t.UnicodeClipboardFormat = function(e) {
        return Zg(e, 2)
      }(i), 0 == (r = i.read_shift(4)) || r > 40 ? t : (i.l -= 4, void(t.Reserved2 = i.read_shift(0, "lpwstr")))))
    }
    var gA = [60, 1084, 2066, 2165, 2175];

    function fA(e, t, i, r, s) {
      var n = r,
        o = [],
        a = i.slice(i.l, i.l + n);
      if (s && s.enc && s.enc.insitu && a.length > 0) switch (e) {
        case 9:
        case 521:
        case 1033:
        case 2057:
        case 47:
        case 405:
        case 225:
        case 406:
        case 312:
        case 404:
        case 10:
        case 133:
          break;
        default:
          s.enc.insitu(a)
      }
      o.push(a), i.l += n;
      for (var l = XE(i, i.l), c = NA[l], h = 0; null != c && gA.indexOf(l) > -1;) n = XE(i, i.l + 2), h = i.l + 4, 2066 == l ? h += 4 : 2165 != l && 2175 != l || (h += 12), a = i.slice(h, i.l + 4 + n), o.push(a), i.l += 4 + n, c = NA[l = XE(i, i.l)];
      var u = Zu(o);
      rg(u, 0);
      var d = 0;
      u.lens = [];
      for (var p = 0; p < o.length; ++p) u.lens.push(d), d += o[p].length;
      if (u.length < r) throw "XLS Record 0x" + e.toString(16) + " Truncated: " + u.length + " < " + r;
      return t.f(u, u.length, s)
    }

    function TA(e, t, i) {
      if ("z" !== e.t && e.XF) {
        var r = 0;
        try {
          r = e.z || e.XF.numFmtId || 0, t.cellNF && (e.z = ud[r])
        } catch (e) {
          if (t.WTF) throw e
        }
        if (!t || !1 !== t.cellText) try {
          "e" === e.t ? e.w = e.w || pf[e.v] : 0 === r || "General" == r ? "n" === e.t ? (0 | e.v) === e.v ? e.w = e.v.toString(10) : e.w = Rd(e.v) : e.w = Ad(e.v) : e.w = Wd(r, e.v, {
            date1904: !!i,
            dateNF: t && t.dateNF
          })
        } catch (e) {
          if (t.WTF) throw e
        }
        if (t.cellDates && r && "n" == e.t && Hd(ud[r] || String(r))) {
          var s = gd(e.v);
          s && (e.t = "d", e.v = new Date(s.y, s.m - 1, s.d, s.H, s.M, s.S, s.u))
        }
      }
    }

    function mA(e, t, i) {
      return {
        v: e,
        ixfe: t,
        t: i
      }
    }

    function CA(e, t) {
      var i = {
          opts: {}
        },
        r = {};
      null != Bu && null == t.dense && (t.dense = Bu);
      var s, n, o, a, l, c, h, u, d = t.dense ? [] : {},
        p = {},
        E = {},
        g = null,
        f = [],
        T = "",
        m = {},
        C = "",
        S = {},
        R = [],
        A = [],
        v = [],
        N = {
          Sheets: [],
          WBProps: {
            date1904: !1
          },
          Views: [{}]
        },
        I = {},
        O = function(e) {
          return e < 8 ? df[e] : e < 64 && v[e - 8] || df[e]
        },
        L = function(e, t, i) {
          if (!(G > 1 || i.sheetRows && e.r >= i.sheetRows)) {
            if (i.cellStyles && t.XF && t.XF.data && function(e, t, i) {
                var r, s = t.XF.data;
                s && s.patternType && i && i.cellStyles && (t.s = {}, t.s.patternType = s.patternType, (r = xm(O(s.icvFore))) && (t.s.fgColor = {
                  rgb: r
                }), (r = xm(O(s.icvBack))) && (t.s.bgColor = {
                  rgb: r
                }))
              }(0, t, i), delete t.ixfe, delete t.XF, s = e, C = mg(e), E && E.s && E.e || (E = {
                s: {
                  r: 0,
                  c: 0
                },
                e: {
                  r: 0,
                  c: 0
                }
              }), e.r < E.s.r && (E.s.r = e.r), e.c < E.s.c && (E.s.c = e.c), e.r + 1 > E.e.r && (E.e.r = e.r + 1), e.c + 1 > E.e.c && (E.e.c = e.c + 1), i.cellFormula && t.f)
              for (var r = 0; r < R.length; ++r)
                if (!(R[r][0].s.c > e.c || R[r][0].s.r > e.r || R[r][0].e.c < e.c || R[r][0].e.r < e.r)) {
                  t.F = Sg(R[r][0]), R[r][0].s.c == e.c && R[r][0].s.r == e.r || delete t.f, t.f && (t.f = "" + fS(R[r][1], 0, e, M, _));
                  break
                } i.dense ? (d[e.r] || (d[e.r] = []), d[e.r][e.c] = t) : d[C] = t
          }
        },
        _ = {
          enc: !1,
          sbcch: 0,
          snames: [],
          sharedf: S,
          arrayf: R,
          rrtabid: [],
          lastuser: "",
          biff: 8,
          codepage: 0,
          winlocked: 0,
          cellStyles: !!t && !!t.cellStyles,
          WTF: !!t && !!t.wtf
        };
      t.password && (_.password = t.password);
      var y = [],
        w = [],
        D = [],
        P = [],
        b = !1,
        M = [];
      M.SheetNames = _.snames, M.sharedf = _.sharedf, M.arrayf = _.arrayf, M.names = [], M.XTI = [];
      var F, x = 0,
        G = 0,
        U = 0,
        H = [],
        k = [];
      _.codepage = 1200, Pu(1200);
      for (var B = !1; e.l < e.length - 1;) {
        var V = e.l,
          W = e.read_shift(2);
        if (0 === W && 10 === x) break;
        var Y = e.l === e.length ? 0 : e.read_shift(2),
          K = NA[W];
        if (K && K.f) {
          if (t.bookSheets && 133 === x && 133 !== W) break;
          if (x = W, 2 === K.r || 12 == K.r) {
            var X = e.read_shift(2);
            if (Y -= 2, !_.enc && X !== W && ((255 & X) << 8 | X >> 8) !== W) throw new Error("rt mismatch: " + X + "!=" + W);
            12 == K.r && (e.l += 10, Y -= 10)
          }
          var z = {};
          if (z = 10 === W ? K.f(e, Y, _) : fA(W, K, e, Y, _), 0 == G && -1 === [9, 521, 1033, 2057].indexOf(x)) continue;
          switch (W) {
            case 34:
              i.opts.Date1904 = N.WBProps.date1904 = z;
              break;
            case 134:
              i.opts.WriteProtect = !0;
              break;
            case 47:
              if (_.enc || (e.l = 0), _.enc = z, !t.password) throw new Error("File is password-protected");
              if (null == z.valid) throw new Error("Encryption scheme unsupported");
              if (!z.valid) throw new Error("Password is incorrect");
              break;
            case 92:
              _.lastuser = z;
              break;
            case 66:
              var $ = Number(z);
              switch ($) {
                case 21010:
                  $ = 1200;
                  break;
                case 32768:
                  $ = 1e4;
                  break;
                case 32769:
                  $ = 1252
              }
              Pu(_.codepage = $), B = !0;
              break;
            case 317:
              _.rrtabid = z;
              break;
            case 25:
              _.winlocked = z;
              break;
            case 439:
              i.opts.RefreshAll = z;
              break;
            case 12:
              i.opts.CalcCount = z;
              break;
            case 16:
              i.opts.CalcDelta = z;
              break;
            case 17:
              i.opts.CalcIter = z;
              break;
            case 13:
              i.opts.CalcMode = z;
              break;
            case 14:
              i.opts.CalcPrecision = z;
              break;
            case 95:
              i.opts.CalcSaveRecalc = z;
              break;
            case 15:
              _.CalcRefMode = z;
              break;
            case 2211:
              i.opts.FullCalc = z;
              break;
            case 129:
              z.fDialog && (d["!type"] = "dialog"), z.fBelow || ((d["!outline"] || (d["!outline"] = {})).above = !0), z.fRight || ((d["!outline"] || (d["!outline"] = {})).left = !0);
              break;
            case 224:
              A.push(z);
              break;
            case 430:
              M.push([z]), M[M.length - 1].XTI = [];
              break;
            case 35:
            case 547:
              M[M.length - 1].push(z);
              break;
            case 24:
            case 536:
              F = {
                Name: z.Name,
                Ref: fS(z.rgce, 0, null, M, _)
              }, z.itab > 0 && (F.Sheet = z.itab - 1), M.names.push(F), M[0] || (M[0] = [], M[0].XTI = []), M[M.length - 1].push(z), "_xlnm._FilterDatabase" == z.Name && z.itab > 0 && z.rgce && z.rgce[0] && z.rgce[0][0] && "PtgArea3d" == z.rgce[0][0][0] && (k[z.itab - 1] = {
                ref: Sg(z.rgce[0][0][1][2])
              });
              break;
            case 22:
              _.ExternCount = z;
              break;
            case 23:
              0 == M.length && (M[0] = [], M[0].XTI = []), M[M.length - 1].XTI = M[M.length - 1].XTI.concat(z), M.XTI = M.XTI.concat(z);
              break;
            case 2196:
              if (_.biff < 8) break;
              null != F && (F.Comment = z[1]);
              break;
            case 18:
              d["!protect"] = z;
              break;
            case 19:
              0 !== z && _.WTF && console.error("Password verifier: " + z);
              break;
            case 133:
              p[z.pos] = z, _.snames.push(z.name);
              break;
            case 10:
              if (--G) break;
              if (E.e) {
                if (E.e.r > 0 && E.e.c > 0) {
                  if (E.e.r--, E.e.c--, d["!ref"] = Sg(E), t.sheetRows && t.sheetRows <= E.e.r) {
                    var j = E.e.r;
                    E.e.r = t.sheetRows - 1, d["!fullref"] = d["!ref"], d["!ref"] = Sg(E), E.e.r = j
                  }
                  E.e.r++, E.e.c++
                }
                y.length > 0 && (d["!merges"] = y), w.length > 0 && (d["!objects"] = w), D.length > 0 && (d["!cols"] = D), P.length > 0 && (d["!rows"] = P), N.Sheets.push(I)
              }
              "" === T ? m = d : r[T] = d, d = t.dense ? [] : {};
              break;
            case 9:
            case 521:
            case 1033:
            case 2057:
              if (8 === _.biff && (_.biff = {
                  9: 2,
                  521: 3,
                  1033: 4
                } [W] || {
                  512: 2,
                  768: 3,
                  1024: 4,
                  1280: 5,
                  1536: 8,
                  2: 2,
                  7: 2
                } [z.BIFFVer] || 8), _.biffguess = 0 == z.BIFFVer, 0 == z.BIFFVer && 4096 == z.dt && (_.biff = 5, B = !0, Pu(_.codepage = 28591)), 8 == _.biff && 0 == z.BIFFVer && 16 == z.dt && (_.biff = 2), G++) break;
              if (d = t.dense ? [] : {}, _.biff < 8 && !B && (B = !0, Pu(_.codepage = t.codepage || 1252)), _.biff < 5 || 0 == z.BIFFVer && 4096 == z.dt) {
                "" === T && (T = "Sheet1"), E = {
                  s: {
                    r: 0,
                    c: 0
                  },
                  e: {
                    r: 0,
                    c: 0
                  }
                };
                var J = {
                  pos: e.l - Y,
                  name: T
                };
                p[J.pos] = J, _.snames.push(T)
              } else T = (p[V] || {
                name: ""
              }).name;
              32 == z.dt && (d["!type"] = "chart"), 64 == z.dt && (d["!type"] = "macro"), y = [], w = [], _.arrayf = R = [], D = [], P = [], b = !1, I = {
                Hidden: (p[V] || {
                  hs: 0
                }).hs,
                name: T
              };
              break;
            case 515:
            case 3:
            case 2:
              "chart" == d["!type"] && (t.dense ? (d[z.r] || [])[z.c] : d[mg({
                c: z.c,
                r: z.r
              })]) && ++z.c, c = {
                ixfe: z.ixfe,
                XF: A[z.ixfe] || {},
                v: z.val,
                t: "n"
              }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t);
              break;
            case 5:
            case 517:
              c = {
                ixfe: z.ixfe,
                XF: A[z.ixfe],
                v: z.val,
                t: z.t
              }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t);
              break;
            case 638:
              c = {
                ixfe: z.ixfe,
                XF: A[z.ixfe],
                v: z.rknum,
                t: "n"
              }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t);
              break;
            case 189:
              for (var q = z.c; q <= z.C; ++q) {
                var Q = z.rkrec[q - z.c][0];
                c = {
                  ixfe: Q,
                  XF: A[Q],
                  v: z.rkrec[q - z.c][1],
                  t: "n"
                }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                  c: q,
                  r: z.r
                }, c, t)
              }
              break;
            case 6:
            case 518:
            case 1030:
              if ("String" == z.val) {
                g = z;
                break
              }
              if ((c = mA(z.val, z.cell.ixfe, z.tt)).XF = A[c.ixfe], t.cellFormula) {
                var Z = z.formula;
                if (Z && Z[0] && Z[0][0] && "PtgExp" == Z[0][0][0]) {
                  var ee = Z[0][0][1][0],
                    te = Z[0][0][1][1],
                    ie = mg({
                      r: ee,
                      c: te
                    });
                  S[ie] ? c.f = "" + fS(z.formula, 0, z.cell, M, _) : c.F = ((t.dense ? (d[ee] || [])[te] : d[ie]) || {}).F
                } else c.f = "" + fS(z.formula, 0, z.cell, M, _)
              }
              U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L(z.cell, c, t), g = z;
              break;
            case 7:
            case 519:
              if (!g) throw new Error("String record expects Formula");
              g.val = z, (c = mA(z, g.cell.ixfe, "s")).XF = A[c.ixfe], t.cellFormula && (c.f = "" + fS(g.formula, 0, g.cell, M, _)), U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L(g.cell, c, t), g = null;
              break;
            case 33:
            case 545:
              R.push(z);
              var re = mg(z[0].s);
              if (n = t.dense ? (d[z[0].s.r] || [])[z[0].s.c] : d[re], t.cellFormula && n) {
                if (!g) break;
                if (!re || !n) break;
                n.f = "" + fS(z[1], 0, z[0], M, _), n.F = Sg(z[0])
              }
              break;
            case 1212:
              if (!t.cellFormula) break;
              if (C) {
                if (!g) break;
                S[mg(g.cell)] = z[0], ((n = t.dense ? (d[g.cell.r] || [])[g.cell.c] : d[mg(g.cell)]) || {}).f = "" + fS(z[0], 0, s, M, _)
              }
              break;
            case 253:
              c = mA(f[z.isst].t, z.ixfe, "s"), f[z.isst].h && (c.h = f[z.isst].h), c.XF = A[c.ixfe], U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t);
              break;
            case 513:
              t.sheetStubs && (c = {
                ixfe: z.ixfe,
                XF: A[z.ixfe],
                t: "z"
              }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t));
              break;
            case 190:
              if (t.sheetStubs)
                for (var se = z.c; se <= z.C; ++se) {
                  var ne = z.ixfe[se - z.c];
                  c = {
                    ixfe: ne,
                    XF: A[ne],
                    t: "z"
                  }, U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                    c: se,
                    r: z.r
                  }, c, t)
                }
              break;
            case 214:
            case 516:
            case 4:
              (c = mA(z.val, z.ixfe, "s")).XF = A[c.ixfe], U > 0 && (c.z = H[c.ixfe >> 8 & 63]), TA(c, t, i.opts.Date1904), L({
                c: z.c,
                r: z.r
              }, c, t);
              break;
            case 0:
            case 512:
              1 === G && (E = z);
              break;
            case 252:
              f = z;
              break;
            case 1054:
              if (4 == _.biff) {
                H[U++] = z[1];
                for (var oe = 0; oe < U + 163 && ud[oe] != z[1]; ++oe);
                oe >= 163 && Yd(z[1], U + 163)
              } else Yd(z[1], z[0]);
              break;
            case 30:
              H[U++] = z;
              for (var ae = 0; ae < U + 163 && ud[ae] != z; ++ae);
              ae >= 163 && Yd(z, U + 163);
              break;
            case 229:
              y = y.concat(z);
              break;
            case 93:
              w[z.cmo[0]] = _.lastobj = z;
              break;
            case 438:
              _.lastobj.TxO = z;
              break;
            case 127:
              _.lastobj.ImData = z;
              break;
            case 440:
              for (l = z[0].s.r; l <= z[0].e.r; ++l)
                for (a = z[0].s.c; a <= z[0].e.c; ++a)(n = t.dense ? (d[l] || [])[a] : d[mg({
                  c: a,
                  r: l
                })]) && (n.l = z[1]);
              break;
            case 2048:
              for (l = z[0].s.r; l <= z[0].e.r; ++l)
                for (a = z[0].s.c; a <= z[0].e.c; ++a)(n = t.dense ? (d[l] || [])[a] : d[mg({
                  c: a,
                  r: l
                })]) && n.l && (n.l.Tooltip = z[1]);
              break;
            case 28:
              if (_.biff <= 5 && _.biff >= 2) break;
              n = t.dense ? (d[z[0].r] || [])[z[0].c] : d[mg(z[0])];
              var le = w[z[2]];
              n || (t.dense ? (d[z[0].r] || (d[z[0].r] = []), n = d[z[0].r][z[0].c] = {
                t: "z"
              }) : n = d[mg(z[0])] = {
                t: "z"
              }, E.e.r = Math.max(E.e.r, z[0].r), E.s.r = Math.min(E.s.r, z[0].r), E.e.c = Math.max(E.e.c, z[0].c), E.s.c = Math.min(E.s.c, z[0].c)), n.c || (n.c = []), o = {
                a: z[1],
                t: le.TxO.t
              }, n.c.push(o);
              break;
            case 2173:
              LC(A[z.ixfe], z.ext);
              break;
            case 125:
              if (!_.cellStyles) break;
              for (; z.e >= z.s;) D[z.e--] = {
                width: z.w / 256,
                level: z.level || 0,
                hidden: !!(1 & z.flags)
              }, b || (b = !0, Xm(z.w / 256)), zm(D[z.e + 1]);
              break;
            case 520:
              var ce = {};
              null != z.level && (P[z.r] = ce, ce.level = z.level), z.hidden && (P[z.r] = ce, ce.hidden = !0), z.hpt && (P[z.r] = ce, ce.hpt = z.hpt, ce.hpx = Jm(z.hpt));
              break;
            case 38:
            case 39:
            case 40:
            case 41:
              d["!margins"] || US(d["!margins"] = {}), d["!margins"][{
                38: "left",
                39: "right",
                40: "top",
                41: "bottom"
              } [W]] = z;
              break;
            case 161:
              d["!margins"] || US(d["!margins"] = {}), d["!margins"].header = z.header, d["!margins"].footer = z.footer;
              break;
            case 574:
              z.RTL && (N.Views[0].RTL = !0);
              break;
            case 146:
              v = z;
              break;
            case 2198:
              u = z;
              break;
            case 140:
              h = z;
              break;
            case 442:
              T ? I.CodeName = z || I.name : N.WBProps.CodeName = z || "ThisWorkbook"
          }
        } else K || console.error("Missing Info for XLS Record 0x" + W.toString(16)), e.l += Y
      }
      return i.SheetNames = ip(p).sort(function(e, t) {
        return Number(e) - Number(t)
      }).map(function(e) {
        return p[e].name
      }), t.bookSheets || (i.Sheets = r), !i.SheetNames.length && m["!ref"] ? (i.SheetNames.push("Sheet1"), i.Sheets && (i.Sheets.Sheet1 = m)) : i.Preamble = m, i.Sheets && k.forEach(function(e, t) {
        i.Sheets[i.SheetNames[t]]["!autofilter"] = e
      }), i.Strings = f, i.SSF = mp(ud), _.enc && (i.Encryption = _.enc), u && (i.Themes = u), i.Metadata = {}, void 0 !== h && (i.Metadata.Country = h), M.names.length > 0 && (N.Names = M.names), i.Workbook = N, i
    }
    var SA = {
      SI: "e0859ff2f94f6810ab9108002b27b3d9",
      DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
      UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
    };

    function RA(e, t) {
      var i, r, s, n;
      if (t || (t = {}), Ov(t), bu(), t.codepage && Du(t.codepage), e.FullPaths) {
        if (qd.find(e, "/encryption")) throw new Error("File is password-protected");
        i = qd.find(e, "!CompObj"), r = qd.find(e, "/Workbook") || qd.find(e, "/Book")
      } else {
        switch (t.type) {
          case "base64":
            e = ju(Yu(e));
            break;
          case "binary":
            e = ju(e);
            break;
          case "buffer":
            break;
          case "array":
            Array.isArray(e) || (e = Array.prototype.slice.call(e))
        }
        rg(e, 0), r = {
          content: e
        }
      }
      if (i && EA(i), t.bookProps && !t.bookSheets) s = {};
      else {
        var o = Ku ? "buffer" : "array";
        if (r && r.content) s = CA(r.content, t);
        else if ((n = qd.find(e, "PerfectOffice_MAIN")) && n.content) s = lm.to_workbook(n.content, (t.type = o, t));
        else {
          if (!(n = qd.find(e, "NativeContent_MAIN")) || !n.content) throw (n = qd.find(e, "MN0")) && n.content ? new Error("Unsupported Works 4 for Mac file") : new Error("Cannot find Workbook stream");
          s = lm.to_workbook(n.content, (t.type = o, t))
        }
        t.bookVBA && e.FullPaths && qd.find(e, "/_VBA_PROJECT_CUR/VBA/dir") && (s.vbaraw = function(e) {
          var t = qd.utils.cfb_new({
            root: "R"
          });
          return e.FullPaths.forEach(function(i, r) {
            if ("/" !== i.slice(-1) && i.match(/_VBA_PROJECT_CUR/)) {
              var s = i.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
              qd.utils.cfb_add(t, s, e.FileIndex[r].content)
            }
          }), qd.write(t)
        }(e))
      }
      var a = {};
      return e.FullPaths && function(e, t, i) {
        var r = qd.find(e, "/!DocumentSummaryInformation");
        if (r && r.size > 0) try {
          var s = tT(r, af, SA.DSI);
          for (var n in s) t[n] = s[n]
        } catch (e) {
          if (i.WTF) throw e
        }
        var o = qd.find(e, "/!SummaryInformation");
        if (o && o.size > 0) try {
          var a = tT(o, lf, SA.SI);
          for (var l in a) null == t[l] && (t[l] = a[l])
        } catch (e) {
          if (i.WTF) throw e
        }
        t.HeadingPairs && t.TitlesOfParts && (Mf(t.HeadingPairs, t.TitlesOfParts, t, i), delete t.HeadingPairs, delete t.TitlesOfParts)
      }(e, a, t), s.Props = s.Custprops = a, t.bookFiles && (s.cfb = e), s
    }

    function AA(e, t) {
      var i = t || {},
        r = qd.utils.cfb_new({
          root: "R"
        }),
        s = "/Workbook";
      switch (i.bookType || "xls") {
        case "xls":
          i.bookType = "biff8";
        case "xla":
          i.bookType || (i.bookType = "xla");
        case "biff8":
          s = "/Workbook", i.biff = 8;
          break;
        case "biff5":
          s = "/Book", i.biff = 5;
          break;
        default:
          throw new Error("invalid type " + i.bookType + " for XLS CFB")
      }
      return qd.utils.cfb_add(r, s, MA(e, i)), 8 == i.biff && (e.Props || e.Custprops) && function(e, t) {
        var i, r = [],
          s = [],
          n = [],
          o = 0,
          a = rp(af, "n"),
          l = rp(lf, "n");
        if (e.Props)
          for (i = ip(e.Props), o = 0; o < i.length; ++o)(Object.prototype.hasOwnProperty.call(a, i[o]) ? r : Object.prototype.hasOwnProperty.call(l, i[o]) ? s : n).push([i[o], e.Props[i[o]]]);
        if (e.Custprops)
          for (i = ip(e.Custprops), o = 0; o < i.length; ++o) Object.prototype.hasOwnProperty.call(e.Props || {}, i[o]) || (Object.prototype.hasOwnProperty.call(a, i[o]) ? r : Object.prototype.hasOwnProperty.call(l, i[o]) ? s : n).push([i[o], e.Custprops[i[o]]]);
        var c = [];
        for (o = 0; o < n.length; ++o) Qf.indexOf(n[o][0]) > -1 || bf.indexOf(n[o][0]) > -1 || null != n[o][1] && c.push(n[o]);
        s.length && qd.utils.cfb_add(t, "/SummaryInformation", iT(s, SA.SI, l, lf)), (r.length || c.length) && qd.utils.cfb_add(t, "/DocumentSummaryInformation", iT(r, SA.DSI, a, af, c.length ? c : null, SA.UDI))
      }(e, r), 8 == i.biff && e.vbaraw && function(e, t) {
        t.FullPaths.forEach(function(i, r) {
          if (0 != r) {
            var s = i.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
            "/" !== s.slice(-1) && qd.utils.cfb_add(e, s, t.FileIndex[r].content)
          }
        })
      }(r, qd.read(e.vbaraw, {
        type: "string" == typeof e.vbaraw ? "binary" : "buffer"
      })), r
    }
    var vA = {
        0: {
          f: function(e, t) {
            var i = {},
              r = e.l + t;
            i.r = e.read_shift(4), e.l += 4;
            var s = e.read_shift(2);
            e.l += 1;
            var n = e.read_shift(1);
            return e.l = r, 7 & n && (i.level = 7 & n), 16 & n && (i.hidden = !0), 32 & n && (i.hpt = s / 20), i
          }
        },
        1: {
          f: function(e) {
            return [Mg(e)]
          }
        },
        2: {
          f: function(e) {
            return [Mg(e), Kg(e), "n"]
          }
        },
        3: {
          f: function(e) {
            return [Mg(e), e.read_shift(1), "e"]
          }
        },
        4: {
          f: function(e) {
            return [Mg(e), e.read_shift(1), "b"]
          }
        },
        5: {
          f: function(e) {
            return [Mg(e), Jg(e), "n"]
          }
        },
        6: {
          f: function(e) {
            return [Mg(e), _g(e), "str"]
          }
        },
        7: {
          f: function(e) {
            return [Mg(e), e.read_shift(4), "s"]
          }
        },
        8: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = Mg(e);
            s.r = i["!row"];
            var n = [s, _g(e), "str"];
            if (i.cellFormula) {
              e.l += 2;
              var o = vS(e, r - e.l, i);
              n[3] = fS(o, 0, s, i.supbooks, i)
            } else e.l = r;
            return n
          }
        },
        9: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = Mg(e);
            s.r = i["!row"];
            var n = [s, Jg(e), "n"];
            if (i.cellFormula) {
              e.l += 2;
              var o = vS(e, r - e.l, i);
              n[3] = fS(o, 0, s, i.supbooks, i)
            } else e.l = r;
            return n
          }
        },
        10: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = Mg(e);
            s.r = i["!row"];
            var n = [s, e.read_shift(1), "b"];
            if (i.cellFormula) {
              e.l += 2;
              var o = vS(e, r - e.l, i);
              n[3] = fS(o, 0, s, i.supbooks, i)
            } else e.l = r;
            return n
          }
        },
        11: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = Mg(e);
            s.r = i["!row"];
            var n = [s, e.read_shift(1), "e"];
            if (i.cellFormula) {
              e.l += 2;
              var o = vS(e, r - e.l, i);
              n[3] = fS(o, 0, s, i.supbooks, i)
            } else e.l = r;
            return n
          }
        },
        12: {
          f: function(e) {
            return [xg(e)]
          }
        },
        13: {
          f: function(e) {
            return [xg(e), Kg(e), "n"]
          }
        },
        14: {
          f: function(e) {
            return [xg(e), e.read_shift(1), "e"]
          }
        },
        15: {
          f: function(e) {
            return [xg(e), e.read_shift(1), "b"]
          }
        },
        16: {
          f: cR
        },
        17: {
          f: function(e) {
            return [xg(e), _g(e), "str"]
          }
        },
        18: {
          f: function(e) {
            return [xg(e), e.read_shift(4), "s"]
          }
        },
        19: {
          f: Dg
        },
        20: {},
        21: {},
        22: {},
        23: {},
        24: {},
        25: {},
        26: {},
        27: {},
        28: {},
        29: {},
        30: {},
        31: {},
        32: {},
        33: {},
        34: {},
        35: {
          T: 1
        },
        36: {
          T: -1
        },
        37: {
          T: 1
        },
        38: {
          T: -1
        },
        39: {
          f: function(e, t, i) {
            var r = e.l + t;
            e.l += 4, e.l += 1;
            var s = e.read_shift(4),
              n = Vg(e),
              o = NS(e, 0, i),
              a = kg(e);
            e.l = r;
            var l = {
              Name: n,
              Ptg: o
            };
            return s < 268435455 && (l.Sheet = s), a && (l.Comment = a), l
          }
        },
        40: {},
        42: {},
        43: {
          f: function(e, t, i) {
            var r = {};
            r.sz = e.read_shift(2) / 20;
            var s = function(e) {
              var t = e.read_shift(1);
              return e.l++, {
                fBold: 1 & t,
                fItalic: 2 & t,
                fUnderline: 4 & t,
                fStrikeout: 8 & t,
                fOutline: 16 & t,
                fShadow: 32 & t,
                fCondense: 64 & t,
                fExtend: 128 & t
              }
            }(e);
            switch (s.fItalic && (r.italic = 1), s.fCondense && (r.condense = 1), s.fExtend && (r.extend = 1), s.fShadow && (r.shadow = 1), s.fOutline && (r.outline = 1), s.fStrikeout && (r.strike = 1), 700 === e.read_shift(2) && (r.bold = 1), e.read_shift(2)) {
              case 1:
                r.vertAlign = "superscript";
                break;
              case 2:
                r.vertAlign = "subscript"
            }
            var n = e.read_shift(1);
            0 != n && (r.underline = n);
            var o = e.read_shift(1);
            o > 0 && (r.family = o);
            var a = e.read_shift(1);
            switch (a > 0 && (r.charset = a), e.l++, r.color = function(e) {
                var t = {},
                  i = e.read_shift(1) >>> 1,
                  r = e.read_shift(1),
                  s = e.read_shift(2, "i"),
                  n = e.read_shift(1),
                  o = e.read_shift(1),
                  a = e.read_shift(1);
                switch (e.l++, i) {
                  case 0:
                    t.auto = 1;
                    break;
                  case 1:
                    t.index = r;
                    var l = df[r];
                    l && (t.rgb = xm(l));
                    break;
                  case 2:
                    t.rgb = xm([n, o, a]);
                    break;
                  case 3:
                    t.theme = r
                }
                return 0 != s && (t.tint = s > 0 ? s / 32767 : s / 32768), t
              }(e), e.read_shift(1)) {
              case 1:
                r.scheme = "major";
                break;
              case 2:
                r.scheme = "minor"
            }
            return r.name = _g(e), r
          }
        },
        44: {
          f: function(e, t) {
            return [e.read_shift(2), _g(e)]
          }
        },
        45: {
          f: oC
        },
        46: {
          f: hC
        },
        47: {
          f: function(e, t) {
            var i = e.l + t,
              r = e.read_shift(2),
              s = e.read_shift(2);
            return e.l = i, {
              ixfe: r,
              numFmtId: s
            }
          }
        },
        48: {},
        49: {
          f: function(e) {
            return e.read_shift(4, "i")
          }
        },
        50: {},
        51: {
          f: function(e) {
            for (var t = [], i = e.read_shift(4); i-- > 0;) t.push([e.read_shift(4), e.read_shift(4)]);
            return t
          }
        },
        52: {
          T: 1
        },
        53: {
          T: -1
        },
        54: {
          T: 1
        },
        55: {
          T: -1
        },
        56: {
          T: 1
        },
        57: {
          T: -1
        },
        58: {},
        59: {},
        60: {
          f: QT
        },
        62: {
          f: function(e) {
            return [Mg(e), Dg(e), "is"]
          }
        },
        63: {
          f: function(e) {
            var t = {};
            t.i = e.read_shift(4);
            var i = {};
            i.r = e.read_shift(4), i.c = e.read_shift(4), t.r = mg(i);
            var r = e.read_shift(1);
            return 2 & r && (t.l = "1"), 8 & r && (t.a = "1"), t
          }
        },
        64: {
          f: function() {}
        },
        65: {},
        66: {},
        67: {},
        68: {},
        69: {},
        70: {},
        128: {},
        129: {
          T: 1
        },
        130: {
          T: -1
        },
        131: {
          T: 1,
          f: sg,
          p: 0
        },
        132: {
          T: -1
        },
        133: {
          T: 1
        },
        134: {
          T: -1
        },
        135: {
          T: 1
        },
        136: {
          T: -1
        },
        137: {
          T: 1,
          f: function(e) {
            var t = e.read_shift(2);
            return e.l += 28, {
              RTL: 32 & t
            }
          }
        },
        138: {
          T: -1
        },
        139: {
          T: 1
        },
        140: {
          T: -1
        },
        141: {
          T: 1
        },
        142: {
          T: -1
        },
        143: {
          T: 1
        },
        144: {
          T: -1
        },
        145: {
          T: 1
        },
        146: {
          T: -1
        },
        147: {
          f: function(e, t) {
            var i = {},
              r = e[e.l];
            return ++e.l, i.above = !(64 & r), i.left = !(128 & r), e.l += 18, i.name = Ug(e, t - 19), i
          }
        },
        148: {
          f: aR,
          p: 16
        },
        151: {
          f: function() {}
        },
        152: {},
        153: {
          f: function(e, t) {
            var i = {},
              r = e.read_shift(4);
            i.defaultThemeVersion = e.read_shift(4);
            var s = t > 8 ? _g(e) : "";
            return s.length > 0 && (i.CodeName = s), i.autoCompressPictures = !!(65536 & r), i.backupFile = !!(64 & r), i.checkCompatibility = !!(4096 & r), i.date1904 = !!(1 & r), i.filterPrivacy = !!(8 & r), i.hidePivotFieldList = !!(1024 & r), i.promptedSolutions = !!(16 & r), i.publishItems = !!(2048 & r), i.refreshAllConnections = !!(262144 & r), i.saveExternalLinkValues = !!(128 & r), i.showBorderUnselectedTables = !!(4 & r), i.showInkAnnotation = !!(32 & r), i.showObjects = ["all", "placeholders", "none"][r >> 13 & 3], i.showPivotChartFilter = !!(32768 & r), i.updateLinks = ["userSet", "never", "always"][r >> 8 & 3], i
          }
        },
        154: {},
        155: {},
        156: {
          f: function(e, t) {
            var i = {};
            return i.Hidden = e.read_shift(4), i.iTabID = e.read_shift(4), i.strRelID = Wg(e, t - 8), i.name = _g(e), i
          }
        },
        157: {},
        158: {},
        159: {
          T: 1,
          f: function(e) {
            return [e.read_shift(4), e.read_shift(4)]
          }
        },
        160: {
          T: -1
        },
        161: {
          T: 1,
          f: $g
        },
        162: {
          T: -1
        },
        163: {
          T: 1
        },
        164: {
          T: -1
        },
        165: {
          T: 1
        },
        166: {
          T: -1
        },
        167: {},
        168: {},
        169: {},
        170: {},
        171: {},
        172: {
          T: 1
        },
        173: {
          T: -1
        },
        174: {},
        175: {},
        176: {
          f: hR
        },
        177: {
          T: 1
        },
        178: {
          T: -1
        },
        179: {
          T: 1
        },
        180: {
          T: -1
        },
        181: {
          T: 1
        },
        182: {
          T: -1
        },
        183: {
          T: 1
        },
        184: {
          T: -1
        },
        185: {
          T: 1
        },
        186: {
          T: -1
        },
        187: {
          T: 1
        },
        188: {
          T: -1
        },
        189: {
          T: 1
        },
        190: {
          T: -1
        },
        191: {
          T: 1
        },
        192: {
          T: -1
        },
        193: {
          T: 1
        },
        194: {
          T: -1
        },
        195: {
          T: 1
        },
        196: {
          T: -1
        },
        197: {
          T: 1
        },
        198: {
          T: -1
        },
        199: {
          T: 1
        },
        200: {
          T: -1
        },
        201: {
          T: 1
        },
        202: {
          T: -1
        },
        203: {
          T: 1
        },
        204: {
          T: -1
        },
        205: {
          T: 1
        },
        206: {
          T: -1
        },
        207: {
          T: 1
        },
        208: {
          T: -1
        },
        209: {
          T: 1
        },
        210: {
          T: -1
        },
        211: {
          T: 1
        },
        212: {
          T: -1
        },
        213: {
          T: 1
        },
        214: {
          T: -1
        },
        215: {
          T: 1
        },
        216: {
          T: -1
        },
        217: {
          T: 1
        },
        218: {
          T: -1
        },
        219: {
          T: 1
        },
        220: {
          T: -1
        },
        221: {
          T: 1
        },
        222: {
          T: -1
        },
        223: {
          T: 1
        },
        224: {
          T: -1
        },
        225: {
          T: 1
        },
        226: {
          T: -1
        },
        227: {
          T: 1
        },
        228: {
          T: -1
        },
        229: {
          T: 1
        },
        230: {
          T: -1
        },
        231: {
          T: 1
        },
        232: {
          T: -1
        },
        233: {
          T: 1
        },
        234: {
          T: -1
        },
        235: {
          T: 1
        },
        236: {
          T: -1
        },
        237: {
          T: 1
        },
        238: {
          T: -1
        },
        239: {
          T: 1
        },
        240: {
          T: -1
        },
        241: {
          T: 1
        },
        242: {
          T: -1
        },
        243: {
          T: 1
        },
        244: {
          T: -1
        },
        245: {
          T: 1
        },
        246: {
          T: -1
        },
        247: {
          T: 1
        },
        248: {
          T: -1
        },
        249: {
          T: 1
        },
        250: {
          T: -1
        },
        251: {
          T: 1
        },
        252: {
          T: -1
        },
        253: {
          T: 1
        },
        254: {
          T: -1
        },
        255: {
          T: 1
        },
        256: {
          T: -1
        },
        257: {
          T: 1
        },
        258: {
          T: -1
        },
        259: {
          T: 1
        },
        260: {
          T: -1
        },
        261: {
          T: 1
        },
        262: {
          T: -1
        },
        263: {
          T: 1
        },
        264: {
          T: -1
        },
        265: {
          T: 1
        },
        266: {
          T: -1
        },
        267: {
          T: 1
        },
        268: {
          T: -1
        },
        269: {
          T: 1
        },
        270: {
          T: -1
        },
        271: {
          T: 1
        },
        272: {
          T: -1
        },
        273: {
          T: 1
        },
        274: {
          T: -1
        },
        275: {
          T: 1
        },
        276: {
          T: -1
        },
        277: {},
        278: {
          T: 1
        },
        279: {
          T: -1
        },
        280: {
          T: 1
        },
        281: {
          T: -1
        },
        282: {
          T: 1
        },
        283: {
          T: 1
        },
        284: {
          T: -1
        },
        285: {
          T: 1
        },
        286: {
          T: -1
        },
        287: {
          T: 1
        },
        288: {
          T: -1
        },
        289: {
          T: 1
        },
        290: {
          T: -1
        },
        291: {
          T: 1
        },
        292: {
          T: -1
        },
        293: {
          T: 1
        },
        294: {
          T: -1
        },
        295: {
          T: 1
        },
        296: {
          T: -1
        },
        297: {
          T: 1
        },
        298: {
          T: -1
        },
        299: {
          T: 1
        },
        300: {
          T: -1
        },
        301: {
          T: 1
        },
        302: {
          T: -1
        },
        303: {
          T: 1
        },
        304: {
          T: -1
        },
        305: {
          T: 1
        },
        306: {
          T: -1
        },
        307: {
          T: 1
        },
        308: {
          T: -1
        },
        309: {
          T: 1
        },
        310: {
          T: -1
        },
        311: {
          T: 1
        },
        312: {
          T: -1
        },
        313: {
          T: -1
        },
        314: {
          T: 1
        },
        315: {
          T: -1
        },
        316: {
          T: 1
        },
        317: {
          T: -1
        },
        318: {
          T: 1
        },
        319: {
          T: -1
        },
        320: {
          T: 1
        },
        321: {
          T: -1
        },
        322: {
          T: 1
        },
        323: {
          T: -1
        },
        324: {
          T: 1
        },
        325: {
          T: -1
        },
        326: {
          T: 1
        },
        327: {
          T: -1
        },
        328: {
          T: 1
        },
        329: {
          T: -1
        },
        330: {
          T: 1
        },
        331: {
          T: -1
        },
        332: {
          T: 1
        },
        333: {
          T: -1
        },
        334: {
          T: 1
        },
        335: {
          f: function(e, t) {
            return {
              flags: e.read_shift(4),
              version: e.read_shift(4),
              name: _g(e)
            }
          }
        },
        336: {
          T: -1
        },
        337: {
          f: function(e) {
            return e.l += 4, 0 != e.read_shift(4)
          },
          T: 1
        },
        338: {
          T: -1
        },
        339: {
          T: 1
        },
        340: {
          T: -1
        },
        341: {
          T: 1
        },
        342: {
          T: -1
        },
        343: {
          T: 1
        },
        344: {
          T: -1
        },
        345: {
          T: 1
        },
        346: {
          T: -1
        },
        347: {
          T: 1
        },
        348: {
          T: -1
        },
        349: {
          T: 1
        },
        350: {
          T: -1
        },
        351: {},
        352: {},
        353: {
          T: 1
        },
        354: {
          T: -1
        },
        355: {
          f: Wg
        },
        357: {},
        358: {},
        359: {},
        360: {
          T: 1
        },
        361: {},
        362: {
          f: zT
        },
        363: {},
        364: {},
        366: {},
        367: {},
        368: {},
        369: {},
        370: {},
        371: {},
        372: {
          T: 1
        },
        373: {
          T: -1
        },
        374: {
          T: 1
        },
        375: {
          T: -1
        },
        376: {
          T: 1
        },
        377: {
          T: -1
        },
        378: {
          T: 1
        },
        379: {
          T: -1
        },
        380: {
          T: 1
        },
        381: {
          T: -1
        },
        382: {
          T: 1
        },
        383: {
          T: -1
        },
        384: {
          T: 1
        },
        385: {
          T: -1
        },
        386: {
          T: 1
        },
        387: {
          T: -1
        },
        388: {
          T: 1
        },
        389: {
          T: -1
        },
        390: {
          T: 1
        },
        391: {
          T: -1
        },
        392: {
          T: 1
        },
        393: {
          T: -1
        },
        394: {
          T: 1
        },
        395: {
          T: -1
        },
        396: {},
        397: {},
        398: {},
        399: {},
        400: {},
        401: {
          T: 1
        },
        403: {},
        404: {},
        405: {},
        406: {},
        407: {},
        408: {},
        409: {},
        410: {},
        411: {},
        412: {},
        413: {},
        414: {},
        415: {},
        416: {},
        417: {},
        418: {},
        419: {},
        420: {},
        421: {},
        422: {
          T: 1
        },
        423: {
          T: 1
        },
        424: {
          T: -1
        },
        425: {
          T: -1
        },
        426: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = zg(e),
              n = e.read_shift(1),
              o = [s];
            if (o[2] = n, i.cellFormula) {
              var a = AS(e, r - e.l, i);
              o[1] = a
            } else e.l = r;
            return o
          }
        },
        427: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = [$g(e, 16)];
            if (i.cellFormula) {
              var n = IS(e, r - e.l, i);
              s[1] = n, e.l = r
            } else e.l = r;
            return s
          }
        },
        428: {},
        429: {
          T: 1
        },
        430: {
          T: -1
        },
        431: {
          T: 1
        },
        432: {
          T: -1
        },
        433: {
          T: 1
        },
        434: {
          T: -1
        },
        435: {
          T: 1
        },
        436: {
          T: -1
        },
        437: {
          T: 1
        },
        438: {
          T: -1
        },
        439: {
          T: 1
        },
        440: {
          T: -1
        },
        441: {
          T: 1
        },
        442: {
          T: -1
        },
        443: {
          T: 1
        },
        444: {
          T: -1
        },
        445: {
          T: 1
        },
        446: {
          T: -1
        },
        447: {
          T: 1
        },
        448: {
          T: -1
        },
        449: {
          T: 1
        },
        450: {
          T: -1
        },
        451: {
          T: 1
        },
        452: {
          T: -1
        },
        453: {
          T: 1
        },
        454: {
          T: -1
        },
        455: {
          T: 1
        },
        456: {
          T: -1
        },
        457: {
          T: 1
        },
        458: {
          T: -1
        },
        459: {
          T: 1
        },
        460: {
          T: -1
        },
        461: {
          T: 1
        },
        462: {
          T: -1
        },
        463: {
          T: 1
        },
        464: {
          T: -1
        },
        465: {
          T: 1
        },
        466: {
          T: -1
        },
        467: {
          T: 1
        },
        468: {
          T: -1
        },
        469: {
          T: 1
        },
        470: {
          T: -1
        },
        471: {},
        472: {},
        473: {
          T: 1
        },
        474: {
          T: -1
        },
        475: {},
        476: {
          f: function(e) {
            var t = {};
            return dR.forEach(function(i) {
              t[i] = Jg(e)
            }), t
          }
        },
        477: {},
        478: {},
        479: {
          T: 1
        },
        480: {
          T: -1
        },
        481: {
          T: 1
        },
        482: {
          T: -1
        },
        483: {
          T: 1
        },
        484: {
          T: -1
        },
        485: {
          f: function() {}
        },
        486: {
          T: 1
        },
        487: {
          T: -1
        },
        488: {
          T: 1
        },
        489: {
          T: -1
        },
        490: {
          T: 1
        },
        491: {
          T: -1
        },
        492: {
          T: 1
        },
        493: {
          T: -1
        },
        494: {
          f: function(e, t) {
            var i = e.l + t,
              r = $g(e, 16),
              s = kg(e),
              n = _g(e),
              o = _g(e),
              a = _g(e);
            e.l = i;
            var l = {
              rfx: r,
              relId: s,
              loc: n,
              display: a
            };
            return o && (l.Tooltip = o), l
          }
        },
        495: {
          T: 1
        },
        496: {
          T: -1
        },
        497: {
          T: 1
        },
        498: {
          T: -1
        },
        499: {},
        500: {
          T: 1
        },
        501: {
          T: -1
        },
        502: {
          T: 1
        },
        503: {
          T: -1
        },
        504: {},
        505: {
          T: 1
        },
        506: {
          T: -1
        },
        507: {},
        508: {
          T: 1
        },
        509: {
          T: -1
        },
        510: {
          T: 1
        },
        511: {
          T: -1
        },
        512: {},
        513: {},
        514: {
          T: 1
        },
        515: {
          T: -1
        },
        516: {
          T: 1
        },
        517: {
          T: -1
        },
        518: {
          T: 1
        },
        519: {
          T: -1
        },
        520: {
          T: 1
        },
        521: {
          T: -1
        },
        522: {},
        523: {},
        524: {},
        525: {},
        526: {},
        527: {},
        528: {
          T: 1
        },
        529: {
          T: -1
        },
        530: {
          T: 1
        },
        531: {
          T: -1
        },
        532: {
          T: 1
        },
        533: {
          T: -1
        },
        534: {},
        535: {},
        536: {},
        537: {},
        538: {
          T: 1
        },
        539: {
          T: -1
        },
        540: {
          T: 1
        },
        541: {
          T: -1
        },
        542: {
          T: 1
        },
        548: {},
        549: {},
        550: {
          f: Wg
        },
        551: {},
        552: {},
        553: {},
        554: {
          T: 1
        },
        555: {
          T: -1
        },
        556: {
          T: 1
        },
        557: {
          T: -1
        },
        558: {
          T: 1
        },
        559: {
          T: -1
        },
        560: {
          T: 1
        },
        561: {
          T: -1
        },
        562: {},
        564: {},
        565: {
          T: 1
        },
        566: {
          T: -1
        },
        569: {
          T: 1
        },
        570: {
          T: -1
        },
        572: {},
        573: {
          T: 1
        },
        574: {
          T: -1
        },
        577: {},
        578: {},
        579: {},
        580: {},
        581: {},
        582: {},
        583: {},
        584: {},
        585: {},
        586: {},
        587: {},
        588: {
          T: -1
        },
        589: {},
        590: {
          T: 1
        },
        591: {
          T: -1
        },
        592: {
          T: 1
        },
        593: {
          T: -1
        },
        594: {
          T: 1
        },
        595: {
          T: -1
        },
        596: {},
        597: {
          T: 1
        },
        598: {
          T: -1
        },
        599: {
          T: 1
        },
        600: {
          T: -1
        },
        601: {
          T: 1
        },
        602: {
          T: -1
        },
        603: {
          T: 1
        },
        604: {
          T: -1
        },
        605: {
          T: 1
        },
        606: {
          T: -1
        },
        607: {},
        608: {
          T: 1
        },
        609: {
          T: -1
        },
        610: {},
        611: {
          T: 1
        },
        612: {
          T: -1
        },
        613: {
          T: 1
        },
        614: {
          T: -1
        },
        615: {
          T: 1
        },
        616: {
          T: -1
        },
        617: {
          T: 1
        },
        618: {
          T: -1
        },
        619: {
          T: 1
        },
        620: {
          T: -1
        },
        625: {},
        626: {
          T: 1
        },
        627: {
          T: -1
        },
        628: {
          T: 1
        },
        629: {
          T: -1
        },
        630: {
          T: 1
        },
        631: {
          T: -1
        },
        632: {
          f: FC
        },
        633: {
          T: 1
        },
        634: {
          T: -1
        },
        635: {
          T: 1,
          f: function(e) {
            var t = {};
            t.iauthor = e.read_shift(4);
            var i = $g(e, 16);
            return t.rfx = i.s, t.ref = mg(i.s), e.l += 16, t
          }
        },
        636: {
          T: -1
        },
        637: {
          f: Pg
        },
        638: {
          T: 1
        },
        639: {},
        640: {
          T: -1
        },
        641: {
          T: 1
        },
        642: {
          T: -1
        },
        643: {
          T: 1
        },
        644: {},
        645: {
          T: -1
        },
        646: {
          T: 1
        },
        648: {
          T: 1
        },
        649: {},
        650: {
          T: -1
        },
        651: {
          f: function(e, t) {
            return e.l += 10, {
              name: _g(e)
            }
          }
        },
        652: {},
        653: {
          T: 1
        },
        654: {
          T: -1
        },
        655: {
          T: 1
        },
        656: {
          T: -1
        },
        657: {
          T: 1
        },
        658: {
          T: -1
        },
        659: {},
        660: {
          T: 1
        },
        661: {},
        662: {
          T: -1
        },
        663: {},
        664: {
          T: 1
        },
        665: {},
        666: {
          T: -1
        },
        667: {},
        668: {},
        669: {},
        671: {
          T: 1
        },
        672: {
          T: -1
        },
        673: {
          T: 1
        },
        674: {
          T: -1
        },
        675: {},
        676: {},
        677: {},
        678: {},
        679: {},
        680: {},
        681: {},
        1024: {},
        1025: {},
        1026: {
          T: 1
        },
        1027: {
          T: -1
        },
        1028: {
          T: 1
        },
        1029: {
          T: -1
        },
        1030: {},
        1031: {
          T: 1
        },
        1032: {
          T: -1
        },
        1033: {
          T: 1
        },
        1034: {
          T: -1
        },
        1035: {},
        1036: {},
        1037: {},
        1038: {
          T: 1
        },
        1039: {
          T: -1
        },
        1040: {},
        1041: {
          T: 1
        },
        1042: {
          T: -1
        },
        1043: {},
        1044: {},
        1045: {},
        1046: {
          T: 1
        },
        1047: {
          T: -1
        },
        1048: {
          T: 1
        },
        1049: {
          T: -1
        },
        1050: {},
        1051: {
          T: 1
        },
        1052: {
          T: 1
        },
        1053: {
          f: function() {}
        },
        1054: {
          T: 1
        },
        1055: {},
        1056: {
          T: 1
        },
        1057: {
          T: -1
        },
        1058: {
          T: 1
        },
        1059: {
          T: -1
        },
        1061: {},
        1062: {
          T: 1
        },
        1063: {
          T: -1
        },
        1064: {
          T: 1
        },
        1065: {
          T: -1
        },
        1066: {
          T: 1
        },
        1067: {
          T: -1
        },
        1068: {
          T: 1
        },
        1069: {
          T: -1
        },
        1070: {
          T: 1
        },
        1071: {
          T: -1
        },
        1072: {
          T: 1
        },
        1073: {
          T: -1
        },
        1075: {
          T: 1
        },
        1076: {
          T: -1
        },
        1077: {
          T: 1
        },
        1078: {
          T: -1
        },
        1079: {
          T: 1
        },
        1080: {
          T: -1
        },
        1081: {
          T: 1
        },
        1082: {
          T: -1
        },
        1083: {
          T: 1
        },
        1084: {
          T: -1
        },
        1085: {},
        1086: {
          T: 1
        },
        1087: {
          T: -1
        },
        1088: {
          T: 1
        },
        1089: {
          T: -1
        },
        1090: {
          T: 1
        },
        1091: {
          T: -1
        },
        1092: {
          T: 1
        },
        1093: {
          T: -1
        },
        1094: {
          T: 1
        },
        1095: {
          T: -1
        },
        1096: {},
        1097: {
          T: 1
        },
        1098: {},
        1099: {
          T: -1
        },
        1100: {
          T: 1
        },
        1101: {
          T: -1
        },
        1102: {},
        1103: {},
        1104: {},
        1105: {},
        1111: {},
        1112: {},
        1113: {
          T: 1
        },
        1114: {
          T: -1
        },
        1115: {
          T: 1
        },
        1116: {
          T: -1
        },
        1117: {},
        1118: {
          T: 1
        },
        1119: {
          T: -1
        },
        1120: {
          T: 1
        },
        1121: {
          T: -1
        },
        1122: {
          T: 1
        },
        1123: {
          T: -1
        },
        1124: {
          T: 1
        },
        1125: {
          T: -1
        },
        1126: {},
        1128: {
          T: 1
        },
        1129: {
          T: -1
        },
        1130: {},
        1131: {
          T: 1
        },
        1132: {
          T: -1
        },
        1133: {
          T: 1
        },
        1134: {
          T: -1
        },
        1135: {
          T: 1
        },
        1136: {
          T: -1
        },
        1137: {
          T: 1
        },
        1138: {
          T: -1
        },
        1139: {
          T: 1
        },
        1140: {
          T: -1
        },
        1141: {},
        1142: {
          T: 1
        },
        1143: {
          T: -1
        },
        1144: {
          T: 1
        },
        1145: {
          T: -1
        },
        1146: {},
        1147: {
          T: 1
        },
        1148: {
          T: -1
        },
        1149: {
          T: 1
        },
        1150: {
          T: -1
        },
        1152: {
          T: 1
        },
        1153: {
          T: -1
        },
        1154: {
          T: -1
        },
        1155: {
          T: -1
        },
        1156: {
          T: -1
        },
        1157: {
          T: 1
        },
        1158: {
          T: -1
        },
        1159: {
          T: 1
        },
        1160: {
          T: -1
        },
        1161: {
          T: 1
        },
        1162: {
          T: -1
        },
        1163: {
          T: 1
        },
        1164: {
          T: -1
        },
        1165: {
          T: 1
        },
        1166: {
          T: -1
        },
        1167: {
          T: 1
        },
        1168: {
          T: -1
        },
        1169: {
          T: 1
        },
        1170: {
          T: -1
        },
        1171: {},
        1172: {
          T: 1
        },
        1173: {
          T: -1
        },
        1177: {},
        1178: {
          T: 1
        },
        1180: {},
        1181: {},
        1182: {},
        2048: {
          T: 1
        },
        2049: {
          T: -1
        },
        2050: {},
        2051: {
          T: 1
        },
        2052: {
          T: -1
        },
        2053: {},
        2054: {},
        2055: {
          T: 1
        },
        2056: {
          T: -1
        },
        2057: {
          T: 1
        },
        2058: {
          T: -1
        },
        2060: {},
        2067: {},
        2068: {
          T: 1
        },
        2069: {
          T: -1
        },
        2070: {},
        2071: {},
        2072: {
          T: 1
        },
        2073: {
          T: -1
        },
        2075: {},
        2076: {},
        2077: {
          T: 1
        },
        2078: {
          T: -1
        },
        2079: {},
        2080: {
          T: 1
        },
        2081: {
          T: -1
        },
        2082: {},
        2083: {
          T: 1
        },
        2084: {
          T: -1
        },
        2085: {
          T: 1
        },
        2086: {
          T: -1
        },
        2087: {
          T: 1
        },
        2088: {
          T: -1
        },
        2089: {
          T: 1
        },
        2090: {
          T: -1
        },
        2091: {},
        2092: {},
        2093: {
          T: 1
        },
        2094: {
          T: -1
        },
        2095: {},
        2096: {
          T: 1
        },
        2097: {
          T: -1
        },
        2098: {
          T: 1
        },
        2099: {
          T: -1
        },
        2100: {
          T: 1
        },
        2101: {
          T: -1
        },
        2102: {},
        2103: {
          T: 1
        },
        2104: {
          T: -1
        },
        2105: {},
        2106: {
          T: 1
        },
        2107: {
          T: -1
        },
        2108: {},
        2109: {
          T: 1
        },
        2110: {
          T: -1
        },
        2111: {
          T: 1
        },
        2112: {
          T: -1
        },
        2113: {
          T: 1
        },
        2114: {
          T: -1
        },
        2115: {},
        2116: {},
        2117: {},
        2118: {
          T: 1
        },
        2119: {
          T: -1
        },
        2120: {},
        2121: {
          T: 1
        },
        2122: {
          T: -1
        },
        2123: {
          T: 1
        },
        2124: {
          T: -1
        },
        2125: {},
        2126: {
          T: 1
        },
        2127: {
          T: -1
        },
        2128: {},
        2129: {
          T: 1
        },
        2130: {
          T: -1
        },
        2131: {
          T: 1
        },
        2132: {
          T: -1
        },
        2133: {
          T: 1
        },
        2134: {},
        2135: {},
        2136: {},
        2137: {
          T: 1
        },
        2138: {
          T: -1
        },
        2139: {
          T: 1
        },
        2140: {
          T: -1
        },
        2141: {},
        3072: {},
        3073: {},
        4096: {
          T: 1
        },
        4097: {
          T: -1
        },
        5002: {
          T: 1
        },
        5003: {
          T: -1
        },
        5081: {
          T: 1
        },
        5082: {
          T: -1
        },
        5083: {},
        5084: {
          T: 1
        },
        5085: {
          T: -1
        },
        5086: {
          T: 1
        },
        5087: {
          T: -1
        },
        5088: {},
        5089: {},
        5090: {},
        5092: {
          T: 1
        },
        5093: {
          T: -1
        },
        5094: {},
        5095: {
          T: 1
        },
        5096: {
          T: -1
        },
        5097: {},
        5099: {},
        65535: {
          n: ""
        }
      },
      NA = {
        6: {
          f: CS
        },
        10: {
          f: rT
        },
        12: {
          f: oT
        },
        13: {
          f: oT
        },
        14: {
          f: sT
        },
        15: {
          f: sT
        },
        16: {
          f: Jg
        },
        17: {
          f: sT
        },
        18: {
          f: sT
        },
        19: {
          f: oT
        },
        20: {
          f: WT
        },
        21: {
          f: WT
        },
        23: {
          f: zT
        },
        24: {
          f: XT
        },
        25: {
          f: sT
        },
        26: {},
        27: {},
        28: {
          f: function(e, t, i) {
            return function(e, t, i) {
              if (!(i.biff < 8)) {
                var r = e.read_shift(2),
                  s = e.read_shift(2),
                  n = e.read_shift(2),
                  o = e.read_shift(2),
                  a = gT(e, 0, i);
                return i.biff < 8 && e.read_shift(1), [{
                  r,
                  c: s
                }, a, o, n]
              }
            }(e, 0, i)
          }
        },
        29: {},
        34: {
          f: sT
        },
        35: {
          f: YT
        },
        38: {
          f: Jg
        },
        39: {
          f: Jg
        },
        40: {
          f: Jg
        },
        41: {
          f: Jg
        },
        42: {
          f: sT
        },
        43: {
          f: sT
        },
        47: {
          f: function(e, t, i) {
            var r = {
              Type: i.biff >= 8 ? e.read_shift(2) : 0
            };
            return r.Type ? Mm(e, t - 2, r) : function(e, t, i, r) {
              var s = {
                key: oT(e),
                verificationBytes: oT(e)
              };
              i.password && (s.verifier = Dm(i.password)), r.valid = s.verificationBytes === s.verifier, r.valid && (r.insitu = bm(i.password))
            }(e, i.biff, i, r), r
          }
        },
        49: {
          f: function(e, t, i) {
            var r = {
              dyHeight: e.read_shift(2),
              fl: e.read_shift(2)
            };
            switch (i && i.biff || 8) {
              case 2:
                break;
              case 3:
              case 4:
                e.l += 2;
                break;
              default:
                e.l += 10
            }
            return r.name = hT(e, 0, i), r
          }
        },
        51: {
          f: oT
        },
        60: {},
        61: {
          f: function(e) {
            return {
              Pos: [e.read_shift(2), e.read_shift(2)],
              Dim: [e.read_shift(2), e.read_shift(2)],
              Flags: e.read_shift(2),
              CurTab: e.read_shift(2),
              FirstTab: e.read_shift(2),
              Selected: e.read_shift(2),
              TabRatio: e.read_shift(2)
            }
          }
        },
        64: {
          f: sT
        },
        65: {
          f: function() {}
        },
        66: {
          f: oT
        },
        77: {},
        80: {},
        81: {},
        82: {},
        85: {
          f: oT
        },
        89: {},
        90: {},
        91: {},
        92: {
          f: function(e, t, i) {
            if (i.enc) return e.l += t, "";
            var r = e.l,
              s = gT(e, 0, i);
            return e.read_shift(t + r - e.l), s
          }
        },
        93: {
          f: function(e, t, i) {
            if (i && i.biff < 8) return function(e, t, i) {
              e.l += 4;
              var r = e.read_shift(2),
                s = e.read_shift(2),
                n = e.read_shift(2);
              e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 2, e.l += 6, t -= 36;
              var o = [];
              return o.push((jT[r] || sg)(e, t, i)), {
                cmo: [s, r, n],
                ft: o
              }
            }(e, t, i);
            var r = DT(e),
              s = function(e, t) {
                for (var i = e.l + t, r = []; e.l < i;) {
                  var s = e.read_shift(2);
                  e.l -= 2;
                  try {
                    r.push(bT[s](e, i - e.l))
                  } catch (t) {
                    return e.l = i, r
                  }
                }
                return e.l != i && (e.l = i), r
              }(e, t - 22, r[1]);
            return {
              cmo: r,
              ft: s
            }
          }
        },
        94: {},
        95: {
          f: sT
        },
        96: {},
        97: {},
        99: {
          f: sT
        },
        125: {
          f: QT
        },
        128: {
          f: function(e) {
            e.l += 4;
            var t = [e.read_shift(2), e.read_shift(2)];
            if (0 !== t[0] && t[0]--, 0 !== t[1] && t[1]--, t[0] > 7 || t[1] > 7) throw new Error("Bad Gutters: " + t.join("|"));
            return t
          }
        },
        129: {
          f: function(e, t, i) {
            var r = i && 8 == i.biff || 2 == t ? e.read_shift(2) : (e.l += t, 0);
            return {
              fDialog: 16 & r,
              fBelow: 64 & r,
              fRight: 128 & r
            }
          }
        },
        130: {
          f: oT
        },
        131: {
          f: sT
        },
        132: {
          f: sT
        },
        133: {
          f: function(e, t, i) {
            var r = e.read_shift(4),
              s = 3 & e.read_shift(1),
              n = e.read_shift(1);
            switch (n) {
              case 0:
                n = "Worksheet";
                break;
              case 1:
                n = "Macrosheet";
                break;
              case 2:
                n = "Chartsheet";
                break;
              case 6:
                n = "VBAModule"
            }
            var o = hT(e, 0, i);
            return 0 === o.length && (o = "Sheet1"), {
              pos: r,
              hs: s,
              dt: n,
              name: o
            }
          }
        },
        134: {},
        140: {
          f: function(e) {
            var t, i = [0, 0];
            return t = e.read_shift(2), i[0] = cf[t] || t, t = e.read_shift(2), i[1] = cf[t] || t, i
          }
        },
        141: {
          f: oT
        },
        144: {},
        146: {
          f: function(e) {
            for (var t = e.read_shift(2), i = []; t-- > 0;) i.push(AT(e));
            return i
          }
        },
        151: {},
        152: {},
        153: {},
        154: {},
        155: {},
        156: {
          f: oT
        },
        157: {},
        158: {},
        160: {
          f: em
        },
        161: {
          f: function(e, t) {
            var i = {};
            return t < 32 || (e.l += 16, i.header = Jg(e), i.footer = Jg(e), e.l += 2), i
          }
        },
        174: {},
        175: {},
        176: {},
        177: {},
        178: {},
        180: {},
        181: {},
        182: {},
        184: {},
        185: {},
        189: {
          f: function(e, t) {
            for (var i = e.l + t - 2, r = e.read_shift(2), s = e.read_shift(2), n = []; e.l < i;) n.push(OT(e));
            if (e.l !== i) throw new Error("MulRK read error");
            var o = e.read_shift(2);
            if (n.length != o - s + 1) throw new Error("MulRK length mismatch");
            return {
              r,
              c: s,
              C: o,
              rkrec: n
            }
          }
        },
        190: {
          f: function(e, t) {
            for (var i = e.l + t - 2, r = e.read_shift(2), s = e.read_shift(2), n = []; e.l < i;) n.push(e.read_shift(2));
            if (e.l !== i) throw new Error("MulBlank read error");
            var o = e.read_shift(2);
            if (n.length != o - s + 1) throw new Error("MulBlank length mismatch");
            return {
              r,
              c: s,
              C: o,
              ixfe: n
            }
          }
        },
        193: {
          f: rT
        },
        197: {},
        198: {},
        199: {},
        200: {},
        201: {},
        202: {
          f: sT
        },
        203: {},
        204: {},
        205: {},
        206: {},
        207: {},
        208: {},
        209: {},
        210: {},
        211: {},
        213: {},
        215: {},
        216: {},
        217: {},
        218: {
          f: oT
        },
        220: {},
        221: {
          f: sT
        },
        222: {},
        224: {
          f: function(e, t, i) {
            var r = {};
            return r.ifnt = e.read_shift(2), r.numFmtId = e.read_shift(2), r.flags = e.read_shift(2), r.fStyle = r.flags >> 2 & 1, r.data = function(e, t, i, r) {
              var s = {},
                n = e.read_shift(4),
                o = e.read_shift(4),
                a = e.read_shift(4),
                l = e.read_shift(2);
              return s.patternType = hf[a >> 26], r.cellStyles ? (s.alc = 7 & n, s.fWrap = n >> 3 & 1, s.alcV = n >> 4 & 7, s.fJustLast = n >> 7 & 1, s.trot = n >> 8 & 255, s.cIndent = n >> 16 & 15, s.fShrinkToFit = n >> 20 & 1, s.iReadOrder = n >> 22 & 2, s.fAtrNum = n >> 26 & 1, s.fAtrFnt = n >> 27 & 1, s.fAtrAlc = n >> 28 & 1, s.fAtrBdr = n >> 29 & 1, s.fAtrPat = n >> 30 & 1, s.fAtrProt = n >> 31 & 1, s.dgLeft = 15 & o, s.dgRight = o >> 4 & 15, s.dgTop = o >> 8 & 15, s.dgBottom = o >> 12 & 15, s.icvLeft = o >> 16 & 127, s.icvRight = o >> 23 & 127, s.grbitDiag = o >> 30 & 3, s.icvTop = 127 & a, s.icvBottom = a >> 7 & 127, s.icvDiag = a >> 14 & 127, s.dgDiag = a >> 21 & 15, s.icvFore = 127 & l, s.icvBack = l >> 7 & 127, s.fsxButton = l >> 14 & 1, s) : s
            }(e, 0, r.fStyle, i), r
          }
        },
        225: {
          f: function(e, t) {
            return 0 === t || e.read_shift(2), 1200
          }
        },
        226: {
          f: rT
        },
        227: {},
        229: {
          f: function(e, t) {
            for (var i = [], r = e.read_shift(2); r--;) i.push(LT(e));
            return i
          }
        },
        233: {},
        235: {},
        236: {},
        237: {},
        239: {},
        240: {},
        241: {},
        242: {},
        244: {},
        245: {},
        246: {},
        247: {},
        248: {},
        249: {},
        251: {},
        252: {
          f: function(e, t) {
            for (var i = e.l + t, r = e.read_shift(4), s = e.read_shift(4), n = [], o = 0; o != s && e.l < i; ++o) n.push(uT(e));
            return n.Count = r, n.Unique = s, n
          }
        },
        253: {
          f: function(e) {
            var t = vT(e);
            return t.isst = e.read_shift(4), t
          }
        },
        255: {
          f: function(e, t) {
            var i = {};
            return i.dsst = e.read_shift(2), e.l += t - 2, i
          }
        },
        256: {},
        259: {},
        290: {},
        311: {},
        312: {},
        315: {},
        317: {
          f: lT
        },
        318: {},
        319: {},
        320: {},
        330: {},
        331: {},
        333: {},
        334: {},
        335: {},
        336: {},
        337: {},
        338: {},
        339: {},
        340: {},
        351: {},
        352: {
          f: sT
        },
        353: {
          f: rT
        },
        401: {},
        402: {},
        403: {},
        404: {},
        405: {},
        406: {},
        407: {},
        408: {},
        425: {},
        426: {},
        427: {},
        428: {},
        429: {},
        430: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = e.read_shift(2),
              n = e.read_shift(2);
            if (i.sbcch = n, 1025 == n || 14849 == n) return [n, s];
            if (n < 1 || n > 255) throw new Error("Unexpected SupBook type: " + n);
            for (var o = pT(e, n), a = []; r > e.l;) a.push(ET(e));
            return [n, s, o, a]
          }
        },
        431: {
          f: sT
        },
        432: {},
        433: {},
        434: {},
        437: {},
        438: {
          f: function(e, t, i) {
            var r = e.l,
              s = "";
            try {
              e.l += 4;
              var n = (i.lastobj || {
                cmo: [0, 0]
              }).cmo[1]; - 1 == [0, 5, 7, 11, 12, 14].indexOf(n) ? e.l += 6 : function(e) {
                var t = e.read_shift(1);
                e.l++;
                var i = e.read_shift(2);
                return e.l += 2, [t, i]
              }(e);
              var o = e.read_shift(2);
              e.read_shift(2), oT(e);
              var a = e.read_shift(2);
              e.l += a;
              for (var l = 1; l < e.lens.length - 1; ++l) {
                if (e.l - r != e.lens[l]) throw new Error("TxO: bad continue record");
                var c = e[e.l];
                if ((s += pT(e, e.lens[l + 1] - e.lens[l] - 1)).length >= (c ? o : 2 * o)) break
              }
              if (s.length !== o && s.length !== 2 * o) throw new Error("cchText: " + o + " != " + s.length);
              return e.l = r + t, {
                t: s
              }
            } catch (i) {
              return e.l = r + t, {
                t: s
              }
            }
          }
        },
        439: {
          f: sT
        },
        440: {
          f: function(e, t) {
            var i = LT(e);
            e.l += 16;
            var r = function(e, t) {
              var i = e.l + t,
                r = e.read_shift(4);
              if (2 !== r) throw new Error("Unrecognized streamVersion: " + r);
              var s = e.read_shift(2);
              e.l += 2;
              var n, o, a, l, c, h, u = "";
              16 & s && (n = mT(e, e.l)), 128 & s && (o = mT(e, e.l)), 257 & ~s || (a = mT(e, e.l)), 1 == (257 & s) && (l = TT(e, e.l)), 8 & s && (u = mT(e, e.l)), 32 & s && (c = e.read_shift(16)), 64 & s && (h = Bf(e)), e.l = i;
              var d = o || a || l || "";
              d && u && (d += "#" + u), d || (d = "#" + u), 2 & s && "/" == d.charAt(0) && "/" != d.charAt(1) && (d = "file://" + d);
              var p = {
                Target: d
              };
              return c && (p.guid = c), h && (p.time = h), n && (p.Tooltip = n), p
            }(e, t - 24);
            return [i, r]
          }
        },
        441: {},
        442: {
          f: ET
        },
        443: {},
        444: {
          f: oT
        },
        445: {},
        446: {},
        448: {
          f: rT
        },
        449: {
          f: function(e) {
            return e.read_shift(2), e.read_shift(4)
          },
          r: 2
        },
        450: {
          f: rT
        },
        512: {
          f: kT
        },
        513: {
          f: ZT
        },
        515: {
          f: function(e, t, i) {
            i.biffguess && 2 == i.biff && (i.biff = 5);
            var r = vT(e),
              s = Jg(e);
            return r.val = s, r
          }
        },
        516: {
          f: function(e, t, i) {
            i.biffguess && 2 == i.biff && (i.biff = 5), e.l;
            var r = vT(e);
            2 == i.biff && e.l++;
            var s = ET(e, e.l, i);
            return r.val = s, r
          }
        },
        517: {
          f: VT
        },
        519: {
          f: tm
        },
        520: {
          f: function(e) {
            var t = {};
            t.r = e.read_shift(2), t.c = e.read_shift(2), t.cnt = e.read_shift(2) - t.c;
            var i = e.read_shift(2);
            e.l += 4;
            var r = e.read_shift(1);
            return e.l += 3, 7 & r && (t.level = 7 & r), 32 & r && (t.hidden = !0), 64 & r && (t.hpt = i / 20), t
          }
        },
        523: {},
        545: {
          f: $T
        },
        549: {
          f: GT
        },
        566: {},
        574: {
          f: function(e, t, i) {
            return i && i.biff >= 2 && i.biff < 5 ? {} : {
              RTL: 64 & e.read_shift(2)
            }
          }
        },
        638: {
          f: function(e) {
            var t = e.read_shift(2),
              i = e.read_shift(2),
              r = OT(e);
            return {
              r: t,
              c: i,
              ixfe: r[0],
              rknum: r[1]
            }
          }
        },
        659: {},
        1048: {},
        1054: {
          f: function(e, t, i) {
            return [e.read_shift(2), gT(e, 0, i)]
          }
        },
        1084: {},
        1212: {
          f: function(e, t, i) {
            var r = yT(e);
            e.l++;
            var s = e.read_shift(1);
            return [mS(e, t -= 8, i), s, r]
          }
        },
        2048: {
          f: function(e, t) {
            e.read_shift(2);
            var i = LT(e),
              r = e.read_shift((t - 10) / 2, "dbcs-cont");
            return [i, r = r.replace(ed, "")]
          }
        },
        2049: {},
        2050: {},
        2051: {},
        2052: {},
        2053: {},
        2054: {},
        2055: {},
        2056: {},
        2057: {
          f: MT
        },
        2058: {},
        2059: {},
        2060: {},
        2061: {},
        2062: {},
        2063: {},
        2064: {},
        2066: {},
        2067: {},
        2128: {},
        2129: {},
        2130: {},
        2131: {},
        2132: {},
        2133: {},
        2134: {},
        2135: {},
        2136: {},
        2137: {},
        2138: {},
        2146: {},
        2147: {
          r: 12
        },
        2148: {},
        2149: {},
        2150: {},
        2151: {
          f: rT
        },
        2152: {},
        2154: {},
        2155: {},
        2156: {},
        2161: {},
        2162: {},
        2164: {},
        2165: {},
        2166: {},
        2167: {},
        2168: {},
        2169: {},
        2170: {},
        2171: {},
        2172: {
          f: function(e) {
            e.l += 2;
            var t = {
              cxfs: 0,
              crc: 0
            };
            return t.cxfs = e.read_shift(2), t.crc = e.read_shift(4), t
          },
          r: 12
        },
        2173: {
          f: function(e, t) {
            e.l, e.l += 2;
            var i = e.read_shift(2);
            e.l += 2;
            for (var r = e.read_shift(2), s = []; r-- > 0;) s.push(OC(e, e.l));
            return {
              ixfe: i,
              ext: s
            }
          },
          r: 12
        },
        2174: {},
        2175: {},
        2180: {},
        2181: {},
        2182: {},
        2183: {},
        2184: {},
        2185: {},
        2186: {},
        2187: {},
        2188: {
          f: sT,
          r: 12
        },
        2189: {},
        2190: {
          r: 12
        },
        2191: {},
        2192: {},
        2194: {},
        2195: {},
        2196: {
          f: function(e, t, i) {
            if (!(i.biff < 8)) {
              var r = e.read_shift(2),
                s = e.read_shift(2);
              return [pT(e, r, i), pT(e, s, i)]
            }
            e.l += t
          },
          r: 12
        },
        2197: {},
        2198: {
          f: function(e, t, i) {
            var r = e.l + t;
            if (124226 !== e.read_shift(4))
              if (i.cellStyles) {
                var s, n = e.slice(e.l);
                e.l = r;
                try {
                  s = Mp(n, {
                    type: "array"
                  })
                } catch (e) {
                  return
                }
                var o = yp(s, "theme/theme/theme1.xml", !0);
                if (o) return vC(o, i)
              } else e.l = r
          },
          r: 12
        },
        2199: {},
        2200: {},
        2201: {},
        2202: {
          f: function(e) {
            return [0 !== e.read_shift(4), 0 !== e.read_shift(4), e.read_shift(4)]
          },
          r: 12
        },
        2203: {
          f: rT
        },
        2204: {},
        2205: {},
        2206: {},
        2207: {},
        2211: {
          f: function(e) {
            var t = function(e) {
              var t = e.read_shift(2),
                i = e.read_shift(2);
              return e.l += 8, {
                type: t,
                flags: i
              }
            }(e);
            if (2211 != t.type) throw new Error("Invalid Future Record " + t.type);
            return 0 !== e.read_shift(4)
          }
        },
        2212: {},
        2213: {},
        2214: {},
        2215: {},
        4097: {},
        4098: {},
        4099: {},
        4102: {},
        4103: {},
        4105: {},
        4106: {},
        4107: {},
        4108: {},
        4109: {},
        4116: {},
        4117: {},
        4118: {},
        4119: {},
        4120: {},
        4121: {},
        4122: {},
        4123: {},
        4124: {},
        4125: {},
        4126: {},
        4127: {},
        4128: {},
        4129: {},
        4130: {},
        4132: {},
        4133: {},
        4134: {
          f: oT
        },
        4135: {},
        4146: {},
        4147: {},
        4148: {},
        4149: {},
        4154: {},
        4156: {},
        4157: {},
        4158: {},
        4159: {},
        4160: {},
        4161: {},
        4163: {},
        4164: {
          f: function(e, t, i) {
            var r = {
              area: !1
            };
            if (5 != i.biff) return e.l += t, r;
            var s = e.read_shift(1);
            return e.l += 3, 16 & s && (r.area = !0), r
          }
        },
        4165: {},
        4166: {},
        4168: {},
        4170: {},
        4171: {},
        4174: {},
        4175: {},
        4176: {},
        4177: {},
        4187: {},
        4188: {
          f: function(e) {
            for (var t = e.read_shift(2), i = []; t-- > 0;) i.push(AT(e));
            return i
          }
        },
        4189: {},
        4191: {},
        4192: {},
        4193: {},
        4194: {},
        4195: {},
        4196: {},
        4197: {},
        4198: {},
        4199: {},
        4200: {},
        0: {
          f: kT
        },
        1: {},
        2: {
          f: function(e) {
            var t = vT(e);
            ++e.l;
            var i = e.read_shift(2);
            return t.t = "n", t.val = i, t
          }
        },
        3: {
          f: function(e) {
            var t = vT(e);
            ++e.l;
            var i = Jg(e);
            return t.t = "n", t.val = i, t
          }
        },
        4: {
          f: function(e, t, i) {
            i.biffguess && 5 == i.biff && (i.biff = 2);
            var r = vT(e);
            ++e.l;
            var s = gT(e, 0, i);
            return r.t = "str", r.val = s, r
          }
        },
        5: {
          f: VT
        },
        7: {
          f: function(e) {
            var t = e.read_shift(1);
            return 0 === t ? (e.l++, "") : e.read_shift(t, "sbcs-cont")
          }
        },
        8: {},
        9: {
          f: MT
        },
        11: {},
        22: {
          f: oT
        },
        30: {
          f: HT
        },
        31: {},
        32: {},
        33: {
          f: $T
        },
        36: {},
        37: {
          f: GT
        },
        50: {
          f: function(e, t) {
            e.l += 6, e.l += 2, e.l += 1, e.l += 3, e.l += 1, e.l += t - 13
          }
        },
        62: {},
        52: {},
        67: {},
        68: {
          f: oT
        },
        69: {},
        86: {},
        126: {},
        127: {
          f: function(e) {
            var t = e.read_shift(2),
              i = e.read_shift(2),
              r = e.read_shift(4),
              s = {
                fmt: t,
                env: i,
                len: r,
                data: e.slice(e.l, e.l + r)
              };
            return e.l += r, s
          }
        },
        135: {},
        136: {},
        137: {},
        145: {},
        148: {},
        149: {},
        150: {},
        169: {},
        171: {},
        188: {},
        191: {},
        192: {},
        194: {},
        195: {},
        214: {
          f: function(e, t, i) {
            var r = e.l + t,
              s = vT(e),
              n = e.read_shift(2),
              o = pT(e, n, i);
            return e.l = r, s.t = "str", s.val = o, s
          }
        },
        223: {},
        234: {},
        354: {},
        421: {},
        518: {
          f: CS
        },
        521: {
          f: MT
        },
        536: {
          f: XT
        },
        547: {
          f: YT
        },
        561: {},
        579: {},
        1030: {
          f: CS
        },
        1033: {
          f: MT
        },
        1091: {},
        2157: {},
        2163: {},
        2177: {},
        2240: {},
        2241: {},
        2242: {},
        2243: {},
        2244: {},
        2245: {},
        2246: {},
        2247: {},
        2248: {},
        2249: {},
        2250: {},
        2251: {},
        2262: {
          r: 12
        },
        29282: {}
      };

    function IA(e, t, i, r) {
      var s = t;
      if (!isNaN(s)) {
        var n = r || (i || []).length || 0,
          o = e.next(4);
        o.write_shift(2, s), o.write_shift(2, n), n > 0 && WE(i) && e.push(i)
      }
    }

    function OA(e, t, i) {
      return e || (e = ng(7)), e.write_shift(2, t), e.write_shift(2, i), e.write_shift(2, 0), e.write_shift(1, 0), e
    }

    function LA(e, t, i, r) {
      if (null != t.v) switch (t.t) {
        case "d":
        case "n":
          var s = "d" == t.t ? ap(fp(t.v)) : t.v;
          return void(s == (0 | s) && s >= 0 && s < 65536 ? IA(e, 2, (n = i, o = r, a = s, l = ng(9), OA(l, n, o), l.write_shift(2, a), l)) : IA(e, 3, function(e, t, i) {
            var r = ng(15);
            return OA(r, e, t), r.write_shift(8, i, "f"), r
          }(i, r, s)));
        case "b":
        case "e":
          return void IA(e, 5, function(e, t, i, r) {
            var s = ng(9);
            return OA(s, e, t), cT(i, r || "b", s), s
          }(i, r, t.v, t.t));
        case "s":
        case "str":
          return void IA(e, 4, function(e, t, i) {
            var r = ng(8 + 2 * i.length);
            return OA(r, e, t), r.write_shift(1, i.length), r.write_shift(i.length, i, "sbcs"), r.l < r.length ? r.slice(0, r.l) : r
          }(i, r, (t.v || "").slice(0, 255)))
      }
      var n, o, a, l;
      IA(e, 1, OA(null, i, r))
    }

    function _A(e, t) {
      var i = t || {};
      null != Bu && null == i.dense && (i.dense = Bu);
      for (var r = ag(), s = 0, n = 0; n < e.SheetNames.length; ++n) e.SheetNames[n] == i.sheet && (s = n);
      if (0 == s && i.sheet && e.SheetNames[0] != i.sheet) throw new Error("Sheet not found: " + i.sheet);
      return IA(r, 4 == i.biff ? 1033 : 3 == i.biff ? 521 : 9, FT(0, 16, i)),
        function(e, t, i, r) {
          var s, n = Array.isArray(t),
            o = Rg(t["!ref"] || "A1"),
            a = "",
            l = [];
          if (o.e.c > 255 || o.e.r > 16383) {
            if (r.WTF) throw new Error("Range " + (t["!ref"] || "A1") + " exceeds format limit A1:IV16384");
            o.e.c = Math.min(o.e.c, 255), o.e.r = Math.min(o.e.c, 16383), s = Sg(o)
          }
          for (var c = o.s.r; c <= o.e.r; ++c) {
            a = Eg(c);
            for (var h = o.s.c; h <= o.e.c; ++h) {
              c === o.s.r && (l[h] = fg(h)), s = l[h] + a;
              var u = n ? (t[c] || [])[h] : t[s];
              u && LA(e, u, c, h)
            }
          }
        }(r, e.Sheets[e.SheetNames[s]], 0, i), IA(r, 10), r.end()
    }

    function yA(e, t, i) {
      IA(e, 49, function(e, t) {
        var i = e.name || "Arial",
          r = t && 5 == t.biff,
          s = ng(r ? 15 + i.length : 16 + 2 * i.length);
        return s.write_shift(2, 20 * (e.sz || 12)), s.write_shift(4, 0), s.write_shift(2, 400), s.write_shift(4, 0), s.write_shift(2, 0), s.write_shift(1, i.length), r || s.write_shift(1, 1), s.write_shift((r ? 1 : 2) * i.length, i, r ? "sbcs" : "utf16le"), s
      }({
        sz: 12,
        color: {
          theme: 1
        },
        name: "Arial",
        family: 2,
        scheme: "minor"
      }, i))
    }

    function wA(e, t) {
      if (t) {
        var i = 0;
        t.forEach(function(t, r) {
          ++i <= 256 && t && IA(e, 125, function(e, t) {
            var i = ng(12);
            i.write_shift(2, t), i.write_shift(2, t), i.write_shift(2, 256 * e.width), i.write_shift(2, 0);
            var r = 0;
            return e.hidden && (r |= 1), i.write_shift(1, r), r = e.level || 0, i.write_shift(1, r), i.write_shift(2, 0), i
          }(GS(r, t), r))
        })
      }
    }

    function DA(e, t, i, r, s) {
      var n = 16 + HS(s.cellXfs, t, s);
      if (null != t.v || t.bf)
        if (t.bf) IA(e, 6, SS(t, i, r, 0, n));
        else switch (t.t) {
          case "d":
          case "n":
            IA(e, 515, function(e, t, i, r) {
              var s = ng(14);
              return NT(e, t, r, s), qg(i, s), s
            }(i, r, "d" == t.t ? ap(fp(t.v)) : t.v, n));
            break;
          case "b":
          case "e":
            IA(e, 517, function(e, t, i, r, s, n) {
              var o = ng(8);
              return NT(e, t, r, o), cT(i, n, o), o
            }(i, r, t.v, n, 0, t.t));
            break;
          case "s":
          case "str":
            if (s.bookSST) IA(e, 253, function(e, t, i, r) {
              var s = ng(10);
              return NT(e, t, r, s), s.write_shift(4, i), s
            }(i, r, xS(s.Strings, t.v, s.revStrings), n));
            else IA(e, 516, function(e, t, i, r, s) {
              var n = !s || 8 == s.biff,
                o = ng(+n + 8 + (1 + n) * i.length);
              return NT(e, t, r, o), o.write_shift(2, i.length), n && o.write_shift(1, 1), o.write_shift((1 + n) * i.length, i, n ? "utf16le" : "sbcs"), o
            }(i, r, (t.v || "").slice(0, 255), n, s));
            break;
          default:
            IA(e, 513, NT(i, r, n))
        } else IA(e, 513, NT(i, r, n))
    }

    function PA(e, t, i) {
      var r, s, n, o = ag(),
        a = i.SheetNames[e],
        l = i.Sheets[a] || {},
        c = (i || {}).Workbook || {},
        h = (c.Sheets || [])[e] || {},
        u = Array.isArray(l),
        d = 8 == t.biff,
        p = "",
        E = [],
        g = Rg(l["!ref"] || "A1"),
        f = d ? 65536 : 16384;
      if (g.e.c > 255 || g.e.r >= f) {
        if (t.WTF) throw new Error("Range " + (l["!ref"] || "A1") + " exceeds format limit A1:IV16384");
        g.e.c = Math.min(g.e.c, 255), g.e.r = Math.min(g.e.c, f - 1)
      }
      IA(o, 2057, FT(0, 16, t)), IA(o, 13, aT(1)), IA(o, 12, aT(100)), IA(o, 15, nT(!0)), IA(o, 17, nT(!1)), IA(o, 16, qg(.001)), IA(o, 95, nT(!0)), IA(o, 42, nT(!1)), IA(o, 43, nT(!1)), IA(o, 130, aT(1)), IA(o, 128, (s = [0, 0], (n = ng(8)).write_shift(4, 0), n.write_shift(2, s[0] ? s[0] + 1 : 0), n.write_shift(2, s[1] ? s[1] + 1 : 0), n)), IA(o, 131, nT(!1)), IA(o, 132, nT(!1)), d && wA(o, l["!cols"]), IA(o, 512, function(e, t) {
        var i = 8 != t.biff && t.biff ? 2 : 4,
          r = ng(2 * i + 6);
        return r.write_shift(i, e.s.r), r.write_shift(i, e.e.r + 1), r.write_shift(2, e.s.c), r.write_shift(2, e.e.c + 1), r.write_shift(2, 0), r
      }(g, t)), d && (l["!links"] = []);
      for (var T = g.s.r; T <= g.e.r; ++T) {
        p = Eg(T);
        for (var m = g.s.c; m <= g.e.c; ++m) {
          T === g.s.r && (E[m] = fg(m)), r = E[m] + p;
          var C = u ? (l[T] || [])[m] : l[r];
          C && (DA(o, C, T, m, t), d && C.l && l["!links"].push([r, C.l]))
        }
      }
      var S = h.CodeName || h.name || a;
      return d && IA(o, 574, function(e) {
        var t = ng(18),
          i = 1718;
        return e && e.RTL && (i |= 64), t.write_shift(2, i), t.write_shift(4, 0), t.write_shift(4, 64), t.write_shift(4, 0), t.write_shift(4, 0), t
      }((c.Views || [])[0])), d && (l["!merges"] || []).length && IA(o, 229, function(e) {
        var t = ng(2 + 8 * e.length);
        t.write_shift(2, e.length);
        for (var i = 0; i < e.length; ++i) _T(e[i], t);
        return t
      }(l["!merges"])), d && function(e, t) {
        for (var i = 0; i < t["!links"].length; ++i) {
          var r = t["!links"][i];
          IA(e, 440, JT(r)), r[1].Tooltip && IA(e, 2048, qT(r))
        }
        delete t["!links"]
      }(o, l), IA(o, 442, fT(S)), d && function(e, t) {
        var i = ng(19);
        i.write_shift(4, 2151), i.write_shift(4, 0), i.write_shift(4, 0), i.write_shift(2, 3), i.write_shift(1, 1), i.write_shift(4, 0), IA(e, 2151, i), (i = ng(39)).write_shift(4, 2152), i.write_shift(4, 0), i.write_shift(4, 0), i.write_shift(2, 3), i.write_shift(1, 0), i.write_shift(4, 0), i.write_shift(2, 1), i.write_shift(4, 4), i.write_shift(2, 0), _T(Rg(t["!ref"] || "A1"), i), i.write_shift(4, 4), IA(e, 2152, i)
      }(o, l), IA(o, 10), o.end()
    }

    function bA(e, t, i) {
      var r, s = ag(),
        n = (e || {}).Workbook || {},
        o = n.Sheets || [],
        a = n.WBProps || {},
        l = 8 == i.biff,
        c = 5 == i.biff;
      (IA(s, 2057, FT(0, 5, i)), "xla" == i.bookType && IA(s, 135), IA(s, 225, l ? aT(1200) : null), IA(s, 193, function(e, t) {
        t || (t = ng(e));
        for (var i = 0; i < e; ++i) t.write_shift(1, 0);
        return t
      }(2)), c && IA(s, 191), c && IA(s, 192), IA(s, 226), IA(s, 92, function(e, t) {
        var i = !t || 8 == t.biff,
          r = ng(i ? 112 : 54);
        for (r.write_shift(8 == t.biff ? 2 : 1, 7), i && r.write_shift(1, 0), r.write_shift(4, 859007059), r.write_shift(4, 5458548 | (i ? 0 : 536870912)); r.l < r.length;) r.write_shift(1, i ? 0 : 32);
        return r
      }(0, i)), IA(s, 66, aT(l ? 1200 : 1252)), l && IA(s, 353, aT(0)), l && IA(s, 448), IA(s, 317, function(e) {
        for (var t = ng(2 * e), i = 0; i < e; ++i) t.write_shift(2, i + 1);
        return t
      }(e.SheetNames.length)), l && e.vbaraw && IA(s, 211), l && e.vbaraw) && IA(s, 442, fT(a.CodeName || "ThisWorkbook"));
      IA(s, 156, aT(17)), IA(s, 25, nT(!1)), IA(s, 18, nT(!1)), IA(s, 19, aT(0)), l && IA(s, 431, nT(!1)), l && IA(s, 444, aT(0)), IA(s, 61, ((r = ng(18)).write_shift(2, 0), r.write_shift(2, 0), r.write_shift(2, 29280), r.write_shift(2, 17600), r.write_shift(2, 56), r.write_shift(2, 0), r.write_shift(2, 0), r.write_shift(2, 1), r.write_shift(2, 500), r)), IA(s, 64, nT(!1)), IA(s, 141, aT(0)), IA(s, 34, nT("true" == function(e) {
          return e.Workbook && e.Workbook.WBProps && eE(e.Workbook.WBProps.date1904) ? "true" : "false"
        }(e))), IA(s, 14, nT(!0)), l && IA(s, 439, nT(!1)), IA(s, 218, aT(0)), yA(s, 0, i),
        function(e, t, i) {
          t && [
            [5, 8],
            [23, 26],
            [41, 44],
            [50, 392]
          ].forEach(function(r) {
            for (var s = r[0]; s <= r[1]; ++s) null != t[s] && IA(e, 1054, UT(s, t[s], i))
          })
        }(s, e.SSF, i),
        function(e, t) {
          for (var i = 0; i < 16; ++i) IA(e, 224, BT({
            numFmtId: 0,
            style: !0
          }, 0, t));
          t.cellXfs.forEach(function(i) {
            IA(e, 224, BT(i, 0, t))
          })
        }(s, i), l && IA(s, 352, nT(!1));
      var h = s.end(),
        u = ag();
      l && IA(u, 140, function(e) {
        return e || (e = ng(4)), e.write_shift(2, 1), e.write_shift(2, 1), e
      }()), l && i.Strings && function(e, t, i, r) {
        var s = r || (i || []).length || 0;
        if (s <= 8224) return IA(e, t, i, s);
        var n = t;
        if (!isNaN(n)) {
          for (var o = i.parts || [], a = 0, l = 0, c = 0; c + (o[a] || 8224) <= 8224;) c += o[a] || 8224, a++;
          var h = e.next(4);
          for (h.write_shift(2, n), h.write_shift(2, c), e.push(i.slice(l, l + c)), l += c; l < s;) {
            for ((h = e.next(4)).write_shift(2, 60), c = 0; c + (o[a] || 8224) <= 8224;) c += o[a] || 8224, a++;
            h.write_shift(2, c), e.push(i.slice(l, l + c)), l += c
          }
        }
      }(u, 252, function(e) {
        var t = ng(8);
        t.write_shift(4, e.Count), t.write_shift(4, e.Unique);
        for (var i = [], r = 0; r < e.length; ++r) i[r] = dT(e[r]);
        var s = Zu([t].concat(i));
        return s.parts = [t.length].concat(i.map(function(e) {
          return e.length
        })), s
      }(i.Strings)), IA(u, 10);
      var d = u.end(),
        p = ag(),
        E = 0,
        g = 0;
      for (g = 0; g < e.SheetNames.length; ++g) E += (l ? 12 : 11) + (l ? 2 : 1) * e.SheetNames[g].length;
      var f = h.length + E + d.length;
      for (g = 0; g < e.SheetNames.length; ++g) {
        IA(p, 133, xT({
          pos: f,
          hs: (o[g] || {}).Hidden || 0,
          dt: 0,
          name: e.SheetNames[g]
        }, i)), f += t[g].length
      }
      var T = p.end();
      if (E != T.length) throw new Error("BS8 " + E + " != " + T.length);
      var m = [];
      return h.length && m.push(h), T.length && m.push(T), d.length && m.push(d), Zu(m)
    }

    function MA(e, t) {
      for (var i = 0; i <= e.SheetNames.length; ++i) {
        var r = e.Sheets[e.SheetNames[i]];
        if (r && r["!ref"]) Cg(r["!ref"]).e.c > 255 && "undefined" != typeof console && console.error && console.error("Worksheet '" + e.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.")
      }
      var s = t || {};
      switch (s.biff || 2) {
        case 8:
        case 5:
          return function(e, t) {
            var i = t || {},
              r = [];
            e && !e.SSF && (e.SSF = mp(ud)), e && e.SSF && (Xd(), Kd(e.SSF), i.revssf = np(e.SSF), i.revssf[e.SSF[65535]] = 0, i.ssf = e.SSF), i.Strings = [], i.Strings.Count = 0, i.Strings.Unique = 0, Lv(i), i.cellXfs = [], HS(i.cellXfs, {}, {
              revssf: {
                General: 0
              }
            }), e.Props || (e.Props = {});
            for (var s = 0; s < e.SheetNames.length; ++s) r[r.length] = PA(s, i, e);
            return r.unshift(bA(e, r, i)), Zu(r)
          }(e, t);
        case 4:
        case 3:
        case 2:
          return _A(e, t)
      }
      throw new Error("invalid type " + s.bookType + " for BIFF")
    }

    function FA(e, t) {
      var i = t || {};
      null != Bu && null == i.dense && (i.dense = Bu);
      var r = i.dense ? [] : {},
        s = (e = e.replace(/<!--.*?-->/g, "")).match(/<table/i);
      if (!s) throw new Error("Invalid HTML: could not find <table>");
      var n = e.match(/<\/table/i),
        o = s.index,
        a = n && n.index || e.length,
        l = vp(e.slice(o, a), /(:?<tr[^>]*>)/i, "<tr>"),
        c = -1,
        h = 0,
        u = 0,
        d = 0,
        p = {
          s: {
            r: 1e7,
            c: 1e7
          },
          e: {
            r: 0,
            c: 0
          }
        },
        E = [];
      for (o = 0; o < l.length; ++o) {
        var g = l[o].trim(),
          f = g.slice(0, 3).toLowerCase();
        if ("<tr" != f) {
          if ("<td" == f || "<th" == f) {
            var T = g.split(/<\/t[dh]>/i);
            for (a = 0; a < T.length; ++a) {
              var m = T[a].trim();
              if (m.match(/<t[dh]/i)) {
                for (var C = m, S = 0;
                  "<" == C.charAt(0) && (S = C.indexOf(">")) > -1;) C = C.slice(S + 1);
                for (var R = 0; R < E.length; ++R) {
                  var A = E[R];
                  A.s.c == h && A.s.r < c && c <= A.e.r && (h = A.e.c + 1, R = -1)
                }
                var v = Vp(m.slice(0, m.indexOf(">")));
                d = v.colspan ? +v.colspan : 1, ((u = +v.rowspan) > 1 || d > 1) && E.push({
                  s: {
                    r: c,
                    c: h
                  },
                  e: {
                    r: c + (u || 1) - 1,
                    c: h + d - 1
                  }
                });
                var N = v.t || v["data-t"] || "";
                if (C.length)
                  if (C = lE(C), p.s.r > c && (p.s.r = c), p.e.r < c && (p.e.r = c), p.s.c > h && (p.s.c = h), p.e.c < h && (p.e.c = h), C.length) {
                    var I = {
                      t: "s",
                      v: C
                    };
                    i.raw || !C.trim().length || "s" == N || ("TRUE" === C ? I = {
                      t: "b",
                      v: !0
                    } : "FALSE" === C ? I = {
                      t: "b",
                      v: !1
                    } : isNaN(Sp(C)) ? isNaN(Ap(C).getDate()) || (I = {
                      t: "d",
                      v: fp(C)
                    }, i.cellDates || (I = {
                      t: "n",
                      v: ap(I.v)
                    }), I.z = i.dateNF || ud[14]) : I = {
                      t: "n",
                      v: Sp(C)
                    }), i.dense ? (r[c] || (r[c] = []), r[c][h] = I) : r[mg({
                      r: c,
                      c: h
                    })] = I, h += d
                  } else h += d;
                else h += d
              }
            }
          }
        } else {
          if (++c, i.sheetRows && i.sheetRows <= c) {
            --c;
            break
          }
          h = 0
        }
      }
      return r["!ref"] = Sg(p), E.length && (r["!merges"] = E), r
    }

    function xA(e, t, i, r) {
      for (var s = e["!merges"] || [], n = [], o = t.s.c; o <= t.e.c; ++o) {
        for (var a = 0, l = 0, c = 0; c < s.length; ++c)
          if (!(s[c].s.r > i || s[c].s.c > o || s[c].e.r < i || s[c].e.c < o)) {
            if (s[c].s.r < i || s[c].s.c < o) {
              a = -1;
              break
            }
            a = s[c].e.r - s[c].s.r + 1, l = s[c].e.c - s[c].s.c + 1;
            break
          } if (!(a < 0)) {
          var h = mg({
              r: i,
              c: o
            }),
            u = r.dense ? (e[i] || [])[o] : e[h],
            d = u && null != u.v && (u.h || Qp(u.w || (vg(u), u.w) || "")) || "",
            p = {};
          a > 1 && (p.rowspan = a), l > 1 && (p.colspan = l), r.editable ? d = '<span contenteditable="true">' + d + "</span>" : u && (p["data-t"] = u && u.t || "z", null != u.v && (p["data-v"] = u.v), null != u.z && (p["data-z"] = u.z), u.l && "#" != (u.l.Target || "#").charAt(0) && (d = '<a href="' + u.l.Target + '">' + d + "</a>")), p.id = (r.id || "sjs") + "-" + h, n.push(fE("td", d, p))
        }
      }
      return "<tr>" + n.join("") + "</tr>"
    }
    var GA = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>',
      UA = "</body></html>";

    function HA(e, t, i) {
      return [].join("") + "<table" + (i && i.id ? ' id="' + i.id + '"' : "") + ">"
    }

    function kA(e, t) {
      var i = t || {},
        r = null != i.header ? i.header : GA,
        s = null != i.footer ? i.footer : UA,
        n = [r],
        o = Cg(e["!ref"]);
      i.dense = Array.isArray(e), n.push(HA(0, 0, i));
      for (var a = o.s.r; a <= o.e.r; ++a) n.push(xA(e, o, a, i));
      return n.push("</table>" + s), n.join("")
    }

    function BA(e, t, i) {
      var r = i || {};
      null != Bu && (r.dense = Bu);
      var s = 0,
        n = 0;
      if (null != r.origin)
        if ("number" == typeof r.origin) s = r.origin;
        else {
          var o = "string" == typeof r.origin ? Tg(r.origin) : r.origin;
          s = o.r, n = o.c
        } var a = t.getElementsByTagName("tr"),
        l = Math.min(r.sheetRows || 1e7, a.length),
        c = {
          s: {
            r: 0,
            c: 0
          },
          e: {
            r: s,
            c: n
          }
        };
      if (e["!ref"]) {
        var h = Cg(e["!ref"]);
        c.s.r = Math.min(c.s.r, h.s.r), c.s.c = Math.min(c.s.c, h.s.c), c.e.r = Math.max(c.e.r, h.e.r), c.e.c = Math.max(c.e.c, h.e.c), -1 == s && (c.e.r = s = h.e.r + 1)
      }
      var u = [],
        d = 0,
        p = e["!rows"] || (e["!rows"] = []),
        E = 0,
        g = 0,
        f = 0,
        T = 0,
        m = 0,
        C = 0;
      for (e["!cols"] || (e["!cols"] = []); E < a.length && g < l; ++E) {
        var S = a[E];
        if (WA(S)) {
          if (r.display) continue;
          p[g] = {
            hidden: !0
          }
        }
        var R = S.children;
        for (f = T = 0; f < R.length; ++f) {
          var A = R[f];
          if (!r.display || !WA(A)) {
            var v = A.hasAttribute("data-v") ? A.getAttribute("data-v") : A.hasAttribute("v") ? A.getAttribute("v") : lE(A.innerHTML),
              N = A.getAttribute("data-z") || A.getAttribute("z");
            for (d = 0; d < u.length; ++d) {
              var I = u[d];
              I.s.c == T + n && I.s.r < g + s && g + s <= I.e.r && (T = I.e.c + 1 - n, d = -1)
            }
            C = +A.getAttribute("colspan") || 1, ((m = +A.getAttribute("rowspan") || 1) > 1 || C > 1) && u.push({
              s: {
                r: g + s,
                c: T + n
              },
              e: {
                r: g + s + (m || 1) - 1,
                c: T + n + (C || 1) - 1
              }
            });
            var O = {
                t: "s",
                v
              },
              L = A.getAttribute("data-t") || A.getAttribute("t") || "";
            null != v && (0 == v.length ? O.t = L || "z" : r.raw || 0 == v.trim().length || "s" == L || ("TRUE" === v ? O = {
              t: "b",
              v: !0
            } : "FALSE" === v ? O = {
              t: "b",
              v: !1
            } : isNaN(Sp(v)) ? isNaN(Ap(v).getDate()) || (O = {
              t: "d",
              v: fp(v)
            }, r.cellDates || (O = {
              t: "n",
              v: ap(O.v)
            }), O.z = r.dateNF || ud[14]) : O = {
              t: "n",
              v: Sp(v)
            })), void 0 === O.z && null != N && (O.z = N);
            var _ = "",
              y = A.getElementsByTagName("A");
            if (y && y.length)
              for (var w = 0; w < y.length && (!y[w].hasAttribute("href") || "#" == (_ = y[w].getAttribute("href")).charAt(0)); ++w);
            _ && "#" != _.charAt(0) && (O.l = {
              Target: _
            }), r.dense ? (e[g + s] || (e[g + s] = []), e[g + s][T + n] = O) : e[mg({
              c: T + n,
              r: g + s
            })] = O, c.e.c < T + n && (c.e.c = T + n), T += C
          }
        }++g
      }
      return u.length && (e["!merges"] = (e["!merges"] || []).concat(u)), c.e.r = Math.max(c.e.r, g - 1 + s), e["!ref"] = Sg(c), g >= l && (e["!fullref"] = Sg((c.e.r = a.length - E + g - 1 + s, c))), e
    }

    function VA(e, t) {
      return BA((t || {}).dense ? [] : {}, e, t)
    }

    function WA(e) {
      var t = "",
        i = function(e) {
          return e.ownerDocument.defaultView && "function" == typeof e.ownerDocument.defaultView.getComputedStyle ? e.ownerDocument.defaultView.getComputedStyle : "function" == typeof getComputedStyle ? getComputedStyle : null
        }(e);
      return i && (t = i(e).getPropertyValue("display")), t || (t = e.style && e.style.display), "none" === t
    }

    function YA(e) {
      var t = e.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function(e, t) {
        return Array(parseInt(t, 10) + 1).join(" ")
      }).replace(/<text:tab[^>]*\/>/g, "\t").replace(/<text:line-break\/>/g, "\n");
      return [Xp(t.replace(/<[^>]*>/g, ""))]
    }
    var KA = {
      day: ["d", "dd"],
      month: ["m", "mm"],
      year: ["y", "yy"],
      hours: ["h", "hh"],
      minutes: ["m", "mm"],
      seconds: ["s", "ss"],
      "am-pm": ["A/P", "AM/PM"],
      "day-of-week": ["ddd", "dddd"],
      era: ["e", "ee"],
      quarter: ["\\Qm", 'm\\"th quarter"']
    };

    function XA(e, t) {
      var i = t || {};
      null != Bu && null == i.dense && (i.dense = Bu);
      var r, s, n, o, a, l, c = mE(e),
        h = [],
        u = {
          name: ""
        },
        d = "",
        p = 0,
        E = {},
        g = [],
        f = i.dense ? [] : {},
        T = {
          value: ""
        },
        m = "",
        C = 0,
        S = [],
        R = -1,
        A = -1,
        v = {
          s: {
            r: 1e6,
            c: 1e7
          },
          e: {
            r: 0,
            c: 0
          }
        },
        N = 0,
        I = {},
        O = [],
        L = {},
        _ = [],
        y = 1,
        w = 1,
        D = [],
        P = {
          Names: []
        },
        b = {},
        M = ["", ""],
        F = [],
        x = {},
        G = "",
        U = 0,
        H = !1,
        k = !1,
        B = 0;
      for (CE.lastIndex = 0, c = c.replace(/<!--([\s\S]*?)-->/gm, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, ""); a = CE.exec(c);) switch (a[3] = a[3].replace(/_.*$/, "")) {
        case "table":
        case "工作表":
          "/" === a[1] ? (v.e.c >= v.s.c && v.e.r >= v.s.r ? f["!ref"] = Sg(v) : f["!ref"] = "A1:A1", i.sheetRows > 0 && i.sheetRows <= v.e.r && (f["!fullref"] = f["!ref"], v.e.r = i.sheetRows - 1, f["!ref"] = Sg(v)), O.length && (f["!merges"] = O), _.length && (f["!rows"] = _), n.name = n["名称"] || n.name, "undefined" != typeof JSON && JSON.stringify(n), g.push(n.name), E[n.name] = f, k = !1) : "/" !== a[0].charAt(a[0].length - 2) && (n = Vp(a[0], !1), R = A = -1, v.s.r = v.s.c = 1e7, v.e.r = v.e.c = 0, f = i.dense ? [] : {}, O = [], _ = [], k = !0);
          break;
        case "table-row-group":
          "/" === a[1] ? --N : ++N;
          break;
        case "table-row":
        case "行":
          if ("/" === a[1]) {
            R += y, y = 1;
            break
          }
          if ((o = Vp(a[0], !1))["行号"] ? R = o["行号"] - 1 : -1 == R && (R = 0), (y = +o["number-rows-repeated"] || 1) < 10)
            for (B = 0; B < y; ++B) N > 0 && (_[R + B] = {
              level: N
            });
          A = -1;
          break;
        case "covered-table-cell":
          "/" !== a[1] && ++A, i.sheetStubs && (i.dense ? (f[R] || (f[R] = []), f[R][A] = {
            t: "z"
          }) : f[mg({
            r: R,
            c: A
          })] = {
            t: "z"
          }), m = "", S = [];
          break;
        case "table-cell":
        case "数据":
          if ("/" === a[0].charAt(a[0].length - 2)) ++A, T = Vp(a[0], !1), w = parseInt(T["number-columns-repeated"] || "1", 10), l = {
            t: "z",
            v: null
          }, T.formula && 0 != i.cellFormula && (l.f = yS(Xp(T.formula))), "string" == (T["数据类型"] || T["value-type"]) && (l.t = "s", l.v = Xp(T["string-value"] || ""), i.dense ? (f[R] || (f[R] = []), f[R][A] = l) : f[mg({
            r: R,
            c: A
          })] = l), A += w - 1;
          else if ("/" !== a[1]) {
            m = "", C = 0, S = [], w = 1;
            var V = y ? R + y - 1 : R;
            if (++A > v.e.c && (v.e.c = A), A < v.s.c && (v.s.c = A), R < v.s.r && (v.s.r = R), V > v.e.r && (v.e.r = V), F = [], x = {}, l = {
                t: (T = Vp(a[0], !1))["数据类型"] || T["value-type"],
                v: null
              }, i.cellFormula)
              if (T.formula && (T.formula = Xp(T.formula)), T["number-matrix-columns-spanned"] && T["number-matrix-rows-spanned"] && (L = {
                  s: {
                    r: R,
                    c: A
                  },
                  e: {
                    r: R + (parseInt(T["number-matrix-rows-spanned"], 10) || 0) - 1,
                    c: A + (parseInt(T["number-matrix-columns-spanned"], 10) || 0) - 1
                  }
                }, l.F = Sg(L), D.push([L, l.F])), T.formula) l.f = yS(T.formula);
              else
                for (B = 0; B < D.length; ++B) R >= D[B][0].s.r && R <= D[B][0].e.r && A >= D[B][0].s.c && A <= D[B][0].e.c && (l.F = D[B][1]);
            switch ((T["number-columns-spanned"] || T["number-rows-spanned"]) && (L = {
                s: {
                  r: R,
                  c: A
                },
                e: {
                  r: R + (parseInt(T["number-rows-spanned"], 10) || 0) - 1,
                  c: A + (parseInt(T["number-columns-spanned"], 10) || 0) - 1
                }
              }, O.push(L)), T["number-columns-repeated"] && (w = parseInt(T["number-columns-repeated"], 10)), l.t) {
              case "boolean":
                l.t = "b", l.v = eE(T["boolean-value"]);
                break;
              case "float":
              case "percentage":
              case "currency":
                l.t = "n", l.v = parseFloat(T.value);
                break;
              case "date":
                l.t = "d", l.v = fp(T["date-value"]), i.cellDates || (l.t = "n", l.v = ap(l.v)), l.z = "m/d/yy";
                break;
              case "time":
                l.t = "n", l.v = dp(T["time-value"]) / 86400, i.cellDates && (l.t = "d", l.v = up(l.v)), l.z = "HH:MM:SS";
                break;
              case "number":
                l.t = "n", l.v = parseFloat(T["数据数值"]);
                break;
              default:
                if ("string" !== l.t && "text" !== l.t && l.t) throw new Error("Unsupported value type " + l.t);
                l.t = "s", null != T["string-value"] && (m = Xp(T["string-value"]), S = [])
            }
          } else {
            if (H = !1, "s" === l.t && (l.v = m || "", S.length && (l.R = S), H = 0 == C), b.Target && (l.l = b), F.length > 0 && (l.c = F, F = []), m && !1 !== i.cellText && (l.w = m), H && (l.t = "z", delete l.v), (!H || i.sheetStubs) && !(i.sheetRows && i.sheetRows <= R))
              for (var W = 0; W < y; ++W) {
                if (w = parseInt(T["number-columns-repeated"] || "1", 10), i.dense)
                  for (f[R + W] || (f[R + W] = []), f[R + W][A] = 0 == W ? l : mp(l); --w > 0;) f[R + W][A + w] = mp(l);
                else
                  for (f[mg({
                      r: R + W,
                      c: A
                    })] = l; --w > 0;) f[mg({
                    r: R + W,
                    c: A + w
                  })] = mp(l);
                v.e.c <= A && (v.e.c = A)
              }
            A += (w = parseInt(T["number-columns-repeated"] || "1", 10)) - 1, w = 0, l = {}, m = "", S = []
          }
          b = {};
          break;
        case "document":
        case "document-content":
        case "电子表格文档":
        case "spreadsheet":
        case "主体":
        case "scripts":
        case "styles":
        case "font-face-decls":
        case "master-styles":
          if ("/" === a[1]) {
            if ((r = h.pop())[0] !== a[3]) throw "Bad state: " + r
          } else "/" !== a[0].charAt(a[0].length - 2) && h.push([a[3], !0]);
          break;
        case "annotation":
          if ("/" === a[1]) {
            if ((r = h.pop())[0] !== a[3]) throw "Bad state: " + r;
            x.t = m, S.length && (x.R = S), x.a = G, F.push(x)
          } else "/" !== a[0].charAt(a[0].length - 2) && h.push([a[3], !1]);
          G = "", U = 0, m = "", C = 0, S = [];
          break;
        case "creator":
          "/" === a[1] ? G = c.slice(U, a.index) : U = a.index + a[0].length;
          break;
        case "meta":
        case "元数据":
        case "settings":
        case "config-item-set":
        case "config-item-map-indexed":
        case "config-item-map-entry":
        case "config-item-map-named":
        case "shapes":
        case "frame":
        case "text-box":
        case "image":
        case "data-pilot-tables":
        case "list-style":
        case "form":
        case "dde-links":
        case "event-listeners":
        case "chart":
          if ("/" === a[1]) {
            if ((r = h.pop())[0] !== a[3]) throw "Bad state: " + r
          } else "/" !== a[0].charAt(a[0].length - 2) && h.push([a[3], !1]);
          m = "", C = 0, S = [];
          break;
        case "scientific-number":
        case "currency-symbol":
        case "currency-style":
        case "script":
        case "libraries":
        case "automatic-styles":
        case "default-style":
        case "page-layout":
        case "style":
        case "map":
        case "font-face":
        case "paragraph-properties":
        case "table-properties":
        case "table-column-properties":
        case "table-row-properties":
        case "table-cell-properties":
        case "fraction":
        case "boolean-style":
        case "boolean":
        case "text-style":
        case "text-content":
        case "text-properties":
        case "embedded-text":
        case "body":
        case "电子表格":
        case "forms":
        case "table-column":
        case "table-header-rows":
        case "table-rows":
        case "table-column-group":
        case "table-header-columns":
        case "table-columns":
        case "null-date":
        case "graphic-properties":
        case "calculation-settings":
        case "named-expressions":
        case "label-range":
        case "label-ranges":
        case "named-expression":
        case "sort":
        case "sort-by":
        case "sort-groups":
        case "tab":
        case "line-break":
        case "span":
        case "s":
        case "date":
        case "object":
        case "title":
        case "标题":
        case "desc":
        case "binary-data":
        case "table-source":
        case "scenario":
        case "iteration":
        case "content-validations":
        case "content-validation":
        case "help-message":
        case "error-message":
        case "database-ranges":
        case "filter":
        case "filter-and":
        case "filter-or":
        case "filter-condition":
        case "list-level-style-bullet":
        case "list-level-style-number":
        case "list-level-properties":
        case "sender-firstname":
        case "sender-lastname":
        case "sender-initials":
        case "sender-title":
        case "sender-position":
        case "sender-email":
        case "sender-phone-private":
        case "sender-fax":
        case "sender-company":
        case "sender-phone-work":
        case "sender-street":
        case "sender-city":
        case "sender-postal-code":
        case "sender-country":
        case "sender-state-or-province":
        case "author-name":
        case "author-initials":
        case "chapter":
        case "file-name":
        case "template-name":
        case "sheet-name":
        case "event-listener":
        case "initial-creator":
        case "creation-date":
        case "print-date":
        case "generator":
        case "document-statistic":
        case "user-defined":
        case "editing-duration":
        case "editing-cycles":
        case "config-item":
        case "page-number":
        case "page-count":
        case "time":
        case "cell-range-source":
        case "detective":
        case "operation":
        case "highlighted-range":
        case "data-pilot-table":
        case "source-cell-range":
        case "source-service":
        case "data-pilot-field":
        case "data-pilot-level":
        case "data-pilot-subtotals":
        case "data-pilot-subtotal":
        case "data-pilot-members":
        case "data-pilot-member":
        case "data-pilot-display-info":
        case "data-pilot-sort-info":
        case "data-pilot-layout-info":
        case "data-pilot-field-reference":
        case "data-pilot-groups":
        case "data-pilot-group":
        case "data-pilot-group-member":
        case "rect":
        case "dde-connection-decls":
        case "dde-connection-decl":
        case "dde-link":
        case "dde-source":
        case "properties":
        case "property":
        case "table-protection":
        case "data-pilot-grand-total":
        case "office-document-common-attrs":
          break;
        case "number-style":
        case "percentage-style":
        case "date-style":
        case "time-style":
          if ("/" === a[1]) {
            if (I[u.name] = d, (r = h.pop())[0] !== a[3]) throw "Bad state: " + r
          } else "/" !== a[0].charAt(a[0].length - 2) && (d = "", u = Vp(a[0], !1), h.push([a[3], !0]));
          break;
        case "number":
        case "day":
        case "month":
        case "year":
        case "era":
        case "day-of-week":
        case "week-of-year":
        case "quarter":
        case "hours":
        case "minutes":
        case "seconds":
        case "am-pm":
          switch (h[h.length - 1][0]) {
            case "time-style":
            case "date-style":
              s = Vp(a[0], !1), d += KA[a[3]]["long" === s.style ? 1 : 0]
          }
          break;
        case "text":
          if ("/>" === a[0].slice(-2)) break;
          if ("/" === a[1]) switch (h[h.length - 1][0]) {
            case "number-style":
            case "date-style":
            case "time-style":
              d += c.slice(p, a.index)
          } else p = a.index + a[0].length;
          break;
        case "named-range":
          M = DS((s = Vp(a[0], !1))["cell-range-address"]);
          var Y = {
            Name: s.name,
            Ref: M[0] + "!" + M[1]
          };
          k && (Y.Sheet = g.length), P.Names.push(Y);
          break;
        case "p":
        case "文本串":
          if (["master-styles"].indexOf(h[h.length - 1][0]) > -1) break;
          if ("/" !== a[1] || T && T["string-value"]) Vp(a[0], !1), C = a.index + a[0].length;
          else {
            var K = YA(c.slice(C, a.index));
            m = (m.length > 0 ? m + "\n" : "") + K[0]
          }
          break;
        case "database-range":
          if ("/" === a[1]) break;
          try {
            E[(M = DS(Vp(a[0])["target-range-address"]))[0]]["!autofilter"] = {
              ref: M[1]
            }
          } catch (e) {}
          break;
        case "a":
          if ("/" !== a[1]) {
            if (!(b = Vp(a[0], !1)).href) break;
            b.Target = Xp(b.href), delete b.href, "#" == b.Target.charAt(0) && b.Target.indexOf(".") > -1 ? (M = DS(b.Target.slice(1)), b.Target = "#" + M[0] + "!" + M[1]) : b.Target.match(/^\.\.[\\\/]/) && (b.Target = b.Target.slice(3))
          }
          break;
        default:
          switch (a[2]) {
            case "dc:":
            case "calcext:":
            case "loext:":
            case "ooo:":
            case "chartooo:":
            case "draw:":
            case "style:":
            case "chart:":
            case "form:":
            case "uof:":
            case "表:":
            case "字:":
              break;
            default:
              if (i.WTF) throw new Error(a)
          }
      }
      var X = {
        Sheets: E,
        SheetNames: g,
        Workbook: P
      };
      return i.bookSheets && delete X.Sheets, X
    }

    function zA(e, t) {
      t = t || {}, Op(e, "META-INF/manifest.xml") && function(e, t) {
        for (var i, r, s = mE(e); i = CE.exec(s);) switch (i[3]) {
          case "manifest":
            break;
          case "file-entry":
            if ("/" == (r = Vp(i[0], !1)).path && r.type !== vf) throw new Error("This OpenDocument is not a spreadsheet");
            break;
          case "encryption-data":
          case "algorithm":
          case "start-key-generation":
          case "key-derivation":
            throw new Error("Unsupported ODS Encryption");
          default:
            if (t && t.WTF) throw i
        }
      }(_p(e, "META-INF/manifest.xml"), t);
      var i = yp(e, "content.xml");
      if (!i) throw new Error("Missing content.xml in ODS / UOF file");
      var r = XA(nE(i), t);
      return Op(e, "meta.xml") && (r.Props = yf(_p(e, "meta.xml"))), r
    }

    function $A(e, t) {
      return XA(e, t)
    }
    var jA = function() {
        var e = ["<office:master-styles>", '<style:master-page style:name="mp1" style:page-layout-name="mp1">', "<style:header/>", '<style:header-left style:display="false"/>', "<style:footer/>", '<style:footer-left style:display="false"/>', "</style:master-page>", "</office:master-styles>"].join(""),
          t = "<office:document-styles " + gE({
            "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
            "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
            "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
            "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
            "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
            "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
            "xmlns:xlink": "http://www.w3.org/1999/xlink",
            "xmlns:dc": "http://purl.org/dc/elements/1.1/",
            "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
            "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
            "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
            "office:version": "1.2"
          }) + ">" + e + "</office:document-styles>";
        return function() {
          return xp + t
        }
      }(),
      JA = function() {
        var e = function(e) {
            return jp(e).replace(/  +/g, function(e) {
              return '<text:s text:c="' + e.length + '"/>'
            }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>")
          },
          t = "          <table:table-cell />\n",
          i = function(i, r, s) {
            var n = [];
            n.push('      <table:table table:name="' + jp(r.SheetNames[s]) + '" table:style-name="ta1">\n');
            var o = 0,
              a = 0,
              l = Cg(i["!ref"] || "A1"),
              c = i["!merges"] || [],
              h = 0,
              u = Array.isArray(i);
            if (i["!cols"])
              for (a = 0; a <= l.e.c; ++a) n.push("        <table:table-column" + (i["!cols"][a] ? ' table:style-name="co' + i["!cols"][a].ods + '"' : "") + "></table:table-column>\n");
            var d = "",
              p = i["!rows"] || [];
            for (o = 0; o < l.s.r; ++o) d = p[o] ? ' table:style-name="ro' + p[o].ods + '"' : "", n.push("        <table:table-row" + d + "></table:table-row>\n");
            for (; o <= l.e.r; ++o) {
              for (d = p[o] ? ' table:style-name="ro' + p[o].ods + '"' : "", n.push("        <table:table-row" + d + ">\n"), a = 0; a < l.s.c; ++a) n.push(t);
              for (; a <= l.e.c; ++a) {
                var E = !1,
                  g = {},
                  f = "";
                for (h = 0; h != c.length; ++h)
                  if (!(c[h].s.c > a || c[h].s.r > o || c[h].e.c < a || c[h].e.r < o)) {
                    c[h].s.c == a && c[h].s.r == o || (E = !0), g["table:number-columns-spanned"] = c[h].e.c - c[h].s.c + 1, g["table:number-rows-spanned"] = c[h].e.r - c[h].s.r + 1;
                    break
                  } if (E) n.push("          <table:covered-table-cell/>\n");
                else {
                  var T = mg({
                      r: o,
                      c: a
                    }),
                    m = u ? (i[o] || [])[a] : i[T];
                  if (m && m.f && (g["table:formula"] = jp(wS(m.f)), m.F && m.F.slice(0, T.length) == T)) {
                    var C = Cg(m.F);
                    g["table:number-matrix-columns-spanned"] = C.e.c - C.s.c + 1, g["table:number-matrix-rows-spanned"] = C.e.r - C.s.r + 1
                  }
                  if (m) {
                    switch (m.t) {
                      case "b":
                        f = m.v ? "TRUE" : "FALSE", g["office:value-type"] = "boolean", g["office:boolean-value"] = m.v ? "true" : "false";
                        break;
                      case "n":
                        f = m.w || String(m.v || 0), g["office:value-type"] = "float", g["office:value"] = m.v || 0;
                        break;
                      case "s":
                      case "str":
                        f = null == m.v ? "" : m.v, g["office:value-type"] = "string";
                        break;
                      case "d":
                        f = m.w || fp(m.v).toISOString(), g["office:value-type"] = "date", g["office:date-value"] = fp(m.v).toISOString(), g["table:style-name"] = "ce1";
                        break;
                      default:
                        n.push(t);
                        continue
                    }
                    var S = e(f);
                    if (m.l && m.l.Target) {
                      var R = m.l.Target;
                      "#" == (R = "#" == R.charAt(0) ? "#" + PS(R.slice(1)) : R).charAt(0) || R.match(/^\w+:/) || (R = "../" + R), S = fE("text:a", S, {
                        "xlink:href": R.replace(/&/g, "&amp;")
                      })
                    }
                    n.push("          " + fE("table:table-cell", fE("text:p", S, {}), g) + "\n")
                  } else n.push(t)
                }
              }
              n.push("        </table:table-row>\n")
            }
            return n.push("      </table:table>\n"), n.join("")
          };
        return function(e, t) {
          var r = [xp],
            s = gE({
              "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
              "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
              "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
              "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
              "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
              "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              "xmlns:dc": "http://purl.org/dc/elements/1.1/",
              "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
              "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
              "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
              "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
              "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
              "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
              "xmlns:math": "http://www.w3.org/1998/Math/MathML",
              "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
              "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
              "xmlns:ooo": "http://openoffice.org/2004/office",
              "xmlns:ooow": "http://openoffice.org/2004/writer",
              "xmlns:oooc": "http://openoffice.org/2004/calc",
              "xmlns:dom": "http://www.w3.org/2001/xml-events",
              "xmlns:xforms": "http://www.w3.org/2002/xforms",
              "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
              "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
              "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
              "xmlns:rpt": "http://openoffice.org/2005/report",
              "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
              "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
              "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
              "xmlns:tableooo": "http://openoffice.org/2009/table",
              "xmlns:drawooo": "http://openoffice.org/2010/draw",
              "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
              "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
              "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
              "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
              "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
              "office:version": "1.2"
            }),
            n = gE({
              "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
              "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
            });
          "fods" == t.bookType ? (r.push("<office:document" + s + n + ">\n"), r.push(Of().replace(/office:document-meta/g, "office:meta"))) : r.push("<office:document-content" + s + ">\n"),
            function(e, t) {
              e.push(" <office:automatic-styles>\n"), e.push('  <number:date-style style:name="N37" number:automatic-order="true">\n'), e.push('   <number:month number:style="long"/>\n'), e.push("   <number:text>/</number:text>\n"), e.push('   <number:day number:style="long"/>\n'), e.push("   <number:text>/</number:text>\n"), e.push("   <number:year/>\n"), e.push("  </number:date-style>\n");
              var i = 0;
              t.SheetNames.map(function(e) {
                return t.Sheets[e]
              }).forEach(function(t) {
                if (t && t["!cols"])
                  for (var r = 0; r < t["!cols"].length; ++r)
                    if (t["!cols"][r]) {
                      var s = t["!cols"][r];
                      if (null == s.width && null == s.wpx && null == s.wch) continue;
                      zm(s), s.ods = i;
                      var n = t["!cols"][r].wpx + "px";
                      e.push('  <style:style style:name="co' + i + '" style:family="table-column">\n'), e.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + n + '"/>\n'), e.push("  </style:style>\n"), ++i
                    }
              });
              var r = 0;
              t.SheetNames.map(function(e) {
                return t.Sheets[e]
              }).forEach(function(t) {
                if (t && t["!rows"])
                  for (var i = 0; i < t["!rows"].length; ++i)
                    if (t["!rows"][i]) {
                      t["!rows"][i].ods = r;
                      var s = t["!rows"][i].hpx + "px";
                      e.push('  <style:style style:name="ro' + r + '" style:family="table-row">\n'), e.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + s + '"/>\n'), e.push("  </style:style>\n"), ++r
                    }
              }), e.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n'), e.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n'), e.push("  </style:style>\n"), e.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n'), e.push(" </office:automatic-styles>\n")
            }(r, e), r.push("  <office:body>\n"), r.push("    <office:spreadsheet>\n");
          for (var o = 0; o != e.SheetNames.length; ++o) r.push(i(e.Sheets[e.SheetNames[o]], e, o));
          return r.push("    </office:spreadsheet>\n"), r.push("  </office:body>\n"), "fods" == t.bookType ? r.push("</office:document>") : r.push("</office:document-content>"), r.join("")
        }
      }();

    function qA(e, t) {
      if ("fods" == t.bookType) return JA(e, t);
      var i = bp(),
        r = "",
        s = [],
        n = [];
      return Pp(i, r = "mimetype", "application/vnd.oasis.opendocument.spreadsheet"), Pp(i, r = "content.xml", JA(e, t)), s.push([r, "text/xml"]), n.push([r, "ContentFile"]), Pp(i, r = "styles.xml", jA(e, t)), s.push([r, "text/xml"]), n.push([r, "StylesFile"]), Pp(i, r = "meta.xml", xp + Of()), s.push([r, "text/xml"]), n.push([r, "MetadataFile"]), Pp(i, r = "manifest.rdf", function(e) {
        var t = [xp];
        t.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
        for (var i = 0; i != e.length; ++i) t.push(Nf(e[i][0], e[i][1])), t.push(If("", e[i][0]));
        return t.push(Nf("", "Document", "pkg")), t.push("</rdf:RDF>"), t.join("")
      }(n)), s.push([r, "application/rdf+xml"]), Pp(i, r = "META-INF/manifest.xml", function(e) {
        var t = [xp];
        t.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n'), t.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
        for (var i = 0; i < e.length; ++i) t.push('  <manifest:file-entry manifest:full-path="' + e[i][0] + '" manifest:media-type="' + e[i][1] + '"/>\n');
        return t.push("</manifest:manifest>"), t.join("")
      }(s)), i
    }

    function QA(e) {
      return new DataView(e.buffer, e.byteOffset, e.byteLength)
    }

    function ZA(e) {
      return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(e) : nE(qu(e))
    }

    function ev(e) {
      return "undefined" != typeof TextEncoder ? (new TextEncoder).encode(e) : ju(oE(e))
    }

    function tv(e) {
      var t = e.reduce(function(e, t) {
          return e + t.length
        }, 0),
        i = new Uint8Array(t),
        r = 0;
      return e.forEach(function(e) {
        i.set(e, r), r += e.length
      }), i
    }

    function iv(e) {
      return 16843009 * ((e = (858993459 & (e -= e >> 1 & 1431655765)) + (e >> 2 & 858993459)) + (e >> 4) & 252645135) >>> 24
    }

    function rv(e, t) {
      var i = t ? t[0] : 0,
        r = 127 & e[i];
      e: if (e[i++] >= 128) {
        if (r |= (127 & e[i]) << 7, e[i++] < 128) break e;
        if (r |= (127 & e[i]) << 14, e[i++] < 128) break e;
        if (r |= (127 & e[i]) << 21, e[i++] < 128) break e;
        if (r += (127 & e[i]) * Math.pow(2, 28), ++i, e[i++] < 128) break e;
        if (r += (127 & e[i]) * Math.pow(2, 35), ++i, e[i++] < 128) break e;
        if (r += (127 & e[i]) * Math.pow(2, 42), ++i, e[i++] < 128) break e
      }
      return t && (t[0] = i), r
    }

    function sv(e) {
      var t = new Uint8Array(7);
      t[0] = 127 & e;
      var i = 1;
      e: if (e > 127) {
        if (t[i - 1] |= 128, t[i] = e >> 7 & 127, ++i, e <= 16383) break e;
        if (t[i - 1] |= 128, t[i] = e >> 14 & 127, ++i, e <= 2097151) break e;
        if (t[i - 1] |= 128, t[i] = e >> 21 & 127, ++i, e <= 268435455) break e;
        if (t[i - 1] |= 128, t[i] = e / 256 >>> 21 & 127, ++i, e <= 34359738367) break e;
        if (t[i - 1] |= 128, t[i] = e / 65536 >>> 21 & 127, ++i, e <= 4398046511103) break e;
        t[i - 1] |= 128, t[i] = e / 16777216 >>> 21 & 127, ++i
      }
      return t.slice(0, i)
    }

    function nv(e) {
      var t = 0,
        i = 127 & e[t];
      e: if (e[t++] >= 128) {
        if (i |= (127 & e[t]) << 7, e[t++] < 128) break e;
        if (i |= (127 & e[t]) << 14, e[t++] < 128) break e;
        if (i |= (127 & e[t]) << 21, e[t++] < 128) break e;
        i |= (127 & e[t]) << 28
      }
      return i
    }

    function ov(e) {
      for (var t = [], i = [0]; i[0] < e.length;) {
        var r, s = i[0],
          n = rv(e, i),
          o = 7 & n,
          a = 0;
        if (0 == (n = Math.floor(n / 8))) break;
        switch (o) {
          case 0:
            for (var l = i[0]; e[i[0]++] >= 128;);
            r = e.slice(l, i[0]);
            break;
          case 5:
            a = 4, r = e.slice(i[0], i[0] + a), i[0] += a;
            break;
          case 1:
            a = 8, r = e.slice(i[0], i[0] + a), i[0] += a;
            break;
          case 2:
            a = rv(e, i), r = e.slice(i[0], i[0] + a), i[0] += a;
            break;
          default:
            throw new Error("PB Type ".concat(o, " for Field ").concat(n, " at offset ").concat(s))
        }
        var c = {
          data: r,
          type: o
        };
        null == t[n] ? t[n] = [c] : t[n].push(c)
      }
      return t
    }

    function av(e) {
      var t = [];
      return e.forEach(function(e, i) {
        e.forEach(function(e) {
          e.data && (t.push(sv(8 * i + e.type)), 2 == e.type && t.push(sv(e.data.length)), t.push(e.data))
        })
      }), tv(t)
    }

    function lv(e, t) {
      return (null == e ? void 0 : e.map(function(e) {
        return t(e.data)
      })) || []
    }

    function cv(e) {
      for (var t, i = [], r = [0]; r[0] < e.length;) {
        var s = rv(e, r),
          n = ov(e.slice(r[0], r[0] + s));
        r[0] += s;
        var o = {
          id: nv(n[1][0].data),
          messages: []
        };
        n[2].forEach(function(t) {
          var i = ov(t.data),
            s = nv(i[3][0].data);
          o.messages.push({
            meta: i,
            data: e.slice(r[0], r[0] + s)
          }), r[0] += s
        }), (null == (t = n[3]) ? void 0 : t[0]) && (o.merge = nv(n[3][0].data) >>> 0 > 0), i.push(o)
      }
      return i
    }

    function hv(e) {
      var t = [];
      return e.forEach(function(e) {
        var i = [];
        i[1] = [{
          data: sv(e.id),
          type: 0
        }], i[2] = [], null != e.merge && (i[3] = [{
          data: sv(+!!e.merge),
          type: 0
        }]);
        var r = [];
        e.messages.forEach(function(e) {
          r.push(e.data), e.meta[3] = [{
            type: 0,
            data: sv(e.data.length)
          }], i[2].push({
            data: av(e.meta),
            type: 2
          })
        });
        var s = av(i);
        t.push(sv(s.length)), t.push(s), r.forEach(function(e) {
          return t.push(e)
        })
      }), tv(t)
    }

    function uv(e, t) {
      if (0 != e) throw new Error("Unexpected Snappy chunk type ".concat(e));
      for (var i = [0], r = rv(t, i), s = []; i[0] < t.length;) {
        var n = 3 & t[i[0]];
        if (0 != n) {
          var o = 0,
            a = 0;
          if (1 == n ? (a = 4 + (t[i[0]] >> 2 & 7), o = (224 & t[i[0]++]) << 3, o |= t[i[0]++]) : (a = 1 + (t[i[0]++] >> 2), 2 == n ? (o = t[i[0]] | t[i[0] + 1] << 8, i[0] += 2) : (o = (t[i[0]] | t[i[0] + 1] << 8 | t[i[0] + 2] << 16 | t[i[0] + 3] << 24) >>> 0, i[0] += 4)), s = [tv(s)], 0 == o) throw new Error("Invalid offset 0");
          if (o > s[0].length) throw new Error("Invalid offset beyond length");
          if (a >= o)
            for (s.push(s[0].slice(-o)), a -= o; a >= s[s.length - 1].length;) s.push(s[s.length - 1]), a -= s[s.length - 1].length;
          s.push(s[0].slice(-o, -o + a))
        } else {
          var l = t[i[0]++] >> 2;
          if (l < 60) ++l;
          else {
            var c = l - 59;
            l = t[i[0]], c > 1 && (l |= t[i[0] + 1] << 8), c > 2 && (l |= t[i[0] + 2] << 16), c > 3 && (l |= t[i[0] + 3] << 24), l >>>= 0, l++, i[0] += c
          }
          s.push(t.slice(i[0], i[0] + l)), i[0] += l
        }
      }
      var h = tv(s);
      if (h.length != r) throw new Error("Unexpected length: ".concat(h.length, " != ").concat(r));
      return h
    }

    function dv(e) {
      for (var t = [], i = 0; i < e.length;) {
        var r = e[i++],
          s = e[i] | e[i + 1] << 8 | e[i + 2] << 16;
        i += 3, t.push(uv(r, e.slice(i, i + s))), i += s
      }
      if (i !== e.length) throw new Error("data is not a valid framed stream!");
      return tv(t)
    }

    function pv(e) {
      for (var t = [], i = 0; i < e.length;) {
        var r = Math.min(e.length - i, 268435455),
          s = new Uint8Array(4);
        t.push(s);
        var n = sv(r),
          o = n.length;
        t.push(n), r <= 60 ? (o++, t.push(new Uint8Array([r - 1 << 2]))) : r <= 256 ? (o += 2, t.push(new Uint8Array([240, r - 1 & 255]))) : r <= 65536 ? (o += 3, t.push(new Uint8Array([244, r - 1 & 255, r - 1 >> 8 & 255]))) : r <= 16777216 ? (o += 4, t.push(new Uint8Array([248, r - 1 & 255, r - 1 >> 8 & 255, r - 1 >> 16 & 255]))) : r <= 4294967296 && (o += 5, t.push(new Uint8Array([252, r - 1 & 255, r - 1 >> 8 & 255, r - 1 >> 16 & 255, r - 1 >>> 24 & 255]))), t.push(e.slice(i, i + r)), o += r, s[0] = 0, s[1] = 255 & o, s[2] = o >> 8 & 255, s[3] = o >> 16 & 255, i += r
      }
      return tv(t)
    }

    function Ev(e, t, i) {
      var r, s = QA(e),
        n = s.getUint32(8, !0),
        o = 12,
        a = -1,
        l = -1,
        c = NaN,
        h = NaN,
        u = new Date(2001, 0, 1);
      switch (1 & n && (c = function(e, t) {
          for (var i = (127 & e[t + 15]) << 7 | e[t + 14] >> 1, r = 1 & e[t + 14], s = t + 13; s >= t; --s) r = 256 * r + e[s];
          return (128 & e[t + 15] ? -r : r) * Math.pow(10, i - 6176)
        }(e, o), o += 16), 2 & n && (h = s.getFloat64(o, !0), o += 8), 4 & n && (u.setTime(u.getTime() + 1e3 * s.getFloat64(o, !0)), o += 8), 8 & n && (l = s.getUint32(o, !0), o += 4), 16 & n && (a = s.getUint32(o, !0), o += 4), e[1]) {
        case 0:
          break;
        case 2:
        case 10:
          r = {
            t: "n",
            v: c
          };
          break;
        case 3:
          r = {
            t: "s",
            v: t[l]
          };
          break;
        case 5:
          r = {
            t: "d",
            v: u
          };
          break;
        case 6:
          r = {
            t: "b",
            v: h > 0
          };
          break;
        case 7:
          r = {
            t: "n",
            v: h / 86400
          };
          break;
        case 8:
          r = {
            t: "e",
            v: 0
          };
          break;
        case 9:
          if (!(a > -1)) throw new Error("Unsupported cell type ".concat(e[1], " : ").concat(31 & n, " : ").concat(e.slice(0, 4)));
          r = {
            t: "s",
            v: i[a]
          };
          break;
        default:
          throw new Error("Unsupported cell type ".concat(e[1], " : ").concat(31 & n, " : ").concat(e.slice(0, 4)))
      }
      return r
    }

    function gv(e, t) {
      var i = new Uint8Array(32),
        r = QA(i),
        s = 12,
        n = 0;
      switch (i[0] = 5, e.t) {
        case "n":
          i[1] = 2,
            function(e, t, i) {
              var r = Math.floor(0 == i ? 0 : Math.LOG10E * Math.log(Math.abs(i))) + 6176 - 20,
                s = i / Math.pow(10, r - 6176);
              e[t + 15] |= r >> 7, e[t + 14] |= (127 & r) << 1;
              for (var n = 0; s >= 1; ++n, s /= 256) e[t + n] = 255 & s;
              e[t + 15] |= i >= 0 ? 0 : 128
            }(i, s, e.v), n |= 1, s += 16;
          break;
        case "b":
          i[1] = 6, r.setFloat64(s, e.v ? 1 : 0, !0), n |= 2, s += 8;
          break;
        case "s":
          if (-1 == t.indexOf(e.v)) throw new Error("Value ".concat(e.v, " missing from SST!"));
          i[1] = 3, r.setUint32(s, t.indexOf(e.v), !0), n |= 8, s += 4;
          break;
        default:
          throw "unsupported cell type " + e.t
      }
      return r.setUint32(8, n, !0), i.slice(0, s)
    }

    function fv(e, t) {
      var i = new Uint8Array(32),
        r = QA(i),
        s = 12,
        n = 0;
      switch (i[0] = 3, e.t) {
        case "n":
          i[2] = 2, r.setFloat64(s, e.v, !0), n |= 32, s += 8;
          break;
        case "b":
          i[2] = 6, r.setFloat64(s, e.v ? 1 : 0, !0), n |= 32, s += 8;
          break;
        case "s":
          if (-1 == t.indexOf(e.v)) throw new Error("Value ".concat(e.v, " missing from SST!"));
          i[2] = 3, r.setUint32(s, t.indexOf(e.v), !0), n |= 16, s += 4;
          break;
        default:
          throw "unsupported cell type " + e.t
      }
      return r.setUint32(4, n, !0), i.slice(0, s)
    }

    function Tv(e, t, i) {
      switch (e[0]) {
        case 0:
        case 1:
        case 2:
        case 3:
          return function(e, t, i, r) {
            var s, n = QA(e),
              o = n.getUint32(4, !0),
              a = (r > 1 ? 12 : 8) + 4 * iv(o & (r > 1 ? 3470 : 398)),
              l = -1,
              c = -1,
              h = NaN,
              u = new Date(2001, 0, 1);
            switch (512 & o && (l = n.getUint32(a, !0), a += 4), a += 4 * iv(o & (r > 1 ? 12288 : 4096)), 16 & o && (c = n.getUint32(a, !0), a += 4), 32 & o && (h = n.getFloat64(a, !0), a += 8), 64 & o && (u.setTime(u.getTime() + 1e3 * n.getFloat64(a, !0)), a += 8), e[2]) {
              case 0:
                break;
              case 2:
                s = {
                  t: "n",
                  v: h
                };
                break;
              case 3:
                s = {
                  t: "s",
                  v: t[c]
                };
                break;
              case 5:
                s = {
                  t: "d",
                  v: u
                };
                break;
              case 6:
                s = {
                  t: "b",
                  v: h > 0
                };
                break;
              case 7:
                s = {
                  t: "n",
                  v: h / 86400
                };
                break;
              case 8:
                s = {
                  t: "e",
                  v: 0
                };
                break;
              case 9:
                if (l > -1) s = {
                  t: "s",
                  v: i[l]
                };
                else if (c > -1) s = {
                  t: "s",
                  v: t[c]
                };
                else {
                  if (isNaN(h)) throw new Error("Unsupported cell type ".concat(e.slice(0, 4)));
                  s = {
                    t: "n",
                    v: h
                  }
                }
                break;
              default:
                throw new Error("Unsupported cell type ".concat(e.slice(0, 4)))
            }
            return s
          }(e, t, i, e[0]);
        case 5:
          return Ev(e, t, i);
        default:
          throw new Error("Unsupported payload version ".concat(e[0]))
      }
    }

    function mv(e) {
      return rv(ov(e)[1][0].data)
    }

    function Cv(e, t) {
      var i = ov(t.data),
        r = nv(i[1][0].data),
        s = i[3],
        n = [];
      return (s || []).forEach(function(t) {
        var i = ov(t.data),
          s = nv(i[1][0].data) >>> 0;
        switch (r) {
          case 1:
            n[s] = ZA(i[3][0].data);
            break;
          case 8:
            var o = ov(e[mv(i[9][0].data)][0].data),
              a = e[mv(o[1][0].data)][0],
              l = nv(a.meta[1][0].data);
            if (2001 != l) throw new Error("2000 unexpected reference to ".concat(l));
            var c = ov(a.data);
            n[s] = c[3].map(function(e) {
              return ZA(e.data)
            }).join("")
        }
      }), n
    }

    function Sv(e, t) {
      var i, r = ov(t.data),
        s = (null == (i = null == r ? void 0 : r[7]) ? void 0 : i[0]) ? nv(r[7][0].data) >>> 0 > 0 ? 1 : 0 : -1,
        n = lv(r[5], function(e) {
          return function(e, t) {
            var i, r, s, n, o, a, l, c, h, u, d, p, E, g, f, T, m = ov(e),
              C = nv(m[1][0].data) >>> 0,
              S = nv(m[2][0].data) >>> 0,
              R = (null == (r = null == (i = m[8]) ? void 0 : i[0]) ? void 0 : r.data) && nv(m[8][0].data) > 0 || !1;
            if ((null == (n = null == (s = m[7]) ? void 0 : s[0]) ? void 0 : n.data) && 0 != t) f = null == (a = null == (o = m[7]) ? void 0 : o[0]) ? void 0 : a.data, T = null == (c = null == (l = m[6]) ? void 0 : l[0]) ? void 0 : c.data;
            else {
              if (!(null == (u = null == (h = m[4]) ? void 0 : h[0]) ? void 0 : u.data) || 1 == t) throw "NUMBERS Tile missing ".concat(t, " cell storage");
              f = null == (p = null == (d = m[4]) ? void 0 : d[0]) ? void 0 : p.data, T = null == (g = null == (E = m[3]) ? void 0 : E[0]) ? void 0 : g.data
            }
            for (var A = R ? 4 : 1, v = QA(f), N = [], I = 0; I < f.length / 2; ++I) {
              var O = v.getUint16(2 * I, !0);
              O < 65535 && N.push([I, O])
            }
            if (N.length != S) throw "Expected ".concat(S, " cells, found ").concat(N.length);
            var L = [];
            for (I = 0; I < N.length - 1; ++I) L[N[I][0]] = T.subarray(N[I][1] * A, N[I + 1][1] * A);
            return N.length >= 1 && (L[N[N.length - 1][0]] = T.subarray(N[N.length - 1][1] * A)), {
              R: C,
              cells: L
            }
          }(e, s)
        });
      return {
        nrows: nv(r[4][0].data) >>> 0,
        data: n.reduce(function(e, t) {
          return e[t.R] || (e[t.R] = []), t.cells.forEach(function(i, r) {
            if (e[t.R][r]) throw new Error("Duplicate cell r=".concat(t.R, " c=").concat(r));
            e[t.R][r] = i
          }), e
        }, [])
      }
    }

    function Rv(e, t) {
      var i = {
          "!ref": "A1"
        },
        r = e[mv(ov(t.data)[2][0].data)],
        s = nv(r[0].meta[1][0].data);
      if (6001 != s) throw new Error("6000 unexpected reference to ".concat(s));
      return function(e, t, i) {
        var r, s = ov(t.data),
          n = {
            s: {
              r: 0,
              c: 0
            },
            e: {
              r: 0,
              c: 0
            }
          };
        if (n.e.r = (nv(s[6][0].data) >>> 0) - 1, n.e.r < 0) throw new Error("Invalid row varint ".concat(s[6][0].data));
        if (n.e.c = (nv(s[7][0].data) >>> 0) - 1, n.e.c < 0) throw new Error("Invalid col varint ".concat(s[7][0].data));
        i["!ref"] = Sg(n);
        var o = ov(s[4][0].data),
          a = Cv(e, e[mv(o[4][0].data)][0]),
          l = (null == (r = o[17]) ? void 0 : r[0]) ? Cv(e, e[mv(o[17][0].data)][0]) : [],
          c = ov(o[3][0].data),
          h = 0;
        c[1].forEach(function(t) {
          var r = ov(t.data),
            s = e[mv(r[2][0].data)][0],
            n = nv(s.meta[1][0].data);
          if (6002 != n) throw new Error("6001 unexpected reference to ".concat(n));
          var o = Sv(0, s);
          o.data.forEach(function(e, t) {
            e.forEach(function(e, r) {
              var s = mg({
                  r: h + t,
                  c: r
                }),
                n = Tv(e, a, l);
              n && (i[s] = n)
            })
          }), h += o.nrows
        })
      }(e, r[0], i), i
    }

    function Av(e, t) {
      var i = {
        SheetNames: [],
        Sheets: {}
      };
      if (lv(ov(t.data)[1], mv).forEach(function(t) {
          e[t].forEach(function(t) {
            if (2 == nv(t.meta[1][0].data)) {
              var r = function(e, t) {
                var i, r = ov(t.data),
                  s = {
                    name: (null == (i = r[1]) ? void 0 : i[0]) ? ZA(r[1][0].data) : "",
                    sheets: []
                  };
                return lv(r[2], mv).forEach(function(t) {
                  e[t].forEach(function(t) {
                    6e3 == nv(t.meta[1][0].data) && s.sheets.push(Rv(e, t))
                  })
                }), s
              }(e, t);
              r.sheets.forEach(function(e, t) {
                sN(i, e, 0 == t ? r.name : r.name + "_" + t, !0)
              })
            }
          })
        }), 0 == i.SheetNames.length) throw new Error("Empty NUMBERS file");
      return i
    }

    function vv(e) {
      var t, i, r, s, n = {},
        o = [];
      if (e.FullPaths.forEach(function(e) {
          if (e.match(/\.iwpv2/)) throw new Error("Unsupported password protection")
        }), e.FileIndex.forEach(function(e) {
          if (e.name.match(/\.iwa$/)) {
            var t, i;
            try {
              t = dv(e.content)
            } catch (t) {
              return console.log("?? " + e.content.length + " " + (t.message || t))
            }
            try {
              i = cv(t)
            } catch (e) {
              return console.log("## " + (e.message || e))
            }
            i.forEach(function(e) {
              n[e.id] = e.messages, o.push(e.id)
            })
          }
        }), !o.length) throw new Error("File has no messages");
      var a = (null == (s = null == (r = null == (i = null == (t = null == n ? void 0 : n[1]) ? void 0 : t[0]) ? void 0 : i.meta) ? void 0 : r[1]) ? void 0 : s[0].data) && 1 == nv(n[1][0].meta[1][0].data) && n[1][0];
      if (a || o.forEach(function(e) {
          n[e].forEach(function(e) {
            if (1 == nv(e.meta[1][0].data) >>> 0) {
              if (a) throw new Error("Document has multiple roots");
              a = e
            }
          })
        }), !a) throw new Error("Cannot find Document root");
      return Av(n, a)
    }

    function Nv(e, t, i) {
      var r, s, n, o;
      if (!(null == (r = e[6]) ? void 0 : r[0]) || !(null == (s = e[7]) ? void 0 : s[0])) throw "Mutation only works on post-BNC storages!";
      if ((null == (o = null == (n = e[8]) ? void 0 : n[0]) ? void 0 : o.data) && nv(e[8][0].data) > 0 || !1) throw "Math only works with normal offsets";
      for (var a = 0, l = QA(e[7][0].data), c = 0, h = [], u = QA(e[4][0].data), d = 0, p = [], E = 0; E < t.length; ++E)
        if (null != t[E]) {
          var g, f;
          switch (l.setUint16(2 * E, c, !0), u.setUint16(2 * E, d, !0), typeof t[E]) {
            case "string":
              g = gv({
                t: "s",
                v: t[E]
              }, i), f = fv({
                t: "s",
                v: t[E]
              }, i);
              break;
            case "number":
              g = gv({
                t: "n",
                v: t[E]
              }, i), f = fv({
                t: "n",
                v: t[E]
              }, i);
              break;
            case "boolean":
              g = gv({
                t: "b",
                v: t[E]
              }, i), f = fv({
                t: "b",
                v: t[E]
              }, i);
              break;
            default:
              throw new Error("Unsupported value " + t[E])
          }
          h.push(g), c += g.length, p.push(f), d += f.length, ++a
        } else l.setUint16(2 * E, 65535, !0), u.setUint16(2 * E, 65535);
      for (e[2][0].data = sv(a); E < e[7][0].data.length / 2; ++E) l.setUint16(2 * E, 65535, !0), u.setUint16(2 * E, 65535, !0);
      return e[6][0].data = tv(h), e[3][0].data = tv(p), a
    }

    function Iv(e) {
      return function(t) {
        for (var i = 0; i != e.length; ++i) {
          var r = e[i];
          void 0 === t[r[0]] && (t[r[0]] = r[1]), "n" === r[2] && (t[r[0]] = Number(t[r[0]]))
        }
      }
    }

    function Ov(e) {
      Iv([
        ["cellNF", !1],
        ["cellHTML", !0],
        ["cellFormula", !0],
        ["cellStyles", !1],
        ["cellText", !0],
        ["cellDates", !1],
        ["sheetStubs", !1],
        ["sheetRows", 0, "n"],
        ["bookDeps", !1],
        ["bookSheets", !1],
        ["bookProps", !1],
        ["bookFiles", !1],
        ["bookVBA", !1],
        ["password", ""],
        ["WTF", !1]
      ])(e)
    }

    function Lv(e) {
      Iv([
        ["cellDates", !1],
        ["bookSST", !1],
        ["bookType", "xlsx"],
        ["compression", !1],
        ["WTF", !1]
      ])(e)
    }

    function _v(e, t, i, r, s, n, o, a, l, c, h, u) {
      try {
        n[r] = Sf(yp(e, i, !0), t);
        var d, p = _p(e, t);
        switch (a) {
          case "sheet":
            d = kR(p, t, s, l, n[r], c, h, u);
            break;
          case "chart":
            if (!(d = BR(p, t, s, l, n[r], c)) || !d["!drawel"]) break;
            var E = Fp(d["!drawel"].Target, t),
              g = Cf(E),
              f = function(e, t) {
                if (!e) return "??";
                var i = (e.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
                return t["!id"][i].Target
              }(yp(e, E, !0), Sf(yp(e, g, !0), E)),
              T = Fp(f, E),
              m = Cf(T);
            d = RR(yp(e, T, !0), 0, 0, Sf(yp(e, m, !0), T), 0, d);
            break;
          case "macro":
            S = t, n[r], S.slice(-4), d = {
              "!type": "macro"
            };
            break;
          case "dialog":
            d = function(e, t) {
              return t.slice(-4), {
                "!type": "dialog"
              }
            }(0, t, 0, 0, n[r]);
            break;
          default:
            throw new Error("Unrecognized sheet type " + a)
        }
        o[r] = d;
        var C = [];
        n && n[r] && ip(n[r]).forEach(function(i) {
          var s = "";
          if (n[r][i].Type == mf.CMNT) {
            s = Fp(n[r][i].Target, t);
            var o = YR(_p(e, s, !0), s, l);
            if (!o || !o.length) return;
            PC(d, o, !1)
          }
          n[r][i].Type == mf.TCMNT && (s = Fp(n[r][i].Target, t), C = C.concat(function(e, t) {
            var i = [],
              r = !1,
              s = {},
              n = 0;
            return e.replace(Hp, function(o, a) {
              var l = Vp(o);
              switch (Wp(l[0])) {
                case "<?xml":
                case "<ThreadedComments":
                case "</ThreadedComments>":
                case "<extLst":
                case "<extLst>":
                case "</extLst>":
                case "<extLst/>":
                  break;
                case "<threadedComment":
                  s = {
                    author: l.personId,
                    guid: l.id,
                    ref: l.ref,
                    T: 1
                  };
                  break;
                case "</threadedComment>":
                  null != s.t && i.push(s);
                  break;
                case "<text>":
                case "<text":
                  n = a + o.length;
                  break;
                case "</text>":
                  s.t = e.slice(n, a).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                  break;
                case "<mentions":
                case "<mentions>":
                case "<ext":
                  r = !0;
                  break;
                case "</mentions>":
                case "</ext>":
                  r = !1;
                  break;
                default:
                  if (!r && t.WTF) throw new Error("unrecognized " + l[0] + " in threaded comments")
              }
              return o
            }), i
          }(_p(e, s, !0), l)))
        }), C && C.length && PC(d, C, !0, l.people || [])
      } catch (e) {
        if (l.WTF) throw e
      }
      var S
    }

    function yv(e) {
      return "/" == e.charAt(0) ? e.slice(1) : e
    }

    function wv(e, t) {
      if (Xd(), Ov(t = t || {}), Op(e, "META-INF/manifest.xml")) return zA(e, t);
      if (Op(e, "objectdata.xml")) return zA(e, t);
      if (Op(e, "Index/Document.iwa")) {
        if ("undefined" == typeof Uint8Array) throw new Error("NUMBERS file parsing requires Uint8Array support");
        if (void 0 !== vv) {
          if (e.FileIndex) return vv(e);
          var i = qd.utils.cfb_new();
          return Dp(e).forEach(function(t) {
            Pp(i, t, wp(e, t))
          }), vv(i)
        }
        throw new Error("Unsupported NUMBERS file")
      }
      if (!Op(e, "[Content_Types].xml")) {
        if (Op(e, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
        if (Op(e, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
        throw new Error("Unsupported ZIP file")
      }
      var r, s, n = Dp(e),
        o = function(e) {
          var t = {
            workbooks: [],
            sheets: [],
            charts: [],
            dialogs: [],
            macros: [],
            rels: [],
            strs: [],
            comments: [],
            threadedcomments: [],
            links: [],
            coreprops: [],
            extprops: [],
            custprops: [],
            themes: [],
            styles: [],
            calcchains: [],
            vba: [],
            drawings: [],
            metadata: [],
            people: [],
            TODO: [],
            xmlns: ""
          };
          if (!e || !e.match) return t;
          var i = {};
          if ((e.match(Hp) || []).forEach(function(e) {
              var r = Vp(e);
              switch (r[0].replace(kp, "<")) {
                case "<?xml":
                  break;
                case "<Types":
                  t.xmlns = r["xmlns" + (r[0].match(/<(\w+):/) || ["", ""])[1]];
                  break;
                case "<Default":
                  i[r.Extension] = r.ContentType;
                  break;
                case "<Override":
                  void 0 !== t[gf[r.ContentType]] && t[gf[r.ContentType]].push(r.PartName)
              }
            }), t.xmlns !== SE.CT) throw new Error("Unknown Namespace: " + t.xmlns);
          return t.calcchain = t.calcchains.length > 0 ? t.calcchains[0] : "", t.sst = t.strs.length > 0 ? t.strs[0] : "", t.style = t.styles.length > 0 ? t.styles[0] : "", t.defaults = i, delete t.calcchains, t
        }(yp(e, "[Content_Types].xml")),
        a = !1;
      if (0 === o.workbooks.length && _p(e, s = "xl/workbook.xml", !0) && o.workbooks.push(s), 0 === o.workbooks.length) {
        if (!_p(e, s = "xl/workbook.bin", !0)) throw new Error("Could not find workbook");
        o.workbooks.push(s), a = !0
      }
      "bin" == o.workbooks[0].slice(-3) && (a = !0);
      var l = {},
        c = {};
      if (!t.bookSheets && !t.bookProps) {
        if (bS = [], o.sst) try {
          bS = WR(_p(e, yv(o.sst)), o.sst, t)
        } catch (e) {
          if (t.WTF) throw e
        }
        t.cellStyles && o.themes.length && (l = function(e, t, i) {
          return vC(e, i)
        }(yp(e, o.themes[0].replace(/^\//, ""), !0) || "", o.themes[0], t)), o.style && (c = VR(_p(e, yv(o.style)), o.style, l, t))
      }
      o.links.map(function(i) {
        try {
          Sf(yp(e, Cf(yv(i))), i);
          return XR(_p(e, yv(i)), 0, i, t)
        } catch (e) {}
      });
      var h = HR(_p(e, yv(o.workbooks[0])), o.workbooks[0], t),
        u = {},
        d = "";
      o.coreprops.length && ((d = _p(e, yv(o.coreprops[0]), !0)) && (u = yf(d)), 0 !== o.extprops.length && (d = _p(e, yv(o.extprops[0]), !0)) && function(e, t, i) {
        var r = {};
        t || (t = {}), e = nE(e), Pf.forEach(function(i) {
          var s = (e.match(aE(i[0])) || [])[1];
          switch (i[2]) {
            case "string":
              s && (t[i[1]] = Xp(s));
              break;
            case "bool":
              t[i[1]] = "true" === s;
              break;
            case "raw":
              var n = e.match(new RegExp("<" + i[0] + "[^>]*>([\\s\\S]*?)</" + i[0] + ">"));
              n && n.length > 0 && (r[i[1]] = n[1])
          }
        }), r.HeadingPairs && r.TitlesOfParts && Mf(r.HeadingPairs, r.TitlesOfParts, t, i)
      }(d, u, t));
      var p = {};
      t.bookSheets && !t.bookProps || 0 !== o.custprops.length && (d = yp(e, yv(o.custprops[0]), !0)) && (p = function(e, t) {
        var i = {},
          r = "",
          s = e.match(xf);
        if (s)
          for (var n = 0; n != s.length; ++n) {
            var o = s[n],
              a = Vp(o);
            switch (a[0]) {
              case "<?xml":
              case "<Properties":
                break;
              case "<property":
                r = Xp(a.name);
                break;
              case "</property>":
                r = null;
                break;
              default:
                if (0 === o.indexOf("<vt:")) {
                  var l = o.split(">"),
                    c = l[0].slice(4),
                    h = l[1];
                  switch (c) {
                    case "lpstr":
                    case "bstr":
                    case "lpwstr":
                    case "cy":
                    case "error":
                      i[r] = Xp(h);
                      break;
                    case "bool":
                      i[r] = eE(h);
                      break;
                    case "i1":
                    case "i2":
                    case "i4":
                    case "i8":
                    case "int":
                    case "uint":
                      i[r] = parseInt(h, 10);
                      break;
                    case "r4":
                    case "r8":
                    case "decimal":
                      i[r] = parseFloat(h);
                      break;
                    case "filetime":
                    case "date":
                      i[r] = fp(h);
                      break;
                    default:
                      if ("/" == c.slice(-1)) break;
                      t.WTF && "undefined" != typeof console && console.warn("Unexpected", o, c, l)
                  }
                } else if ("</" === o.slice(0, 2));
                else if (t.WTF) throw new Error(o)
            }
          }
        return i
      }(d, t));
      var E = {};
      if ((t.bookSheets || t.bookProps) && (h.Sheets ? r = h.Sheets.map(function(e) {
          return e.name
        }) : u.Worksheets && u.SheetNames.length > 0 && (r = u.SheetNames), t.bookProps && (E.Props = u, E.Custprops = p), t.bookSheets && void 0 !== r && (E.SheetNames = r), t.bookSheets ? E.SheetNames : t.bookProps)) return E;
      r = {};
      var g = {};
      t.bookDeps && o.calcchain && (g = KR(_p(e, yv(o.calcchain)), o.calcchain));
      var f, T, m = 0,
        C = {},
        S = h.Sheets;
      u.Worksheets = S.length, u.SheetNames = [];
      for (var R = 0; R != S.length; ++R) u.SheetNames[R] = S[R].name;
      var A = a ? "bin" : "xml",
        v = o.workbooks[0].lastIndexOf("/"),
        N = (o.workbooks[0].slice(0, v + 1) + "_rels/" + o.workbooks[0].slice(v + 1) + ".rels").replace(/^\//, "");
      Op(e, N) || (N = "xl/_rels/workbook." + A + ".rels");
      var I = Sf(yp(e, N, !0), N.replace(/_rels.*/, "s5s"));
      (o.metadata || []).length >= 1 && (t.xlmeta = zR(_p(e, yv(o.metadata[0])), o.metadata[0], t)), (o.people || []).length >= 1 && (t.people = function(e, t) {
        var i = [],
          r = !1;
        return e.replace(Hp, function(e) {
          var s = Vp(e);
          switch (Wp(s[0])) {
            case "<?xml":
            case "<personList":
            case "</personList>":
            case "</person>":
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<person":
              i.push({
                name: s.displayname,
                id: s.id
              });
              break;
            case "<ext":
              r = !0;
              break;
            case "</ext>":
              r = !1;
              break;
            default:
              if (!r && t.WTF) throw new Error("unrecognized " + s[0] + " in threaded comments")
          }
          return e
        }), i
      }(_p(e, yv(o.people[0])), t)), I && (I = function(e, t) {
        if (!e) return 0;
        try {
          e = t.map(function(t) {
            return t.id || (t.id = t.strRelID), [t.name, e["!id"][t.id].Target, (i = e["!id"][t.id].Type, mf.WS.indexOf(i) > -1 ? "sheet" : mf.CS && i == mf.CS ? "chart" : mf.DS && i == mf.DS ? "dialog" : mf.MS && i == mf.MS ? "macro" : i && i.length ? i : "sheet")];
            var i
          })
        } catch (e) {
          return null
        }
        return e && 0 !== e.length ? e : null
      }(I, h.Sheets));
      var O = _p(e, "xl/worksheets/sheet.xml", !0) ? 1 : 0;
      e: for (m = 0; m != u.Worksheets; ++m) {
        var L = "sheet";
        if (I && I[m] ? (f = "xl/" + I[m][1].replace(/[\/]?xl\//, ""), Op(e, f) || (f = I[m][1]), Op(e, f) || (f = N.replace(/_rels\/.*$/, "") + I[m][1]), L = I[m][2]) : f = (f = "xl/worksheets/sheet" + (m + 1 - O) + "." + A).replace(/sheet0\./, "sheet."), T = f.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels"), t && null != t.sheets) switch (typeof t.sheets) {
          case "number":
            if (m != t.sheets) continue e;
            break;
          case "string":
            if (u.SheetNames[m].toLowerCase() != t.sheets.toLowerCase()) continue e;
            break;
          default:
            if (Array.isArray && Array.isArray(t.sheets)) {
              for (var _ = !1, y = 0; y != t.sheets.length; ++y) "number" == typeof t.sheets[y] && t.sheets[y] == m && (_ = 1), "string" == typeof t.sheets[y] && t.sheets[y].toLowerCase() == u.SheetNames[m].toLowerCase() && (_ = 1);
              if (!_) continue e
            }
        }
        _v(e, f, T, u.SheetNames[m], m, C, r, L, t, h, l, c)
      }
      return E = {
        Directory: o,
        Workbook: h,
        Props: u,
        Custprops: p,
        Deps: g,
        Sheets: r,
        SheetNames: u.SheetNames,
        Strings: bS,
        Styles: c,
        Themes: l,
        SSF: mp(ud)
      }, t && t.bookFiles && (e.files ? (E.keys = n, E.files = e.files) : (E.keys = [], E.files = {}, e.FullPaths.forEach(function(t, i) {
        t = t.replace(/^Root Entry[\/]/, ""), E.keys.push(t), E.files[t] = e.FileIndex[i]
      }))), t && t.bookVBA && (o.vba.length > 0 ? E.vbaraw = _p(e, yv(o.vba[0]), !0) : o.defaults && o.defaults.bin === GC && (E.vbaraw = _p(e, "xl/vbaProject.bin", !0))), E
    }

    function Dv(e, t) {
      var i, r, s = t || {},
        n = "Workbook",
        o = qd.find(e, n);
      try {
        if (n = "/!DataSpaces/Version", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
        if (i = o.content, (r = {}).id = i.read_shift(0, "lpp4"), r.R = vm(i, 4), r.U = vm(i, 4), r.W = vm(i, 4), n = "/!DataSpaces/DataSpaceMap", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
        var a = function(e) {
          var t = [];
          e.l += 4;
          for (var i = e.read_shift(4); i-- > 0;) t.push(Nm(e));
          return t
        }(o.content);
        if (1 !== a.length || 1 !== a[0].comps.length || 0 !== a[0].comps[0].t || "StrongEncryptionDataSpace" !== a[0].name || "EncryptedPackage" !== a[0].comps[0].v) throw new Error("ECMA-376 Encrypted file bad " + n);
        if (n = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
        var l = function(e) {
          var t = [];
          e.l += 4;
          for (var i = e.read_shift(4); i-- > 0;) t.push(e.read_shift(0, "lpp4"));
          return t
        }(o.content);
        if (1 != l.length || "StrongEncryptionTransform" != l[0]) throw new Error("ECMA-376 Encrypted file bad " + n);
        if (n = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
        Im(o.content)
      } catch (e) {}
      if (n = "/EncryptionInfo", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
      var c = function(e) {
        var t = vm(e);
        switch (t.Minor) {
          case 2:
            return [t.Minor, _m(e)];
          case 3:
            return [t.Minor, ym()];
          case 4:
            return [t.Minor, wm(e)]
        }
        throw new Error("ECMA-376 Encrypted file unrecognized Version: " + t.Minor)
      }(o.content);
      if (n = "/EncryptedPackage", !(o = qd.find(e, n)) || !o.content) throw new Error("ECMA-376 Encrypted file missing " + n);
      if (4 == c[0] && "undefined" != typeof decrypt_agile) return decrypt_agile(c[1], o.content, s.password || "", s);
      if (2 == c[0] && "undefined" != typeof decrypt_std76) return decrypt_std76(c[1], o.content, s.password || "", s);
      throw new Error("File is password-protected")
    }

    function Pv(e, t) {
      return "ods" == t.bookType ? qA(e, t) : "numbers" == t.bookType ? function(e, t) {
        if (!t || !t.numbers) throw new Error("Must pass a `numbers` option -- check the README");
        var i = e.Sheets[e.SheetNames[0]];
        e.SheetNames.length > 1 && console.error("The Numbers writer currently writes only the first table");
        var r = Cg(i["!ref"]);
        r.s.r = r.s.c = 0;
        var s = !1;
        r.e.c > 9 && (s = !0, r.e.c = 9), r.e.r > 49 && (s = !0, r.e.r = 49), s && console.error("The Numbers writer is currently limited to ".concat(Sg(r)));
        var n = Jv(i, {
            range: r,
            header: 1
          }),
          o = ["~Sh33tJ5~"];
        n.forEach(function(e) {
          return e.forEach(function(e) {
            "string" == typeof e && o.push(e)
          })
        });
        var a = {},
          l = [],
          c = qd.read(t.numbers, {
            type: "base64"
          });
        c.FileIndex.map(function(e, t) {
          return [e, c.FullPaths[t]]
        }).forEach(function(e) {
          var t = e[0],
            i = e[1];
          2 == t.type && t.name.match(/\.iwa/) && cv(dv(t.content)).forEach(function(e) {
            l.push(e.id), a[e.id] = {
              deps: [],
              location: i,
              type: nv(e.messages[0].meta[1][0].data)
            }
          })
        }), l.sort(function(e, t) {
          return e - t
        });
        var h = l.filter(function(e) {
          return e > 1
        }).map(function(e) {
          return [e, sv(e)]
        });
        c.FileIndex.map(function(e, t) {
          return [e, c.FullPaths[t]]
        }).forEach(function(e) {
          var t = e[0];
          e[1], t.name.match(/\.iwa/) && cv(dv(t.content)).forEach(function(e) {
            e.messages.forEach(function(t) {
              h.forEach(function(t) {
                e.messages.some(function(e) {
                  return 11006 != nv(e.meta[1][0].data) && function(e, t) {
                    e: for (var i = 0; i <= e.length - t.length; ++i) {
                      for (var r = 0; r < t.length; ++r)
                        if (e[i + r] != t[r]) continue e;
                      return !0
                    }
                    return !1
                  }(e.data, t[1])
                }) && a[t[0]].deps.push(e.id)
              })
            })
          })
        });
        for (var u, d = qd.find(c, a[1].location), p = cv(dv(d.content)), E = 0; E < p.length; ++E) {
          var g = p[E];
          1 == g.id && (u = g)
        }
        var f = mv(ov(u.messages[0].data)[1][0].data);
        for (p = cv(dv((d = qd.find(c, a[f].location)).content)), E = 0; E < p.length; ++E)(g = p[E]).id == f && (u = g);
        for (f = mv(ov(u.messages[0].data)[2][0].data), p = cv(dv((d = qd.find(c, a[f].location)).content)), E = 0; E < p.length; ++E)(g = p[E]).id == f && (u = g);
        for (f = mv(ov(u.messages[0].data)[2][0].data), p = cv(dv((d = qd.find(c, a[f].location)).content)), E = 0; E < p.length; ++E)(g = p[E]).id == f && (u = g);
        var T = ov(u.messages[0].data);
        T[6][0].data = sv(r.e.r + 1), T[7][0].data = sv(r.e.c + 1);
        for (var m = mv(T[46][0].data), C = qd.find(c, a[m].location), S = cv(dv(C.content)), R = 0; R < S.length && S[R].id != m; ++R);
        if (S[R].id != m) throw "Bad ColumnRowUIDMapArchive";
        var A = ov(S[R].messages[0].data);
        A[1] = [], A[2] = [], A[3] = [];
        for (var v = 0; v <= r.e.c; ++v) {
          var N = [];
          N[1] = N[2] = [{
            type: 0,
            data: sv(v + 420690)
          }], A[1].push({
            type: 2,
            data: av(N)
          }), A[2].push({
            type: 0,
            data: sv(v)
          }), A[3].push({
            type: 0,
            data: sv(v)
          })
        }
        A[4] = [], A[5] = [], A[6] = [];
        for (var I = 0; I <= r.e.r; ++I)(N = [])[1] = N[2] = [{
          type: 0,
          data: sv(I + 726270)
        }], A[4].push({
          type: 2,
          data: av(N)
        }), A[5].push({
          type: 0,
          data: sv(I)
        }), A[6].push({
          type: 0,
          data: sv(I)
        });
        S[R].messages[0].data = av(A), C.content = pv(hv(S)), C.size = C.content.length, delete T[46];
        var O = ov(T[4][0].data);
        O[7][0].data = sv(r.e.r + 1);
        var L = mv(ov(O[1][0].data)[2][0].data);
        if ((S = cv(dv((C = qd.find(c, a[L].location)).content)))[0].id != L) throw "Bad HeaderStorageBucket";
        var _ = ov(S[0].messages[0].data);
        for (I = 0; I < n.length; ++I) {
          var y = ov(_[2][0].data);
          y[1][0].data = sv(I), y[4][0].data = sv(n[I].length), _[2][I] = {
            type: _[2][0].type,
            data: av(y)
          }
        }
        S[0].messages[0].data = av(_), C.content = pv(hv(S)), C.size = C.content.length;
        var w = mv(O[2][0].data);
        if ((S = cv(dv((C = qd.find(c, a[w].location)).content)))[0].id != w) throw "Bad HeaderStorageBucket";
        for (_ = ov(S[0].messages[0].data), v = 0; v <= r.e.c; ++v)(y = ov(_[2][0].data))[1][0].data = sv(v), y[4][0].data = sv(r.e.r + 1), _[2][v] = {
          type: _[2][0].type,
          data: av(y)
        };
        S[0].messages[0].data = av(_), C.content = pv(hv(S)), C.size = C.content.length;
        var D = mv(O[4][0].data);
        ! function() {
          for (var e, t = qd.find(c, a[D].location), i = cv(dv(t.content)), r = 0; r < i.length; ++r) {
            var s = i[r];
            s.id == D && (e = s)
          }
          var n = ov(e.messages[0].data);
          n[3] = [];
          var l = [];
          o.forEach(function(e, t) {
            l[1] = [{
              type: 0,
              data: sv(t)
            }], l[2] = [{
              type: 0,
              data: sv(1)
            }], l[3] = [{
              type: 2,
              data: ev(e)
            }], n[3].push({
              type: 2,
              data: av(l)
            })
          }), e.messages[0].data = av(n);
          var h = pv(hv(i));
          t.content = h, t.size = t.content.length
        }();
        var P = ov(O[3][0].data),
          b = P[1][0];
        delete P[2];
        var M = ov(b.data),
          F = mv(M[2][0].data);
        ! function() {
          for (var e, t = qd.find(c, a[F].location), i = cv(dv(t.content)), s = 0; s < i.length; ++s) {
            var l = i[s];
            l.id == F && (e = l)
          }
          var h = ov(e.messages[0].data);
          delete h[6], delete P[7];
          var u = new Uint8Array(h[5][0].data);
          h[5] = [];
          for (var d = 0, p = 0; p <= r.e.r; ++p) {
            var E = ov(u);
            d += Nv(E, n[p], o), E[1][0].data = sv(p), h[5].push({
              data: av(E),
              type: 2
            })
          }
          h[1] = [{
            type: 0,
            data: sv(r.e.c + 1)
          }], h[2] = [{
            type: 0,
            data: sv(r.e.r + 1)
          }], h[3] = [{
            type: 0,
            data: sv(d)
          }], h[4] = [{
            type: 0,
            data: sv(r.e.r + 1)
          }], e.messages[0].data = av(h);
          var g = pv(hv(i));
          t.content = g, t.size = t.content.length
        }(), b.data = av(M), O[3][0].data = av(P), T[4][0].data = av(O), u.messages[0].data = av(T);
        var x = pv(hv(p));
        return d.content = x, d.size = d.content.length, c
      }(e, t) : "xlsb" == t.bookType ? function(e, t) {
        wC = 1024, e && !e.SSF && (e.SSF = mp(ud));
        e && e.SSF && (Xd(), Kd(e.SSF), t.revssf = np(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF);
        t.rels = {}, t.wbrels = {}, t.Strings = [], t.Strings.Count = 0, t.Strings.Unique = 0, FS ? t.revStrings = new Map : (t.revStrings = {}, t.revStrings.foo = [], delete t.revStrings.foo);
        var i = "xlsb" == t.bookType ? "bin" : "xml",
          r = UC.indexOf(t.bookType) > -1,
          s = {
            workbooks: [],
            sheets: [],
            charts: [],
            dialogs: [],
            macros: [],
            rels: [],
            strs: [],
            comments: [],
            threadedcomments: [],
            links: [],
            coreprops: [],
            extprops: [],
            custprops: [],
            themes: [],
            styles: [],
            calcchains: [],
            vba: [],
            drawings: [],
            metadata: [],
            people: [],
            TODO: [],
            xmlns: ""
          };
        Lv(t = t || {});
        var n = bp(),
          o = "",
          a = 0;
        t.cellXfs = [], HS(t.cellXfs, {}, {
          revssf: {
            General: 0
          }
        }), e.Props || (e.Props = {});
        if (Pp(n, o = "docProps/core.xml", Df(e.Props, t)), s.coreprops.push(o), Af(t.rels, 2, o, mf.CORE_PROPS), o = "docProps/app.xml", e.Props && e.Props.SheetNames);
        else if (e.Workbook && e.Workbook.Sheets) {
          for (var l = [], c = 0; c < e.SheetNames.length; ++c) 2 != (e.Workbook.Sheets[c] || {}).Hidden && l.push(e.SheetNames[c]);
          e.Props.SheetNames = l
        } else e.Props.SheetNames = e.SheetNames;
        e.Props.Worksheets = e.Props.SheetNames.length, Pp(n, o, Ff(e.Props)), s.extprops.push(o), Af(t.rels, 3, o, mf.EXT_PROPS), e.Custprops !== e.Props && ip(e.Custprops || {}).length > 0 && (Pp(n, o = "docProps/custom.xml", Gf(e.Custprops)), s.custprops.push(o), Af(t.rels, 4, o, mf.CUST_PROPS));
        for (a = 1; a <= e.SheetNames.length; ++a) {
          var h = {
              "!id": {}
            },
            u = e.Sheets[e.SheetNames[a - 1]];
          (u || {})["!type"];
          if (Pp(n, o = "xl/worksheets/sheet" + a + "." + i, $R(a - 1, o, t, e, h)), s.sheets.push(o), Af(t.wbrels, -1, "worksheets/sheet" + a + "." + i, mf.WS[0]), u) {
            var d = u["!comments"],
              p = !1,
              E = "";
            d && d.length > 0 && (Pp(n, E = "xl/comments" + a + "." + i, jR(d, E, t)), s.comments.push(E), Af(h, -1, "../comments" + a + "." + i, mf.CMNT), p = !0), u["!legacy"] && p && Pp(n, "xl/drawings/vmlDrawing" + a + ".vml", DC(a, u["!comments"])), delete u["!comments"], delete u["!legacy"]
          }
          h["!id"].rId1 && Pp(n, Cf(o), Rf(h))
        }
        null != t.Strings && t.Strings.length > 0 && (Pp(n, o = "xl/sharedStrings." + i, function(e, t, i) {
          return (".bin" === t.slice(-4) ? Rm : Cm)(e, i)
        }(t.Strings, o, t)), s.strs.push(o), Af(t.wbrels, -1, "sharedStrings." + i, mf.SST));
        Pp(n, o = "xl/workbook." + i, function(e, t, i) {
          return (".bin" === t.slice(-4) ? UR : MR)(e, i)
        }(e, o, t)), s.workbooks.push(o), Af(t.rels, 1, o, mf.WB), Pp(n, o = "xl/theme/theme1.xml", NC(e.Themes, t)), s.themes.push(o), Af(t.wbrels, -1, "theme/theme1.xml", mf.THEME), Pp(n, o = "xl/styles." + i, function(e, t, i) {
          return (".bin" === t.slice(-4) ? EC : tC)(e, i)
        }(e, o, t)), s.styles.push(o), Af(t.wbrels, -1, "styles." + i, mf.STY), e.vbaraw && r && (Pp(n, o = "xl/vbaProject.bin", e.vbaraw), s.vba.push(o), Af(t.wbrels, -1, "vbaProject.bin", mf.VBA));
        return Pp(n, o = "xl/metadata." + i, function(e) {
          return (".bin" === e.slice(-4) ? _C : yC)()
        }(o)), s.metadata.push(o), Af(t.wbrels, -1, "metadata." + i, mf.XLMETA), Pp(n, "[Content_Types].xml", Tf(s, t)), Pp(n, "_rels/.rels", Rf(t.rels)), Pp(n, "xl/_rels/workbook." + i + ".rels", Rf(t.wbrels)), delete t.revssf, delete t.ssf, n
      }(e, t) : bv(e, t)
    }

    function bv(e, t) {
      wC = 1024, e && !e.SSF && (e.SSF = mp(ud)), e && e.SSF && (Xd(), Kd(e.SSF), t.revssf = np(e.SSF), t.revssf[e.SSF[65535]] = 0, t.ssf = e.SSF), t.rels = {}, t.wbrels = {}, t.Strings = [], t.Strings.Count = 0, t.Strings.Unique = 0, FS ? t.revStrings = new Map : (t.revStrings = {}, t.revStrings.foo = [], delete t.revStrings.foo);
      var i = "xml",
        r = UC.indexOf(t.bookType) > -1,
        s = {
          workbooks: [],
          sheets: [],
          charts: [],
          dialogs: [],
          macros: [],
          rels: [],
          strs: [],
          comments: [],
          threadedcomments: [],
          links: [],
          coreprops: [],
          extprops: [],
          custprops: [],
          themes: [],
          styles: [],
          calcchains: [],
          vba: [],
          drawings: [],
          metadata: [],
          people: [],
          TODO: [],
          xmlns: ""
        };
      Lv(t = t || {});
      var n = bp(),
        o = "",
        a = 0;
      if (t.cellXfs = [], HS(t.cellXfs, {}, {
          revssf: {
            General: 0
          }
        }), e.Props || (e.Props = {}), Pp(n, o = "docProps/core.xml", Df(e.Props, t)), s.coreprops.push(o), Af(t.rels, 2, o, mf.CORE_PROPS), o = "docProps/app.xml", e.Props && e.Props.SheetNames);
      else if (e.Workbook && e.Workbook.Sheets) {
        for (var l = [], c = 0; c < e.SheetNames.length; ++c) 2 != (e.Workbook.Sheets[c] || {}).Hidden && l.push(e.SheetNames[c]);
        e.Props.SheetNames = l
      } else e.Props.SheetNames = e.SheetNames;
      e.Props.Worksheets = e.Props.SheetNames.length, Pp(n, o, Ff(e.Props)), s.extprops.push(o), Af(t.rels, 3, o, mf.EXT_PROPS), e.Custprops !== e.Props && ip(e.Custprops || {}).length > 0 && (Pp(n, o = "docProps/custom.xml", Gf(e.Custprops)), s.custprops.push(o), Af(t.rels, 4, o, mf.CUST_PROPS));
      var h = ["SheetJ5"];
      for (t.tcid = 0, a = 1; a <= e.SheetNames.length; ++a) {
        var u = {
            "!id": {}
          },
          d = e.Sheets[e.SheetNames[a - 1]];
        (d || {})["!type"];
        if (Pp(n, o = "xl/worksheets/sheet" + a + "." + i, nR(a - 1, t, e, u)), s.sheets.push(o), Af(t.wbrels, -1, "worksheets/sheet" + a + "." + i, mf.WS[0]), d) {
          var p = d["!comments"],
            E = !1,
            g = "";
          if (p && p.length > 0) {
            var f = !1;
            p.forEach(function(e) {
              e[1].forEach(function(e) {
                1 == e.T && (f = !0)
              })
            }), f && (Pp(n, g = "xl/threadedComments/threadedComment" + a + "." + i, MC(p, h, t)), s.threadedcomments.push(g), Af(u, -1, "../threadedComments/threadedComment" + a + "." + i, mf.TCMNT)), Pp(n, g = "xl/comments" + a + "." + i, bC(p)), s.comments.push(g), Af(u, -1, "../comments" + a + "." + i, mf.CMNT), E = !0
          }
          d["!legacy"] && E && Pp(n, "xl/drawings/vmlDrawing" + a + ".vml", DC(a, d["!comments"])), delete d["!comments"], delete d["!legacy"]
        }
        u["!id"].rId1 && Pp(n, Cf(o), Rf(u))
      }
      return null != t.Strings && t.Strings.length > 0 && (Pp(n, o = "xl/sharedStrings." + i, Cm(t.Strings, t)), s.strs.push(o), Af(t.wbrels, -1, "sharedStrings." + i, mf.SST)), Pp(n, o = "xl/workbook." + i, MR(e)), s.workbooks.push(o), Af(t.rels, 1, o, mf.WB), Pp(n, o = "xl/theme/theme1.xml", NC(e.Themes, t)), s.themes.push(o), Af(t.wbrels, -1, "theme/theme1.xml", mf.THEME), Pp(n, o = "xl/styles." + i, tC(e, t)), s.styles.push(o), Af(t.wbrels, -1, "styles." + i, mf.STY), e.vbaraw && r && (Pp(n, o = "xl/vbaProject.bin", e.vbaraw), s.vba.push(o), Af(t.wbrels, -1, "vbaProject.bin", mf.VBA)), Pp(n, o = "xl/metadata." + i, yC()), s.metadata.push(o), Af(t.wbrels, -1, "metadata." + i, mf.XLMETA), h.length > 1 && (Pp(n, o = "xl/persons/person.xml", function(e) {
        var t = [xp, fE("personList", null, {
          xmlns: SE.TCMNT,
          "xmlns:x": RE[0]
        }).replace(/[\/]>/, ">")];
        return e.forEach(function(e, i) {
          t.push(fE("person", null, {
            displayName: e,
            id: "{54EE7950-7262-4200-6969-" + ("000000000000" + i).slice(-12) + "}",
            userId: e,
            providerId: "None"
          }))
        }), t.push("</personList>"), t.join("")
      }(h)), s.people.push(o), Af(t.wbrels, -1, "persons/person.xml", mf.PEOPLE)), Pp(n, "[Content_Types].xml", Tf(s, t)), Pp(n, "_rels/.rels", Rf(t.rels)), Pp(n, "xl/_rels/workbook.xml.rels", Rf(t.wbrels)), delete t.revssf, delete t.ssf, n
    }

    function Mv(e, t) {
      var i = "";
      switch ((t || {}).type || "base64") {
        case "buffer":
        case "array":
          return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]];
        case "base64":
          i = Yu(e.slice(0, 12));
          break;
        case "binary":
          i = e;
          break;
        default:
          throw new Error("Unrecognized type " + (t && t.type || "undefined"))
      }
      return [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3), i.charCodeAt(4), i.charCodeAt(5), i.charCodeAt(6), i.charCodeAt(7)]
    }

    function Fv(e, t) {
      var i = 0;
      e: for (; i < e.length;) switch (e.charCodeAt(i)) {
        case 10:
        case 13:
        case 32:
          ++i;
          break;
        case 60:
          return aA(e.slice(i), t);
        default:
          break e
      }
      return am.to_workbook(e, t)
    }

    function xv(e, t, i, r) {
      return r ? (i.type = "string", am.to_workbook(e, i)) : am.to_workbook(t, i)
    }

    function Gv(e, t) {
      bu();
      var i = t || {};
      if ("undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer) return Gv(new Uint8Array(e), ((i = mp(i)).type = "array", i));
      "undefined" != typeof Uint8Array && e instanceof Uint8Array && !i.type && (i.type = "undefined" != typeof Deno ? "buffer" : "array");
      var r, s = e,
        n = !1;
      if (i.cellStyles && (i.cellNF = !0, i.sheetStubs = !0), MS = {}, i.dateNF && (MS.dateNF = i.dateNF), i.type || (i.type = Ku && Buffer.isBuffer(e) ? "buffer" : "base64"), "file" == i.type && (i.type = Ku ? "buffer" : "binary", s = function(e) {
          if (void 0 !== Qd) return Qd.readFileSync(e);
          if ("undefined" != typeof Deno) return Deno.readFileSync(e);
          if ("undefined" != typeof $ && "undefined" != typeof File && "undefined" != typeof Folder) try {
            var t = File(e);
            t.open("r"), t.encoding = "binary";
            var i = t.read();
            return t.close(), i
          } catch (e) {
            if (!e.message || !e.message.match(/onstruct/)) throw e
          }
          throw new Error("Cannot access file " + e)
        }(e), "undefined" == typeof Uint8Array || Ku || (i.type = "array")), "string" == i.type && (n = !0, i.type = "binary", i.codepage = 65001, s = function(e) {
          return e.match(/[^\x00-\x7F]/) ? oE(e) : e
        }(e)), "array" == i.type && "undefined" != typeof Uint8Array && e instanceof Uint8Array && "undefined" != typeof ArrayBuffer) {
        var o = new ArrayBuffer(3),
          a = new Uint8Array(o);
        if (a.foo = "bar", !a.foo) return (i = mp(i)).type = "array", Gv(Qu(s), i)
      }
      switch ((r = Mv(s, i))[0]) {
        case 208:
          if (207 === r[1] && 17 === r[2] && 224 === r[3] && 161 === r[4] && 177 === r[5] && 26 === r[6] && 225 === r[7]) return function(e, t) {
            return qd.find(e, "EncryptedPackage") ? Dv(e, t) : RA(e, t)
          }(qd.read(s, i), i);
          break;
        case 9:
          if (r[1] <= 8) return RA(s, i);
          break;
        case 60:
          return aA(s, i);
        case 73:
          if (73 === r[1] && 42 === r[2] && 0 === r[3]) throw new Error("TIFF Image File is not a spreadsheet");
          if (68 === r[1]) return function(e, t) {
            var i = t || {},
              r = !!i.WTF;
            i.WTF = !0;
            try {
              var s = sm.to_workbook(e, i);
              return i.WTF = r, s
            } catch (s) {
              if (i.WTF = r, !s.message.match(/SYLK bad record ID/) && r) throw s;
              return am.to_workbook(e, t)
            }
          }(s, i);
          break;
        case 84:
          if (65 === r[1] && 66 === r[2] && 76 === r[3]) return nm.to_workbook(s, i);
          break;
        case 80:
          return 75 === r[1] && r[2] < 9 && r[3] < 9 ? function(e, t) {
            var i = e,
              r = t || {};
            return r.type || (r.type = Ku && Buffer.isBuffer(e) ? "buffer" : "base64"), wv(Mp(i, r), r)
          }(s, i) : xv(e, s, i, n);
        case 239:
          return 60 === r[3] ? aA(s, i) : xv(e, s, i, n);
        case 255:
          if (254 === r[1]) return function(e, t) {
            var i = e;
            return "base64" == t.type && (i = Yu(i)), i = xu.utils.decode(1200, i.slice(2), "str"), t.type = "binary", Fv(i, t)
          }(s, i);
          if (0 === r[1] && 2 === r[2] && 0 === r[3]) return lm.to_workbook(s, i);
          break;
        case 0:
          if (0 === r[1]) {
            if (r[2] >= 2 && 0 === r[3]) return lm.to_workbook(s, i);
            if (0 === r[2] && (8 === r[3] || 9 === r[3])) return lm.to_workbook(s, i)
          }
          break;
        case 3:
        case 131:
        case 139:
        case 140:
          return rm.to_workbook(s, i);
        case 123:
          if (92 === r[1] && 114 === r[2] && 116 === r[3]) return Fm.to_workbook(s, i);
          break;
        case 10:
        case 13:
        case 32:
          return function(e, t) {
            var i = "",
              r = Mv(e, t);
            switch (t.type) {
              case "base64":
                i = Yu(e);
                break;
              case "binary":
                i = e;
                break;
              case "buffer":
                i = e.toString("binary");
                break;
              case "array":
                i = Tp(e);
                break;
              default:
                throw new Error("Unrecognized type " + t.type)
            }
            return 239 == r[0] && 187 == r[1] && 191 == r[2] && (i = nE(i)), t.type = "binary", Fv(i, t)
          }(s, i);
        case 137:
          if (80 === r[1] && 78 === r[2] && 71 === r[3]) throw new Error("PNG Image File is not a spreadsheet")
      }
      return im.indexOf(r[0]) > -1 && r[2] <= 12 && r[3] <= 31 ? rm.to_workbook(s, i) : xv(e, s, i, n)
    }

    function Uv(e, t) {
      var i = t || {};
      return i.type = "file", Gv(e, i)
    }

    function Hv(e, t) {
      switch (t.type) {
        case "base64":
        case "binary":
          break;
        case "buffer":
        case "array":
          t.type = "";
          break;
        case "file":
          return tp(t.file, qd.write(e, {
            type: Ku ? "buffer" : ""
          }));
        case "string":
          throw new Error("'string' output type invalid for '" + t.bookType + "' files");
        default:
          throw new Error("Unrecognized type " + t.type)
      }
      return qd.write(e, t)
    }

    function kv(e, t) {
      var i = {},
        r = Ku ? "nodebuffer" : "undefined" != typeof Uint8Array ? "array" : "string";
      if (t.compression && (i.compression = "DEFLATE"), t.password) i.type = r;
      else switch (t.type) {
        case "base64":
          i.type = "base64";
          break;
        case "binary":
          i.type = "string";
          break;
        case "string":
          throw new Error("'string' output type invalid for '" + t.bookType + "' files");
        case "buffer":
        case "file":
          i.type = r;
          break;
        default:
          throw new Error("Unrecognized type " + t.type)
      }
      var s = e.FullPaths ? qd.write(e, {
        fileType: "zip",
        type: {
          nodebuffer: "buffer",
          string: "binary"
        } [i.type] || i.type,
        compression: !!t.compression
      }) : e.generate(i);
      if ("undefined" != typeof Deno && "string" == typeof s) {
        if ("binary" == t.type || "base64" == t.type) return s;
        s = new Uint8Array(Ju(s))
      }
      return t.password && "undefined" != typeof encrypt_agile ? Hv(encrypt_agile(s, t.password), t) : "file" === t.type ? tp(t.file, s) : "string" == t.type ? nE(s) : s
    }

    function Bv(e, t, i) {
      i || (i = "");
      var r = i + e;
      switch (t.type) {
        case "base64":
          return Wu(oE(r));
        case "binary":
          return oE(r);
        case "string":
          return e;
        case "file":
          return tp(t.file, r, "utf8");
        case "buffer":
          return Ku ? Xu(r, "utf8") : "undefined" != typeof TextEncoder ? (new TextEncoder).encode(r) : Bv(r, {
            type: "binary"
          }).split("").map(function(e) {
            return e.charCodeAt(0)
          })
      }
      throw new Error("Unrecognized type " + t.type)
    }

    function Vv(e, t) {
      switch (t.type) {
        case "string":
        case "base64":
        case "binary":
          for (var i = "", r = 0; r < e.length; ++r) i += String.fromCharCode(e[r]);
          return "base64" == t.type ? Wu(i) : "string" == t.type ? nE(i) : i;
        case "file":
          return tp(t.file, e);
        case "buffer":
          return e;
        default:
          throw new Error("Unrecognized type " + t.type)
      }
    }

    function Wv(e, t) {
      bu(), PR(e);
      var i = mp(t || {});
      if (i.cellStyles && (i.cellNF = !0, i.sheetStubs = !0), "array" == i.type) {
        i.type = "binary";
        var r = Wv(e, i);
        return i.type = "array", Ju(r)
      }
      return function(e, t) {
        var i = mp(t || {});
        return kv(bv(e, i), i)
      }(e, i)
    }

    function Yv(e, t) {
      bu(), PR(e);
      var i = mp(t || {});
      if (i.cellStyles && (i.cellNF = !0, i.sheetStubs = !0), "array" == i.type) {
        i.type = "binary";
        var r = Yv(e, i);
        return i.type = "array", Ju(r)
      }
      var s = 0;
      if (i.sheet && (s = "number" == typeof i.sheet ? i.sheet : e.SheetNames.indexOf(i.sheet), !e.SheetNames[s])) throw new Error("Sheet not found: " + i.sheet + " : " + typeof i.sheet);
      switch (i.bookType || "xlsb") {
        case "xml":
        case "xlml":
          return Bv(pA(e, i), i);
        case "slk":
        case "sylk":
          return Bv(sm.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "htm":
        case "html":
          return Bv(kA(e.Sheets[e.SheetNames[s]], i), i);
        case "txt":
          return function(e, t) {
            switch (t.type) {
              case "base64":
                return Wu(e);
              case "binary":
              case "string":
                return e;
              case "file":
                return tp(t.file, e, "binary");
              case "buffer":
                return Ku ? Xu(e, "binary") : e.split("").map(function(e) {
                  return e.charCodeAt(0)
                })
            }
            throw new Error("Unrecognized type " + t.type)
          }(eN(e.Sheets[e.SheetNames[s]], i), i);
        case "csv":
          return Bv(Zv(e.Sheets[e.SheetNames[s]], i), i, "\ufeff");
        case "dif":
          return Bv(nm.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "dbf":
          return Vv(rm.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "prn":
          return Bv(am.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "rtf":
          return Bv(Fm.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "eth":
          return Bv(om.from_sheet(e.Sheets[e.SheetNames[s]], i), i);
        case "fods":
          return Bv(qA(e, i), i);
        case "wk1":
          return Vv(lm.sheet_to_wk1(e.Sheets[e.SheetNames[s]], i), i);
        case "wk3":
          return Vv(lm.book_to_wk3(e, i), i);
        case "biff2":
          i.biff || (i.biff = 2);
        case "biff3":
          i.biff || (i.biff = 3);
        case "biff4":
          return i.biff || (i.biff = 4), Vv(MA(e, i), i);
        case "biff5":
          i.biff || (i.biff = 5);
        case "biff8":
        case "xla":
        case "xls":
          return i.biff || (i.biff = 8),
            function(e, t) {
              var i = t || {};
              return Hv(AA(e, i), i)
            }(e, i);
        case "xlsx":
        case "xlsm":
        case "xlam":
        case "xlsb":
        case "numbers":
        case "ods":
          return function(e, t) {
            var i = mp(t || {});
            return kv(Pv(e, i), i)
          }(e, i);
        default:
          throw new Error("Unrecognized bookType |" + i.bookType + "|")
      }
    }

    function Kv(e) {
      if (!e.bookType) {
        var t = e.file.slice(e.file.lastIndexOf(".")).toLowerCase();
        t.match(/^\.[a-z]+$/) && (e.bookType = t.slice(1)), e.bookType = {
          xls: "biff8",
          htm: "html",
          slk: "sylk",
          socialcalc: "eth",
          Sh33tJS: "WTF"
        } [e.bookType] || e.bookType
      }
    }

    function Xv(e, t, i) {
      var r = i || {};
      return r.type = "file", r.file = t, Kv(r), Yv(e, r)
    }

    function zv(e, t, i) {
      var r = i || {};
      return r.type = "file", r.file = t, Kv(r), Wv(e, r)
    }

    function $v(e, t, i, r) {
      var s = i || {};
      s.type = "file", s.file = e, Kv(s), s.type = "buffer";
      var n = r;
      return n instanceof Function || (n = i), Qd.writeFile(e, Yv(t, s), n)
    }

    function jv(e, t, i, r, s, n, o, a) {
      var l = Eg(i),
        c = a.defval,
        h = a.raw || !Object.prototype.hasOwnProperty.call(a, "raw"),
        u = !0,
        d = 1 === s ? [] : {};
      if (1 !== s)
        if (Object.defineProperty) try {
          Object.defineProperty(d, "__rowNum__", {
            value: i,
            enumerable: !1
          })
        } catch (e) {
          d.__rowNum__ = i
        } else d.__rowNum__ = i;
      if (!o || e[i])
        for (var p = t.s.c; p <= t.e.c; ++p) {
          var E = o ? e[i][p] : e[r[p] + l];
          if (void 0 !== E && void 0 !== E.t) {
            var g = E.v;
            switch (E.t) {
              case "z":
                if (null == g) break;
                continue;
              case "e":
                g = 0 == g ? null : void 0;
                break;
              case "s":
              case "d":
              case "b":
              case "n":
                break;
              default:
                throw new Error("unrecognized type " + E.t)
            }
            if (null != n[p]) {
              if (null == g)
                if ("e" == E.t && null === g) d[n[p]] = null;
                else if (void 0 !== c) d[n[p]] = c;
              else {
                if (!h || null !== g) continue;
                d[n[p]] = null
              } else d[n[p]] = h && ("n" !== E.t || "n" === E.t && !1 !== a.rawNumbers) ? g : vg(E, g, a);
              null != g && (u = !1)
            }
          } else {
            if (void 0 === c) continue;
            null != n[p] && (d[n[p]] = c)
          }
        }
      return {
        row: d,
        isempty: u
      }
    }

    function Jv(e, t) {
      if (null == e || null == e["!ref"]) return [];
      var i = {
          t: "n",
          v: 0
        },
        r = 0,
        s = 1,
        n = [],
        o = 0,
        a = "",
        l = {
          s: {
            r: 0,
            c: 0
          },
          e: {
            r: 0,
            c: 0
          }
        },
        c = t || {},
        h = null != c.range ? c.range : e["!ref"];
      switch (1 === c.header ? r = 1 : "A" === c.header ? r = 2 : Array.isArray(c.header) ? r = 3 : null == c.header && (r = 0), typeof h) {
        case "string":
          l = Rg(h);
          break;
        case "number":
          (l = Rg(e["!ref"])).s.r = h;
          break;
        default:
          l = h
      }
      r > 0 && (s = 0);
      var u = Eg(l.s.r),
        d = [],
        p = [],
        E = 0,
        g = 0,
        f = Array.isArray(e),
        T = l.s.r,
        m = 0,
        C = {};
      f && !e[T] && (e[T] = []);
      var S = c.skipHidden && e["!cols"] || [],
        R = c.skipHidden && e["!rows"] || [];
      for (m = l.s.c; m <= l.e.c; ++m)
        if (!(S[m] || {}).hidden) switch (d[m] = fg(m), i = f ? e[T][m] : e[d[m] + u], r) {
          case 1:
            n[m] = m - l.s.c;
            break;
          case 2:
            n[m] = d[m];
            break;
          case 3:
            n[m] = c.header[m - l.s.c];
            break;
          default:
            if (null == i && (i = {
                w: "__EMPTY",
                t: "s"
              }), a = o = vg(i, null, c), g = C[o] || 0) {
              do {
                a = o + "_" + g++
              } while (C[a]);
              C[o] = g, C[a] = 1
            } else C[o] = 1;
            n[m] = a
        }
      for (T = l.s.r + s; T <= l.e.r; ++T)
        if (!(R[T] || {}).hidden) {
          var A = jv(e, l, T, d, r, n, f, c);
          (!1 === A.isempty || (1 === r ? !1 !== c.blankrows : c.blankrows)) && (p[E++] = A.row)
        } return p.length = E, p
    }
    var qv = /"/g;

    function Qv(e, t, i, r, s, n, o, a) {
      for (var l = !0, c = [], h = "", u = Eg(i), d = t.s.c; d <= t.e.c; ++d)
        if (r[d]) {
          var p = a.dense ? (e[i] || [])[d] : e[r[d] + u];
          if (null == p) h = "";
          else if (null != p.v) {
            l = !1, h = "" + (a.rawNumbers && "n" == p.t ? p.v : vg(p, null, a));
            for (var E = 0, g = 0; E !== h.length; ++E)
              if ((g = h.charCodeAt(E)) === s || g === n || 34 === g || a.forceQuotes) {
                h = '"' + h.replace(qv, '""') + '"';
                break
              }
            "ID" == h && (h = '"ID"')
          } else null == p.f || p.F ? h = "" : (l = !1, (h = "=" + p.f).indexOf(",") >= 0 && (h = '"' + h.replace(qv, '""') + '"'));
          c.push(h)
        } return !1 === a.blankrows && l ? null : c.join(o)
    }

    function Zv(e, t) {
      var i = [],
        r = null == t ? {} : t;
      if (null == e || null == e["!ref"]) return "";
      var s = Rg(e["!ref"]),
        n = void 0 !== r.FS ? r.FS : ",",
        o = n.charCodeAt(0),
        a = void 0 !== r.RS ? r.RS : "\n",
        l = a.charCodeAt(0),
        c = new RegExp(("|" == n ? "\\|" : n) + "+$"),
        h = "",
        u = [];
      r.dense = Array.isArray(e);
      for (var d = r.skipHidden && e["!cols"] || [], p = r.skipHidden && e["!rows"] || [], E = s.s.c; E <= s.e.c; ++E)(d[E] || {}).hidden || (u[E] = fg(E));
      for (var g = 0, f = s.s.r; f <= s.e.r; ++f)(p[f] || {}).hidden || null != (h = Qv(e, s, f, u, o, l, n, r)) && (r.strip && (h = h.replace(c, "")), (h || !1 !== r.blankrows) && i.push((g++ ? a : "") + h));
      return delete r.dense, i.join("")
    }

    function eN(e, t) {
      t || (t = {}), t.FS = "\t", t.RS = "\n";
      var i = Zv(e, t);
      if (void 0 === xu || "string" == t.type) return i;
      var r = xu.utils.encode(1200, i, "str");
      return String.fromCharCode(255) + String.fromCharCode(254) + r
    }

    function tN(e, t, i) {
      var r, s = i || {},
        n = +!s.skipHeader,
        o = e || {},
        a = 0,
        l = 0;
      if (o && null != s.origin)
        if ("number" == typeof s.origin) a = s.origin;
        else {
          var c = "string" == typeof s.origin ? Tg(s.origin) : s.origin;
          a = c.r, l = c.c
        } var h = {
        s: {
          c: 0,
          r: 0
        },
        e: {
          c: l,
          r: a + t.length - 1 + n
        }
      };
      if (o["!ref"]) {
        var u = Rg(o["!ref"]);
        h.e.c = Math.max(h.e.c, u.e.c), h.e.r = Math.max(h.e.r, u.e.r), -1 == a && (a = u.e.r + 1, h.e.r = a + t.length - 1 + n)
      } else -1 == a && (a = 0, h.e.r = t.length - 1 + n);
      var d = s.header || [],
        p = 0;
      t.forEach(function(e, t) {
        ip(e).forEach(function(i) {
          -1 == (p = d.indexOf(i)) && (d[p = d.length] = i);
          var c = e[i],
            h = "z",
            u = "",
            E = mg({
              c: l + p,
              r: a + t + n
            });
          r = iN(o, E), !c || "object" != typeof c || c instanceof Date ? ("number" == typeof c ? h = "n" : "boolean" == typeof c ? h = "b" : "string" == typeof c ? h = "s" : c instanceof Date ? (h = "d", s.cellDates || (h = "n", c = ap(c)), u = s.dateNF || ud[14]) : null === c && s.nullError && (h = "e", c = 0), r ? (r.t = h, r.v = c, delete r.w, delete r.R, u && (r.z = u)) : o[E] = r = {
            t: h,
            v: c
          }, u && (r.z = u)) : o[E] = c
        })
      }), h.e.c = Math.max(h.e.c, l + d.length - 1);
      var E = Eg(a);
      if (n)
        for (p = 0; p < d.length; ++p) o[fg(p + l) + E] = {
          t: "s",
          v: d[p]
        };
      return o["!ref"] = Sg(h), o
    }

    function iN(e, t, i) {
      if ("string" == typeof t) {
        if (Array.isArray(e)) {
          var r = Tg(t);
          return e[r.r] || (e[r.r] = []), e[r.r][r.c] || (e[r.r][r.c] = {
            t: "z"
          })
        }
        return e[t] || (e[t] = {
          t: "z"
        })
      }
      return iN(e, mg("number" != typeof t ? t : {
        r: t,
        c: i || 0
      }))
    }

    function rN() {
      return {
        SheetNames: [],
        Sheets: {}
      }
    }

    function sN(e, t, i, r) {
      var s = 1;
      if (!i)
        for (; s <= 65535 && -1 != e.SheetNames.indexOf(i = "Sheet" + s); ++s, i = void 0);
      if (!i || e.SheetNames.length >= 65535) throw new Error("Too many worksheets");
      if (r && e.SheetNames.indexOf(i) >= 0) {
        var n = i.match(/(^.*?)(\d+)$/);
        s = n && +n[2] || 0;
        var o = n && n[1] || i;
        for (++s; s <= 65535 && -1 != e.SheetNames.indexOf(i = o + s); ++s);
      }
      if (DR(i), e.SheetNames.indexOf(i) >= 0) throw new Error("Worksheet with name |" + i + "| already exists!");
      return e.SheetNames.push(i), e.Sheets[i] = t, i
    }

    function nN(e, t, i) {
      return t ? (e.l = {
        Target: t
      }, i && (e.l.Tooltip = i)) : delete e.l, e
    }
    var oN, aN = {
      encode_col: fg,
      encode_row: Eg,
      encode_cell: mg,
      encode_range: Sg,
      decode_col: gg,
      decode_row: pg,
      split_cell: function(e) {
        return e.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",")
      },
      decode_cell: Tg,
      decode_range: Cg,
      format_cell: vg,
      sheet_add_aoa: Ig,
      sheet_add_json: tN,
      sheet_add_dom: BA,
      aoa_to_sheet: Og,
      json_to_sheet: function(e, t) {
        return tN(null, e, t)
      },
      table_to_sheet: VA,
      table_to_book: function(e, t) {
        return Ng(VA(e, t), t)
      },
      sheet_to_csv: Zv,
      sheet_to_txt: eN,
      sheet_to_json: Jv,
      sheet_to_html: kA,
      sheet_to_formulae: function(e) {
        var t, i = "",
          r = "";
        if (null == e || null == e["!ref"]) return [];
        var s, n = Rg(e["!ref"]),
          o = "",
          a = [],
          l = [],
          c = Array.isArray(e);
        for (s = n.s.c; s <= n.e.c; ++s) a[s] = fg(s);
        for (var h = n.s.r; h <= n.e.r; ++h)
          for (o = Eg(h), s = n.s.c; s <= n.e.c; ++s)
            if (i = a[s] + o, r = "", void 0 !== (t = c ? (e[h] || [])[s] : e[i])) {
              if (null != t.F) {
                if (i = t.F, !t.f) continue;
                r = t.f, -1 == i.indexOf(":") && (i = i + ":" + i)
              }
              if (null != t.f) r = t.f;
              else {
                if ("z" == t.t) continue;
                if ("n" == t.t && null != t.v) r = "" + t.v;
                else if ("b" == t.t) r = t.v ? "TRUE" : "FALSE";
                else if (void 0 !== t.w) r = "'" + t.w;
                else {
                  if (void 0 === t.v) continue;
                  r = "s" == t.t ? "'" + t.v : "" + t.v
                }
              }
              l[l.length] = i + "=" + r
            } return l
      },
      sheet_to_row_object_array: Jv,
      sheet_get_cell: iN,
      book_new: rN,
      book_append_sheet: sN,
      book_set_sheet_visibility: function(e, t, i) {
        e.Workbook || (e.Workbook = {}), e.Workbook.Sheets || (e.Workbook.Sheets = []);
        var r = function(e, t) {
          if ("number" == typeof t) {
            if (t >= 0 && e.SheetNames.length > t) return t;
            throw new Error("Cannot find sheet # " + t)
          }
          if ("string" == typeof t) {
            var i = e.SheetNames.indexOf(t);
            if (i > -1) return i;
            throw new Error("Cannot find sheet name |" + t + "|")
          }
          throw new Error("Cannot find sheet |" + t + "|")
        }(e, t);
        switch (e.Workbook.Sheets[r] || (e.Workbook.Sheets[r] = {}), i) {
          case 0:
          case 1:
          case 2:
            break;
          default:
            throw new Error("Bad sheet visibility setting " + i)
        }
        e.Workbook.Sheets[r].Hidden = i
      },
      cell_set_number_format: function(e, t) {
        return e.z = t, e
      },
      cell_set_hyperlink: nN,
      cell_set_internal_link: function(e, t, i) {
        return nN(e, "#" + t, i)
      },
      cell_add_comment: function(e, t, i) {
        e.c || (e.c = []), e.c.push({
          t,
          a: i || "SheetJS"
        })
      },
      sheet_set_array_formula: function(e, t, i, r) {
        for (var s = "string" != typeof t ? t : Rg(t), n = "string" == typeof t ? t : Sg(t), o = s.s.r; o <= s.e.r; ++o)
          for (var a = s.s.c; a <= s.e.c; ++a) {
            var l = iN(e, o, a);
            l.t = "n", l.F = n, delete l.v, o == s.s.r && a == s.s.c && (l.f = i, r && (l.D = !0))
          }
        return e
      },
      consts: {
        SHEET_VISIBLE: 0,
        SHEET_HIDDEN: 1,
        SHEET_VERY_HIDDEN: 2
      }
    };
    var lN = {
      to_json: function(e, t) {
        var i = oN({
          objectMode: !0
        });
        if (null == e || null == e["!ref"]) return i.push(null), i;
        var r = {
            t: "n",
            v: 0
          },
          s = 0,
          n = 1,
          o = [],
          a = 0,
          l = "",
          c = {
            s: {
              r: 0,
              c: 0
            },
            e: {
              r: 0,
              c: 0
            }
          },
          h = t || {},
          u = null != h.range ? h.range : e["!ref"];
        switch (1 === h.header ? s = 1 : "A" === h.header ? s = 2 : Array.isArray(h.header) && (s = 3), typeof u) {
          case "string":
            c = Rg(u);
            break;
          case "number":
            (c = Rg(e["!ref"])).s.r = u;
            break;
          default:
            c = u
        }
        s > 0 && (n = 0);
        var d = Eg(c.s.r),
          p = [],
          E = 0,
          g = Array.isArray(e),
          f = c.s.r,
          T = 0,
          m = {};
        g && !e[f] && (e[f] = []);
        var C = h.skipHidden && e["!cols"] || [],
          S = h.skipHidden && e["!rows"] || [];
        for (T = c.s.c; T <= c.e.c; ++T)
          if (!(C[T] || {}).hidden) switch (p[T] = fg(T), r = g ? e[f][T] : e[p[T] + d], s) {
            case 1:
              o[T] = T - c.s.c;
              break;
            case 2:
              o[T] = p[T];
              break;
            case 3:
              o[T] = h.header[T - c.s.c];
              break;
            default:
              if (null == r && (r = {
                  w: "__EMPTY",
                  t: "s"
                }), l = a = vg(r, null, h), E = m[a] || 0) {
                do {
                  l = a + "_" + E++
                } while (m[l]);
                m[a] = E, m[l] = 1
              } else m[a] = 1;
              o[T] = l
          }
        return f = c.s.r + n, i._read = function() {
          for (; f <= c.e.r;)
            if (!(S[f - 1] || {}).hidden) {
              var t = jv(e, c, f, p, s, o, g, h);
              if (++f, !1 === t.isempty || (1 === s ? !1 !== h.blankrows : h.blankrows)) return void i.push(t.row)
            } return i.push(null)
        }, i
      },
      to_html: function(e, t) {
        var i = oN(),
          r = t || {},
          s = null != r.header ? r.header : GA,
          n = null != r.footer ? r.footer : UA;
        i.push(s);
        var o = Cg(e["!ref"]);
        r.dense = Array.isArray(e), i.push(HA(0, 0, r));
        var a = o.s.r,
          l = !1;
        return i._read = function() {
          if (a > o.e.r) return l || (l = !0, i.push("</table>" + n)), i.push(null);
          for (; a <= o.e.r;) {
            i.push(xA(e, o, a, r)), ++a;
            break
          }
        }, i
      },
      to_csv: function(e, t) {
        var i = oN(),
          r = null == t ? {} : t;
        if (null == e || null == e["!ref"]) return i.push(null), i;
        var s = Rg(e["!ref"]),
          n = void 0 !== r.FS ? r.FS : ",",
          o = n.charCodeAt(0),
          a = void 0 !== r.RS ? r.RS : "\n",
          l = a.charCodeAt(0),
          c = new RegExp(("|" == n ? "\\|" : n) + "+$"),
          h = "",
          u = [];
        r.dense = Array.isArray(e);
        for (var d = r.skipHidden && e["!cols"] || [], p = r.skipHidden && e["!rows"] || [], E = s.s.c; E <= s.e.c; ++E)(d[E] || {}).hidden || (u[E] = fg(E));
        var g = s.s.r,
          f = !1,
          T = 0;
        return i._read = function() {
          if (!f) return f = !0, i.push("\ufeff");
          for (; g <= s.e.r;)
            if (++g, !(p[g - 1] || {}).hidden && null != (h = Qv(e, s, g - 1, u, o, l, n, r)) && (r.strip && (h = h.replace(c, "")), h || !1 !== r.blankrows)) return i.push((T++ ? a : "") + h);
          return i.push(null)
        }, i
      },
      set_readable: function(e) {
        oN = e
      }
    };
    const cN = Ou.version,
      hN = e => e.flatMap(uN),
      uN = e => CN(pN(e)).map(dN),
      dN = e => e.replace(/ +/g, " ").trim(),
      pN = e => ({
        type: "mandatory_block",
        items: EN(e, 0)[0]
      }),
      EN = (e, t, i) => {
        const r = [];
        for (; e[t];) {
          const [s, n] = gN(e, t);
          if (r.push(s), "|" !== e[t = n]) {
            if ("}" === e[t] || "]" === e[t]) {
              if (i !== e[t]) throw new Error(`Unbalanced parenthesis in: ${e}`);
              return [r, ++t]
            }
            if (t === e.length) {
              if (i) throw new Error(`Unbalanced parenthesis in: ${e}`);
              return [r, t]
            }
            throw new Error(`Unexpected "${e[t]}"`)
          }
          t++
        }
        return [r, t]
      },
      gN = (e, t) => {
        const i = [];
        for (;;) {
          const [r, s] = fN(e, t);
          if (!r) break;
          i.push(r), t = s
        }
        return 1 === i.length ? [i[0], t] : [{
          type: "concatenation",
          items: i
        }, t]
      },
      fN = (e, t) => {
        if ("{" === e[t]) return TN(e, t + 1);
        if ("[" === e[t]) return mN(e, t + 1); {
          let i = "";
          for (; e[t] && /[A-Za-z0-9_ ]/.test(e[t]);) i += e[t], t++;
          return [i, t]
        }
      },
      TN = (e, t) => {
        const [i, r] = EN(e, t, "}");
        return [{
          type: "mandatory_block",
          items: i
        }, r]
      },
      mN = (e, t) => {
        const [i, r] = EN(e, t, "]");
        return [{
          type: "optional_block",
          items: i
        }, r]
      },
      CN = e => {
        if ("string" == typeof e) return [e];
        if ("concatenation" === e.type) return e.items.map(CN).reduce(SN, [""]);
        if ("mandatory_block" === e.type) return e.items.flatMap(CN);
        if ("optional_block" === e.type) return ["", ...e.items.flatMap(CN)];
        throw new Error(`Unknown node type: ${e}`)
      },
      SN = (e, t) => {
        const i = [];
        for (const r of e)
          for (const e of t) i.push(r + e);
        return i
      };
    var RN;
    ! function(e) {
      e.QUOTED_IDENTIFIER = "QUOTED_IDENTIFIER", e.IDENTIFIER = "IDENTIFIER", e.STRING = "STRING", e.VARIABLE = "VARIABLE", e.RESERVED_DATA_TYPE = "RESERVED_DATA_TYPE", e.RESERVED_PARAMETERIZED_DATA_TYPE = "RESERVED_PARAMETERIZED_DATA_TYPE", e.RESERVED_KEYWORD = "RESERVED_KEYWORD", e.RESERVED_FUNCTION_NAME = "RESERVED_FUNCTION_NAME", e.RESERVED_KEYWORD_PHRASE = "RESERVED_KEYWORD_PHRASE", e.RESERVED_DATA_TYPE_PHRASE = "RESERVED_DATA_TYPE_PHRASE", e.RESERVED_SET_OPERATION = "RESERVED_SET_OPERATION", e.RESERVED_CLAUSE = "RESERVED_CLAUSE", e.RESERVED_SELECT = "RESERVED_SELECT", e.RESERVED_JOIN = "RESERVED_JOIN", e.ARRAY_IDENTIFIER = "ARRAY_IDENTIFIER", e.ARRAY_KEYWORD = "ARRAY_KEYWORD", e.CASE = "CASE", e.END = "END", e.WHEN = "WHEN", e.ELSE = "ELSE", e.THEN = "THEN", e.LIMIT = "LIMIT", e.BETWEEN = "BETWEEN", e.AND = "AND", e.OR = "OR", e.XOR = "XOR", e.OPERATOR = "OPERATOR", e.COMMA = "COMMA", e.ASTERISK = "ASTERISK", e.PROPERTY_ACCESS_OPERATOR = "PROPERTY_ACCESS_OPERATOR", e.OPEN_PAREN = "OPEN_PAREN", e.CLOSE_PAREN = "CLOSE_PAREN", e.LINE_COMMENT = "LINE_COMMENT", e.BLOCK_COMMENT = "BLOCK_COMMENT", e.DISABLE_COMMENT = "DISABLE_COMMENT", e.NUMBER = "NUMBER", e.NAMED_PARAMETER = "NAMED_PARAMETER", e.QUOTED_PARAMETER = "QUOTED_PARAMETER", e.NUMBERED_PARAMETER = "NUMBERED_PARAMETER", e.POSITIONAL_PARAMETER = "POSITIONAL_PARAMETER", e.CUSTOM_PARAMETER = "CUSTOM_PARAMETER", e.DELIMITER = "DELIMITER", e.EOF = "EOF"
    }(RN = RN || (RN = {}));
    const AN = e => ({
        type: RN.EOF,
        raw: "«EOF»",
        text: "«EOF»",
        start: e
      }),
      vN = AN(1 / 0),
      NN = e => t => t.type === e.type && t.text === e.text,
      IN = {
        ARRAY: NN({
          text: "ARRAY",
          type: RN.RESERVED_DATA_TYPE
        }),
        BY: NN({
          text: "BY",
          type: RN.RESERVED_KEYWORD
        }),
        SET: NN({
          text: "SET",
          type: RN.RESERVED_CLAUSE
        }),
        STRUCT: NN({
          text: "STRUCT",
          type: RN.RESERVED_DATA_TYPE
        }),
        WINDOW: NN({
          text: "WINDOW",
          type: RN.RESERVED_CLAUSE
        }),
        VALUES: NN({
          text: "VALUES",
          type: RN.RESERVED_CLAUSE
        })
      },
      ON = e => e === RN.RESERVED_DATA_TYPE || e === RN.RESERVED_KEYWORD || e === RN.RESERVED_FUNCTION_NAME || e === RN.RESERVED_KEYWORD_PHRASE || e === RN.RESERVED_DATA_TYPE_PHRASE || e === RN.RESERVED_CLAUSE || e === RN.RESERVED_SELECT || e === RN.RESERVED_SET_OPERATION || e === RN.RESERVED_JOIN || e === RN.ARRAY_KEYWORD || e === RN.CASE || e === RN.END || e === RN.WHEN || e === RN.ELSE || e === RN.THEN || e === RN.LIMIT || e === RN.BETWEEN || e === RN.AND || e === RN.OR || e === RN.XOR,
      LN = hN(["SELECT [ALL | DISTINCT] [AS STRUCT | AS VALUE]"]),
      _N = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "QUALIFY", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "OMIT RECORD IF", "INSERT [INTO]", "VALUES", "SET", "MERGE [INTO]", "WHEN [NOT] MATCHED [BY SOURCE | BY TARGET] [THEN]", "UPDATE SET", "CLUSTER BY", "FOR SYSTEM_TIME AS OF", "WITH CONNECTION", "WITH PARTITION COLUMNS", "REMOTE WITH CONNECTION"]),
      yN = hN(["CREATE [OR REPLACE] [TEMP|TEMPORARY|SNAPSHOT|EXTERNAL] TABLE [IF NOT EXISTS]"]),
      wN = hN(["CREATE [OR REPLACE] [MATERIALIZED] VIEW [IF NOT EXISTS]", "UPDATE", "DELETE [FROM]", "DROP [SNAPSHOT | EXTERNAL] TABLE [IF EXISTS]", "ALTER TABLE [IF EXISTS]", "ADD COLUMN [IF NOT EXISTS]", "DROP COLUMN [IF EXISTS]", "RENAME TO", "ALTER COLUMN [IF EXISTS]", "SET DEFAULT COLLATE", "SET OPTIONS", "DROP NOT NULL", "SET DATA TYPE", "ALTER SCHEMA [IF EXISTS]", "ALTER [MATERIALIZED] VIEW [IF EXISTS]", "ALTER BI_CAPACITY", "TRUNCATE TABLE", "CREATE SCHEMA [IF NOT EXISTS]", "DEFAULT COLLATE", "CREATE [OR REPLACE] [TEMP|TEMPORARY|TABLE] FUNCTION [IF NOT EXISTS]", "CREATE [OR REPLACE] PROCEDURE [IF NOT EXISTS]", "CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]", "GRANT TO", "FILTER USING", "CREATE CAPACITY", "AS JSON", "CREATE RESERVATION", "CREATE ASSIGNMENT", "CREATE SEARCH INDEX [IF NOT EXISTS]", "DROP SCHEMA [IF EXISTS]", "DROP [MATERIALIZED] VIEW [IF EXISTS]", "DROP [TABLE] FUNCTION [IF EXISTS]", "DROP PROCEDURE [IF EXISTS]", "DROP ROW ACCESS POLICY", "DROP ALL ROW ACCESS POLICIES", "DROP CAPACITY [IF EXISTS]", "DROP RESERVATION [IF EXISTS]", "DROP ASSIGNMENT [IF EXISTS]", "DROP SEARCH INDEX [IF EXISTS]", "DROP [IF EXISTS]", "GRANT", "REVOKE", "DECLARE", "EXECUTE IMMEDIATE", "LOOP", "END LOOP", "REPEAT", "END REPEAT", "WHILE", "END WHILE", "BREAK", "LEAVE", "CONTINUE", "ITERATE", "FOR", "END FOR", "BEGIN", "BEGIN TRANSACTION", "COMMIT TRANSACTION", "ROLLBACK TRANSACTION", "RAISE", "RETURN", "CALL", "ASSERT", "EXPORT DATA"]),
      DN = hN(["UNION {ALL | DISTINCT}", "EXCEPT DISTINCT", "INTERSECT DISTINCT"]),
      PN = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]),
      bN = hN(["TABLESAMPLE SYSTEM", "ANY TYPE", "ALL COLUMNS", "NOT DETERMINISTIC", "{ROWS | RANGE} BETWEEN", "IS [NOT] DISTINCT FROM"]),
      MN = hN([]),
      FN = {
        name: "bigquery",
        tokenizerOptions: {
          reservedSelect: LN,
          reservedClauses: [..._N, ...wN, ...yN],
          reservedSetOperations: DN,
          reservedJoins: PN,
          reservedKeywordPhrases: bN,
          reservedDataTypePhrases: MN,
          reservedKeywords: ["ALL", "AND", "ANY", "AS", "ASC", "ASSERT_ROWS_MODIFIED", "AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE", "CONTAINS", "CREATE", "CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE", "DESC", "DISTINCT", "ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXTRACT", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN", "INNER", "INTERSECT", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LIMIT", "LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "NULL", "NULLS", "OF", "ON", "OR", "ORDER", "OUTER", "OVER", "PARTITION", "PRECEDING", "PROTO", "RANGE", "RECURSIVE", "RESPECT", "RIGHT", "ROLLUP", "ROWS", "SELECT", "SET", "SOME", "TABLE", "TABLESAMPLE", "THEN", "TO", "TREAT", "TRUE", "UNBOUNDED", "UNION", "UNNEST", "USING", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "SAFE", "LIKE", "COPY", "CLONE", "IN", "OUT", "INOUT", "RETURNS", "LANGUAGE", "CASCADE", "RESTRICT", "DETERMINISTIC"],
          reservedDataTypes: ["ARRAY", "BOOL", "BYTES", "DATE", "DATETIME", "GEOGRAPHY", "INTERVAL", "INT64", "INT", "SMALLINT", "INTEGER", "BIGINT", "TINYINT", "BYTEINT", "NUMERIC", "DECIMAL", "BIGNUMERIC", "BIGDECIMAL", "FLOAT64", "STRING", "STRUCT", "TIME", "TIMEZONE"],
          reservedFunctionNames: ["KEYS.NEW_KEYSET", "KEYS.ADD_KEY_FROM_RAW_BYTES", "AEAD.DECRYPT_BYTES", "AEAD.DECRYPT_STRING", "AEAD.ENCRYPT", "KEYS.KEYSET_CHAIN", "KEYS.KEYSET_FROM_JSON", "KEYS.KEYSET_TO_JSON", "KEYS.ROTATE_KEYSET", "KEYS.KEYSET_LENGTH", "ANY_VALUE", "ARRAY_AGG", "AVG", "CORR", "COUNT", "COUNTIF", "COVAR_POP", "COVAR_SAMP", "MAX", "MIN", "ST_CLUSTERDBSCAN", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "VAR_POP", "VAR_SAMP", "ANY_VALUE", "ARRAY_AGG", "ARRAY_CONCAT_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "COUNTIF", "LOGICAL_AND", "LOGICAL_OR", "MAX", "MIN", "STRING_AGG", "SUM", "APPROX_COUNT_DISTINCT", "APPROX_QUANTILES", "APPROX_TOP_COUNT", "APPROX_TOP_SUM", "ARRAY_CONCAT", "ARRAY_LENGTH", "ARRAY_TO_STRING", "GENERATE_ARRAY", "GENERATE_DATE_ARRAY", "GENERATE_TIMESTAMP_ARRAY", "ARRAY_REVERSE", "OFFSET", "SAFE_OFFSET", "ORDINAL", "SAFE_ORDINAL", "BIT_COUNT", "PARSE_BIGNUMERIC", "PARSE_NUMERIC", "SAFE_CAST", "CURRENT_DATE", "EXTRACT", "DATE", "DATE_ADD", "DATE_SUB", "DATE_DIFF", "DATE_TRUNC", "DATE_FROM_UNIX_DATE", "FORMAT_DATE", "LAST_DAY", "PARSE_DATE", "UNIX_DATE", "CURRENT_DATETIME", "DATETIME", "EXTRACT", "DATETIME_ADD", "DATETIME_SUB", "DATETIME_DIFF", "DATETIME_TRUNC", "FORMAT_DATETIME", "LAST_DAY", "PARSE_DATETIME", "ERROR", "EXTERNAL_QUERY", "S2_CELLIDFROMPOINT", "S2_COVERINGCELLIDS", "ST_ANGLE", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_AZIMUTH", "ST_BOUNDARY", "ST_BOUNDINGBOX", "ST_BUFFER", "ST_BUFFERWITHTOLERANCE", "ST_CENTROID", "ST_CENTROID_AGG", "ST_CLOSESTPOINT", "ST_CLUSTERDBSCAN", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DUMP", "ST_DWITHIN", "ST_ENDPOINT", "ST_EQUALS", "ST_EXTENT", "ST_EXTERIORRING", "ST_GEOGFROM", "ST_GEOGFROMGEOJSON", "ST_GEOGFROMTEXT", "ST_GEOGFROMWKB", "ST_GEOGPOINT", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOHASH", "ST_GEOMETRYTYPE", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_INTERSECTSBOX", "ST_ISCOLLECTION", "ST_ISEMPTY", "ST_LENGTH", "ST_MAKELINE", "ST_MAKEPOLYGON", "ST_MAKEPOLYGONORIENTED", "ST_MAXDISTANCE", "ST_NPOINTS", "ST_NUMGEOMETRIES", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SIMPLIFY", "ST_SNAPTOGRID", "ST_STARTPOINT", "ST_TOUCHES", "ST_UNION", "ST_UNION_AGG", "ST_WITHIN", "ST_X", "ST_Y", "FARM_FINGERPRINT", "MD5", "SHA1", "SHA256", "SHA512", "HLL_COUNT.INIT", "HLL_COUNT.MERGE", "HLL_COUNT.MERGE_PARTIAL", "HLL_COUNT.EXTRACT", "MAKE_INTERVAL", "EXTRACT", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL", "JSON_EXTRACT", "JSON_QUERY", "JSON_EXTRACT_SCALAR", "JSON_VALUE", "JSON_EXTRACT_ARRAY", "JSON_QUERY_ARRAY", "JSON_EXTRACT_STRING_ARRAY", "JSON_VALUE_ARRAY", "TO_JSON_STRING", "ABS", "SIGN", "IS_INF", "IS_NAN", "IEEE_DIVIDE", "RAND", "SQRT", "POW", "POWER", "EXP", "LN", "LOG", "LOG10", "GREATEST", "LEAST", "DIV", "SAFE_DIVIDE", "SAFE_MULTIPLY", "SAFE_NEGATE", "SAFE_ADD", "SAFE_SUBTRACT", "MOD", "ROUND", "TRUNC", "CEIL", "CEILING", "FLOOR", "COS", "COSH", "ACOS", "ACOSH", "SIN", "SINH", "ASIN", "ASINH", "TAN", "TANH", "ATAN", "ATANH", "ATAN2", "RANGE_BUCKET", "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "LEAD", "LAG", "PERCENTILE_CONT", "PERCENTILE_DISC", "NET.IP_FROM_STRING", "NET.SAFE_IP_FROM_STRING", "NET.IP_TO_STRING", "NET.IP_NET_MASK", "NET.IP_TRUNC", "NET.IPV4_FROM_INT64", "NET.IPV4_TO_INT64", "NET.HOST", "NET.PUBLIC_SUFFIX", "NET.REG_DOMAIN", "RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE", "ROW_NUMBER", "SESSION_USER", "CORR", "COVAR_POP", "COVAR_SAMP", "STDDEV_POP", "STDDEV_SAMP", "STDDEV", "VAR_POP", "VAR_SAMP", "VARIANCE", "ASCII", "BYTE_LENGTH", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CODE_POINTS_TO_BYTES", "CODE_POINTS_TO_STRING", "CONCAT", "CONTAINS_SUBSTR", "ENDS_WITH", "FORMAT", "FROM_BASE32", "FROM_BASE64", "FROM_HEX", "INITCAP", "INSTR", "LEFT", "LENGTH", "LPAD", "LOWER", "LTRIM", "NORMALIZE", "NORMALIZE_AND_CASEFOLD", "OCTET_LENGTH", "REGEXP_CONTAINS", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "REPEAT", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SAFE_CONVERT_BYTES_TO_STRING", "SOUNDEX", "SPLIT", "STARTS_WITH", "STRPOS", "SUBSTR", "SUBSTRING", "TO_BASE32", "TO_BASE64", "TO_CODE_POINTS", "TO_HEX", "TRANSLATE", "TRIM", "UNICODE", "UPPER", "CURRENT_TIME", "TIME", "EXTRACT", "TIME_ADD", "TIME_SUB", "TIME_DIFF", "TIME_TRUNC", "FORMAT_TIME", "PARSE_TIME", "CURRENT_TIMESTAMP", "EXTRACT", "STRING", "TIMESTAMP", "TIMESTAMP_ADD", "TIMESTAMP_SUB", "TIMESTAMP_DIFF", "TIMESTAMP_TRUNC", "FORMAT_TIMESTAMP", "PARSE_TIMESTAMP", "TIMESTAMP_SECONDS", "TIMESTAMP_MILLIS", "TIMESTAMP_MICROS", "UNIX_SECONDS", "UNIX_MILLIS", "UNIX_MICROS", "GENERATE_UUID", "COALESCE", "IF", "IFNULL", "NULLIF", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "EXACT_COUNT_DISTINCT", "FIRST", "GROUP_CONCAT", "GROUP_CONCAT_UNQUOTED", "LAST", "MAX", "MIN", "NEST", "NTH", "QUANTILES", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "TOP", "UNIQUE", "VARIANCE", "VAR_POP", "VAR_SAMP", "BIT_COUNT", "BOOLEAN", "BYTES", "CAST", "FLOAT", "HEX_STRING", "INTEGER", "STRING", "COALESCE", "GREATEST", "IFNULL", "IS_INF", "IS_NAN", "IS_EXPLICITLY_DEFINED", "LEAST", "NVL", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATE_ADD", "DATEDIFF", "DAY", "DAYOFWEEK", "DAYOFYEAR", "FORMAT_UTC_USEC", "HOUR", "MINUTE", "MONTH", "MSEC_TO_TIMESTAMP", "NOW", "PARSE_UTC_USEC", "QUARTER", "SEC_TO_TIMESTAMP", "SECOND", "STRFTIME_UTC_USEC", "TIME", "TIMESTAMP", "TIMESTAMP_TO_MSEC", "TIMESTAMP_TO_SEC", "TIMESTAMP_TO_USEC", "USEC_TO_TIMESTAMP", "UTC_USEC_TO_DAY", "UTC_USEC_TO_HOUR", "UTC_USEC_TO_MONTH", "UTC_USEC_TO_WEEK", "UTC_USEC_TO_YEAR", "WEEK", "YEAR", "FORMAT_IP", "PARSE_IP", "FORMAT_PACKED_IP", "PARSE_PACKED_IP", "JSON_EXTRACT", "JSON_EXTRACT_SCALAR", "ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATANH", "ATAN2", "CEIL", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG2", "LOG10", "PI", "POW", "RADIANS", "RAND", "ROUND", "SIN", "SINH", "SQRT", "TAN", "TANH", "REGEXP_MATCH", "REGEXP_EXTRACT", "REGEXP_REPLACE", "CONCAT", "INSTR", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "REPLACE", "RIGHT", "RPAD", "RTRIM", "SPLIT", "SUBSTR", "UPPER", "TABLE_DATE_RANGE", "TABLE_DATE_RANGE_STRICT", "TABLE_QUERY", "HOST", "DOMAIN", "TLD", "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "CURRENT_USER", "EVERY", "FROM_BASE64", "HASH", "FARM_FINGERPRINT", "IF", "POSITION", "SHA1", "SOME", "TO_BASE64", "BQ.JOBS.CANCEL", "BQ.REFRESH_MATERIALIZED_VIEW", "OPTIONS", "PIVOT", "UNPIVOT"],
          extraParens: ["[]"],
          stringTypes: [{
            quote: '""".."""',
            prefixes: ["R", "B", "RB", "BR"]
          }, {
            quote: "'''..'''",
            prefixes: ["R", "B", "RB", "BR"]
          }, '""-bs', "''-bs", {
            quote: '""-raw',
            prefixes: ["R", "B", "RB", "BR"],
            requirePrefix: !0
          }, {
            quote: "''-raw",
            prefixes: ["R", "B", "RB", "BR"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            dashes: !0
          },
          paramTypes: {
            positional: !0,
            named: ["@"],
            quoted: ["@"]
          },
          variableTypes: [{
            regex: String.raw`@@\w+`
          }],
          lineCommentTypes: ["--", "#"],
          operators: ["&", "|", "^", "~", ">>", "<<", "||", "=>"],
          postProcess: function(e) {
            return function(e) {
              let t = vN;
              return e.map(e => "OFFSET" === e.text && "[" === t.text ? (t = e, Object.assign(Object.assign({}, e), {
                type: RN.RESERVED_FUNCTION_NAME
              })) : (t = e, e))
            }(function(e) {
              var t;
              const i = [];
              for (let r = 0; r < e.length; r++) {
                const s = e[r];
                if ((IN.ARRAY(s) || IN.STRUCT(s)) && "<" === (null === (t = e[r + 1]) || void 0 === t ? void 0 : t.text)) {
                  const t = GN(e, r + 1),
                    n = e.slice(r, t + 1);
                  i.push({
                    type: RN.IDENTIFIER,
                    raw: n.map(xN("raw")).join(""),
                    text: n.map(xN("text")).join(""),
                    start: s.start
                  }), r = t
                } else i.push(s)
              }
              return i
            }(e))
          }
        },
        formatOptions: {
          onelineClauses: [...yN, ...wN],
          tabularOnelineClauses: wN
        }
      };
    const xN = e => t => t.type === RN.IDENTIFIER || t.type === RN.COMMA ? t[e] + " " : t[e];

    function GN(e, t) {
      let i = 0;
      for (let r = t; r < e.length; r++) {
        const t = e[r];
        if ("<" === t.text ? i++ : ">" === t.text ? i-- : ">>" === t.text && (i -= 2), 0 === i) return r
      }
      return e.length - 1
    }
    const UN = hN(["SELECT [ALL | DISTINCT]"]),
      HN = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER BY [INPUT SEQUENCE]", "LIMIT", "OFFSET", "FETCH NEXT", "FOR UPDATE [OF]", "FOR {READ | FETCH} ONLY", "FOR {RR | CS | UR | RS} [USE AND KEEP {SHARE | UPDATE | EXCLUSIVE} LOCKS]", "WAIT FOR OUTCOME", "SKIP LOCKED DATA", "INTO", "INSERT INTO", "VALUES", "SET", "MERGE INTO", "WHEN [NOT] MATCHED [THEN]", "UPDATE SET", "INSERT"]),
      kN = hN(["CREATE [GLOBAL TEMPORARY | EXTERNAL] TABLE [IF NOT EXISTS]"]),
      BN = hN(["CREATE [OR REPLACE] VIEW", "UPDATE", "WHERE CURRENT OF", "WITH {RR | RS | CS | UR}", "DELETE FROM", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "ADD [COLUMN]", "DROP [COLUMN]", "RENAME COLUMN", "ALTER [COLUMN]", "SET DATA TYPE", "SET NOT NULL", "DROP {DEFAULT | GENERATED | NOT NULL}", "TRUNCATE [TABLE]", "ALLOCATE", "ALTER AUDIT POLICY", "ALTER BUFFERPOOL", "ALTER DATABASE PARTITION GROUP", "ALTER DATABASE", "ALTER EVENT MONITOR", "ALTER FUNCTION", "ALTER HISTOGRAM TEMPLATE", "ALTER INDEX", "ALTER MASK", "ALTER METHOD", "ALTER MODULE", "ALTER NICKNAME", "ALTER PACKAGE", "ALTER PERMISSION", "ALTER PROCEDURE", "ALTER SCHEMA", "ALTER SECURITY LABEL COMPONENT", "ALTER SECURITY POLICY", "ALTER SEQUENCE", "ALTER SERVER", "ALTER SERVICE CLASS", "ALTER STOGROUP", "ALTER TABLESPACE", "ALTER THRESHOLD", "ALTER TRIGGER", "ALTER TRUSTED CONTEXT", "ALTER TYPE", "ALTER USAGE LIST", "ALTER USER MAPPING", "ALTER VIEW", "ALTER WORK ACTION SET", "ALTER WORK CLASS SET", "ALTER WORKLOAD", "ALTER WRAPPER", "ALTER XSROBJECT", "ALTER STOGROUP", "ALTER TABLESPACE", "ALTER TRIGGER", "ALTER TRUSTED CONTEXT", "ALTER VIEW", "ASSOCIATE [RESULT SET] {LOCATOR | LOCATORS}", "AUDIT", "BEGIN DECLARE SECTION", "CALL", "CLOSE", "COMMENT ON", "COMMIT [WORK]", "CONNECT", "CREATE [OR REPLACE] [PUBLIC] ALIAS", "CREATE AUDIT POLICY", "CREATE BUFFERPOOL", "CREATE DATABASE PARTITION GROUP", "CREATE EVENT MONITOR", "CREATE [OR REPLACE] FUNCTION", "CREATE FUNCTION MAPPING", "CREATE HISTOGRAM TEMPLATE", "CREATE [UNIQUE] INDEX", "CREATE INDEX EXTENSION", "CREATE [OR REPLACE] MASK", "CREATE [SPECIFIC] METHOD", "CREATE [OR REPLACE] MODULE", "CREATE [OR REPLACE] NICKNAME", "CREATE [OR REPLACE] PERMISSION", "CREATE [OR REPLACE] PROCEDURE", "CREATE ROLE", "CREATE SCHEMA", "CREATE SECURITY LABEL [COMPONENT]", "CREATE SECURITY POLICY", "CREATE [OR REPLACE] SEQUENCE", "CREATE SERVICE CLASS", "CREATE SERVER", "CREATE STOGROUP", "CREATE SYNONYM", "CREATE [LARGE | REGULAR | {SYSTEM | USER} TEMPORARY] TABLESPACE", "CREATE THRESHOLD", "CREATE {TRANSFORM | TRANSFORMS} FOR", "CREATE [OR REPLACE] TRIGGER", "CREATE TRUSTED CONTEXT", "CREATE [OR REPLACE] TYPE", "CREATE TYPE MAPPING", "CREATE USAGE LIST", "CREATE USER MAPPING FOR", "CREATE [OR REPLACE] VARIABLE", "CREATE WORK ACTION SET", "CREATE WORK CLASS SET", "CREATE WORKLOAD", "CREATE WRAPPER", "DECLARE", "DECLARE GLOBAL TEMPORARY TABLE", "DESCRIBE [INPUT | OUTPUT]", "DISCONNECT", "DROP [PUBLIC] ALIAS", "DROP AUDIT POLICY", "DROP BUFFERPOOL", "DROP DATABASE PARTITION GROUP", "DROP EVENT MONITOR", "DROP [SPECIFIC] FUNCTION", "DROP FUNCTION MAPPING", "DROP HISTOGRAM TEMPLATE", "DROP INDEX [EXTENSION]", "DROP MASK", "DROP [SPECIFIC] METHOD", "DROP MODULE", "DROP NICKNAME", "DROP PACKAGE", "DROP PERMISSION", "DROP [SPECIFIC] PROCEDURE", "DROP ROLE", "DROP SCHEMA", "DROP SECURITY LABEL [COMPONENT]", "DROP SECURITY POLICY", "DROP SEQUENCE", "DROP SERVER", "DROP SERVICE CLASS", "DROP STOGROUP", "DROP TABLE HIERARCHY", "DROP {TABLESPACE | TABLESPACES}", "DROP {TRANSFORM | TRANSFORMS}", "DROP THRESHOLD", "DROP TRIGGER", "DROP TRUSTED CONTEXT", "DROP TYPE [MAPPING]", "DROP USAGE LIST", "DROP USER MAPPING FOR", "DROP VARIABLE", "DROP VIEW [HIERARCHY]", "DROP WORK {ACTION | CLASS} SET", "DROP WORKLOAD", "DROP WRAPPER", "DROP XSROBJECT", "END DECLARE SECTION", "EXECUTE [IMMEDIATE]", "EXPLAIN {PLAN [SECTION] | ALL}", "FETCH [FROM]", "FLUSH {BUFFERPOOL | BUFFERPOOLS} ALL", "FLUSH EVENT MONITOR", "FLUSH FEDERATED CACHE", "FLUSH OPTIMIZATION PROFILE CACHE", "FLUSH PACKAGE CACHE [DYNAMIC]", "FLUSH AUTHENTICATION CACHE [FOR ALL]", "FREE LOCATOR", "GET DIAGNOSTICS", "GOTO", "GRANT", "INCLUDE", "ITERATE", "LEAVE", "LOCK TABLE", "LOOP", "OPEN", "PIPE", "PREPARE", "REFRESH TABLE", "RELEASE", "RELEASE [TO] SAVEPOINT", "RENAME [TABLE | INDEX | STOGROUP | TABLESPACE]", "REPEAT", "RESIGNAL", "RETURN", "REVOKE", "ROLLBACK [WORK] [TO SAVEPOINT]", "SAVEPOINT", "SET COMPILATION ENVIRONMENT", "SET CONNECTION", "SET CURRENT", "SET ENCRYPTION PASSWORD", "SET EVENT MONITOR STATE", "SET INTEGRITY", "SET PASSTHRU", "SET PATH", "SET ROLE", "SET SCHEMA", "SET SERVER OPTION", "SET {SESSION AUTHORIZATION | SESSION_USER}", "SET USAGE LIST", "SIGNAL", "TRANSFER OWNERSHIP OF", "WHENEVER {NOT FOUND | SQLERROR | SQLWARNING}", "WHILE"]),
      VN = hN(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]),
      WN = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]),
      YN = hN(["ON DELETE", "ON UPDATE", "SET NULL", "{ROWS | RANGE} BETWEEN"]),
      KN = hN([]),
      XN = {
        name: "db2",
        tokenizerOptions: {
          reservedSelect: UN,
          reservedClauses: [...HN, ...kN, ...BN],
          reservedSetOperations: VN,
          reservedJoins: WN,
          reservedKeywordPhrases: YN,
          reservedDataTypePhrases: KN,
          reservedKeywords: ["ACTIVATE", "ADD", "AFTER", "ALIAS", "ALL", "ALLOCATE", "ALLOW", "ALTER", "AND", "ANY", "AS", "ASENSITIVE", "ASSOCIATE", "ASUTIME", "AT", "ATTRIBUTES", "AUDIT", "AUTHORIZATION", "AUX", "AUXILIARY", "BEFORE", "BEGIN", "BETWEEN", "BINARY", "BUFFERPOOL", "BY", "CACHE", "CALL", "CALLED", "CAPTURE", "CARDINALITY", "CASCADED", "CASE", "CAST", "CHECK", "CLONE", "CLOSE", "CLUSTER", "COLLECTION", "COLLID", "COLUMN", "COMMENT", "COMMIT", "CONCAT", "CONDITION", "CONNECT", "CONNECTION", "CONSTRAINT", "CONTAINS", "CONTINUE", "COUNT", "COUNT_BIG", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_LC_CTYPE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_SERVER", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATAPARTITIONNAME", "DATAPARTITIONNUM", "DAY", "DAYS", "DB2GENERAL", "DB2GENRL", "DB2SQL", "DBINFO", "DBPARTITIONNAME", "DBPARTITIONNUM", "DEALLOCATE", "DECLARE", "DEFAULT", "DEFAULTS", "DEFINITION", "DELETE", "DENSERANK", "DENSE_RANK", "DESCRIBE", "DESCRIPTOR", "DETERMINISTIC", "DIAGNOSTICS", "DISABLE", "DISALLOW", "DISCONNECT", "DISTINCT", "DO", "DOCUMENT", "DROP", "DSSIZE", "DYNAMIC", "EACH", "EDITPROC", "ELSE", "ELSEIF", "ENABLE", "ENCODING", "ENCRYPTION", "END", "END-EXEC", "ENDING", "ERASE", "ESCAPE", "EVERY", "EXCEPT", "EXCEPTION", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTENDED", "EXTERNAL", "EXTRACT", "FENCED", "FETCH", "FIELDPROC", "FILE", "FINAL", "FIRST1", "FOR", "FOREIGN", "FREE", "FROM", "FULL", "FUNCTION", "GENERAL", "GENERATED", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GRAPHIC", "GROUP", "HANDLER", "HASH", "HASHED_VALUE", "HAVING", "HINT", "HOLD", "HOUR", "HOURS", "IDENTITY", "IF", "IMMEDIATE", "IMPORT", "IN", "INCLUDING", "INCLUSIVE", "INCREMENT", "INDEX", "INDICATOR", "INDICATORS", "INF", "INFINITY", "INHERIT", "INNER", "INOUT", "INSENSITIVE", "INSERT", "INTEGRITY", "INTERSECT", "INTO", "IS", "ISNULL", "ISOBID", "ISOLATION", "ITERATE", "JAR", "JAVA", "JOIN", "KEEP", "KEY", "LABEL", "LANGUAGE", "LAST3", "LATERAL", "LC_CTYPE", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINKTYPE", "LOCAL", "LOCALDATE", "LOCALE", "LOCALTIME", "LOCALTIMESTAMP", "LOCATOR", "LOCATORS", "LOCK", "LOCKMAX", "LOCKSIZE", "LOOP", "MAINTAINED", "MATERIALIZED", "MAXVALUE", "MICROSECOND", "MICROSECONDS", "MINUTE", "MINUTES", "MINVALUE", "MODE", "MODIFIES", "MONTH", "MONTHS", "NAN", "NEW", "NEW_TABLE", "NEXTVAL", "NO", "NOCACHE", "NOCYCLE", "NODENAME", "NODENUMBER", "NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NORMALIZED", "NOT2", "NOTNULL", "NULL", "NULLS", "NUMPARTS", "OBID", "OF", "OFF", "OFFSET", "OLD", "OLD_TABLE", "ON", "OPEN", "OPTIMIZATION", "OPTIMIZE", "OPTION", "OR", "ORDER", "OUT", "OUTER", "OVER", "OVERRIDING", "PACKAGE", "PADDED", "PAGESIZE", "PARAMETER", "PART", "PARTITION", "PARTITIONED", "PARTITIONING", "PARTITIONS", "PASSWORD", "PATH", "PERCENT", "PIECESIZE", "PLAN", "POSITION", "PRECISION", "PREPARE", "PREVVAL", "PRIMARY", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PSID", "PUBLIC", "QUERY", "QUERYNO", "RANGE", "RANK", "READ", "READS", "RECOVERY", "REFERENCES", "REFERENCING", "REFRESH", "RELEASE", "RENAME", "REPEAT", "RESET", "RESIGNAL", "RESTART", "RESTRICT", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROUND_CEILING", "ROUND_DOWN", "ROUND_FLOOR", "ROUND_HALF_DOWN", "ROUND_HALF_EVEN", "ROUND_HALF_UP", "ROUND_UP", "ROUTINE", "ROW", "ROWNUMBER", "ROWS", "ROWSET", "ROW_NUMBER", "RRN", "RUN", "SAVEPOINT", "SCHEMA", "SCRATCHPAD", "SCROLL", "SEARCH", "SECOND", "SECONDS", "SECQTY", "SECURITY", "SELECT", "SENSITIVE", "SEQUENCE", "SESSION", "SESSION_USER", "SET", "SIGNAL", "SIMPLE", "SNAN", "SOME", "SOURCE", "SPECIFIC", "SQL", "SQLID", "STACKED", "STANDARD", "START", "STARTING", "STATEMENT", "STATIC", "STATMENT", "STAY", "STOGROUP", "STORES", "STYLE", "SUBSTRING", "SUMMARY", "SYNONYM", "SYSFUN", "SYSIBM", "SYSPROC", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLESPACE", "THEN", "TO", "TRANSACTION", "TRIGGER", "TRIM", "TRUNCATE", "TYPE", "UNDO", "UNION", "UNIQUE", "UNTIL", "UPDATE", "USAGE", "USER", "USING", "VALIDPROC", "VALUE", "VALUES", "VARIABLE", "VARIANT", "VCAT", "VERSION", "VIEW", "VOLATILE", "VOLUMES", "WHEN", "WHENEVER", "WHERE", "WHILE", "WITH", "WITHOUT", "WLM", "WRITE", "XMLELEMENT", "XMLEXISTS", "XMLNAMESPACES", "YEAR", "YEARS"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY", "BLOB", "BOOLEAN", "CCSID", "CHAR", "CHARACTER", "CLOB", "DATE", "DATETIME", "DBCLOB", "DEC", "DECIMAL", "DOUBLE", "DOUBLE PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "GRAPHIC", "INT", "INT2", "INT4", "INT8", "INTEGER", "INTERVAL", "LONG VARCHAR", "LONG VARGRAPHIC", "NCHAR", "NCHR", "NCLOB", "NVARCHAR", "NUMERIC", "SMALLINT", "REAL", "TIME", "TIMESTAMP", "VARBINARY", "VARCHAR", "VARGRAPHIC"],
          reservedFunctionNames: ["ARRAY_AGG", "AVG", "CORRELATION", "COUNT", "COUNT_BIG", "COVARIANCE", "COVARIANCE_SAMP", "CUME_DIST", "GROUPING", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_ICPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV", "STDDEV_SAMP", "SUM", "VARIANCE", "VARIANCE_SAMP", "XMLAGG", "XMLGROUP", "ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_HOURS", "ADD_MINUTES", "ADD_MONTHS", "ADD_SECONDS", "ADD_YEARS", "AGE", "ARRAY_DELETE", "ARRAY_FIRST", "ARRAY_LAST", "ARRAY_NEXT", "ARRAY_PRIOR", "ASCII", "ASCII_STR", "ASIN", "ATAN", "ATAN2", "ATANH", "BITAND", "BITANDNOT", "BITOR", "BITXOR", "BITNOT", "BPCHAR", "BSON_TO_JSON", "BTRIM", "CARDINALITY", "CEILING", "CEIL", "CHARACTER_LENGTH", "CHR", "COALESCE", "COLLATION_KEY", "COLLATION_KEY_BIT", "COMPARE_DECFLOAT", "CONCAT", "COS", "COSH", "COT", "CURSOR_ROWCOUNT", "DATAPARTITIONNUM", "DATE_PART", "DATE_TRUNC", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEK_ISO", "DAYOFYEAR", "DAYS", "DAYS_BETWEEN", "DAYS_TO_END_OF_MONTH", "DBPARTITIONNUM", "DECFLOAT", "DECFLOAT_FORMAT", "DECODE", "DECRYPT_BIN", "DECRYPT_CHAR", "DEGREES", "DEREF", "DIFFERENCE", "DIGITS", "DOUBLE_PRECISION", "EMPTY_BLOB", "EMPTY_CLOB", "EMPTY_DBCLOB", "EMPTY_NCLOB", "ENCRYPT", "EVENT_MON_STATE", "EXP", "EXTRACT", "FIRST_DAY", "FLOOR", "FROM_UTC_TIMESTAMP", "GENERATE_UNIQUE", "GETHINT", "GREATEST", "HASH", "HASH4", "HASH8", "HASHEDVALUE", "HEX", "HEXTORAW", "HOUR", "HOURS_BETWEEN", "IDENTITY_VAL_LOCAL", "IFNULL", "INITCAP", "INSERT", "INSTR", "INSTR2", "INSTR4", "INSTRB", "INTNAND", "INTNOR", "INTNXOR", "INTNNOT", "ISNULL", "JSON_ARRAY", "JSON_OBJECT", "JSON_QUERY", "JSON_TO_BSON", "JSON_VALUE", "JULIAN_DAY", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LENGTH2", "LENGTH4", "LENGTHB", "LN", "LOCATE", "LOCATE_IN_STRING", "LOG10", "LONG_VARCHAR", "LONG_VARGRAPHIC", "LOWER", "LPAD", "LTRIM", "MAX", "MAX_CARDINALITY", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MINUTES_BETWEEN", "MOD", "MONTH", "MONTHNAME", "MONTHS_BETWEEN", "MULTIPLY_ALT", "NEXT_DAY", "NEXT_MONTH", "NEXT_QUARTER", "NEXT_WEEK", "NEXT_YEAR", "NORMALIZE_DECFLOAT", "NOW", "NULLIF", "NVL", "NVL2", "OCTET_LENGTH", "OVERLAY", "PARAMETER", "POSITION", "POSSTR", "POW", "POWER", "QUANTIZE", "QUARTER", "QUOTE_IDENT", "QUOTE_LITERAL", "RADIANS", "RAISE_ERROR", "RAND", "RANDOM", "RAWTOHEX", "REC2XML", "REGEXP_COUNT", "REGEXP_EXTRACT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_MATCH_COUNT", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RID_BIT", "RIGHT", "ROUND", "ROUND_TIMESTAMP", "RPAD", "RTRIM", "SECLABEL", "SECLABEL_BY_NAME", "SECLABEL_TO_CHAR", "SECOND", "SECONDS_BETWEEN", "SIGN", "SIN", "SINH", "SOUNDEX", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTR2", "SUBSTR4", "SUBSTRB", "SUBSTRING", "TABLE_NAME", "TABLE_SCHEMA", "TAN", "TANH", "THIS_MONTH", "THIS_QUARTER", "THIS_WEEK", "THIS_YEAR", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMPDIFF", "TIMEZONE", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_HEX", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_UTC_TIMESTAMP", "TOTALORDER", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNC_TIMESTAMP", "TRUNCATE", "TRUNC", "TYPE_ID", "TYPE_NAME", "TYPE_SCHEMA", "UCASE", "UNICODE_STR", "UPPER", "VALUE", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT", "VARCHAR_FORMAT_BIT", "VERIFY_GROUP_FOR_USER", "VERIFY_ROLE_FOR_USER", "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER", "WEEK", "WEEK_ISO", "WEEKS_BETWEEN", "WIDTH_BUCKET", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROW", "XMLSERIALIZE", "XMLTEXT", "XMLVALIDATE", "XMLXSROBJECTID", "XSLTRANSFORM", "YEAR", "YEARS_BETWEEN", "YMD_BETWEEN", "BASE_TABLE", "JSON_TABLE", "UNNEST", "XMLTABLE", "RANK", "DENSE_RANK", "NTILE", "LAG", "LEAD", "ROW_NUMBER", "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "RATIO_TO_REPORT", "CAST"],
          extraParens: ["[]"],
          stringTypes: [{
            quote: "''-qq",
            prefixes: ["G", "N", "U&"]
          }, {
            quote: "''-raw",
            prefixes: ["X", "BX", "GX", "UX"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq'],
          identChars: {
            first: "@#$",
            rest: "@#$"
          },
          paramTypes: {
            positional: !0,
            named: [":"]
          },
          paramChars: {
            first: "@#$",
            rest: "@#$"
          },
          operators: ["**", "%", "|", "&", "^", "~", "¬=", "¬>", "¬<", "!>", "!<", "^=", "^>", "^<", "||", "->", "=>"]
        },
        formatOptions: {
          onelineClauses: [...kN, ...BN],
          tabularOnelineClauses: BN
        }
      },
      zN = hN(["SELECT [ALL | DISTINCT]"]),
      $N = hN(["WITH [RECURSIVE]", "INTO", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER [SIBLINGS] BY [INPUT SEQUENCE]", "LIMIT", "OFFSET", "FETCH {FIRST | NEXT}", "FOR UPDATE [OF]", "FOR READ ONLY", "OPTIMIZE FOR", "INSERT INTO", "VALUES", "SET", "MERGE INTO", "WHEN [NOT] MATCHED [THEN]", "UPDATE SET", "DELETE", "INSERT", "FOR SYSTEM NAME"]),
      jN = hN(["CREATE [OR REPLACE] TABLE"]),
      JN = hN(["CREATE [OR REPLACE] [RECURSIVE] VIEW", "UPDATE", "WHERE CURRENT OF", "WITH {NC | RR | RS | CS | UR}", "DELETE FROM", "DROP TABLE", "ALTER TABLE", "ADD [COLUMN]", "ALTER [COLUMN]", "DROP [COLUMN]", "SET DATA TYPE", "SET {GENERATED ALWAYS | GENERATED BY DEFAULT}", "SET NOT NULL", "SET {NOT HIDDEN | IMPLICITLY HIDDEN}", "SET FIELDPROC", "DROP {DEFAULT | NOT NULL | GENERATED | IDENTITY | ROW CHANGE TIMESTAMP | FIELDPROC}", "TRUNCATE [TABLE]", "SET [CURRENT] SCHEMA", "SET CURRENT_SCHEMA", "ALLOCATE CURSOR", "ALLOCATE [SQL] DESCRIPTOR [LOCAL | GLOBAL] SQL", "ALTER [SPECIFIC] {FUNCTION | PROCEDURE}", "ALTER {MASK | PERMISSION | SEQUENCE | TRIGGER}", "ASSOCIATE [RESULT SET] {LOCATOR | LOCATORS}", "BEGIN DECLARE SECTION", "CALL", "CLOSE", "COMMENT ON {ALIAS | COLUMN | CONSTRAINT | INDEX | MASK | PACKAGE | PARAMETER | PERMISSION | SEQUENCE | TABLE | TRIGGER | VARIABLE | XSROBJECT}", "COMMENT ON [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE}", "COMMENT ON PARAMETER SPECIFIC {FUNCTION | PROCEDURE | ROUTINE}", "COMMENT ON [TABLE FUNCTION] RETURN COLUMN", "COMMENT ON [TABLE FUNCTION] RETURN COLUMN SPECIFIC [PROCEDURE | ROUTINE]", "COMMIT [WORK] [HOLD]", "CONNECT [TO | RESET] USER", "CREATE [OR REPLACE] {ALIAS | FUNCTION | MASK | PERMISSION | PROCEDURE | SEQUENCE | TRIGGER | VARIABLE}", "CREATE [ENCODED VECTOR] INDEX", "CREATE UNIQUE [WHERE NOT NULL] INDEX", "CREATE SCHEMA", "CREATE TYPE", "DEALLOCATE [SQL] DESCRIPTOR [LOCAL | GLOBAL]", "DECLARE CURSOR", "DECLARE GLOBAL TEMPORARY TABLE", "DECLARE", "DESCRIBE CURSOR", "DESCRIBE INPUT", "DESCRIBE [OUTPUT]", "DESCRIBE {PROCEDURE | ROUTINE}", "DESCRIBE TABLE", "DISCONNECT ALL [SQL]", "DISCONNECT [CURRENT]", "DROP {ALIAS | INDEX | MASK | PACKAGE | PERMISSION | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT} [IF EXISTS]", "DROP [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE} [IF EXISTS]", "END DECLARE SECTION", "EXECUTE [IMMEDIATE]", "FREE LOCATOR", "GET [SQL] DESCRIPTOR [LOCAL | GLOBAL]", "GET [CURRENT | STACKED] DIAGNOSTICS", "GRANT {ALL [PRIVILEGES] | ALTER | EXECUTE} ON {FUNCTION | PROCEDURE | ROUTINE | PACKAGE | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT}", "HOLD LOCATOR", "INCLUDE", "LABEL ON {ALIAS | COLUMN | CONSTRAINT | INDEX | MASK | PACKAGE | PERMISSION | SEQUENCE | TABLE | TRIGGER | VARIABLE | XSROBJECT}", "LABEL ON [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE}", "LOCK TABLE", "OPEN", "PREPARE", "REFRESH TABLE", "RELEASE", "RELEASE [TO] SAVEPOINT", "RENAME [TABLE | INDEX] TO", "REVOKE {ALL [PRIVILEGES] | ALTER | EXECUTE} ON {FUNCTION | PROCEDURE | ROUTINE | PACKAGE | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT}", "ROLLBACK [WORK] [HOLD | TO SAVEPOINT]", "SAVEPOINT", "SET CONNECTION", "SET CURRENT {DEBUG MODE | DECFLOAT ROUNDING MODE | DEGREE | IMPLICIT XMLPARSE OPTION | TEMPORAL SYSTEM_TIME}", "SET [SQL] DESCRIPTOR [LOCAL | GLOBAL]", "SET ENCRYPTION PASSWORD", "SET OPTION", "SET {[CURRENT [FUNCTION]] PATH | CURRENT_PATH}", "SET RESULT SETS [WITH RETURN [TO CALLER | TO CLIENT]]", "SET SESSION AUTHORIZATION", "SET SESSION_USER", "SET TRANSACTION", "SIGNAL SQLSTATE [VALUE]", "TAG", "TRANSFER OWNERSHIP OF", "WHENEVER {NOT FOUND | SQLERROR | SQLWARNING}"]),
      qN = hN(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]),
      QN = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "[LEFT | RIGHT] EXCEPTION JOIN", "{INNER | CROSS} JOIN"]),
      ZN = hN(["ON DELETE", "ON UPDATE", "SET NULL", "{ROWS | RANGE} BETWEEN"]),
      eI = hN([]),
      tI = {
        name: "db2i",
        tokenizerOptions: {
          reservedSelect: zN,
          reservedClauses: [...$N, ...jN, ...JN],
          reservedSetOperations: qN,
          reservedJoins: QN,
          reservedKeywordPhrases: ZN,
          reservedDataTypePhrases: eI,
          reservedKeywords: ["ABSENT", "ACCORDING", "ACCTNG", "ACTION", "ACTIVATE", "ADD", "ALIAS", "ALL", "ALLOCATE", "ALLOW", "ALTER", "AND", "ANY", "APPEND", "APPLNAME", "ARRAY", "ARRAY_AGG", "ARRAY_TRIM", "AS", "ASC", "ASENSITIVE", "ASSOCIATE", "ATOMIC", "ATTACH", "ATTRIBUTES", "AUTHORIZATION", "AUTONOMOUS", "BEFORE", "BEGIN", "BETWEEN", "BIND", "BSON", "BUFFERPOOL", "BY", "CACHE", "CALL", "CALLED", "CARDINALITY", "CASE", "CAST", "CHECK", "CL", "CLOSE", "CLUSTER", "COLLECT", "COLLECTION", "COLUMN", "COMMENT", "COMMIT", "COMPACT", "COMPARISONS", "COMPRESS", "CONCAT", "CONCURRENT", "CONDITION", "CONNECT", "CONNECT_BY_ROOT", "CONNECTION", "CONSTANT", "CONSTRAINT", "CONTAINS", "CONTENT", "CONTINUE", "COPY", "COUNT", "COUNT_BIG", "CREATE", "CREATEIN", "CROSS", "CUBE", "CUME_DIST", "CURRENT", "CURRENT_DATE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_SERVER", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "CURSOR", "CYCLE", "DATABASE", "DATAPARTITIONNAME", "DATAPARTITIONNUM", "DAY", "DAYS", "DB2GENERAL", "DB2GENRL", "DB2SQL", "DBINFO", "DBPARTITIONNAME", "DBPARTITIONNUM", "DEACTIVATE", "DEALLOCATE", "DECLARE", "DEFAULT", "DEFAULTS", "DEFER", "DEFINE", "DEFINITION", "DELETE", "DELETING", "DENSE_RANK", "DENSERANK", "DESC", "DESCRIBE", "DESCRIPTOR", "DETACH", "DETERMINISTIC", "DIAGNOSTICS", "DISABLE", "DISALLOW", "DISCONNECT", "DISTINCT", "DO", "DOCUMENT", "DROP", "DYNAMIC", "EACH", "ELSE", "ELSEIF", "EMPTY", "ENABLE", "ENCODING", "ENCRYPTION", "END", "END-EXEC", "ENDING", "ENFORCED", "ERROR", "ESCAPE", "EVERY", "EXCEPT", "EXCEPTION", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXTEND", "EXTERNAL", "EXTRACT", "FALSE", "FENCED", "FETCH", "FIELDPROC", "FILE", "FINAL", "FIRST_VALUE", "FOR", "FOREIGN", "FORMAT", "FREE", "FREEPAGE", "FROM", "FULL", "FUNCTION", "GBPCACHE", "GENERAL", "GENERATED", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GROUP", "HANDLER", "HASH", "HASH_ROW", "HASHED_VALUE", "HAVING", "HINT", "HOLD", "HOUR", "HOURS", "IDENTITY", "IF", "IGNORE", "IMMEDIATE", "IMPLICITLY", "IN", "INCLUDE", "INCLUDING", "INCLUSIVE", "INCREMENT", "INDEX", "INDEXBP", "INDICATOR", "INF", "INFINITY", "INHERIT", "INLINE", "INNER", "INOUT", "INSENSITIVE", "INSERT", "INSERTING", "INTEGRITY", "INTERPRET", "INTERSECT", "INTO", "IS", "ISNULL", "ISOLATION", "ITERATE", "JAVA", "JOIN", "JSON", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_EXISTS", "JSON_OBJECT", "JSON_OBJECTAGG", "JSON_QUERY", "JSON_TABLE", "JSON_VALUE", "KEEP", "KEY", "KEYS", "LABEL", "LAG", "LANGUAGE", "LAST_VALUE", "LATERAL", "LEAD", "LEAVE", "LEFT", "LEVEL2", "LIKE", "LIMIT", "LINKTYPE", "LISTAGG", "LOCAL", "LOCALDATE", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCATOR", "LOCK", "LOCKSIZE", "LOG", "LOGGED", "LOOP", "MAINTAINED", "MASK", "MATCHED", "MATERIALIZED", "MAXVALUE", "MERGE", "MICROSECOND", "MICROSECONDS", "MINPCTUSED", "MINUTE", "MINUTES", "MINVALUE", "MIRROR", "MIXED", "MODE", "MODIFIES", "MONTH", "MONTHS", "NAMESPACE", "NAN", "NATIONAL", "NCHAR", "NCLOB", "NESTED", "NEW", "NEW_TABLE", "NEXTVAL", "NO", "NOCACHE", "NOCYCLE", "NODENAME", "NODENUMBER", "NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NORMALIZED", "NOT", "NOTNULL", "NTH_VALUE", "NTILE", "NULL", "NULLS", "NVARCHAR", "OBID", "OBJECT", "OF", "OFF", "OFFSET", "OLD", "OLD_TABLE", "OMIT", "ON", "ONLY", "OPEN", "OPTIMIZE", "OPTION", "OR", "ORDER", "ORDINALITY", "ORGANIZE", "OUT", "OUTER", "OVER", "OVERLAY", "OVERRIDING", "PACKAGE", "PADDED", "PAGE", "PAGESIZE", "PARAMETER", "PART", "PARTITION", "PARTITIONED", "PARTITIONING", "PARTITIONS", "PASSING", "PASSWORD", "PATH", "PCTFREE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERIOD", "PERMISSION", "PIECESIZE", "PIPE", "PLAN", "POSITION", "PREPARE", "PREVVAL", "PRIMARY", "PRIOR", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PROGRAMID", "QUERY", "RANGE", "RANK", "RATIO_TO_REPORT", "RCDFMT", "READ", "READS", "RECOVERY", "REFERENCES", "REFERENCING", "REFRESH", "REGEXP_LIKE", "RELEASE", "RENAME", "REPEAT", "RESET", "RESIGNAL", "RESTART", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNING", "RETURNS", "REVOKE", "RID", "RIGHT", "ROLLBACK", "ROLLUP", "ROUTINE", "ROW", "ROW_NUMBER", "ROWNUMBER", "ROWS", "RRN", "RUN", "SAVEPOINT", "SBCS", "SCALAR", "SCHEMA", "SCRATCHPAD", "SCROLL", "SEARCH", "SECOND", "SECONDS", "SECQTY", "SECURED", "SELECT", "SENSITIVE", "SEQUENCE", "SESSION", "SESSION_USER", "SET", "SIGNAL", "SIMPLE", "SKIP", "SNAN", "SOME", "SOURCE", "SPECIFIC", "SQL", "SQLID", "SQLIND_DEFAULT", "SQLIND_UNASSIGNED", "STACKED", "START", "STARTING", "STATEMENT", "STATIC", "STOGROUP", "SUBSTRING", "SUMMARY", "SYNONYM", "SYSTEM_TIME", "SYSTEM_USER", "TABLE", "TABLESPACE", "TABLESPACES", "TAG", "THEN", "THREADSAFE", "TO", "TRANSACTION", "TRANSFER", "TRIGGER", "TRIM", "TRIM_ARRAY", "TRUE", "TRUNCATE", "TRY_CAST", "TYPE", "UNDO", "UNION", "UNIQUE", "UNIT", "UNKNOWN", "UNNEST", "UNTIL", "UPDATE", "UPDATING", "URI", "USAGE", "USE", "USER", "USERID", "USING", "VALUE", "VALUES", "VARIABLE", "VARIANT", "VCAT", "VERSION", "VERSIONING", "VIEW", "VOLATILE", "WAIT", "WHEN", "WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", "WITHOUT", "WRAPPED", "WRAPPER", "WRITE", "WRKSTNNAME", "XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLGROUP", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLROW", "XMLSERIALIZE", "XMLTABLE", "XMLTEXT", "XMLVALIDATE", "XSLTRANSFORM", "XSROBJECT", "YEAR", "YEARS", "YES", "ZONE"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY", "BIT", "BLOB", "BOOLEAN", "CCSID", "CHAR", "CHARACTER", "CLOB", "DATA", "DATALINK", "DATE", "DBCLOB", "DECFLOAT", "DECIMAL", "DEC", "DOUBLE", "DOUBLE PRECISION", "FLOAT", "GRAPHIC", "INT", "INTEGER", "LONG", "NUMERIC", "REAL", "ROWID", "SMALLINT", "TIME", "TIMESTAMP", "VARBINARY", "VARCHAR", "VARGRAPHIC", "XML"],
          reservedFunctionNames: ["ARRAY_AGG", "AVG", "CORR", "CORRELATION", "COUNT", "COUNT_BIG", "COVAR_POP", "COVARIANCE", "COVAR", "COVAR_SAMP", "COVARIANCE_SAMP", "EVERY", "GROUPING", "JSON_ARRAYAGG", "JSON_OBJECTAGG", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "SOME", "STDDEV_POP", "STDDEV", "STDDEV_SAMP", "SUM", "VAR_POP", "VARIANCE", "VAR", "VAR_SAMP", "VARIANCE_SAMP", "XMLAGG", "XMLGROUP", "ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_HOURS", "ADD_MINUTES", "ADD_MONTHS", "ADD_SECONDS", "ADD_YEARS", "ANTILOG", "ARRAY_MAX_CARDINALITY", "ARRAY_TRIM", "ASCII", "ASIN", "ATAN", "ATAN2", "ATANH", "BASE64_DECODE", "BASE64_ENCODE", "BIT_LENGTH", "BITAND", "BITANDNOT", "BITNOT", "BITOR", "BITXOR", "BSON_TO_JSON", "CARDINALITY", "CEIL", "CEILING", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "COALESCE", "COMPARE_DECFLOAT", "CONCAT", "CONTAINS", "COS", "COSH", "COT", "CURDATE", "CURTIME", "DATABASE", "DATAPARTITIONNAME", "DATAPARTITIONNUM", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK_ISO", "DAYOFWEEK", "DAYOFYEAR", "DAYS", "DBPARTITIONNAME", "DBPARTITIONNUM", "DECFLOAT_FORMAT", "DECFLOAT_SORTKEY", "DECRYPT_BINARY", "DECRYPT_BIT", "DECRYPT_CHAR", "DECRYPT_DB", "DEGREES", "DIFFERENCE", "DIGITS", "DLCOMMENT", "DLLINKTYPE", "DLURLCOMPLETE", "DLURLPATH", "DLURLPATHONLY", "DLURLSCHEME", "DLURLSERVER", "DLVALUE", "DOUBLE_PRECISION", "DOUBLE", "ENCRPYT", "ENCRYPT_AES", "ENCRYPT_AES256", "ENCRYPT_RC2", "ENCRYPT_TDES", "EXP", "EXTRACT", "FIRST_DAY", "FLOOR", "GENERATE_UNIQUE", "GET_BLOB_FROM_FILE", "GET_CLOB_FROM_FILE", "GET_DBCLOB_FROM_FILE", "GET_XML_FILE", "GETHINT", "GREATEST", "HASH_MD5", "HASH_ROW", "HASH_SHA1", "HASH_SHA256", "HASH_SHA512", "HASH_VALUES", "HASHED_VALUE", "HEX", "HEXTORAW", "HOUR", "HTML_ENTITY_DECODE", "HTML_ENTITY_ENCODE", "HTTP_DELETE_BLOB", "HTTP_DELETE", "HTTP_GET_BLOB", "HTTP_GET", "HTTP_PATCH_BLOB", "HTTP_PATCH", "HTTP_POST_BLOB", "HTTP_POST", "HTTP_PUT_BLOB", "HTTP_PUT", "IDENTITY_VAL_LOCAL", "IFNULL", "INSERT", "INSTR", "INTERPRET", "ISFALSE", "ISNOTFALSE", "ISNOTTRUE", "ISTRUE", "JSON_ARRAY", "JSON_OBJECT", "JSON_QUERY", "JSON_TO_BSON", "JSON_UPDATE", "JSON_VALUE", "JULIAN_DAY", "LAND", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LN", "LNOT", "LOCATE_IN_STRING", "LOCATE", "LOG10", "LOR", "LOWER", "LPAD", "LTRIM", "MAX_CARDINALITY", "MAX", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MOD", "MONTH", "MONTHNAME", "MONTHS_BETWEEN", "MQREAD", "MQREADCLOB", "MQRECEIVE", "MQRECEIVECLOB", "MQSEND", "MULTIPLY_ALT", "NEXT_DAY", "NORMALIZE_DECFLOAT", "NOW", "NULLIF", "NVL", "OCTET_LENGTH", "OVERLAY", "PI", "POSITION", "POSSTR", "POW", "POWER", "QUANTIZE", "QUARTER", "RADIANS", "RAISE_ERROR", "RANDOM", "RAND", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RIGHT", "ROUND_TIMESTAMP", "ROUND", "RPAD", "RRN", "RTRIM", "SCORE", "SECOND", "SIGN", "SIN", "SINH", "SOUNDEX", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTRING", "TABLE_NAME", "TABLE_SCHEMA", "TAN", "TANH", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMPDIFF_BIG", "TIMESTAMPDIFF", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP", "TOTALORDER", "TRANSLATE", "TRIM_ARRAY", "TRIM", "TRUNC_TIMESTAMP", "TRUNC", "TRUNCATE", "UCASE", "UPPER", "URL_DECODE", "URL_ENCODE", "VALUE", "VARBINARY_FORMAT", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT_BINARY", "VARCHAR_FORMAT", "VERIFY_GROUP_FOR_USER", "WEEK_ISO", "WEEK", "WRAP", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLROW", "XMLSERIALIZE", "XMLTEXT", "XMLVALIDATE", "XOR", "XSLTRANSFORM", "YEAR", "ZONED", "BASE_TABLE", "HTTP_DELETE_BLOB_VERBOSE", "HTTP_DELETE_VERBOSE", "HTTP_GET_BLOB_VERBOSE", "HTTP_GET_VERBOSE", "HTTP_PATCH_BLOB_VERBOSE", "HTTP_PATCH_VERBOSE", "HTTP_POST_BLOB_VERBOSE", "HTTP_POST_VERBOSE", "HTTP_PUT_BLOB_VERBOSE", "HTTP_PUT_VERBOSE", "JSON_TABLE", "MQREADALL", "MQREADALLCLOB", "MQRECEIVEALL", "MQRECEIVEALLCLOB", "XMLTABLE", "UNPACK", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "CAST"],
          nestedBlockComments: !0,
          extraParens: ["[]"],
          stringTypes: [{
            quote: "''-qq",
            prefixes: ["G", "N"]
          }, {
            quote: "''-raw",
            prefixes: ["X", "BX", "GX", "UX"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq'],
          identChars: {
            first: "@#$",
            rest: "@#$"
          },
          paramTypes: {
            positional: !0,
            named: [":"]
          },
          paramChars: {
            first: "@#$",
            rest: "@#$"
          },
          operators: ["**", "¬=", "¬>", "¬<", "!>", "!<", "||", "=>"]
        },
        formatOptions: {
          onelineClauses: [...jN, ...JN],
          tabularOnelineClauses: JN
        }
      },
      iI = hN(["SELECT [ALL | DISTINCT]"]),
      rI = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY [ALL]", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY [ALL]", "LIMIT", "OFFSET", "USING SAMPLE", "QUALIFY", "INSERT [OR REPLACE] INTO", "VALUES", "DEFAULT VALUES", "SET", "RETURNING"]),
      sI = hN(["CREATE [OR REPLACE] [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"]),
      nI = hN(["UPDATE", "ON CONFLICT", "DELETE FROM", "DROP TABLE [IF EXISTS]", "TRUNCATE", "ALTER TABLE", "ADD [COLUMN] [IF NOT EXISTS]", "ADD PRIMARY KEY", "DROP [COLUMN] [IF EXISTS]", "ALTER [COLUMN]", "RENAME [COLUMN]", "RENAME TO", "SET [DATA] TYPE", "{SET | DROP} DEFAULT", "{SET | DROP} NOT NULL", "CREATE [OR REPLACE] [TEMPORARY | TEMP] {MACRO | FUNCTION}", "DROP MACRO [TABLE] [IF EXISTS]", "DROP FUNCTION [IF EXISTS]", "CREATE [UNIQUE] INDEX [IF NOT EXISTS]", "DROP INDEX [IF EXISTS]", "CREATE [OR REPLACE] SCHEMA [IF NOT EXISTS]", "DROP SCHEMA [IF EXISTS]", "CREATE [OR REPLACE] [PERSISTENT | TEMPORARY] SECRET [IF NOT EXISTS]", "DROP [PERSISTENT | TEMPORARY] SECRET [IF EXISTS]", "CREATE [OR REPLACE] [TEMPORARY | TEMP] SEQUENCE", "DROP SEQUENCE [IF EXISTS]", "CREATE [OR REPLACE] [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]", "DROP VIEW [IF EXISTS]", "ALTER VIEW", "CREATE TYPE", "DROP TYPE [IF EXISTS]", "ANALYZE", "ATTACH [DATABASE] [IF NOT EXISTS]", "DETACH [DATABASE] [IF EXISTS]", "CALL", "[FORCE] CHECKPOINT", "COMMENT ON [TABLE | COLUMN | VIEW | INDEX | SEQUENCE | TYPE | MACRO | MACRO TABLE]", "COPY [FROM DATABASE]", "DESCRIBE", "EXPORT DATABASE", "IMPORT DATABASE", "INSTALL", "LOAD", "PIVOT", "PIVOT_WIDER", "UNPIVOT", "EXPLAIN [ANALYZE]", "SET {LOCAL | SESSION | GLOBAL}", "RESET [LOCAL | SESSION | GLOBAL]", "{SET | RESET} VARIABLE", "SUMMARIZE", "BEGIN TRANSACTION", "ROLLBACK", "COMMIT", "ABORT", "USE", "VACUUM [ANALYZE]", "PREPARE", "EXECUTE", "DEALLOCATE [PREPARE]"]),
      oI = hN(["UNION [ALL | BY NAME]", "EXCEPT [ALL]", "INTERSECT [ALL]"]),
      aI = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "{NATURAL | ASOF} [INNER] JOIN", "{NATURAL | ASOF} {LEFT | RIGHT | FULL} [OUTER] JOIN", "POSITIONAL JOIN", "ANTI JOIN", "SEMI JOIN"]),
      lI = hN(["{ROWS | RANGE | GROUPS} BETWEEN", "SIMILAR TO", "IS [NOT] DISTINCT FROM"]),
      cI = hN(["TIMESTAMP WITH TIME ZONE"]),
      hI = {
        name: "duckdb",
        tokenizerOptions: {
          reservedSelect: iI,
          reservedClauses: [...rI, ...sI, ...nI],
          reservedSetOperations: oI,
          reservedJoins: aI,
          reservedKeywordPhrases: lI,
          reservedDataTypePhrases: cI,
          supportsXor: !0,
          reservedKeywords: ["ALL", "ANALYSE", "ANALYZE", "AND", "ANY", "AS", "ASC", "ATTACH", "ASYMMETRIC", "BOTH", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "CONSTRAINT", "CREATE", "DEFAULT", "DEFERRABLE", "DESC", "DESCRIBE", "DETACH", "DISTINCT", "DO", "ELSE", "END", "EXCEPT", "FALSE", "FETCH", "FOR", "FOREIGN", "FROM", "GRANT", "GROUP", "HAVING", "IN", "INITIALLY", "INTERSECT", "INTO", "IS", "LATERAL", "LEADING", "LIMIT", "NOT", "NULL", "OFFSET", "ON", "ONLY", "OR", "ORDER", "PIVOT", "PIVOT_LONGER", "PIVOT_WIDER", "PLACING", "PRIMARY", "REFERENCES", "RETURNING", "SELECT", "SHOW", "SOME", "SUMMARIZE", "SYMMETRIC", "TABLE", "THEN", "TO", "TRAILING", "TRUE", "UNION", "UNIQUE", "UNPIVOT", "USING", "VARIADIC", "WHEN", "WHERE", "WINDOW", "WITH"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY", "BIT", "BITSTRING", "BLOB", "BOOL", "BOOLEAN", "BPCHAR", "BYTEA", "CHAR", "DATE", "DATETIME", "DEC", "DECIMAL", "DOUBLE", "ENUM", "FLOAT", "FLOAT4", "FLOAT8", "GUID", "HUGEINT", "INET", "INT", "INT1", "INT128", "INT16", "INT2", "INT32", "INT4", "INT64", "INT8", "INTEGER", "INTEGRAL", "INTERVAL", "JSON", "LIST", "LOGICAL", "LONG", "MAP", "NUMERIC", "NVARCHAR", "OID", "REAL", "ROW", "SHORT", "SIGNED", "SMALLINT", "STRING", "STRUCT", "TEXT", "TIME", "TIMESTAMP_MS", "TIMESTAMP_NS", "TIMESTAMP_S", "TIMESTAMP_US", "TIMESTAMP", "TIMESTAMPTZ", "TIMETZ", "TINYINT", "UBIGINT", "UHUGEINT", "UINT128", "UINT16", "UINT32", "UINT64", "UINT8", "UINTEGER", "UNION", "USMALLINT", "UTINYINT", "UUID", "VARBINARY", "VARCHAR"],
          reservedFunctionNames: ["ABS", "ACOS", "ADD", "ADD_PARQUET_KEY", "AGE", "AGGREGATE", "ALIAS", "ALL_PROFILING_OUTPUT", "ANY_VALUE", "APPLY", "APPROX_COUNT_DISTINCT", "APPROX_QUANTILE", "ARBITRARY", "ARGMAX", "ARGMIN", "ARG_MAX", "ARG_MAX_NULL", "ARG_MIN", "ARG_MIN_NULL", "ARRAY_AGG", "ARRAY_AGGR", "ARRAY_AGGREGATE", "ARRAY_APPEND", "ARRAY_APPLY", "ARRAY_CAT", "ARRAY_CONCAT", "ARRAY_CONTAINS", "ARRAY_COSINE_SIMILARITY", "ARRAY_CROSS_PRODUCT", "ARRAY_DISTANCE", "ARRAY_DISTINCT", "ARRAY_DOT_PRODUCT", "ARRAY_EXTRACT", "ARRAY_FILTER", "ARRAY_GRADE_UP", "ARRAY_HAS", "ARRAY_HAS_ALL", "ARRAY_HAS_ANY", "ARRAY_INDEXOF", "ARRAY_INNER_PRODUCT", "ARRAY_INTERSECT", "ARRAY_LENGTH", "ARRAY_POP_BACK", "ARRAY_POP_FRONT", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_PUSH_BACK", "ARRAY_PUSH_FRONT", "ARRAY_REDUCE", "ARRAY_RESIZE", "ARRAY_REVERSE", "ARRAY_REVERSE_SORT", "ARRAY_SELECT", "ARRAY_SLICE", "ARRAY_SORT", "ARRAY_TO_JSON", "ARRAY_TO_STRING", "ARRAY_TRANSFORM", "ARRAY_UNIQUE", "ARRAY_VALUE", "ARRAY_WHERE", "ARRAY_ZIP", "ARROW_SCAN", "ARROW_SCAN_DUMB", "ASCII", "ASIN", "ATAN", "ATAN2", "AVG", "BASE64", "BIN", "BITSTRING", "BITSTRING_AGG", "BIT_AND", "BIT_COUNT", "BIT_LENGTH", "BIT_OR", "BIT_POSITION", "BIT_XOR", "BOOL_AND", "BOOL_OR", "CARDINALITY", "CBRT", "CEIL", "CEILING", "CENTURY", "CHECKPOINT", "CHR", "COLLATIONS", "COL_DESCRIPTION", "COMBINE", "CONCAT", "CONCAT_WS", "CONSTANT_OR_NULL", "CONTAINS", "COPY_DATABASE", "CORR", "COS", "COT", "COUNT", "COUNT_IF", "COUNT_STAR", "COVAR_POP", "COVAR_SAMP", "CREATE_SORT_KEY", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_DATE", "CURRENT_LOCALTIME", "CURRENT_LOCALTIMESTAMP", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_SETTING", "CURRENT_USER", "CURRVAL", "DAMERAU_LEVENSHTEIN", "DATABASE_LIST", "DATABASE_SIZE", "DATEDIFF", "DATEPART", "DATESUB", "DATETRUNC", "DATE_ADD", "DATE_DIFF", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECADE", "DECODE", "DEGREES", "DISABLE_CHECKPOINT_ON_SHUTDOWN", "DISABLE_OBJECT_CACHE", "DISABLE_OPTIMIZER", "DISABLE_PRINT_PROGRESS_BAR", "DISABLE_PROFILE", "DISABLE_PROFILING", "DISABLE_PROGRESS_BAR", "DISABLE_VERIFICATION", "DISABLE_VERIFY_EXTERNAL", "DISABLE_VERIFY_FETCH_ROW", "DISABLE_VERIFY_PARALLELISM", "DISABLE_VERIFY_SERIALIZER", "DIVIDE", "DUCKDB_COLUMNS", "DUCKDB_CONSTRAINTS", "DUCKDB_DATABASES", "DUCKDB_DEPENDENCIES", "DUCKDB_EXTENSIONS", "DUCKDB_FUNCTIONS", "DUCKDB_INDEXES", "DUCKDB_KEYWORDS", "DUCKDB_MEMORY", "DUCKDB_OPTIMIZERS", "DUCKDB_SCHEMAS", "DUCKDB_SECRETS", "DUCKDB_SEQUENCES", "DUCKDB_SETTINGS", "DUCKDB_TABLES", "DUCKDB_TEMPORARY_FILES", "DUCKDB_TYPES", "DUCKDB_VIEWS", "EDIT", "EDITDIST3", "ELEMENT_AT", "ENABLE_CHECKPOINT_ON_SHUTDOWN", "ENABLE_OBJECT_CACHE", "ENABLE_OPTIMIZER", "ENABLE_PRINT_PROGRESS_BAR", "ENABLE_PROFILE", "ENABLE_PROFILING", "ENABLE_PROGRESS_BAR", "ENABLE_VERIFICATION", "ENCODE", "ENDS_WITH", "ENTROPY", "ENUM_CODE", "ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE", "ENUM_RANGE_BOUNDARY", "EPOCH", "EPOCH_MS", "EPOCH_NS", "EPOCH_US", "ERA", "ERROR", "EVEN", "EXP", "FACTORIAL", "FAVG", "FDIV", "FILTER", "FINALIZE", "FIRST", "FLATTEN", "FLOOR", "FMOD", "FORCE_CHECKPOINT", "FORMAT", "FORMATREADABLEDECIMALSIZE", "FORMATREADABLESIZE", "FORMAT_BYTES", "FORMAT_PG_TYPE", "FORMAT_TYPE", "FROM_BASE64", "FROM_BINARY", "FROM_HEX", "FROM_JSON", "FROM_JSON_STRICT", "FSUM", "FUNCTIONS", "GAMMA", "GCD", "GENERATE_SERIES", "GENERATE_SUBSCRIPTS", "GEN_RANDOM_UUID", "GEOMEAN", "GEOMETRIC_MEAN", "GETENV", "GET_BIT", "GET_BLOCK_SIZE", "GET_CURRENT_TIME", "GET_CURRENT_TIMESTAMP", "GLOB", "GRADE_UP", "GREATEST", "GREATEST_COMMON_DIVISOR", "GROUP_CONCAT", "HAMMING", "HASH", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HEX", "HISTOGRAM", "HOUR", "ICU_CALENDAR_NAMES", "ICU_SORT_KEY", "ILIKE_ESCAPE", "IMPORT_DATABASE", "INDEX_SCAN", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "INSTR", "IN_SEARCH_PATH", "ISFINITE", "ISINF", "ISNAN", "ISODOW", "ISOYEAR", "JACCARD", "JARO_SIMILARITY", "JARO_WINKLER_SIMILARITY", "JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_CONTAINS", "JSON_DESERIALIZE_SQL", "JSON_EXECUTE_SERIALIZED_SQL", "JSON_EXTRACT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_EXTRACT_STRING", "JSON_GROUP_ARRAY", "JSON_GROUP_OBJECT", "JSON_GROUP_STRUCTURE", "JSON_KEYS", "JSON_MERGE_PATCH", "JSON_OBJECT", "JSON_QUOTE", "JSON_SERIALIZE_PLAN", "JSON_SERIALIZE_SQL", "JSON_STRUCTURE", "JSON_TRANSFORM", "JSON_TRANSFORM_STRICT", "JSON_TYPE", "JSON_VALID", "JULIAN", "KAHAN_SUM", "KURTOSIS", "KURTOSIS_POP", "LAST", "LAST_DAY", "LCASE", "LCM", "LEAST", "LEAST_COMMON_MULTIPLE", "LEFT", "LEFT_GRAPHEME", "LEN", "LENGTH", "LENGTH_GRAPHEME", "LEVENSHTEIN", "LGAMMA", "LIKE_ESCAPE", "LIST", "LISTAGG", "LIST_AGGR", "LIST_AGGREGATE", "LIST_ANY_VALUE", "LIST_APPEND", "LIST_APPLY", "LIST_APPROX_COUNT_DISTINCT", "LIST_AVG", "LIST_BIT_AND", "LIST_BIT_OR", "LIST_BIT_XOR", "LIST_BOOL_AND", "LIST_BOOL_OR", "LIST_CAT", "LIST_CONCAT", "LIST_CONTAINS", "LIST_COSINE_SIMILARITY", "LIST_COUNT", "LIST_DISTANCE", "LIST_DISTINCT", "LIST_DOT_PRODUCT", "LIST_ELEMENT", "LIST_ENTROPY", "LIST_EXTRACT", "LIST_FILTER", "LIST_FIRST", "LIST_GRADE_UP", "LIST_HAS", "LIST_HAS_ALL", "LIST_HAS_ANY", "LIST_HISTOGRAM", "LIST_INDEXOF", "LIST_INNER_PRODUCT", "LIST_INTERSECT", "LIST_KURTOSIS", "LIST_KURTOSIS_POP", "LIST_LAST", "LIST_MAD", "LIST_MAX", "LIST_MEDIAN", "LIST_MIN", "LIST_MODE", "LIST_PACK", "LIST_POSITION", "LIST_PREPEND", "LIST_PRODUCT", "LIST_REDUCE", "LIST_RESIZE", "LIST_REVERSE", "LIST_REVERSE_SORT", "LIST_SELECT", "LIST_SEM", "LIST_SKEWNESS", "LIST_SLICE", "LIST_SORT", "LIST_STDDEV_POP", "LIST_STDDEV_SAMP", "LIST_STRING_AGG", "LIST_SUM", "LIST_TRANSFORM", "LIST_UNIQUE", "LIST_VALUE", "LIST_VAR_POP", "LIST_VAR_SAMP", "LIST_WHERE", "LIST_ZIP", "LN", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LSMODE", "LTRIM", "MAD", "MAKE_DATE", "MAKE_TIME", "MAKE_TIMESTAMP", "MAKE_TIMESTAMPTZ", "MAP", "MAP_CONCAT", "MAP_ENTRIES", "MAP_EXTRACT", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "MAX", "MAX_BY", "MD5", "MD5_NUMBER", "MD5_NUMBER_LOWER", "MD5_NUMBER_UPPER", "MEAN", "MEDIAN", "METADATA_INFO", "MICROSECOND", "MILLENNIUM", "MILLISECOND", "MIN", "MINUTE", "MIN_BY", "MISMATCHES", "MOD", "MODE", "MONTH", "MONTHNAME", "MULTIPLY", "NEXTAFTER", "NEXTVAL", "NFC_NORMALIZE", "NOT_ILIKE_ESCAPE", "NOT_LIKE_ESCAPE", "NOW", "NULLIF", "OBJ_DESCRIPTION", "OCTET_LENGTH", "ORD", "PARQUET_FILE_METADATA", "PARQUET_KV_METADATA", "PARQUET_METADATA", "PARQUET_SCAN", "PARQUET_SCHEMA", "PARSE_DIRNAME", "PARSE_DIRPATH", "PARSE_FILENAME", "PARSE_PATH", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONVERSION_IS_VISIBLE", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IS_OTHER_TEMP_SCHEMA", "PG_MY_TEMP_SCHEMA", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_POSTMASTER_START_TIME", "PG_SIZE_PRETTY", "PG_TABLE_IS_VISIBLE", "PG_TIMEZONE_NAMES", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PI", "PLATFORM", "POSITION", "POW", "POWER", "PRAGMA_COLLATIONS", "PRAGMA_DATABASE_SIZE", "PRAGMA_METADATA_INFO", "PRAGMA_PLATFORM", "PRAGMA_SHOW", "PRAGMA_STORAGE_INFO", "PRAGMA_TABLE_INFO", "PRAGMA_USER_AGENT", "PRAGMA_VERSION", "PREFIX", "PRINTF", "PRODUCT", "QUANTILE", "QUANTILE_CONT", "QUANTILE_DISC", "QUARTER", "RADIANS", "RANDOM", "RANGE", "READFILE", "READ_BLOB", "READ_CSV", "READ_CSV_AUTO", "READ_JSON", "READ_JSON_AUTO", "READ_JSON_OBJECTS", "READ_JSON_OBJECTS_AUTO", "READ_NDJSON", "READ_NDJSON_AUTO", "READ_NDJSON_OBJECTS", "READ_PARQUET", "READ_TEXT", "REDUCE", "REGEXP_ESCAPE", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_FULL_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REPEAT", "REPEAT_ROW", "REPLACE", "RESERVOIR_QUANTILE", "REVERSE", "RIGHT", "RIGHT_GRAPHEME", "ROUND", "ROUNDBANKERS", "ROUND_EVEN", "ROW", "ROW_TO_JSON", "RPAD", "RTRIM", "SECOND", "SEM", "SEQ_SCAN", "SESSION_USER", "SETSEED", "SET_BIT", "SHA256", "SHA3", "SHELL_ADD_SCHEMA", "SHELL_ESCAPE_CRNL", "SHELL_IDQUOTE", "SHELL_MODULE_SCHEMA", "SHELL_PUTSNL", "SHOBJ_DESCRIPTION", "SHOW", "SHOW_DATABASES", "SHOW_TABLES", "SHOW_TABLES_EXPANDED", "SIGN", "SIGNBIT", "SIN", "SKEWNESS", "SNIFF_CSV", "SPLIT", "SPLIT_PART", "SQL_AUTO_COMPLETE", "SQRT", "STARTS_WITH", "STATS", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STORAGE_INFO", "STRFTIME", "STRING_AGG", "STRING_SPLIT", "STRING_SPLIT_REGEX", "STRING_TO_ARRAY", "STRIP_ACCENTS", "STRLEN", "STRPOS", "STRPTIME", "STRUCT_EXTRACT", "STRUCT_INSERT", "STRUCT_PACK", "STR_SPLIT", "STR_SPLIT_REGEX", "SUBSTR", "SUBSTRING", "SUBSTRING_GRAPHEME", "SUBTRACT", "SUFFIX", "SUM", "SUMKAHAN", "SUMMARY", "SUM_NO_OVERFLOW", "TABLE_INFO", "TAN", "TEST_ALL_TYPES", "TEST_VECTOR_TYPES", "TIMEZONE", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIME_BUCKET", "TODAY", "TO_BASE", "TO_BASE64", "TO_BINARY", "TO_CENTURIES", "TO_DAYS", "TO_DECADES", "TO_HEX", "TO_HOURS", "TO_JSON", "TO_MICROSECONDS", "TO_MILLENNIA", "TO_MILLISECONDS", "TO_MINUTES", "TO_MONTHS", "TO_SECONDS", "TO_TIMESTAMP", "TO_WEEKS", "TO_YEARS", "TRANSACTION_TIMESTAMP", "TRANSLATE", "TRIM", "TRUNC", "TRY_STRPTIME", "TXID_CURRENT", "TYPEOF", "UCASE", "UNBIN", "UNHEX", "UNICODE", "UNION_EXTRACT", "UNION_TAG", "UNION_VALUE", "UNNEST", "UNPIVOT_LIST", "UPPER", "USER", "USER_AGENT", "UUID", "VARIANCE", "VAR_POP", "VAR_SAMP", "VECTOR_TYPE", "VERIFY_EXTERNAL", "VERIFY_FETCH_ROW", "VERIFY_PARALLELISM", "VERIFY_SERIALIZER", "VERSION", "WEEK", "WEEKDAY", "WEEKOFYEAR", "WHICH_SECRET", "WRITEFILE", "XOR", "YEAR", "YEARWEEK", "CAST", "COALESCE", "RANK", "ROW_NUMBER"],
          nestedBlockComments: !0,
          extraParens: ["[]", "{}"],
          underscoresInNumbers: !0,
          stringTypes: ["$$", "''-qq", {
            quote: "''-qq-bs",
            prefixes: ["E"],
            requirePrefix: !0
          }, {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq'],
          identChars: {
            rest: "$"
          },
          paramTypes: {
            positional: !0,
            numbered: ["$"],
            quoted: ["$"]
          },
          operators: ["//", "%", "**", "^", "!", "&", "|", "~", "<<", ">>", "::", "==", "->", "->>", ":", ":=", "=>", "~~", "!~~", "~~*", "!~~*", "~~~", "~", "!~", "~*", "!~*", "^@", "||", ">>=", "<<="]
        },
        formatOptions: {
          alwaysDenseOperators: ["::"],
          onelineClauses: [...sI, ...nI],
          tabularOnelineClauses: nI
        }
      },
      uI = hN(["SELECT [ALL | DISTINCT]"]),
      dI = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "SORT BY", "CLUSTER BY", "DISTRIBUTE BY", "LIMIT", "INSERT INTO [TABLE]", "VALUES", "SET", "MERGE INTO", "WHEN [NOT] MATCHED [THEN]", "UPDATE SET", "INSERT [VALUES]", "INSERT OVERWRITE [LOCAL] DIRECTORY", "LOAD DATA [LOCAL] INPATH", "[OVERWRITE] INTO TABLE"]),
      pI = hN(["CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS]"]),
      EI = hN(["CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]", "UPDATE", "DELETE FROM", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "RENAME TO", "TRUNCATE [TABLE]", "ALTER", "CREATE", "USE", "DESCRIBE", "DROP", "FETCH", "SHOW", "STORED AS", "STORED BY", "ROW FORMAT"]),
      gI = hN(["UNION [ALL | DISTINCT]"]),
      fI = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "LEFT SEMI JOIN"]),
      TI = hN(["{ROWS | RANGE} BETWEEN"]),
      mI = hN([]),
      CI = {
        name: "hive",
        tokenizerOptions: {
          reservedSelect: uI,
          reservedClauses: [...dI, ...pI, ...EI],
          reservedSetOperations: gI,
          reservedJoins: fI,
          reservedKeywordPhrases: TI,
          reservedDataTypePhrases: mI,
          reservedKeywords: ["ADD", "ADMIN", "AFTER", "ANALYZE", "ARCHIVE", "ASC", "BEFORE", "BUCKET", "BUCKETS", "CASCADE", "CHANGE", "CLUSTER", "CLUSTERED", "CLUSTERSTATUS", "COLLECTION", "COLUMNS", "COMMENT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", "CONTINUE", "DATA", "DATABASES", "DATETIME", "DAY", "DBPROPERTIES", "DEFERRED", "DEFINED", "DELIMITED", "DEPENDENCY", "DESC", "DIRECTORIES", "DIRECTORY", "DISABLE", "DISTRIBUTE", "ELEM_TYPE", "ENABLE", "ESCAPED", "EXCLUSIVE", "EXPLAIN", "EXPORT", "FIELDS", "FILE", "FILEFORMAT", "FIRST", "FORMAT", "FORMATTED", "FUNCTIONS", "HOLD_DDLTIME", "HOUR", "IDXPROPERTIES", "IGNORE", "INDEX", "INDEXES", "INPATH", "INPUTDRIVER", "INPUTFORMAT", "ITEMS", "JAR", "KEYS", "KEY_TYPE", "LIMIT", "LINES", "LOAD", "LOCATION", "LOCK", "LOCKS", "LOGICAL", "LONG", "MAPJOIN", "MATERIALIZED", "METADATA", "MINUS", "MINUTE", "MONTH", "MSCK", "NOSCAN", "NO_DROP", "OFFLINE", "OPTION", "OUTPUTDRIVER", "OUTPUTFORMAT", "OVERWRITE", "OWNER", "PARTITIONED", "PARTITIONS", "PLUS", "PRETTY", "PRINCIPALS", "PROTECTION", "PURGE", "READ", "READONLY", "REBUILD", "RECORDREADER", "RECORDWRITER", "RELOAD", "RENAME", "REPAIR", "REPLACE", "REPLICATION", "RESTRICT", "REWRITE", "ROLE", "ROLES", "SCHEMA", "SCHEMAS", "SECOND", "SEMI", "SERDE", "SERDEPROPERTIES", "SERVER", "SETS", "SHARED", "SHOW", "SHOW_DATABASE", "SKEWED", "SORT", "SORTED", "SSL", "STATISTICS", "STORED", "STREAMTABLE", "STRING", "TABLES", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "TINYINT", "TOUCH", "TRANSACTIONS", "UNARCHIVE", "UNDO", "UNIONTYPE", "UNLOCK", "UNSET", "UNSIGNED", "URI", "USE", "UTC", "UTCTIMESTAMP", "VALUE_TYPE", "VIEW", "WHILE", "YEAR", "AUTOCOMMIT", "ISOLATION", "LEVEL", "OFFSET", "SNAPSHOT", "TRANSACTION", "WORK", "WRITE", "ABORT", "KEY", "LAST", "NORELY", "NOVALIDATE", "NULLS", "RELY", "VALIDATE", "DETAIL", "DOW", "EXPRESSION", "OPERATOR", "QUARTER", "SUMMARY", "VECTORIZATION", "WEEK", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "TIMESTAMPTZ", "ZONE", "ALL", "ALTER", "AND", "AS", "AUTHORIZATION", "BETWEEN", "BOTH", "BY", "CASE", "CAST", "COLUMN", "CONF", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURSOR", "DATABASE", "DELETE", "DESCRIBE", "DISTINCT", "DROP", "ELSE", "END", "EXCHANGE", "EXISTS", "EXTENDED", "EXTERNAL", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTION", "GRANT", "GROUP", "GROUPING", "HAVING", "IF", "IMPORT", "IN", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LESS", "LIKE", "LOCAL", "MACRO", "MORE", "NONE", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "OUT", "OUTER", "OVER", "PARTIALSCAN", "PARTITION", "PERCENT", "PRECEDING", "PRESERVE", "PROCEDURE", "RANGE", "READS", "REDUCE", "REVOKE", "RIGHT", "ROLLUP", "ROW", "ROWS", "SELECT", "SET", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRANSFORM", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNION", "UNIQUEJOIN", "UPDATE", "USER", "USING", "UTC_TMESTAMP", "VALUES", "WHEN", "WHERE", "WINDOW", "WITH", "COMMIT", "ONLY", "REGEXP", "RLIKE", "ROLLBACK", "START", "CACHE", "CONSTRAINT", "FOREIGN", "PRIMARY", "REFERENCES", "DAYOFWEEK", "EXTRACT", "FLOOR", "VIEWS", "TIME", "SYNC", "TEXTFILE", "SEQUENCEFILE", "ORC", "CSV", "TSV", "PARQUET", "AVRO", "RCFILE", "JSONFILE", "INPUTFORMAT", "OUTPUTFORMAT"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY", "BOOLEAN", "CHAR", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "INTEGER", "INTERVAL", "MAP", "NUMERIC", "PRECISION", "SMALLINT", "STRUCT", "TIMESTAMP", "VARCHAR"],
          reservedFunctionNames: ["ABS", "ACOS", "ASIN", "ATAN", "BIN", "BROUND", "CBRT", "CEIL", "CEILING", "CONV", "COS", "DEGREES", "EXP", "FACTORIAL", "FLOOR", "GREATEST", "HEX", "LEAST", "LN", "LOG", "LOG10", "LOG2", "NEGATIVE", "PI", "PMOD", "POSITIVE", "POW", "POWER", "RADIANS", "RAND", "ROUND", "SHIFTLEFT", "SHIFTRIGHT", "SHIFTRIGHTUNSIGNED", "SIGN", "SIN", "SQRT", "TAN", "UNHEX", "WIDTH_BUCKET", "ARRAY_CONTAINS", "MAP_KEYS", "MAP_VALUES", "SIZE", "SORT_ARRAY", "BINARY", "CAST", "ADD_MONTHS", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "QUARTER", "SECOND", "TIMESTAMP", "TO_DATE", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_TIMESTAMP", "WEEKOFYEAR", "YEAR", "ASSERT_TRUE", "COALESCE", "IF", "ISNOTNULL", "ISNULL", "NULLIF", "NVL", "ASCII", "BASE64", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONTEXT_NGRAMS", "DECODE", "ELT", "ENCODE", "FIELD", "FIND_IN_SET", "FORMAT_NUMBER", "GET_JSON_OBJECT", "IN_FILE", "INITCAP", "INSTR", "LCASE", "LENGTH", "LEVENSHTEIN", "LOCATE", "LOWER", "LPAD", "LTRIM", "NGRAMS", "OCTET_LENGTH", "PARSE_URL", "PRINTF", "QUOTE", "REGEXP_EXTRACT", "REGEXP_REPLACE", "REPEAT", "REVERSE", "RPAD", "RTRIM", "SENTENCES", "SOUNDEX", "SPACE", "SPLIT", "STR_TO_MAP", "SUBSTR", "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UNBASE64", "UPPER", "MASK", "MASK_FIRST_N", "MASK_HASH", "MASK_LAST_N", "MASK_SHOW_FIRST_N", "MASK_SHOW_LAST_N", "AES_DECRYPT", "AES_ENCRYPT", "CRC32", "CURRENT_DATABASE", "CURRENT_USER", "HASH", "JAVA_METHOD", "LOGGED_IN_USER", "MD5", "REFLECT", "SHA", "SHA1", "SHA2", "SURROGATE_KEY", "VERSION", "AVG", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "HISTOGRAM_NUMERIC", "MAX", "MIN", "NTILE", "PERCENTILE", "PERCENTILE_APPROX", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "EXPLODE", "INLINE", "JSON_TUPLE", "PARSE_URL_TUPLE", "POSEXPLODE", "STACK", "LEAD", "LAG", "FIRST_VALUE", "LAST_VALUE", "RANK", "ROW_NUMBER", "DENSE_RANK", "CUME_DIST", "PERCENT_RANK", "NTILE"],
          extraParens: ["[]"],
          stringTypes: ['""-bs', "''-bs"],
          identTypes: ["``"],
          variableTypes: [{
            quote: "{}",
            prefixes: ["$"],
            requirePrefix: !0
          }],
          operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||"]
        },
        formatOptions: {
          onelineClauses: [...pI, ...EI],
          tabularOnelineClauses: EI
        }
      };

    function SI(e) {
      return e.map((t, i) => {
        const r = e[i + 1] || vN;
        if (IN.SET(t) && "(" === r.text) return Object.assign(Object.assign({}, t), {
          type: RN.RESERVED_FUNCTION_NAME
        });
        const s = e[i - 1] || vN;
        return IN.VALUES(t) && "=" === s.text ? Object.assign(Object.assign({}, t), {
          type: RN.RESERVED_FUNCTION_NAME
        }) : t
      })
    }
    const RI = hN(["SELECT [ALL | DISTINCT | DISTINCTROW]"]),
      AI = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "FETCH {FIRST | NEXT}", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]", "REPLACE [LOW_PRIORITY | DELAYED] [INTO]", "VALUES", "ON DUPLICATE KEY UPDATE", "SET", "RETURNING"]),
      vI = hN(["CREATE [OR REPLACE] [TEMPORARY] TABLE [IF NOT EXISTS]"]),
      NI = hN(["CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]", "UPDATE [LOW_PRIORITY] [IGNORE]", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM", "DROP [TEMPORARY] TABLE [IF EXISTS]", "ALTER [ONLINE] [IGNORE] TABLE [IF EXISTS]", "ADD [COLUMN] [IF NOT EXISTS]", "{CHANGE | MODIFY} [COLUMN] [IF EXISTS]", "DROP [COLUMN] [IF EXISTS]", "RENAME [TO]", "RENAME COLUMN", "ALTER [COLUMN]", "{SET | DROP} DEFAULT", "SET {VISIBLE | INVISIBLE}", "TRUNCATE [TABLE]", "ALTER DATABASE", "ALTER DATABASE COMMENT", "ALTER EVENT", "ALTER FUNCTION", "ALTER PROCEDURE", "ALTER SCHEMA", "ALTER SCHEMA COMMENT", "ALTER SEQUENCE", "ALTER SERVER", "ALTER USER", "ALTER VIEW", "ANALYZE", "ANALYZE TABLE", "BACKUP LOCK", "BACKUP STAGE", "BACKUP UNLOCK", "BEGIN", "BINLOG", "CACHE INDEX", "CALL", "CHANGE MASTER TO", "CHECK TABLE", "CHECK VIEW", "CHECKSUM TABLE", "COMMIT", "CREATE AGGREGATE FUNCTION", "CREATE DATABASE", "CREATE EVENT", "CREATE FUNCTION", "CREATE INDEX", "CREATE PROCEDURE", "CREATE ROLE", "CREATE SEQUENCE", "CREATE SERVER", "CREATE SPATIAL INDEX", "CREATE TRIGGER", "CREATE UNIQUE INDEX", "CREATE USER", "DEALLOCATE PREPARE", "DESCRIBE", "DROP DATABASE", "DROP EVENT", "DROP FUNCTION", "DROP INDEX", "DROP PREPARE", "DROP PROCEDURE", "DROP ROLE", "DROP SEQUENCE", "DROP SERVER", "DROP TRIGGER", "DROP USER", "DROP VIEW", "EXECUTE", "EXPLAIN", "FLUSH", "GET DIAGNOSTICS", "GET DIAGNOSTICS CONDITION", "GRANT", "HANDLER", "HELP", "INSTALL PLUGIN", "INSTALL SONAME", "KILL", "LOAD DATA INFILE", "LOAD INDEX INTO CACHE", "LOAD XML INFILE", "LOCK TABLE", "OPTIMIZE TABLE", "PREPARE", "PURGE BINARY LOGS", "PURGE MASTER LOGS", "RELEASE SAVEPOINT", "RENAME TABLE", "RENAME USER", "REPAIR TABLE", "REPAIR VIEW", "RESET MASTER", "RESET QUERY CACHE", "RESET REPLICA", "RESET SLAVE", "RESIGNAL", "REVOKE", "ROLLBACK", "SAVEPOINT", "SET CHARACTER SET", "SET DEFAULT ROLE", "SET GLOBAL TRANSACTION", "SET NAMES", "SET PASSWORD", "SET ROLE", "SET STATEMENT", "SET TRANSACTION", "SHOW", "SHOW ALL REPLICAS STATUS", "SHOW ALL SLAVES STATUS", "SHOW AUTHORS", "SHOW BINARY LOGS", "SHOW BINLOG EVENTS", "SHOW BINLOG STATUS", "SHOW CHARACTER SET", "SHOW CLIENT_STATISTICS", "SHOW COLLATION", "SHOW COLUMNS", "SHOW CONTRIBUTORS", "SHOW CREATE DATABASE", "SHOW CREATE EVENT", "SHOW CREATE FUNCTION", "SHOW CREATE PACKAGE", "SHOW CREATE PACKAGE BODY", "SHOW CREATE PROCEDURE", "SHOW CREATE SEQUENCE", "SHOW CREATE TABLE", "SHOW CREATE TRIGGER", "SHOW CREATE USER", "SHOW CREATE VIEW", "SHOW DATABASES", "SHOW ENGINE", "SHOW ENGINE INNODB STATUS", "SHOW ENGINES", "SHOW ERRORS", "SHOW EVENTS", "SHOW EXPLAIN", "SHOW FUNCTION CODE", "SHOW FUNCTION STATUS", "SHOW GRANTS", "SHOW INDEX", "SHOW INDEXES", "SHOW INDEX_STATISTICS", "SHOW KEYS", "SHOW LOCALES", "SHOW MASTER LOGS", "SHOW MASTER STATUS", "SHOW OPEN TABLES", "SHOW PACKAGE BODY CODE", "SHOW PACKAGE BODY STATUS", "SHOW PACKAGE STATUS", "SHOW PLUGINS", "SHOW PLUGINS SONAME", "SHOW PRIVILEGES", "SHOW PROCEDURE CODE", "SHOW PROCEDURE STATUS", "SHOW PROCESSLIST", "SHOW PROFILE", "SHOW PROFILES", "SHOW QUERY_RESPONSE_TIME", "SHOW RELAYLOG EVENTS", "SHOW REPLICA", "SHOW REPLICA HOSTS", "SHOW REPLICA STATUS", "SHOW SCHEMAS", "SHOW SLAVE", "SHOW SLAVE HOSTS", "SHOW SLAVE STATUS", "SHOW STATUS", "SHOW STORAGE ENGINES", "SHOW TABLE STATUS", "SHOW TABLES", "SHOW TRIGGERS", "SHOW USER_STATISTICS", "SHOW VARIABLES", "SHOW WARNINGS", "SHOW WSREP_MEMBERSHIP", "SHOW WSREP_STATUS", "SHUTDOWN", "SIGNAL", "START ALL REPLICAS", "START ALL SLAVES", "START REPLICA", "START SLAVE", "START TRANSACTION", "STOP ALL REPLICAS", "STOP ALL SLAVES", "STOP REPLICA", "STOP SLAVE", "UNINSTALL PLUGIN", "UNINSTALL SONAME", "UNLOCK TABLE", "USE", "XA BEGIN", "XA COMMIT", "XA END", "XA PREPARE", "XA RECOVER", "XA ROLLBACK", "XA START"]),
      II = hN(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]", "MINUS [ALL | DISTINCT]"]),
      OI = hN(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL JOIN", "NATURAL {LEFT | RIGHT} [OUTER] JOIN", "STRAIGHT_JOIN"]),
      LI = hN(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN", "IDENTIFIED BY"]),
      _I = hN([]),
      yI = {
        name: "mariadb",
        tokenizerOptions: {
          reservedSelect: RI,
          reservedClauses: [...AI, ...vI, ...NI],
          reservedSetOperations: II,
          reservedJoins: OI,
          reservedKeywordPhrases: LI,
          reservedDataTypePhrases: _I,
          supportsXor: !0,
          reservedKeywords: ["ACCESSIBLE", "ADD", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ASENSITIVE", "BEFORE", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DELETE_DOMAIN_ID", "DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DO_DOMAIN_IDS", "DROP", "DUAL", "EACH", "ELSE", "ELSEIF", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERAL", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IF", "IGNORE", "IGNORE_DOMAIN_IDS", "IGNORE_SERVER_IDS", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSENSITIVE", "INSERT", "INTERSECT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LOOP", "LOW_PRIORITY", "MASTER_HEARTBEAT_PERIOD", "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MOD", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL", "OFFSET", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PAGE_CHECKSUM", "PARSE_VCOL_EXPR", "PARTITION", "POSITION", "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "READ", "READS", "READ_WRITE", "RECURSIVE", "REF_SYSTEM_ID", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETURN", "RETURNING", "REVOKE", "RIGHT", "RLIKE", "ROW_NUMBER", "ROWS", "SCHEMA", "SCHEMAS", "SECOND_MICROSECOND", "SELECT", "SENSITIVE", "SEPARATOR", "SET", "SHOW", "SIGNAL", "SLOW", "SPATIAL", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STARTING", "STATS_AUTO_RECALC", "STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VALUES", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WRITE", "XOR", "YEAR_MONTH", "ZEROFILL"],
          reservedDataTypes: ["BIGINT", "BINARY", "BIT", "BLOB", "CHAR BYTE", "CHAR", "CHARACTER", "DATETIME", "DEC", "DECIMAL", "DOUBLE PRECISION", "DOUBLE", "ENUM", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "LONG", "LONGBLOB", "LONGTEXT", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MIDDLEINT", "NATIONAL CHAR", "NATIONAL VARCHAR", "NUMERIC", "PRECISION", "REAL", "SMALLINT", "TEXT", "TIMESTAMP", "TINYBLOB", "TINYINT", "TINYTEXT", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARYING", "YEAR"],
          reservedFunctionNames: ["ADDDATE", "ADD_MONTHS", "BIT_AND", "BIT_OR", "BIT_XOR", "CAST", "COUNT", "CUME_DIST", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "DATE_FORMAT", "DECODE", "DENSE_RANK", "EXTRACT", "FIRST_VALUE", "GROUP_CONCAT", "JSON_ARRAYAGG", "JSON_OBJECTAGG", "LAG", "LEAD", "MAX", "MEDIAN", "MID", "MIN", "NOW", "NTH_VALUE", "NTILE", "POSITION", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "ROW_NUMBER", "SESSION_USER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUBDATE", "SUBSTR", "SUBSTRING", "SUM", "SYSTEM_USER", "TRIM", "TRIM_ORACLE", "VARIANCE", "VAR_POP", "VAR_SAMP", "ABS", "ACOS", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "ASIN", "ATAN", "ATAN2", "BENCHMARK", "BIN", "BINLOG_GTID_POS", "BIT_COUNT", "BIT_LENGTH", "CEIL", "CEILING", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "COERCIBILITY", "COLUMN_CHECK", "COLUMN_EXISTS", "COLUMN_LIST", "COLUMN_JSON", "COMPRESS", "CONCAT", "CONCAT_OPERATOR_ORACLE", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "DATEDIFF", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DEGREES", "DECODE_HISTOGRAM", "DECODE_ORACLE", "DES_DECRYPT", "DES_ENCRYPT", "ELT", "ENCODE", "ENCRYPT", "EXP", "EXPORT_SET", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GET_LOCK", "GREATEST", "HEX", "IFNULL", "INSTR", "ISNULL", "IS_FREE_LOCK", "IS_USED_LOCK", "JSON_ARRAY", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_COMPACT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_DETAILED", "JSON_EXISTS", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_LOOSE", "JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_QUERY", "JSON_QUOTE", "JSON_OBJECT", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_SEARCH", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "LAST_DAY", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", "LENGTHB", "LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LPAD_ORACLE", "LTRIM", "LTRIM_ORACLE", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_GTID_WAIT", "MASTER_POS_WAIT", "MD5", "MONTHNAME", "NAME_CONST", "NVL", "NVL2", "OCT", "OCTET_LENGTH", "ORD", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POW", "POWER", "QUOTE", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "RADIANS", "RAND", "RELEASE_ALL_LOCKS", "RELEASE_LOCK", "REPLACE_ORACLE", "REVERSE", "ROUND", "RPAD", "RPAD_ORACLE", "RTRIM", "RTRIM_ORACLE", "SEC_TO_TIME", "SHA", "SHA1", "SHA2", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SPACE", "SQRT", "STRCMP", "STR_TO_DATE", "SUBSTR_ORACLE", "SUBSTRING_INDEX", "SUBTIME", "SYS_GUID", "TAN", "TIMEDIFF", "TIME_FORMAT", "TIME_TO_SEC", "TO_BASE64", "TO_CHAR", "TO_DAYS", "TO_SECONDS", "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VERSION", "WEEKDAY", "WEEKOFYEAR", "WSREP_LAST_WRITTEN_GTID", "WSREP_LAST_SEEN_GTID", "WSREP_SYNC_WAIT_UPTO_GTID", "YEARWEEK", "COALESCE", "NULLIF"],
          stringTypes: ['""-qq-bs', "''-qq-bs", {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$",
            allowFirstCharNumber: !0
          },
          variableTypes: [{
            regex: "@@?[A-Za-z0-9_.$]+"
          }, {
            quote: '""-qq-bs',
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "''-qq-bs",
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: !0
          }],
          paramTypes: {
            positional: !0
          },
          lineCommentTypes: ["--", "#"],
          operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "!", "*.*"],
          postProcess: SI
        },
        formatOptions: {
          onelineClauses: [...vI, ...NI],
          tabularOnelineClauses: NI
        }
      },
      wI = hN(["SELECT [ALL | DISTINCT | DISTINCTROW]"]),
      DI = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]", "REPLACE [LOW_PRIORITY | DELAYED] [INTO]", "VALUES", "ON DUPLICATE KEY UPDATE", "SET"]),
      PI = hN(["CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"]),
      bI = hN(["CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]", "UPDATE [LOW_PRIORITY] [IGNORE]", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM", "DROP [TEMPORARY] TABLE [IF EXISTS]", "ALTER TABLE", "ADD [COLUMN]", "{CHANGE | MODIFY} [COLUMN]", "DROP [COLUMN]", "RENAME [TO | AS]", "RENAME COLUMN", "ALTER [COLUMN]", "{SET | DROP} DEFAULT", "TRUNCATE [TABLE]", "ALTER DATABASE", "ALTER EVENT", "ALTER FUNCTION", "ALTER INSTANCE", "ALTER LOGFILE GROUP", "ALTER PROCEDURE", "ALTER RESOURCE GROUP", "ALTER SERVER", "ALTER TABLESPACE", "ALTER USER", "ALTER VIEW", "ANALYZE TABLE", "BINLOG", "CACHE INDEX", "CALL", "CHANGE MASTER TO", "CHANGE REPLICATION FILTER", "CHANGE REPLICATION SOURCE TO", "CHECK TABLE", "CHECKSUM TABLE", "CLONE", "COMMIT", "CREATE DATABASE", "CREATE EVENT", "CREATE FUNCTION", "CREATE FUNCTION", "CREATE INDEX", "CREATE LOGFILE GROUP", "CREATE PROCEDURE", "CREATE RESOURCE GROUP", "CREATE ROLE", "CREATE SERVER", "CREATE SPATIAL REFERENCE SYSTEM", "CREATE TABLESPACE", "CREATE TRIGGER", "CREATE USER", "DEALLOCATE PREPARE", "DESCRIBE", "DROP DATABASE", "DROP EVENT", "DROP FUNCTION", "DROP FUNCTION", "DROP INDEX", "DROP LOGFILE GROUP", "DROP PROCEDURE", "DROP RESOURCE GROUP", "DROP ROLE", "DROP SERVER", "DROP SPATIAL REFERENCE SYSTEM", "DROP TABLESPACE", "DROP TRIGGER", "DROP USER", "DROP VIEW", "EXECUTE", "EXPLAIN", "FLUSH", "GRANT", "HANDLER", "HELP", "IMPORT TABLE", "INSTALL COMPONENT", "INSTALL PLUGIN", "KILL", "LOAD DATA", "LOAD INDEX INTO CACHE", "LOAD XML", "LOCK INSTANCE FOR BACKUP", "LOCK TABLES", "MASTER_POS_WAIT", "OPTIMIZE TABLE", "PREPARE", "PURGE BINARY LOGS", "RELEASE SAVEPOINT", "RENAME TABLE", "RENAME USER", "REPAIR TABLE", "RESET", "RESET MASTER", "RESET PERSIST", "RESET REPLICA", "RESET SLAVE", "RESTART", "REVOKE", "ROLLBACK", "ROLLBACK TO SAVEPOINT", "SAVEPOINT", "SET CHARACTER SET", "SET DEFAULT ROLE", "SET NAMES", "SET PASSWORD", "SET RESOURCE GROUP", "SET ROLE", "SET TRANSACTION", "SHOW", "SHOW BINARY LOGS", "SHOW BINLOG EVENTS", "SHOW CHARACTER SET", "SHOW COLLATION", "SHOW COLUMNS", "SHOW CREATE DATABASE", "SHOW CREATE EVENT", "SHOW CREATE FUNCTION", "SHOW CREATE PROCEDURE", "SHOW CREATE TABLE", "SHOW CREATE TRIGGER", "SHOW CREATE USER", "SHOW CREATE VIEW", "SHOW DATABASES", "SHOW ENGINE", "SHOW ENGINES", "SHOW ERRORS", "SHOW EVENTS", "SHOW FUNCTION CODE", "SHOW FUNCTION STATUS", "SHOW GRANTS", "SHOW INDEX", "SHOW MASTER STATUS", "SHOW OPEN TABLES", "SHOW PLUGINS", "SHOW PRIVILEGES", "SHOW PROCEDURE CODE", "SHOW PROCEDURE STATUS", "SHOW PROCESSLIST", "SHOW PROFILE", "SHOW PROFILES", "SHOW RELAYLOG EVENTS", "SHOW REPLICA STATUS", "SHOW REPLICAS", "SHOW SLAVE", "SHOW SLAVE HOSTS", "SHOW STATUS", "SHOW TABLE STATUS", "SHOW TABLES", "SHOW TRIGGERS", "SHOW VARIABLES", "SHOW WARNINGS", "SHUTDOWN", "SOURCE_POS_WAIT", "START GROUP_REPLICATION", "START REPLICA", "START SLAVE", "START TRANSACTION", "STOP GROUP_REPLICATION", "STOP REPLICA", "STOP SLAVE", "TABLE", "UNINSTALL COMPONENT", "UNINSTALL PLUGIN", "UNLOCK INSTANCE", "UNLOCK TABLES", "USE", "XA", "ITERATE", "LEAVE", "LOOP", "REPEAT", "RETURN", "WHILE"]),
      MI = hN(["UNION [ALL | DISTINCT]"]),
      FI = hN(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT} [OUTER] JOIN", "STRAIGHT_JOIN"]),
      xI = hN(["ON {UPDATE | DELETE} [SET NULL]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN", "IDENTIFIED BY"]),
      GI = hN([]),
      UI = {
        name: "mysql",
        tokenizerOptions: {
          reservedSelect: wI,
          reservedClauses: [...DI, ...PI, ...bI],
          reservedSetOperations: MI,
          reservedJoins: FI,
          reservedKeywordPhrases: xI,
          reservedDataTypePhrases: GI,
          supportsXor: !0,
          reservedKeywords: ["ACCESSIBLE", "ADD", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ASENSITIVE", "BEFORE", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CUBE", "CUME_DIST", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DENSE_RANK", "DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DROP", "DUAL", "EACH", "ELSE", "ELSEIF", "EMPTY", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", "FIRST_VALUE", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "FUNCTION", "GENERATED", "GET", "GRANT", "GROUP", "GROUPING", "GROUPS", "HAVING", "HIGH_PRIORITY", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSENSITIVE", "INSERT", "IN", "INTERSECT", "INTERVAL", "INTO", "IO_AFTER_GTIDS", "IO_BEFORE_GTIDS", "IS", "ITERATE", "JOIN", "JSON_TABLE", "KEY", "KEYS", "KILL", "LAG", "LAST_VALUE", "LATERAL", "LEAD", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LONG", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MOD", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NTH_VALUE", "NTILE", "NULL", "OF", "ON", "OPTIMIZE", "OPTIMIZER_COSTS", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PERCENT_RANK", "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "RANK", "READ", "READS", "READ_WRITE", "RECURSIVE", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETURN", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "ROW_NUMBER", "SCHEMA", "SCHEMAS", "SECOND_MICROSECOND", "SELECT", "SENSITIVE", "SEPARATOR", "SET", "SHOW", "SIGNAL", "SPATIAL", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STARTING", "STORED", "STRAIGHT_JOIN", "SYSTEM", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VALUES", "VIRTUAL", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WRITE", "XOR", "YEAR_MONTH", "ZEROFILL"],
          reservedDataTypes: ["BIGINT", "BINARY", "BIT", "BLOB", "BOOL", "BOOLEAN", "CHAR", "CHARACTER", "DATE", "DATETIME", "DEC", "DECIMAL", "DOUBLE PRECISION", "DOUBLE", "ENUM", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "LONGBLOB", "LONGTEXT", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MIDDLEINT", "NATIONAL CHAR", "NATIONAL VARCHAR", "NUMERIC", "PRECISION", "REAL", "SMALLINT", "TEXT", "TIME", "TIMESTAMP", "TINYBLOB", "TINYINT", "TINYTEXT", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARYING", "YEAR"],
          reservedFunctionNames: ["ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "ANY_VALUE", "ASCII", "ASIN", "ATAN", "ATAN2", "AVG", "BENCHMARK", "BIN", "BIN_TO_UUID", "BINARY", "BIT_AND", "BIT_COUNT", "BIT_LENGTH", "BIT_OR", "BIT_XOR", "CAN_ACCESS_COLUMN", "CAN_ACCESS_DATABASE", "CAN_ACCESS_TABLE", "CAN_ACCESS_USER", "CAN_ACCESS_VIEW", "CAST", "CEIL", "CEILING", "CHAR", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARSET", "COALESCE", "COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT", "CONVERT_TZ", "COS", "COT", "COUNT", "CRC32", "CUME_DIST", "CURDATE", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURTIME", "DATABASE", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DEFAULT", "DEGREES", "DENSE_RANK", "DIV", "ELT", "EXP", "EXPORT_SET", "EXTRACT", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FIRST_VALUE", "FLOOR", "FORMAT", "FORMAT_BYTES", "FORMAT_PICO_TIME", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLECTION", "GEOMETRYCOLLECTION", "GET_DD_COLUMN_PRIVILEGES", "GET_DD_CREATE_OPTIONS", "GET_DD_INDEX_SUB_PART_LENGTH", "GET_FORMAT", "GET_LOCK", "GREATEST", "GROUP_CONCAT", "GROUPING", "GTID_SUBSET", "GTID_SUBTRACT", "HEX", "HOUR", "ICU_VERSION", "IF", "IFNULL", "INET_ATON", "INET_NTOA", "INET6_ATON", "INET6_NTOA", "INSERT", "INSTR", "INTERNAL_AUTO_INCREMENT", "INTERNAL_AVG_ROW_LENGTH", "INTERNAL_CHECK_TIME", "INTERNAL_CHECKSUM", "INTERNAL_DATA_FREE", "INTERNAL_DATA_LENGTH", "INTERNAL_DD_CHAR_LENGTH", "INTERNAL_GET_COMMENT_OR_ERROR", "INTERNAL_GET_ENABLED_ROLE_JSON", "INTERNAL_GET_HOSTNAME", "INTERNAL_GET_USERNAME", "INTERNAL_GET_VIEW_WARNING_OR_ERROR", "INTERNAL_INDEX_COLUMN_CARDINALITY", "INTERNAL_INDEX_LENGTH", "INTERNAL_IS_ENABLED_ROLE", "INTERNAL_IS_MANDATORY_ROLE", "INTERNAL_KEYS_DISABLED", "INTERNAL_MAX_DATA_LENGTH", "INTERNAL_TABLE_ROWS", "INTERNAL_UPDATE_TIME", "INTERVAL", "IS", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", "IS_IPV6", "IS NOT", "IS NOT NULL", "IS NULL", "IS_USED_LOCK", "IS_UUID", "ISNULL", "JSON_ARRAY", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_ARRAYAGG", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG", "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE", "JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "LAG", "LAST_DAY", "LAST_INSERT_ID", "LAST_VALUE", "LCASE", "LEAD", "LEAST", "LEFT", "LENGTH", "LIKE", "LINESTRING", "LN", "LOAD_FILE", "LOCALTIME", "LOCALTIMESTAMP", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM", "MAKE_SET", "MAKEDATE", "MAKETIME", "MASTER_POS_WAIT", "MATCH", "MAX", "MBRCONTAINS", "MBRCOVEREDBY", "MBRCOVERS", "MBRDISJOINT", "MBREQUALS", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", "MBRWITHIN", "MD5", "MEMBER OF", "MICROSECOND", "MID", "MIN", "MINUTE", "MOD", "MONTH", "MONTHNAME", "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", "NAME_CONST", "NOT", "NOT IN", "NOT LIKE", "NOT REGEXP", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "OCT", "OCTET_LENGTH", "ORD", "PERCENT_RANK", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINT", "POLYGON", "POSITION", "POW", "POWER", "PS_CURRENT_THREAD_ID", "PS_THREAD_ID", "QUARTER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES", "RANK", "REGEXP", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "RELEASE_ALL_LOCKS", "RELEASE_LOCK", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RLIKE", "ROLES_GRAPHML", "ROUND", "ROW_COUNT", "ROW_NUMBER", "RPAD", "RTRIM", "SCHEMA", "SEC_TO_TIME", "SECOND", "SESSION_USER", "SHA1", "SHA2", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SOUNDS LIKE", "SOURCE_POS_WAIT", "SPACE", "SQRT", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_BUFFER", "ST_BUFFER_STRATEGY", "ST_CENTROID", "ST_COLLECT", "ST_CONTAINS", "ST_CONVEXHULL", "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DISTANCE_SPHERE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_FRECHETDISTANCE", "ST_GEOHASH", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMGEOJSON", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_HAUSDORFFDISTANCE", "ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISSIMPLE", "ST_ISVALID", "ST_LATFROMGEOHASH", "ST_LATITUDE", "ST_LENGTH", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINEINTERPOLATEPOINT", "ST_LINEINTERPOLATEPOINTS", "ST_LONGFROMGEOHASH", "ST_LONGITUDE", "ST_MAKEENVELOPE", "ST_MLINEFROMTEXT", "ST_MLINEFROMWKB", "ST_MPOINTFROMTEXT", "ST_MPOINTFROMWKB", "ST_MPOLYFROMTEXT", "ST_MPOLYFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTATDISTANCE", "ST_POINTFROMGEOHASH", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_SIMPLIFY", "ST_SRID", "ST_STARTPOINT", "ST_SWAPXY", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_TRANSFORM", "ST_UNION", "ST_VALIDATE", "ST_WITHIN", "ST_X", "ST_Y", "STATEMENT_DIGEST", "STATEMENT_DIGEST_TEXT", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STR_TO_DATE", "STRCMP", "SUBDATE", "SUBSTR", "SUBSTRING", "SUBSTRING_INDEX", "SUBTIME", "SUM", "SYSDATE", "SYSTEM_USER", "TAN", "TIME", "TIME_FORMAT", "TIME_TO_SEC", "TIMEDIFF", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TRIM", "TRUNCATE", "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "UUID", "UUID_SHORT", "UUID_TO_BIN", "VALIDATE_PASSWORD_STRENGTH", "VALUES", "VAR_POP", "VAR_SAMP", "VARIANCE", "VERSION", "WAIT_FOR_EXECUTED_GTID_SET", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEK", "WEEKDAY", "WEEKOFYEAR", "WEIGHT_STRING", "YEAR", "YEARWEEK"],
          stringTypes: ['""-qq-bs', {
            quote: "''-qq-bs",
            prefixes: ["N"]
          }, {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$",
            allowFirstCharNumber: !0
          },
          variableTypes: [{
            regex: "@@?[A-Za-z0-9_.$]+"
          }, {
            quote: '""-qq-bs',
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "''-qq-bs",
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: !0
          }],
          paramTypes: {
            positional: !0
          },
          lineCommentTypes: ["--", "#"],
          operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "->", "->>", "&&", "||", "!", "*.*"],
          postProcess: SI
        },
        formatOptions: {
          onelineClauses: [...PI, ...bI],
          tabularOnelineClauses: bI
        }
      },
      HI = hN(["SELECT [ALL | DISTINCT | DISTINCTROW]"]),
      kI = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]", "REPLACE [LOW_PRIORITY | DELAYED] [INTO]", "VALUES", "ON DUPLICATE KEY UPDATE", "SET"]),
      BI = hN(["CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"]),
      VI = hN(["CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]", "UPDATE [LOW_PRIORITY] [IGNORE]", "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM", "DROP [TEMPORARY] TABLE [IF EXISTS]", "ALTER TABLE", "ADD [COLUMN]", "{CHANGE | MODIFY} [COLUMN]", "DROP [COLUMN]", "RENAME [TO | AS]", "RENAME COLUMN", "ALTER [COLUMN]", "{SET | DROP} DEFAULT", "TRUNCATE [TABLE]", "ALTER DATABASE", "ALTER INSTANCE", "ALTER RESOURCE GROUP", "ALTER SEQUENCE", "ALTER USER", "ALTER VIEW", "ANALYZE TABLE", "CHECK TABLE", "CHECKSUM TABLE", "COMMIT", "CREATE DATABASE", "CREATE INDEX", "CREATE RESOURCE GROUP", "CREATE ROLE", "CREATE SEQUENCE", "CREATE USER", "DEALLOCATE PREPARE", "DESCRIBE", "DROP DATABASE", "DROP INDEX", "DROP RESOURCE GROUP", "DROP ROLE", "DROP TABLESPACE", "DROP USER", "DROP VIEW", "EXPLAIN", "FLUSH", "GRANT", "IMPORT TABLE", "INSTALL COMPONENT", "INSTALL PLUGIN", "KILL", "LOAD DATA", "LOCK INSTANCE FOR BACKUP", "LOCK TABLES", "OPTIMIZE TABLE", "PREPARE", "RELEASE SAVEPOINT", "RENAME TABLE", "RENAME USER", "REPAIR TABLE", "RESET", "REVOKE", "ROLLBACK", "ROLLBACK TO SAVEPOINT", "SAVEPOINT", "SET CHARACTER SET", "SET DEFAULT ROLE", "SET NAMES", "SET PASSWORD", "SET RESOURCE GROUP", "SET ROLE", "SET TRANSACTION", "SHOW", "SHOW BINARY LOGS", "SHOW BINLOG EVENTS", "SHOW CHARACTER SET", "SHOW COLLATION", "SHOW COLUMNS", "SHOW CREATE DATABASE", "SHOW CREATE TABLE", "SHOW CREATE USER", "SHOW CREATE VIEW", "SHOW DATABASES", "SHOW ENGINE", "SHOW ENGINES", "SHOW ERRORS", "SHOW EVENTS", "SHOW GRANTS", "SHOW INDEX", "SHOW MASTER STATUS", "SHOW OPEN TABLES", "SHOW PLUGINS", "SHOW PRIVILEGES", "SHOW PROCESSLIST", "SHOW PROFILE", "SHOW PROFILES", "SHOW STATUS", "SHOW TABLE STATUS", "SHOW TABLES", "SHOW TRIGGERS", "SHOW VARIABLES", "SHOW WARNINGS", "TABLE", "UNINSTALL COMPONENT", "UNINSTALL PLUGIN", "UNLOCK INSTANCE", "UNLOCK TABLES", "USE"]),
      WI = hN(["UNION [ALL | DISTINCT]"]),
      YI = hN(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT} [OUTER] JOIN", "STRAIGHT_JOIN"]),
      KI = hN(["ON {UPDATE | DELETE} [SET NULL]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN", "IDENTIFIED BY"]),
      XI = hN([]),
      zI = {
        name: "tidb",
        tokenizerOptions: {
          reservedSelect: HI,
          reservedClauses: [...kI, ...BI, ...VI],
          reservedSetOperations: WI,
          reservedJoins: YI,
          reservedKeywordPhrases: KI,
          reservedDataTypePhrases: XI,
          supportsXor: !0,
          reservedKeywords: ["ADD", "ALL", "ALTER", "ANALYZE", "AND", "ARRAY", "AS", "ASC", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CHECK", "COLLATE", "COLUMN", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DISTINCT", "DISTINCTROW", "DIV", "DOUBLE", "DROP", "DUAL", "ELSE", "ELSEIF", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GRANT", "GROUP", "GROUPS", "HAVING", "HIGH_PRIORITY", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IF", "IGNORE", "ILIKE", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", "INTERSECT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LONG", "LOW_PRIORITY", "MATCH", "MAXVALUE", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MOD", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL", "OF", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY", "PROCEDURE", "RANGE", "READ", "RECURSIVE", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESTRICT", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "SECOND_MICROSECOND", "SELECT", "SET", "SHOW", "SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STARTING", "STATS_EXTENDED", "STORED", "STRAIGHT_JOIN", "TABLE", "TABLESAMPLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "TiDB_CURRENT_TSO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UNTIL", "UPDATE", "USAGE", "USE", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VALUES", "VIRTUAL", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WRITE", "XOR", "YEAR_MONTH", "ZEROFILL"],
          reservedDataTypes: ["BIGINT", "BINARY", "BIT", "BLOB", "BOOL", "BOOLEAN", "CHAR", "CHARACTER", "DATE", "DATETIME", "DEC", "DECIMAL", "DOUBLE PRECISION", "DOUBLE", "ENUM", "FIXED", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "LONGBLOB", "LONGTEXT", "MEDIUMBLOB", "MEDIUMINT", "MIDDLEINT", "NATIONAL CHAR", "NATIONAL VARCHAR", "NUMERIC", "PRECISION", "SMALLINT", "TEXT", "TIME", "TIMESTAMP", "TINYBLOB", "TINYINT", "TINYTEXT", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARYING", "YEAR"],
          reservedFunctionNames: ["ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "ANY_VALUE", "ASCII", "ASIN", "ATAN", "ATAN2", "AVG", "BENCHMARK", "BIN", "BIN_TO_UUID", "BIT_AND", "BIT_COUNT", "BIT_LENGTH", "BIT_OR", "BIT_XOR", "BITAND", "BITNEG", "BITOR", "BITXOR", "CASE", "CAST", "CEIL", "CEILING", "CHAR_FUNC", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARSET", "COALESCE", "COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT", "CONVERT_TZ", "COS", "COT", "COUNT", "CRC32", "CUME_DIST", "CURDATE", "CURRENT_DATE", "CURRENT_RESOURCE_GROUP", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURTIME", "DATABASE", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEFAULT_FUNC", "DEGREES", "DENSE_RANK", "DES_DECRYPT", "DES_ENCRYPT", "DIV", "ELT", "ENCODE", "ENCRYPT", "EQ", "EXP", "EXPORT_SET", "EXTRACT", "FIELD", "FIND_IN_SET", "FIRST_VALUE", "FLOOR", "FORMAT", "FORMAT_BYTES", "FORMAT_NANO_TIME", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GE", "GET_FORMAT", "GET_LOCK", "GETPARAM", "GREATEST", "GROUP_CONCAT", "GROUPING", "GT", "HEX", "HOUR", "IF", "IFNULL", "ILIKE", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", "INSERT_FUNC", "INSTR", "INTDIV", "INTERVAL", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", "IS_IPV6", "IS_USED_LOCK", "IS_UUID", "ISFALSE", "ISNULL", "ISTRUE", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MEMBEROF", "JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG", "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE", "JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "LAG", "LAST_DAY", "LAST_INSERT_ID", "LAST_VALUE", "LASTVAL", "LCASE", "LE", "LEAD", "LEAST", "LEFT", "LEFTSHIFT", "LENGTH", "LIKE", "LN", "LOAD_FILE", "LOCALTIME", "LOCALTIMESTAMP", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LT", "LTRIM", "MAKE_SET", "MAKEDATE", "MAKETIME", "MASTER_POS_WAIT", "MAX", "MD5", "MICROSECOND", "MID", "MIN", "MINUS", "MINUTE", "MOD", "MONTH", "MONTHNAME", "MUL", "NAME_CONST", "NE", "NEXTVAL", "NOT", "NOW", "NTH_VALUE", "NTILE", "NULLEQ", "OCT", "OCTET_LENGTH", "OLD_PASSWORD", "ORD", "PASSWORD_FUNC", "PERCENT_RANK", "PERIOD_ADD", "PERIOD_DIFF", "PI", "PLUS", "POSITION", "POW", "POWER", "QUARTER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES", "RANK", "REGEXP", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "RELEASE_ALL_LOCKS", "RELEASE_LOCK", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RIGHTSHIFT", "ROUND", "ROW_COUNT", "ROW_NUMBER", "RPAD", "RTRIM", "SCHEMA", "SEC_TO_TIME", "SECOND", "SESSION_USER", "SETVAL", "SETVAR", "SHA", "SHA1", "SHA2", "SIGN", "SIN", "SLEEP", "SM3", "SPACE", "SQRT", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STR_TO_DATE", "STRCMP", "SUBDATE", "SUBSTR", "SUBSTRING", "SUBSTRING_INDEX", "SUBTIME", "SUM", "SYSDATE", "SYSTEM_USER", "TAN", "TIDB_BOUNDED_STALENESS", "TIDB_CURRENT_TSO", "TIDB_DECODE_BINARY_PLAN", "TIDB_DECODE_KEY", "TIDB_DECODE_PLAN", "TIDB_DECODE_SQL_DIGESTS", "TIDB_ENCODE_SQL_DIGEST", "TIDB_IS_DDL_OWNER", "TIDB_PARSE_TSO", "TIDB_PARSE_TSO_LOGICAL", "TIDB_ROW_CHECKSUM", "TIDB_SHARD", "TIDB_VERSION", "TIME", "TIME_FORMAT", "TIME_TO_SEC", "TIMEDIFF", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TRANSLATE", "TRIM", "TRUNCATE", "UCASE", "UNARYMINUS", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", "UPPER", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "UUID", "UUID_SHORT", "UUID_TO_BIN", "VALIDATE_PASSWORD_STRENGTH", "VAR_POP", "VAR_SAMP", "VARIANCE", "VERSION", "VITESS_HASH", "WEEK", "WEEKDAY", "WEEKOFYEAR", "WEIGHT_STRING", "YEAR", "YEARWEEK"],
          stringTypes: ['""-qq-bs', {
            quote: "''-qq-bs",
            prefixes: ["N"]
          }, {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$",
            allowFirstCharNumber: !0
          },
          variableTypes: [{
            regex: "@@?[A-Za-z0-9_.$]+"
          }, {
            quote: '""-qq-bs',
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "''-qq-bs",
            prefixes: ["@"],
            requirePrefix: !0
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: !0
          }],
          paramTypes: {
            positional: !0
          },
          lineCommentTypes: ["--", "#"],
          operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "->", "->>", "&&", "||", "!", "*.*"],
          postProcess: SI
        },
        formatOptions: {
          onelineClauses: [...BI, ...VI],
          tabularOnelineClauses: VI
        }
      },
      $I = hN(["SELECT [ALL | DISTINCT]"]),
      jI = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT INTO", "VALUES", "SET", "MERGE INTO", "WHEN [NOT] MATCHED THEN", "UPDATE SET", "INSERT", "NEST", "UNNEST", "RETURNING"]),
      JI = hN(["UPDATE", "DELETE FROM", "SET SCHEMA", "ADVISE", "ALTER INDEX", "BEGIN TRANSACTION", "BUILD INDEX", "COMMIT TRANSACTION", "CREATE COLLECTION", "CREATE FUNCTION", "CREATE INDEX", "CREATE PRIMARY INDEX", "CREATE SCOPE", "DROP COLLECTION", "DROP FUNCTION", "DROP INDEX", "DROP PRIMARY INDEX", "DROP SCOPE", "EXECUTE", "EXECUTE FUNCTION", "EXPLAIN", "GRANT", "INFER", "PREPARE", "REVOKE", "ROLLBACK TRANSACTION", "SAVEPOINT", "SET TRANSACTION", "UPDATE STATISTICS", "UPSERT", "LET", "SET CURRENT SCHEMA", "SHOW", "USE [PRIMARY] KEYS"]),
      qI = hN(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]),
      QI = hN(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "INNER JOIN"]),
      ZI = hN(["{ROWS | RANGE | GROUPS} BETWEEN"]),
      eO = hN([]),
      tO = {
        name: "n1ql",
        tokenizerOptions: {
          reservedSelect: $I,
          reservedClauses: [...jI, ...JI],
          reservedSetOperations: qI,
          reservedJoins: QI,
          reservedKeywordPhrases: ZI,
          reservedDataTypePhrases: eO,
          supportsXor: !0,
          reservedKeywords: ["ADVISE", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BEGIN", "BETWEEN", "BINARY", "BOOLEAN", "BREAK", "BUCKET", "BUILD", "BY", "CALL", "CASE", "CAST", "CLUSTER", "COLLATE", "COLLECTION", "COMMIT", "COMMITTED", "CONNECT", "CONTINUE", "CORRELATED", "COVER", "CREATE", "CURRENT", "DATABASE", "DATASET", "DATASTORE", "DECLARE", "DECREMENT", "DELETE", "DERIVED", "DESC", "DESCRIBE", "DISTINCT", "DO", "DROP", "EACH", "ELEMENT", "ELSE", "END", "EVERY", "EXCEPT", "EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FILTER", "FIRST", "FLATTEN", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FROM", "FTS", "FUNCTION", "GOLANG", "GRANT", "GROUP", "GROUPS", "GSI", "HASH", "HAVING", "IF", "IGNORE", "ILIKE", "IN", "INCLUDE", "INCREMENT", "INDEX", "INFER", "INLINE", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "ISOLATION", "JAVASCRIPT", "JOIN", "KEY", "KEYS", "KEYSPACE", "KNOWN", "LANGUAGE", "LAST", "LEFT", "LET", "LETTING", "LEVEL", "LIKE", "LIMIT", "LSM", "MAP", "MAPPING", "MATCHED", "MATERIALIZED", "MERGE", "MINUS", "MISSING", "NAMESPACE", "NEST", "NL", "NO", "NOT", "NTH_VALUE", "NULL", "NULLS", "NUMBER", "OBJECT", "OFFSET", "ON", "OPTION", "OPTIONS", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARSE", "PARTITION", "PASSWORD", "PATH", "POOL", "PRECEDING", "PREPARE", "PRIMARY", "PRIVATE", "PRIVILEGE", "PROBE", "PROCEDURE", "PUBLIC", "RANGE", "RAW", "REALM", "REDUCE", "RENAME", "RESPECT", "RETURN", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROW", "ROWS", "SATISFIES", "SAVEPOINT", "SCHEMA", "SCOPE", "SELECT", "SELF", "SEMI", "SET", "SHOW", "SOME", "START", "STATISTICS", "STRING", "SYSTEM", "THEN", "TIES", "TO", "TRAN", "TRANSACTION", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UNSET", "UPDATE", "UPSERT", "USE", "USER", "USING", "VALIDATE", "VALUE", "VALUED", "VALUES", "VIA", "VIEW", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WORK", "XOR"],
          reservedDataTypes: [],
          reservedFunctionNames: ["ABORT", "ABS", "ACOS", "ADVISOR", "ARRAY_AGG", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_AVG", "ARRAY_BINARY_SEARCH", "ARRAY_CONCAT", "ARRAY_CONTAINS", "ARRAY_COUNT", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_FLATTEN", "ARRAY_IFNULL", "ARRAY_INSERT", "ARRAY_INTERSECT", "ARRAY_LENGTH", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_MOVE", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_PUT", "ARRAY_RANGE", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_REPLACE", "ARRAY_REVERSE", "ARRAY_SORT", "ARRAY_STAR", "ARRAY_SUM", "ARRAY_SYMDIFF", "ARRAY_SYMDIFF1", "ARRAY_SYMDIFFN", "ARRAY_UNION", "ASIN", "ATAN", "ATAN2", "AVG", "BASE64", "BASE64_DECODE", "BASE64_ENCODE", "BITAND ", "BITCLEAR ", "BITNOT ", "BITOR ", "BITSET ", "BITSHIFT ", "BITTEST ", "BITXOR ", "CEIL", "CLOCK_LOCAL", "CLOCK_MILLIS", "CLOCK_STR", "CLOCK_TZ", "CLOCK_UTC", "COALESCE", "CONCAT", "CONCAT2", "CONTAINS", "CONTAINS_TOKEN", "CONTAINS_TOKEN_LIKE", "CONTAINS_TOKEN_REGEXP", "COS", "COUNT", "COUNT", "COUNTN", "CUME_DIST", "CURL", "DATE_ADD_MILLIS", "DATE_ADD_STR", "DATE_DIFF_MILLIS", "DATE_DIFF_STR", "DATE_FORMAT_STR", "DATE_PART_MILLIS", "DATE_PART_STR", "DATE_RANGE_MILLIS", "DATE_RANGE_STR", "DATE_TRUNC_MILLIS", "DATE_TRUNC_STR", "DECODE", "DECODE_JSON", "DEGREES", "DENSE_RANK", "DURATION_TO_STR", "ENCODED_SIZE", "ENCODE_JSON", "EXP", "FIRST_VALUE", "FLOOR", "GREATEST", "HAS_TOKEN", "IFINF", "IFMISSING", "IFMISSINGORNULL", "IFNAN", "IFNANORINF", "IFNULL", "INITCAP", "ISARRAY", "ISATOM", "ISBITSET", "ISBOOLEAN", "ISNUMBER", "ISOBJECT", "ISSTRING", "LAG", "LAST_VALUE", "LEAD", "LEAST", "LENGTH", "LN", "LOG", "LOWER", "LTRIM", "MAX", "MEAN", "MEDIAN", "META", "MILLIS", "MILLIS_TO_LOCAL", "MILLIS_TO_STR", "MILLIS_TO_TZ", "MILLIS_TO_UTC", "MILLIS_TO_ZONE_NAME", "MIN", "MISSINGIF", "NANIF", "NEGINFIF", "NOW_LOCAL", "NOW_MILLIS", "NOW_STR", "NOW_TZ", "NOW_UTC", "NTH_VALUE", "NTILE", "NULLIF", "NVL", "NVL2", "OBJECT_ADD", "OBJECT_CONCAT", "OBJECT_INNER_PAIRS", "OBJECT_INNER_VALUES", "OBJECT_LENGTH", "OBJECT_NAMES", "OBJECT_PAIRS", "OBJECT_PUT", "OBJECT_REMOVE", "OBJECT_RENAME", "OBJECT_REPLACE", "OBJECT_UNWRAP", "OBJECT_VALUES", "PAIRS", "PERCENT_RANK", "PI", "POLY_LENGTH", "POSINFIF", "POSITION", "POWER", "RADIANS", "RANDOM", "RANK", "RATIO_TO_REPORT", "REGEXP_CONTAINS", "REGEXP_LIKE", "REGEXP_MATCHES", "REGEXP_POSITION", "REGEXP_REPLACE", "REGEXP_SPLIT", "REGEX_CONTAINS", "REGEX_LIKE", "REGEX_MATCHES", "REGEX_POSITION", "REGEX_REPLACE", "REGEX_SPLIT", "REPEAT", "REPLACE", "REVERSE", "ROUND", "ROW_NUMBER", "RTRIM", "SEARCH", "SEARCH_META", "SEARCH_SCORE", "SIGN", "SIN", "SPLIT", "SQRT", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STR_TO_DURATION", "STR_TO_MILLIS", "STR_TO_TZ", "STR_TO_UTC", "STR_TO_ZONE_NAME", "SUBSTR", "SUFFIXES", "SUM", "TAN", "TITLE", "TOARRAY", "TOATOM", "TOBOOLEAN", "TOKENS", "TOKENS", "TONUMBER", "TOOBJECT", "TOSTRING", "TRIM", "TRUNC", "UPPER", "UUID", "VARIANCE", "VARIANCE_POP", "VARIANCE_SAMP", "VAR_POP", "VAR_SAMP", "WEEKDAY_MILLIS", "WEEKDAY_STR", "CAST"],
          stringTypes: ['""-bs', "''-bs"],
          identTypes: ["``"],
          extraParens: ["[]", "{}"],
          paramTypes: {
            positional: !0,
            numbered: ["$"],
            named: ["$"]
          },
          lineCommentTypes: ["#", "--"],
          operators: ["%", "==", ":", "||"]
        },
        formatOptions: {
          onelineClauses: JI
        }
      },
      iO = hN(["SELECT [ALL | DISTINCT | UNIQUE]"]),
      rO = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER [SIBLINGS] BY", "OFFSET", "FETCH {FIRST | NEXT}", "FOR UPDATE [OF]", "INSERT [INTO | ALL INTO]", "VALUES", "SET", "MERGE [INTO]", "WHEN [NOT] MATCHED [THEN]", "UPDATE SET", "RETURNING"]),
      sO = hN(["CREATE [GLOBAL TEMPORARY | PRIVATE TEMPORARY | SHARDED | DUPLICATED | IMMUTABLE BLOCKCHAIN | BLOCKCHAIN | IMMUTABLE] TABLE"]),
      nO = hN(["CREATE [OR REPLACE] [NO FORCE | FORCE] [EDITIONING | EDITIONABLE | EDITIONABLE EDITIONING | NONEDITIONABLE] VIEW", "CREATE MATERIALIZED VIEW", "UPDATE [ONLY]", "DELETE FROM [ONLY]", "DROP TABLE", "ALTER TABLE", "ADD", "DROP {COLUMN | UNUSED COLUMNS | COLUMNS CONTINUE}", "MODIFY", "RENAME TO", "RENAME COLUMN", "TRUNCATE TABLE", "SET SCHEMA", "BEGIN", "CONNECT BY", "DECLARE", "EXCEPT", "EXCEPTION", "LOOP", "START WITH"]),
      oO = hN(["UNION [ALL]", "MINUS", "INTERSECT"]),
      aO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN", "{CROSS | OUTER} APPLY"]),
      lO = hN(["ON {UPDATE | DELETE} [SET NULL]", "ON COMMIT", "{ROWS | RANGE} BETWEEN"]),
      cO = hN([]),
      hO = {
        name: "plsql",
        tokenizerOptions: {
          reservedSelect: iO,
          reservedClauses: [...rO, ...sO, ...nO],
          reservedSetOperations: oO,
          reservedJoins: aO,
          reservedKeywordPhrases: lO,
          reservedDataTypePhrases: cO,
          supportsXor: !0,
          reservedKeywords: ["ADD", "AGENT", "AGGREGATE", "ALL", "ALTER", "AND", "ANY", "ARROW", "AS", "ASC", "AT", "ATTRIBUTE", "AUTHID", "AVG", "BEGIN", "BETWEEN", "BLOCK", "BODY", "BOTH", "BOUND", "BULK", "BY", "BYTE", "CALL", "CALLING", "CASCADE", "CASE", "CHARSET", "CHARSETFORM", "CHARSETID", "CHECK", "CLOSE", "CLUSTER", "CLUSTERS", "COLAUTH", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPILED", "COMPRESS", "CONNECT", "CONSTANT", "CONSTRUCTOR", "CONTEXT", "CONVERT", "COUNT", "CRASH", "CREATE", "CURRENT", "CURSOR", "CUSTOMDATUM", "DANGLING", "DATA", "DAY", "DECLARE", "DEFAULT", "DEFINE", "DELETE", "DESC", "DETERMINISTIC", "DISTINCT", "DROP", "DURATION", "ELEMENT", "ELSE", "ELSIF", "EMPTY", "END", "ESCAPE", "EXCEPT", "EXCEPTION", "EXCEPTIONS", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", "FINAL", "FIXED", "FOR", "FORALL", "FORCE", "FORM", "FROM", "FUNCTION", "GENERAL", "GOTO", "GRANT", "GROUP", "HASH", "HAVING", "HEAP", "HIDDEN", "HOUR", "IDENTIFIED", "IF", "IMMEDIATE", "IN", "INCLUDING", "INDEX", "INDEXES", "INDICATOR", "INDICES", "INFINITE", "INSERT", "INSTANTIABLE", "INTERFACE", "INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "JAVA", "LANGUAGE", "LARGE", "LEADING", "LENGTH", "LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LIMITED", "LOCAL", "LOCK", "LOOP", "MAP", "MAX", "MAXLEN", "MEMBER", "MERGE", "MIN", "MINUS", "MINUTE", "MOD", "MODE", "MODIFY", "MONTH", "MULTISET", "NAME", "NAN", "NATIONAL", "NATIVE", "NEW", "NOCOMPRESS", "NOCOPY", "NOT", "NOWAIT", "NULL", "OBJECT", "OCICOLL", "OCIDATE", "OCIDATETIME", "OCIDURATION", "OCIINTERVAL", "OCILOBLOCATOR", "OCINUMBER", "OCIRAW", "OCIREF", "OCIREFCURSOR", "OCIROWID", "OCISTRING", "OCITYPE", "OF", "ON", "ONLY", "OPAQUE", "OPEN", "OPERATOR", "OPTION", "OR", "ORACLE", "ORADATA", "ORDER", "OVERLAPS", "ORGANIZATION", "ORLANY", "ORLVARY", "OTHERS", "OUT", "OVERRIDING", "PACKAGE", "PARALLEL_ENABLE", "PARAMETER", "PARAMETERS", "PARTITION", "PASCAL", "PIPE", "PIPELINED", "PRAGMA", "PRIOR", "PRIVATE", "PROCEDURE", "PUBLIC", "RAISE", "RANGE", "READ", "RECORD", "REF", "REFERENCE", "REM", "REMAINDER", "RENAME", "RESOURCE", "RESULT", "RETURN", "RETURNING", "REVERSE", "REVOKE", "ROLLBACK", "ROW", "SAMPLE", "SAVE", "SAVEPOINT", "SB1", "SB2", "SB4", "SECOND", "SEGMENT", "SELECT", "SELF", "SEPARATE", "SEQUENCE", "SERIALIZABLE", "SET", "SHARE", "SHORT", "SIZE", "SIZE_T", "SOME", "SPARSE", "SQL", "SQLCODE", "SQLDATA", "SQLNAME", "SQLSTATE", "STANDARD", "START", "STATIC", "STDDEV", "STORED", "STRING", "STRUCT", "STYLE", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", "SUBTYPE", "SUM", "SYNONYM", "TABAUTH", "TABLE", "TDO", "THE", "THEN", "TIME", "TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", "TO", "TRAILING", "TRANSAC", "TRANSACTIONAL", "TRUSTED", "TYPE", "UB1", "UB2", "UB4", "UNDER", "UNION", "UNIQUE", "UNSIGNED", "UNTRUSTED", "UPDATE", "USE", "USING", "VALIST", "VALUE", "VALUES", "VARIABLE", "VARIANCE", "VARRAY", "VIEW", "VIEWS", "VOID", "WHEN", "WHERE", "WHILE", "WITH", "WORK", "WRAPPED", "WRITE", "YEAR", "ZONE"],
          reservedDataTypes: ["ARRAY", "BFILE_BASE", "BINARY", "BLOB_BASE", "CHAR VARYING", "CHAR_BASE", "CHAR", "CHARACTER VARYING", "CHARACTER", "CLOB_BASE", "DATE_BASE", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "INTERVAL DAY", "INTERVAL YEAR", "LONG", "NATIONAL CHAR VARYING", "NATIONAL CHAR", "NATIONAL CHARACTER VARYING", "NATIONAL CHARACTER", "NCHAR VARYING", "NCHAR", "NCHAR", "NUMBER_BASE", "NUMBER", "NUMBERIC", "NVARCHAR", "PRECISION", "RAW", "TIMESTAMP", "UROWID", "VARCHAR", "VARCHAR2"],
          reservedFunctionNames: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "BITAND", "CEIL", "COS", "COSH", "EXP", "FLOOR", "LN", "LOG", "MOD", "NANVL", "POWER", "REMAINDER", "ROUND", "SIGN", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "WIDTH_BUCKET", "CHR", "CONCAT", "INITCAP", "LOWER", "LPAD", "LTRIM", "NLS_INITCAP", "NLS_LOWER", "NLSSORT", "NLS_UPPER", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "RPAD", "RTRIM", "SOUNDEX", "SUBSTR", "TRANSLATE", "TREAT", "TRIM", "UPPER", "NLS_CHARSET_DECL_LEN", "NLS_CHARSET_ID", "NLS_CHARSET_NAME", "ASCII", "INSTR", "LENGTH", "REGEXP_INSTR", "ADD_MONTHS", "CURRENT_DATE", "CURRENT_TIMESTAMP", "DBTIMEZONE", "EXTRACT", "FROM_TZ", "LAST_DAY", "LOCALTIMESTAMP", "MONTHS_BETWEEN", "NEW_TIME", "NEXT_DAY", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "ROUND", "SESSIONTIMEZONE", "SYS_EXTRACT_UTC", "SYSDATE", "SYSTIMESTAMP", "TO_CHAR", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_DSINTERVAL", "TO_YMINTERVAL", "TRUNC", "TZ_OFFSET", "GREATEST", "LEAST", "ASCIISTR", "BIN_TO_NUM", "CAST", "CHARTOROWID", "COMPOSE", "CONVERT", "DECOMPOSE", "HEXTORAW", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "RAWTOHEX", "RAWTONHEX", "ROWIDTOCHAR", "ROWIDTONCHAR", "SCN_TO_TIMESTAMP", "TIMESTAMP_TO_SCN", "TO_BINARY_DOUBLE", "TO_BINARY_FLOAT", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_DSINTERVAL", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TO_YMINTERVAL", "TRANSLATE", "UNISTR", "BFILENAME", "EMPTY_BLOB,", "EMPTY_CLOB", "CARDINALITY", "COLLECT", "POWERMULTISET", "POWERMULTISET_BY_CARDINALITY", "SET", "SYS_CONNECT_BY_PATH", "CLUSTER_ID", "CLUSTER_PROBABILITY", "CLUSTER_SET", "FEATURE_ID", "FEATURE_SET", "FEATURE_VALUE", "PREDICTION", "PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET", "APPENDCHILDXML", "DELETEXML", "DEPTH", "EXTRACT", "EXISTSNODE", "EXTRACTVALUE", "INSERTCHILDXML", "INSERTXMLBEFORE", "PATH", "SYS_DBURIGEN", "SYS_XMLAGG", "SYS_XMLGEN", "UPDATEXML", "XMLAGG", "XMLCDATA", "XMLCOLATTVAL", "XMLCOMMENT", "XMLCONCAT", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", "XMLSEQUENCE", "XMLSERIALIZE", "XMLTABLE", "XMLTRANSFORM", "DECODE", "DUMP", "ORA_HASH", "VSIZE", "COALESCE", "LNNVL", "NULLIF", "NVL", "NVL2", "SYS_CONTEXT", "SYS_GUID", "SYS_TYPEID", "UID", "USER", "USERENV", "AVG", "COLLECT", "CORR", "CORR_S", "CORR_K", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "FIRST", "GROUP_ID", "GROUPING", "GROUPING_ID", "LAST", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANK", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "STATS_BINOMIAL_TEST", "STATS_CROSSTAB", "STATS_F_TEST", "STATS_KS_TEST", "STATS_MODE", "STATS_MW_TEST", "STATS_ONE_WAY_ANOVA", "STATS_T_TEST_ONE", "STATS_T_TEST_PAIRED", "STATS_T_TEST_INDEP", "STATS_T_TEST_INDEPU", "STATS_WSR_TEST", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTILE", "RATIO_TO_REPORT", "ROW_NUMBER", "DEREF", "MAKE_REF", "REF", "REFTOHEX", "VALUE", "CV", "ITERATION_NUMBER", "PRESENTNNV", "PRESENTV", "PREVIOUS"],
          stringTypes: [{
            quote: "''-qq",
            prefixes: ["N"]
          }, {
            quote: "q''",
            prefixes: ["N"]
          }],
          identTypes: ['""-qq'],
          identChars: {
            rest: "$#"
          },
          variableTypes: [{
            regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*"
          }],
          paramTypes: {
            numbered: [":"],
            named: [":"]
          },
          operators: ["**", ":=", "%", "~=", "^=", ">>", "<<", "=>", "@", "||"],
          postProcess: function(e) {
            let t = vN;
            return e.map(e => IN.SET(e) && IN.BY(t) ? Object.assign(Object.assign({}, e), {
              type: RN.RESERVED_KEYWORD
            }) : (ON(e.type) && (t = e), e))
          }
        },
        formatOptions: {
          alwaysDenseOperators: ["@"],
          onelineClauses: [...sO, ...nO],
          tabularOnelineClauses: nO
        }
      };
    const uO = hN(["SELECT [ALL | DISTINCT]"]),
      dO = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY [ALL | DISTINCT]", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "FETCH {FIRST | NEXT}", "FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF]", "INSERT INTO", "VALUES", "DEFAULT VALUES", "SET", "RETURNING"]),
      pO = hN(["CREATE [GLOBAL | LOCAL] [TEMPORARY | TEMP | UNLOGGED] TABLE [IF NOT EXISTS]"]),
      EO = hN(["CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE] VIEW", "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]", "UPDATE [ONLY]", "WHERE CURRENT OF", "ON CONFLICT", "DELETE FROM [ONLY]", "DROP TABLE [IF EXISTS]", "ALTER TABLE [IF EXISTS] [ONLY]", "ALTER TABLE ALL IN TABLESPACE", "RENAME [COLUMN]", "RENAME TO", "ADD [COLUMN] [IF NOT EXISTS]", "DROP [COLUMN] [IF EXISTS]", "ALTER [COLUMN]", "SET DATA TYPE", "{SET | DROP} DEFAULT", "{SET | DROP} NOT NULL", "TRUNCATE [TABLE] [ONLY]", "SET SCHEMA", "AFTER", "ABORT", "ALTER AGGREGATE", "ALTER COLLATION", "ALTER CONVERSION", "ALTER DATABASE", "ALTER DEFAULT PRIVILEGES", "ALTER DOMAIN", "ALTER EVENT TRIGGER", "ALTER EXTENSION", "ALTER FOREIGN DATA WRAPPER", "ALTER FOREIGN TABLE", "ALTER FUNCTION", "ALTER GROUP", "ALTER INDEX", "ALTER LANGUAGE", "ALTER LARGE OBJECT", "ALTER MATERIALIZED VIEW", "ALTER OPERATOR", "ALTER OPERATOR CLASS", "ALTER OPERATOR FAMILY", "ALTER POLICY", "ALTER PROCEDURE", "ALTER PUBLICATION", "ALTER ROLE", "ALTER ROUTINE", "ALTER RULE", "ALTER SCHEMA", "ALTER SEQUENCE", "ALTER SERVER", "ALTER STATISTICS", "ALTER SUBSCRIPTION", "ALTER SYSTEM", "ALTER TABLESPACE", "ALTER TEXT SEARCH CONFIGURATION", "ALTER TEXT SEARCH DICTIONARY", "ALTER TEXT SEARCH PARSER", "ALTER TEXT SEARCH TEMPLATE", "ALTER TRIGGER", "ALTER TYPE", "ALTER USER", "ALTER USER MAPPING", "ALTER VIEW", "ANALYZE", "BEGIN", "CALL", "CHECKPOINT", "CLOSE", "CLUSTER", "COMMIT", "COMMIT PREPARED", "COPY", "CREATE ACCESS METHOD", "CREATE [OR REPLACE] AGGREGATE", "CREATE CAST", "CREATE COLLATION", "CREATE [DEFAULT] CONVERSION", "CREATE DATABASE", "CREATE DOMAIN", "CREATE EVENT TRIGGER", "CREATE EXTENSION", "CREATE FOREIGN DATA WRAPPER", "CREATE FOREIGN TABLE", "CREATE [OR REPLACE] FUNCTION", "CREATE GROUP", "CREATE [UNIQUE] INDEX", "CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE", "CREATE OPERATOR", "CREATE OPERATOR CLASS", "CREATE OPERATOR FAMILY", "CREATE POLICY", "CREATE [OR REPLACE] PROCEDURE", "CREATE PUBLICATION", "CREATE ROLE", "CREATE [OR REPLACE] RULE", "CREATE SCHEMA [AUTHORIZATION]", "CREATE [TEMPORARY | TEMP | UNLOGGED] SEQUENCE", "CREATE SERVER", "CREATE STATISTICS", "CREATE SUBSCRIPTION", "CREATE TABLESPACE", "CREATE TEXT SEARCH CONFIGURATION", "CREATE TEXT SEARCH DICTIONARY", "CREATE TEXT SEARCH PARSER", "CREATE TEXT SEARCH TEMPLATE", "CREATE [OR REPLACE] TRANSFORM", "CREATE [OR REPLACE] [CONSTRAINT] TRIGGER", "CREATE TYPE", "CREATE USER", "CREATE USER MAPPING", "DEALLOCATE", "DECLARE", "DISCARD", "DROP ACCESS METHOD", "DROP AGGREGATE", "DROP CAST", "DROP COLLATION", "DROP CONVERSION", "DROP DATABASE", "DROP DOMAIN", "DROP EVENT TRIGGER", "DROP EXTENSION", "DROP FOREIGN DATA WRAPPER", "DROP FOREIGN TABLE", "DROP FUNCTION", "DROP GROUP", "DROP IDENTITY", "DROP INDEX", "DROP LANGUAGE", "DROP MATERIALIZED VIEW [IF EXISTS]", "DROP OPERATOR", "DROP OPERATOR CLASS", "DROP OPERATOR FAMILY", "DROP OWNED", "DROP POLICY", "DROP PROCEDURE", "DROP PUBLICATION", "DROP ROLE", "DROP ROUTINE", "DROP RULE", "DROP SCHEMA", "DROP SEQUENCE", "DROP SERVER", "DROP STATISTICS", "DROP SUBSCRIPTION", "DROP TABLESPACE", "DROP TEXT SEARCH CONFIGURATION", "DROP TEXT SEARCH DICTIONARY", "DROP TEXT SEARCH PARSER", "DROP TEXT SEARCH TEMPLATE", "DROP TRANSFORM", "DROP TRIGGER", "DROP TYPE", "DROP USER", "DROP USER MAPPING", "DROP VIEW", "EXECUTE", "EXPLAIN", "FETCH", "GRANT", "IMPORT FOREIGN SCHEMA", "LISTEN", "LOAD", "LOCK", "MOVE", "NOTIFY", "OVERRIDING SYSTEM VALUE", "PREPARE", "PREPARE TRANSACTION", "REASSIGN OWNED", "REFRESH MATERIALIZED VIEW", "REINDEX", "RELEASE SAVEPOINT", "RESET [ALL|ROLE|SESSION AUTHORIZATION]", "REVOKE", "ROLLBACK", "ROLLBACK PREPARED", "ROLLBACK TO SAVEPOINT", "SAVEPOINT", "SECURITY LABEL", "SELECT INTO", "SET CONSTRAINTS", "SET ROLE", "SET SESSION AUTHORIZATION", "SET TRANSACTION", "SHOW", "START TRANSACTION", "UNLISTEN", "VACUUM"]),
      gO = hN(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]),
      fO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]),
      TO = hN(["PRIMARY KEY", "GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY", "ON {UPDATE | DELETE} [NO ACTION | RESTRICT | CASCADE | SET NULL | SET DEFAULT]", "DO {NOTHING | UPDATE}", "AS MATERIALIZED", "{ROWS | RANGE | GROUPS} BETWEEN", "IS [NOT] DISTINCT FROM", "NULLS {FIRST | LAST}", "WITH ORDINALITY"]),
      mO = hN(["[TIMESTAMP | TIME] {WITH | WITHOUT} TIME ZONE"]),
      CO = {
        name: "postgresql",
        tokenizerOptions: {
          reservedSelect: uO,
          reservedClauses: [...dO, ...pO, ...EO],
          reservedSetOperations: gO,
          reservedJoins: fO,
          reservedKeywordPhrases: TO,
          reservedDataTypePhrases: mO,
          reservedKeywords: ["ALL", "ANALYSE", "ANALYZE", "AND", "ANY", "AS", "ASC", "ASYMMETRIC", "AUTHORIZATION", "BETWEEN", "BINARY", "BOTH", "CASE", "CAST", "CHECK", "COLLATE", "COLLATION", "COLUMN", "CONCURRENTLY", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DAY", "DEFAULT", "DEFERRABLE", "DESC", "DISTINCT", "DO", "ELSE", "END", "EXCEPT", "EXISTS", "FALSE", "FETCH", "FILTER", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GRANT", "GROUP", "HAVING", "HOUR", "ILIKE", "IN", "INITIALLY", "INNER", "INOUT", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "LATERAL", "LEADING", "LEFT", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "MINUTE", "MONTH", "NATURAL", "NOT", "NOTNULL", "NULL", "NULLIF", "OFFSET", "ON", "ONLY", "OR", "ORDER", "OUT", "OUTER", "OVER", "OVERLAPS", "PLACING", "PRIMARY", "REFERENCES", "RETURNING", "RIGHT", "ROW", "SECOND", "SELECT", "SESSION_USER", "SIMILAR", "SOME", "SYMMETRIC", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRAILING", "TRUE", "UNION", "UNIQUE", "USER", "USING", "VALUES", "VARIADIC", "VERBOSE", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "YEAR"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BIT", "BIT VARYING", "BOOL", "BOOLEAN", "CHAR", "CHARACTER", "CHARACTER VARYING", "DECIMAL", "DEC", "DOUBLE", "ENUM", "FLOAT", "INT", "INTEGER", "INTERVAL", "NCHAR", "NUMERIC", "JSON", "JSONB", "PRECISION", "REAL", "SMALLINT", "TEXT", "TIME", "TIMESTAMP", "TIMESTAMPTZ", "UUID", "VARCHAR", "XML", "ZONE"],
          reservedFunctionNames: ["ABS", "ACOS", "ACOSD", "ACOSH", "ASIN", "ASIND", "ASINH", "ATAN", "ATAN2", "ATAN2D", "ATAND", "ATANH", "CBRT", "CEIL", "CEILING", "COS", "COSD", "COSH", "COT", "COTD", "DEGREES", "DIV", "EXP", "FACTORIAL", "FLOOR", "GCD", "LCM", "LN", "LOG", "LOG10", "MIN_SCALE", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SCALE", "SETSEED", "SIGN", "SIN", "SIND", "SINH", "SQRT", "TAN", "TAND", "TANH", "TRIM_SCALE", "TRUNC", "WIDTH_BUCKET", "ABS", "ASCII", "BIT_LENGTH", "BTRIM", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "FORMAT", "INITCAP", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "MD5", "NORMALIZE", "OCTET_LENGTH", "OVERLAY", "PARSE_IDENT", "PG_CLIENT_ENCODING", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "QUOTE_NULLABLE", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SPLIT_PART", "SPRINTF", "STARTS_WITH", "STRING_AGG", "STRING_TO_ARRAY", "STRING_TO_TABLE", "STRPOS", "SUBSTR", "SUBSTRING", "TO_ASCII", "TO_HEX", "TRANSLATE", "TRIM", "UNISTR", "UPPER", "BIT_COUNT", "BIT_LENGTH", "BTRIM", "CONVERT", "CONVERT_FROM", "CONVERT_TO", "DECODE", "ENCODE", "GET_BIT", "GET_BYTE", "LENGTH", "LTRIM", "MD5", "OCTET_LENGTH", "OVERLAY", "POSITION", "RTRIM", "SET_BIT", "SET_BYTE", "SHA224", "SHA256", "SHA384", "SHA512", "STRING_AGG", "SUBSTR", "SUBSTRING", "TRIM", "BIT_COUNT", "BIT_LENGTH", "GET_BIT", "LENGTH", "OCTET_LENGTH", "OVERLAY", "POSITION", "SET_BIT", "SUBSTRING", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP", "CLOCK_TIMESTAMP", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_BIN", "DATE_PART", "DATE_TRUNC", "EXTRACT", "ISFINITE", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL", "LOCALTIME", "LOCALTIMESTAMP", "MAKE_DATE", "MAKE_INTERVAL", "MAKE_TIME", "MAKE_TIMESTAMP", "MAKE_TIMESTAMPTZ", "NOW", "PG_SLEEP", "PG_SLEEP_FOR", "PG_SLEEP_UNTIL", "STATEMENT_TIMESTAMP", "TIMEOFDAY", "TO_TIMESTAMP", "TRANSACTION_TIMESTAMP", "ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE", "AREA", "BOUND_BOX", "BOX", "CENTER", "CIRCLE", "DIAGONAL", "DIAMETER", "HEIGHT", "ISCLOSED", "ISOPEN", "LENGTH", "LINE", "LSEG", "NPOINTS", "PATH", "PCLOSE", "POINT", "POLYGON", "POPEN", "RADIUS", "SLOPE", "WIDTH", "ABBREV", "BROADCAST", "FAMILY", "HOST", "HOSTMASK", "INET_MERGE", "INET_SAME_FAMILY", "MACADDR8_SET7BIT", "MASKLEN", "NETMASK", "NETWORK", "SET_MASKLEN", "TRUNC", "ARRAY_TO_TSVECTOR", "GET_CURRENT_TS_CONFIG", "JSONB_TO_TSVECTOR", "JSON_TO_TSVECTOR", "LENGTH", "NUMNODE", "PHRASETO_TSQUERY", "PLAINTO_TSQUERY", "QUERYTREE", "SETWEIGHT", "STRIP", "TO_TSQUERY", "TO_TSVECTOR", "TSQUERY_PHRASE", "TSVECTOR_TO_ARRAY", "TS_DEBUG", "TS_DELETE", "TS_FILTER", "TS_HEADLINE", "TS_LEXIZE", "TS_PARSE", "TS_RANK", "TS_RANK_CD", "TS_REWRITE", "TS_STAT", "TS_TOKEN_TYPE", "WEBSEARCH_TO_TSQUERY", "GEN_RANDOM_UUID", "CURSOR_TO_XML", "CURSOR_TO_XMLSCHEMA", "DATABASE_TO_XML", "DATABASE_TO_XMLSCHEMA", "DATABASE_TO_XML_AND_XMLSCHEMA", "NEXTVAL", "QUERY_TO_XML", "QUERY_TO_XMLSCHEMA", "QUERY_TO_XML_AND_XMLSCHEMA", "SCHEMA_TO_XML", "SCHEMA_TO_XMLSCHEMA", "SCHEMA_TO_XML_AND_XMLSCHEMA", "STRING", "TABLE_TO_XML", "TABLE_TO_XMLSCHEMA", "TABLE_TO_XML_AND_XMLSCHEMA", "XMLAGG", "XMLCOMMENT", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_CONTENT", "XML_IS_WELL_FORMED_DOCUMENT", "XPATH", "XPATH_EXISTS", "ARRAY_TO_JSON", "JSONB_AGG", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBJECT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_EXTRACT_PATH", "JSONB_EXTRACT_PATH_TEXT", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_OBJECT_AGG", "JSONB_OBJECT_KEYS", "JSONB_PATH_EXISTS", "JSONB_PATH_EXISTS_TZ", "JSONB_PATH_MATCH", "JSONB_PATH_MATCH_TZ", "JSONB_PATH_QUERY", "JSONB_PATH_QUERY_ARRAY", "JSONB_PATH_QUERY_ARRAY_TZ", "JSONB_PATH_QUERY_FIRST", "JSONB_PATH_QUERY_FIRST_TZ", "JSONB_PATH_QUERY_TZ", "JSONB_POPULATE_RECORD", "JSONB_POPULATE_RECORDSET", "JSONB_PRETTY", "JSONB_SET", "JSONB_SET_LAX", "JSONB_STRIP_NULLS", "JSONB_TO_RECORD", "JSONB_TO_RECORDSET", "JSONB_TYPEOF", "JSON_AGG", "JSON_ARRAY_ELEMENTS", "JSON_ARRAY_ELEMENTS_TEXT", "JSON_ARRAY_LENGTH", "JSON_BUILD_ARRAY", "JSON_BUILD_OBJECT", "JSON_EACH", "JSON_EACH_TEXT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_OBJECT", "JSON_OBJECT_AGG", "JSON_OBJECT_KEYS", "JSON_POPULATE_RECORD", "JSON_POPULATE_RECORDSET", "JSON_STRIP_NULLS", "JSON_TO_RECORD", "JSON_TO_RECORDSET", "JSON_TYPEOF", "ROW_TO_JSON", "TO_JSON", "TO_JSONB", "TO_TIMESTAMP", "CURRVAL", "LASTVAL", "NEXTVAL", "SETVAL", "COALESCE", "GREATEST", "LEAST", "NULLIF", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_DIMS", "ARRAY_FILL", "ARRAY_LENGTH", "ARRAY_LOWER", "ARRAY_NDIMS", "ARRAY_POSITION", "ARRAY_POSITIONS", "ARRAY_PREPEND", "ARRAY_REMOVE", "ARRAY_REPLACE", "ARRAY_TO_STRING", "ARRAY_UPPER", "CARDINALITY", "STRING_TO_ARRAY", "TRIM_ARRAY", "UNNEST", "ISEMPTY", "LOWER", "LOWER_INC", "LOWER_INF", "MULTIRANGE", "RANGE_MERGE", "UPPER", "UPPER_INC", "UPPER_INF", "ARRAY_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_OR", "COALESCE", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "EVERY", "GROUPING", "JSONB_AGG", "JSONB_OBJECT_AGG", "JSON_AGG", "JSON_OBJECT_AGG", "MAX", "MIN", "MODE", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANGE_AGG", "RANGE_INTERSECT_AGG", "RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "TO_JSON", "TO_JSONB", "VARIANCE", "VAR_POP", "VAR_SAMP", "XMLAGG", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER", "GENERATE_SERIES", "GENERATE_SUBSCRIPTS", "ACLDEFAULT", "ACLEXPLODE", "COL_DESCRIPTION", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "FORMAT_TYPE", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HAS_TYPE_PRIVILEGE", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "MAKEACLITEM", "OBJ_DESCRIPTION", "PG_BACKEND_PID", "PG_BLOCKING_PIDS", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONTROL_CHECKPOINT", "PG_CONTROL_INIT", "PG_CONTROL_SYSTEM", "PG_CONVERSION_IS_VISIBLE", "PG_CURRENT_LOGFILE", "PG_CURRENT_SNAPSHOT", "PG_CURRENT_XACT_ID", "PG_CURRENT_XACT_ID_IF_ASSIGNED", "PG_DESCRIBE_OBJECT", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CATALOG_FOREIGN_KEYS", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_FUNCTIONDEF", "PG_GET_FUNCTION_ARGUMENTS", "PG_GET_FUNCTION_IDENTITY_ARGUMENTS", "PG_GET_FUNCTION_RESULT", "PG_GET_INDEXDEF", "PG_GET_KEYWORDS", "PG_GET_OBJECT_ADDRESS", "PG_GET_OWNED_SEQUENCE", "PG_GET_RULEDEF", "PG_GET_SERIAL_SEQUENCE", "PG_GET_STATISTICSOBJDEF", "PG_GET_TRIGGERDEF", "PG_GET_USERBYID", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IDENTIFY_OBJECT", "PG_IDENTIFY_OBJECT_AS_ADDRESS", "PG_INDEXAM_HAS_PROPERTY", "PG_INDEX_COLUMN_HAS_PROPERTY", "PG_INDEX_HAS_PROPERTY", "PG_IS_OTHER_TEMP_SCHEMA", "PG_JIT_AVAILABLE", "PG_LAST_COMMITTED_XACT", "PG_LISTENING_CHANNELS", "PG_MY_TEMP_SCHEMA", "PG_NOTIFICATION_QUEUE_USAGE", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_OPTIONS_TO_TABLE", "PG_POSTMASTER_START_TIME", "PG_SAFE_SNAPSHOT_BLOCKING_PIDS", "PG_SNAPSHOT_XIP", "PG_SNAPSHOT_XMAX", "PG_SNAPSHOT_XMIN", "PG_STATISTICS_OBJ_IS_VISIBLE", "PG_TABLESPACE_DATABASES", "PG_TABLESPACE_LOCATION", "PG_TABLE_IS_VISIBLE", "PG_TRIGGER_DEPTH", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PG_VISIBLE_IN_SNAPSHOT", "PG_XACT_COMMIT_TIMESTAMP", "PG_XACT_COMMIT_TIMESTAMP_ORIGIN", "PG_XACT_STATUS", "PQSERVERVERSION", "ROW_SECURITY_ACTIVE", "SESSION_USER", "SHOBJ_DESCRIPTION", "TO_REGCLASS", "TO_REGCOLLATION", "TO_REGNAMESPACE", "TO_REGOPER", "TO_REGOPERATOR", "TO_REGPROC", "TO_REGPROCEDURE", "TO_REGROLE", "TO_REGTYPE", "TXID_CURRENT", "TXID_CURRENT_IF_ASSIGNED", "TXID_CURRENT_SNAPSHOT", "TXID_SNAPSHOT_XIP", "TXID_SNAPSHOT_XMAX", "TXID_SNAPSHOT_XMIN", "TXID_STATUS", "TXID_VISIBLE_IN_SNAPSHOT", "USER", "VERSION", "BRIN_DESUMMARIZE_RANGE", "BRIN_SUMMARIZE_NEW_VALUES", "BRIN_SUMMARIZE_RANGE", "CONVERT_FROM", "CURRENT_SETTING", "GIN_CLEAN_PENDING_LIST", "PG_ADVISORY_LOCK", "PG_ADVISORY_LOCK_SHARED", "PG_ADVISORY_UNLOCK", "PG_ADVISORY_UNLOCK_ALL", "PG_ADVISORY_UNLOCK_SHARED", "PG_ADVISORY_XACT_LOCK", "PG_ADVISORY_XACT_LOCK_SHARED", "PG_BACKUP_START_TIME", "PG_CANCEL_BACKEND", "PG_COLLATION_ACTUAL_VERSION", "PG_COLUMN_COMPRESSION", "PG_COLUMN_SIZE", "PG_COPY_LOGICAL_REPLICATION_SLOT", "PG_COPY_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_LOGICAL_REPLICATION_SLOT", "PG_CREATE_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_RESTORE_POINT", "PG_CURRENT_WAL_FLUSH_LSN", "PG_CURRENT_WAL_INSERT_LSN", "PG_CURRENT_WAL_LSN", "PG_DATABASE_SIZE", "PG_DROP_REPLICATION_SLOT", "PG_EXPORT_SNAPSHOT", "PG_FILENODE_RELATION", "PG_GET_WAL_REPLAY_PAUSE_STATE", "PG_IMPORT_SYSTEM_COLLATIONS", "PG_INDEXES_SIZE", "PG_IS_IN_BACKUP", "PG_IS_IN_RECOVERY", "PG_IS_WAL_REPLAY_PAUSED", "PG_LAST_WAL_RECEIVE_LSN", "PG_LAST_WAL_REPLAY_LSN", "PG_LAST_XACT_REPLAY_TIMESTAMP", "PG_LOGICAL_EMIT_MESSAGE", "PG_LOGICAL_SLOT_GET_BINARY_CHANGES", "PG_LOGICAL_SLOT_GET_CHANGES", "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES", "PG_LOGICAL_SLOT_PEEK_CHANGES", "PG_LOG_BACKEND_MEMORY_CONTEXTS", "PG_LS_ARCHIVE_STATUSDIR", "PG_LS_DIR", "PG_LS_LOGDIR", "PG_LS_TMPDIR", "PG_LS_WALDIR", "PG_PARTITION_ANCESTORS", "PG_PARTITION_ROOT", "PG_PARTITION_TREE", "PG_PROMOTE", "PG_READ_BINARY_FILE", "PG_READ_FILE", "PG_RELATION_FILENODE", "PG_RELATION_FILEPATH", "PG_RELATION_SIZE", "PG_RELOAD_CONF", "PG_REPLICATION_ORIGIN_ADVANCE", "PG_REPLICATION_ORIGIN_CREATE", "PG_REPLICATION_ORIGIN_DROP", "PG_REPLICATION_ORIGIN_OID", "PG_REPLICATION_ORIGIN_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP", "PG_REPLICATION_ORIGIN_SESSION_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_RESET", "PG_REPLICATION_ORIGIN_SESSION_SETUP", "PG_REPLICATION_ORIGIN_XACT_RESET", "PG_REPLICATION_ORIGIN_XACT_SETUP", "PG_REPLICATION_SLOT_ADVANCE", "PG_ROTATE_LOGFILE", "PG_SIZE_BYTES", "PG_SIZE_PRETTY", "PG_START_BACKUP", "PG_STAT_FILE", "PG_STOP_BACKUP", "PG_SWITCH_WAL", "PG_TABLESPACE_SIZE", "PG_TABLE_SIZE", "PG_TERMINATE_BACKEND", "PG_TOTAL_RELATION_SIZE", "PG_TRY_ADVISORY_LOCK", "PG_TRY_ADVISORY_LOCK_SHARED", "PG_TRY_ADVISORY_XACT_LOCK", "PG_TRY_ADVISORY_XACT_LOCK_SHARED", "PG_WALFILE_NAME", "PG_WALFILE_NAME_OFFSET", "PG_WAL_LSN_DIFF", "PG_WAL_REPLAY_PAUSE", "PG_WAL_REPLAY_RESUME", "SET_CONFIG", "SUPPRESS_REDUNDANT_UPDATES_TRIGGER", "TSVECTOR_UPDATE_TRIGGER", "TSVECTOR_UPDATE_TRIGGER_COLUMN", "PG_EVENT_TRIGGER_DDL_COMMANDS", "PG_EVENT_TRIGGER_DROPPED_OBJECTS", "PG_EVENT_TRIGGER_TABLE_REWRITE_OID", "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON", "PG_GET_OBJECT_ADDRESS", "PG_MCV_LIST_ITEMS", "CAST"],
          nestedBlockComments: !0,
          extraParens: ["[]"],
          underscoresInNumbers: !0,
          stringTypes: ["$$", {
            quote: "''-qq",
            prefixes: ["U&"]
          }, {
            quote: "''-qq-bs",
            prefixes: ["E"],
            requirePrefix: !0
          }, {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: [{
            quote: '""-qq',
            prefixes: ["U&"]
          }],
          identChars: {
            rest: "$"
          },
          paramTypes: {
            numbered: ["$"]
          },
          operators: ["%", "^", "|/", "||/", "@", ":=", "&", "|", "#", "~", "<<", ">>", "~>~", "~<~", "~>=~", "~<=~", "@-@", "@@", "##", "<->", "&&", "&<", "&>", "<<|", "&<|", "|>>", "|&>", "<^", "^>", "?#", "?-", "?|", "?-|", "?||", "@>", "<@", "~=", "?", "@?", "?&", "->", "->>", "#>", "#>>", "#-", "=>", ">>=", "<<=", "~~", "~~*", "!~~", "!~~*", "~", "~*", "!~", "!~*", "-|-", "||", "@@@", "!!", "^@", "<%", "%>", "<<%", "%>>", "<<->", "<->>", "<<<->", "<->>>", "::", ":", "<#>", "<=>", "<+>", "<~>", "<%>"],
          operatorKeyword: !0
        },
        formatOptions: {
          alwaysDenseOperators: ["::", ":"],
          onelineClauses: [...pO, ...EO],
          tabularOnelineClauses: EO
        }
      },
      SO = hN(["SELECT [ALL | DISTINCT]"]),
      RO = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "QUALIFY", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT INTO", "VALUES", "SET"]),
      AO = hN(["CREATE [TEMPORARY | TEMP | LOCAL TEMPORARY | LOCAL TEMP] TABLE [IF NOT EXISTS]"]),
      vO = hN(["CREATE [OR REPLACE | MATERIALIZED] VIEW", "UPDATE", "DELETE [FROM]", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "ALTER TABLE APPEND", "ADD [COLUMN]", "DROP [COLUMN]", "RENAME TO", "RENAME COLUMN", "ALTER COLUMN", "TYPE", "ENCODE", "TRUNCATE [TABLE]", "ABORT", "ALTER DATABASE", "ALTER DATASHARE", "ALTER DEFAULT PRIVILEGES", "ALTER GROUP", "ALTER MATERIALIZED VIEW", "ALTER PROCEDURE", "ALTER SCHEMA", "ALTER USER", "ANALYSE", "ANALYZE", "ANALYSE COMPRESSION", "ANALYZE COMPRESSION", "BEGIN", "CALL", "CANCEL", "CLOSE", "COMMIT", "COPY", "CREATE DATABASE", "CREATE DATASHARE", "CREATE EXTERNAL FUNCTION", "CREATE EXTERNAL SCHEMA", "CREATE EXTERNAL TABLE", "CREATE FUNCTION", "CREATE GROUP", "CREATE LIBRARY", "CREATE MODEL", "CREATE PROCEDURE", "CREATE SCHEMA", "CREATE USER", "DEALLOCATE", "DECLARE", "DESC DATASHARE", "DROP DATABASE", "DROP DATASHARE", "DROP FUNCTION", "DROP GROUP", "DROP LIBRARY", "DROP MODEL", "DROP MATERIALIZED VIEW", "DROP PROCEDURE", "DROP SCHEMA", "DROP USER", "DROP VIEW", "DROP", "EXECUTE", "EXPLAIN", "FETCH", "GRANT", "LOCK", "PREPARE", "REFRESH MATERIALIZED VIEW", "RESET", "REVOKE", "ROLLBACK", "SELECT INTO", "SET SESSION AUTHORIZATION", "SET SESSION CHARACTERISTICS", "SHOW", "SHOW EXTERNAL TABLE", "SHOW MODEL", "SHOW DATASHARES", "SHOW PROCEDURE", "SHOW TABLE", "SHOW VIEW", "START TRANSACTION", "UNLOAD", "VACUUM"]),
      NO = hN(["UNION [ALL]", "EXCEPT", "INTERSECT", "MINUS"]),
      IO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]),
      OO = hN(["NULL AS", "DATA CATALOG", "HIVE METASTORE", "{ROWS | RANGE} BETWEEN"]),
      LO = hN([]),
      _O = {
        name: "redshift",
        tokenizerOptions: {
          reservedSelect: SO,
          reservedClauses: [...RO, ...AO, ...vO],
          reservedSetOperations: NO,
          reservedJoins: IO,
          reservedKeywordPhrases: OO,
          reservedDataTypePhrases: LO,
          reservedKeywords: ["AES128", "AES256", "ALL", "ALLOWOVERWRITE", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BETWEEN", "BINARY", "BOTH", "CHECK", "COLUMN", "CONSTRAINT", "CREATE", "CROSS", "DEFAULT", "DEFERRABLE", "DEFLATE", "DEFRAG", "DESC", "DISABLE", "DISTINCT", "DO", "ENABLE", "ENCODE", "ENCRYPT", "ENCRYPTION", "EXPLICIT", "FALSE", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GLOBALDICT256", "GLOBALDICT64K", "GROUP", "IDENTITY", "IGNORE", "ILIKE", "IN", "INITIALLY", "INNER", "INTO", "IS", "ISNULL", "LANGUAGE", "LEADING", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LUN", "LUNS", "MINUS", "NATURAL", "NEW", "NOT", "NOTNULL", "NULL", "NULLS", "OFF", "OFFLINE", "OFFSET", "OID", "OLD", "ON", "ONLY", "OPEN", "ORDER", "OUTER", "OVERLAPS", "PARALLEL", "PARTITION", "PERCENT", "PERMISSIONS", "PLACING", "PRIMARY", "RECOVER", "REFERENCES", "REJECTLOG", "RESORT", "RESPECT", "RESTORE", "SIMILAR", "SNAPSHOT", "SOME", "SYSTEM", "TABLE", "TAG", "TDES", "THEN", "TIMESTAMP", "TO", "TOP", "TRAILING", "TRUE", "UNIQUE", "USING", "VERBOSE", "WALLET", "WITHOUT", "ACCEPTANYDATE", "ACCEPTINVCHARS", "BLANKSASNULL", "DATEFORMAT", "EMPTYASNULL", "ENCODING", "ESCAPE", "EXPLICIT_IDS", "FILLRECORD", "IGNOREBLANKLINES", "IGNOREHEADER", "REMOVEQUOTES", "ROUNDEC", "TIMEFORMAT", "TRIMBLANKS", "TRUNCATECOLUMNS", "COMPROWS", "COMPUPDATE", "MAXERROR", "NOLOAD", "STATUPDATE", "FORMAT", "CSV", "DELIMITER", "FIXEDWIDTH", "SHAPEFILE", "AVRO", "JSON", "PARQUET", "ORC", "ACCESS_KEY_ID", "CREDENTIALS", "ENCRYPTED", "IAM_ROLE", "MASTER_SYMMETRIC_KEY", "SECRET_ACCESS_KEY", "SESSION_TOKEN", "BZIP2", "GZIP", "LZOP", "ZSTD", "MANIFEST", "READRATIO", "REGION", "SSH", "RAW", "AZ64", "BYTEDICT", "DELTA", "DELTA32K", "LZO", "MOSTLY8", "MOSTLY16", "MOSTLY32", "RUNLENGTH", "TEXT255", "TEXT32K", "CATALOG_ROLE", "SECRET_ARN", "EXTERNAL", "AUTO", "EVEN", "KEY", "PREDICATE", "COMPRESSION"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BPCHAR", "CHAR", "CHARACTER VARYING", "CHARACTER", "DECIMAL", "INT", "INT2", "INT4", "INT8", "INTEGER", "NCHAR", "NUMERIC", "NVARCHAR", "SMALLINT", "TEXT", "VARBYTE", "VARCHAR"],
          reservedFunctionNames: ["ANY_VALUE", "APPROXIMATE PERCENTILE_DISC", "AVG", "COUNT", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP", "array_concat", "array_flatten", "get_array_length", "split_to_array", "subarray", "BIT_AND", "BIT_OR", "BOOL_AND", "BOOL_OR", "COALESCE", "DECODE", "GREATEST", "LEAST", "NVL", "NVL2", "NULLIF", "ADD_MONTHS", "AT TIME ZONE", "CONVERT_TIMEZONE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_CMP", "DATE_CMP_TIMESTAMP", "DATE_CMP_TIMESTAMPTZ", "DATE_PART_YEAR", "DATEADD", "DATEDIFF", "DATE_PART", "DATE_TRUNC", "EXTRACT", "GETDATE", "INTERVAL_CMP", "LAST_DAY", "MONTHS_BETWEEN", "NEXT_DAY", "SYSDATE", "TIMEOFDAY", "TIMESTAMP_CMP", "TIMESTAMP_CMP_DATE", "TIMESTAMP_CMP_TIMESTAMPTZ", "TIMESTAMPTZ_CMP", "TIMESTAMPTZ_CMP_DATE", "TIMESTAMPTZ_CMP_TIMESTAMP", "TIMEZONE", "TO_TIMESTAMP", "TRUNC", "AddBBox", "DropBBox", "GeometryType", "ST_AddPoint", "ST_Angle", "ST_Area", "ST_AsBinary", "ST_AsEWKB", "ST_AsEWKT", "ST_AsGeoJSON", "ST_AsText", "ST_Azimuth", "ST_Boundary", "ST_Collect", "ST_Contains", "ST_ContainsProperly", "ST_ConvexHull", "ST_CoveredBy", "ST_Covers", "ST_Crosses", "ST_Dimension", "ST_Disjoint", "ST_Distance", "ST_DistanceSphere", "ST_DWithin", "ST_EndPoint", "ST_Envelope", "ST_Equals", "ST_ExteriorRing", "ST_Force2D", "ST_Force3D", "ST_Force3DM", "ST_Force3DZ", "ST_Force4D", "ST_GeometryN", "ST_GeometryType", "ST_GeomFromEWKB", "ST_GeomFromEWKT", "ST_GeomFromText", "ST_GeomFromWKB", "ST_InteriorRingN", "ST_Intersects", "ST_IsPolygonCCW", "ST_IsPolygonCW", "ST_IsClosed", "ST_IsCollection", "ST_IsEmpty", "ST_IsSimple", "ST_IsValid", "ST_Length", "ST_LengthSphere", "ST_Length2D", "ST_LineFromMultiPoint", "ST_LineInterpolatePoint", "ST_M", "ST_MakeEnvelope", "ST_MakeLine", "ST_MakePoint", "ST_MakePolygon", "ST_MemSize", "ST_MMax", "ST_MMin", "ST_Multi", "ST_NDims", "ST_NPoints", "ST_NRings", "ST_NumGeometries", "ST_NumInteriorRings", "ST_NumPoints", "ST_Perimeter", "ST_Perimeter2D", "ST_Point", "ST_PointN", "ST_Points", "ST_Polygon", "ST_RemovePoint", "ST_Reverse", "ST_SetPoint", "ST_SetSRID", "ST_Simplify", "ST_SRID", "ST_StartPoint", "ST_Touches", "ST_Within", "ST_X", "ST_XMax", "ST_XMin", "ST_Y", "ST_YMax", "ST_YMin", "ST_Z", "ST_ZMax", "ST_ZMin", "SupportsBBox", "CHECKSUM", "FUNC_SHA1", "FNV_HASH", "MD5", "SHA", "SHA1", "SHA2", "HLL", "HLL_CREATE_SKETCH", "HLL_CARDINALITY", "HLL_COMBINE", "IS_VALID_JSON", "IS_VALID_JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_EXTRACT_ARRAY_ELEMENT_TEXT", "JSON_EXTRACT_PATH_TEXT", "JSON_PARSE", "JSON_SERIALIZE", "ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CBRT", "CEILING", "CEIL", "COS", "COT", "DEGREES", "DEXP", "DLOG1", "DLOG10", "EXP", "FLOOR", "LN", "LOG", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SIN", "SIGN", "SQRT", "TAN", "TO_HEX", "TRUNC", "EXPLAIN_MODEL", "ASCII", "BPCHARCMP", "BTRIM", "BTTEXT_PATTERN_CMP", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARINDEX", "CHR", "COLLATE", "CONCAT", "CRC32", "DIFFERENCE", "INITCAP", "LEFT", "RIGHT", "LEN", "LENGTH", "LOWER", "LPAD", "RPAD", "LTRIM", "OCTETINDEX", "OCTET_LENGTH", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "REPLICATE", "REVERSE", "RTRIM", "SOUNDEX", "SPLIT_PART", "STRPOS", "STRTOL", "SUBSTRING", "TEXTLEN", "TRANSLATE", "TRIM", "UPPER", "decimal_precision", "decimal_scale", "is_array", "is_bigint", "is_boolean", "is_char", "is_decimal", "is_float", "is_integer", "is_object", "is_scalar", "is_smallint", "is_varchar", "json_typeof", "AVG", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAST_VALUE", "LAG", "LEAD", "LISTAGG", "MAX", "MEDIAN", "MIN", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP", "CAST", "CONVERT", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TEXT_TO_INT_ALT", "TEXT_TO_NUMERIC_ALT", "CHANGE_QUERY_PRIORITY", "CHANGE_SESSION_PRIORITY", "CHANGE_USER_PRIORITY", "CURRENT_SETTING", "PG_CANCEL_BACKEND", "PG_TERMINATE_BACKEND", "REBOOT_CLUSTER", "SET_CONFIG", "CURRENT_AWS_ACCOUNT", "CURRENT_DATABASE", "CURRENT_NAMESPACE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "CURRENT_USER_ID", "HAS_ASSUMEROLE_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "PG_BACKEND_PID", "PG_GET_COLS", "PG_GET_GRANTEE_BY_IAM_ROLE", "PG_GET_IAM_ROLE_BY_USER", "PG_GET_LATE_BINDING_VIEW_COLS", "PG_LAST_COPY_COUNT", "PG_LAST_COPY_ID", "PG_LAST_UNLOAD_ID", "PG_LAST_QUERY_ID", "PG_LAST_UNLOAD_COUNT", "SESSION_USER", "SLICE_NUM", "USER", "VERSION"],
          extraParens: ["[]"],
          stringTypes: ["''-qq"],
          identTypes: ['""-qq'],
          identChars: {
            first: "#"
          },
          paramTypes: {
            numbered: ["$"]
          },
          operators: ["^", "%", "@", "|/", "||/", "&", "|", "~", "<<", ">>", "||", "::"]
        },
        formatOptions: {
          alwaysDenseOperators: ["::"],
          onelineClauses: [...AO, ...vO],
          tabularOnelineClauses: vO
        }
      },
      yO = hN(["SELECT [ALL | DISTINCT]"]),
      wO = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "SORT BY", "CLUSTER BY", "DISTRIBUTE BY", "LIMIT", "INSERT [INTO | OVERWRITE] [TABLE]", "VALUES", "INSERT OVERWRITE [LOCAL] DIRECTORY", "LOAD DATA [LOCAL] INPATH", "[OVERWRITE] INTO TABLE"]),
      DO = hN(["CREATE [EXTERNAL] TABLE [IF NOT EXISTS]"]),
      PO = hN(["CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "ADD COLUMNS", "DROP {COLUMN | COLUMNS}", "RENAME TO", "RENAME COLUMN", "ALTER COLUMN", "TRUNCATE TABLE", "LATERAL VIEW", "ALTER DATABASE", "ALTER VIEW", "CREATE DATABASE", "CREATE FUNCTION", "DROP DATABASE", "DROP FUNCTION", "DROP VIEW", "REPAIR TABLE", "USE DATABASE", "TABLESAMPLE", "PIVOT", "TRANSFORM", "EXPLAIN", "ADD FILE", "ADD JAR", "ANALYZE TABLE", "CACHE TABLE", "CLEAR CACHE", "DESCRIBE DATABASE", "DESCRIBE FUNCTION", "DESCRIBE QUERY", "DESCRIBE TABLE", "LIST FILE", "LIST JAR", "REFRESH", "REFRESH TABLE", "REFRESH FUNCTION", "RESET", "SHOW COLUMNS", "SHOW CREATE TABLE", "SHOW DATABASES", "SHOW FUNCTIONS", "SHOW PARTITIONS", "SHOW TABLE EXTENDED", "SHOW TABLES", "SHOW TBLPROPERTIES", "SHOW VIEWS", "UNCACHE TABLE"]),
      bO = hN(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]),
      MO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN", "[LEFT] {ANTI | SEMI} JOIN", "NATURAL [LEFT] {ANTI | SEMI} JOIN"]),
      FO = hN(["ON DELETE", "ON UPDATE", "CURRENT ROW", "{ROWS | RANGE} BETWEEN"]),
      xO = hN([]),
      GO = {
        name: "spark",
        tokenizerOptions: {
          reservedSelect: yO,
          reservedClauses: [...wO, ...DO, ...PO],
          reservedSetOperations: bO,
          reservedJoins: MO,
          reservedKeywordPhrases: FO,
          reservedDataTypePhrases: xO,
          supportsXor: !0,
          reservedKeywords: ["ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANTI", "ANY", "ARCHIVE", "AS", "ASC", "AT", "AUTHORIZATION", "BETWEEN", "BOTH", "BUCKET", "BUCKETS", "BY", "CACHE", "CASCADE", "CAST", "CHANGE", "CHECK", "CLEAR", "CLUSTER", "CLUSTERED", "CODEGEN", "COLLATE", "COLLECTION", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", "CONSTRAINT", "COST", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", "DATABASES", "DAY", "DBPROPERTIES", "DEFINED", "DELETE", "DELIMITED", "DESC", "DESCRIBE", "DFS", "DIRECTORIES", "DIRECTORY", "DISTINCT", "DISTRIBUTE", "DIV", "DROP", "ESCAPE", "ESCAPED", "EXCEPT", "EXCHANGE", "EXISTS", "EXPORT", "EXTENDED", "EXTERNAL", "EXTRACT", "FALSE", "FETCH", "FIELDS", "FILTER", "FILEFORMAT", "FIRST", "FIRST_VALUE", "FOLLOWING", "FOR", "FOREIGN", "FORMAT", "FORMATTED", "FULL", "FUNCTION", "FUNCTIONS", "GLOBAL", "GRANT", "GROUP", "GROUPING", "HOUR", "IF", "IGNORE", "IMPORT", "IN", "INDEX", "INDEXES", "INNER", "INPATH", "INPUTFORMAT", "INTERSECT", "INTO", "IS", "ITEMS", "KEYS", "LAST", "LAST_VALUE", "LATERAL", "LAZY", "LEADING", "LEFT", "LIKE", "LINES", "LIST", "LOCAL", "LOCATION", "LOCK", "LOCKS", "LOGICAL", "MACRO", "MATCHED", "MERGE", "MINUTE", "MONTH", "MSCK", "NAMESPACE", "NAMESPACES", "NATURAL", "NO", "NOT", "NULL", "NULLS", "OF", "ONLY", "OPTION", "OPTIONS", "OR", "ORDER", "OUT", "OUTER", "OUTPUTFORMAT", "OVER", "OVERLAPS", "OVERLAY", "OVERWRITE", "OWNER", "PARTITION", "PARTITIONED", "PARTITIONS", "PERCENT", "PLACING", "POSITION", "PRECEDING", "PRIMARY", "PRINCIPALS", "PROPERTIES", "PURGE", "QUERY", "RANGE", "RECORDREADER", "RECORDWRITER", "RECOVER", "REDUCE", "REFERENCES", "RENAME", "REPAIR", "REPLACE", "RESPECT", "RESTRICT", "REVOKE", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SCHEMA", "SECOND", "SELECT", "SEMI", "SEPARATED", "SERDE", "SERDEPROPERTIES", "SESSION_USER", "SETS", "SHOW", "SKEWED", "SOME", "SORT", "SORTED", "START", "STATISTICS", "STORED", "STRATIFY", "SUBSTR", "SUBSTRING", "TABLE", "TABLES", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "THEN", "TO", "TOUCH", "TRAILING", "TRANSACTION", "TRANSACTIONS", "TRIM", "TRUE", "TRUNCATE", "UNARCHIVE", "UNBOUNDED", "UNCACHE", "UNIQUE", "UNKNOWN", "UNLOCK", "UNSET", "USE", "USER", "USING", "VIEW", "WINDOW", "YEAR", "ANALYSE", "ARRAY_ZIP", "COALESCE", "CONTAINS", "CONVERT", "DAYS", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "DECODE", "DEFAULT", "DISTINCTROW", "ENCODE", "EXPLODE", "EXPLODE_OUTER", "FIXED", "GREATEST", "GROUP_CONCAT", "HOURS", "HOUR_MINUTE", "HOUR_SECOND", "IFNULL", "LEAST", "LEVEL", "MINUTE_SECOND", "NULLIF", "OFFSET", "ON", "OPTIMIZE", "REGEXP", "SEPARATOR", "SIZE", "TYPE", "TYPES", "UNSIGNED", "VARIABLES", "YEAR_MONTH"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY", "BOOLEAN", "BYTE", "CHAR", "DATE", "DEC", "DECIMAL", "DOUBLE", "FLOAT", "INT", "INTEGER", "INTERVAL", "LONG", "MAP", "NUMERIC", "REAL", "SHORT", "SMALLINT", "STRING", "STRUCT", "TIMESTAMP_LTZ", "TIMESTAMP_NTZ", "TIMESTAMP", "TINYINT", "VARCHAR"],
          reservedFunctionNames: ["APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_OR", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COUNT", "COUNT", "COUNT_IF", "COUNT_MIN_SKETCH", "COVAR_POP", "COVAR_SAMP", "EVERY", "FIRST", "FIRST_VALUE", "GROUPING", "GROUPING_ID", "KURTOSIS", "LAST", "LAST_VALUE", "MAX", "MAX_BY", "MEAN", "MIN", "MIN_BY", "PERCENTILE", "PERCENTILE", "PERCENTILE_APPROX", "SKEWNESS", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CUME_DIST", "DENSE_RANK", "LAG", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER", "ARRAY", "ARRAY_CONTAINS", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_UNION", "ARRAYS_OVERLAP", "ARRAYS_ZIP", "FLATTEN", "SEQUENCE", "SHUFFLE", "SLICE", "SORT_ARRAY", "ELEMENT_AT", "ELEMENT_AT", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FROM_ARRAYS", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "STR_TO_MAP", "ADD_MONTHS", "CURRENT_DATE", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "DATE_ADD", "DATE_FORMAT", "DATE_FROM_UNIX_DATE", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DATEDIFF", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MAKE_DATE", "MAKE_DT_INTERVAL", "MAKE_INTERVAL", "MAKE_TIMESTAMP", "MAKE_YM_INTERVAL", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "NOW", "QUARTER", "SECOND", "SESSION_WINDOW", "TIMESTAMP_MICROS", "TIMESTAMP_MILLIS", "TIMESTAMP_SECONDS", "TO_DATE", "TO_TIMESTAMP", "TO_UNIX_TIMESTAMP", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_DATE", "UNIX_MICROS", "UNIX_MILLIS", "UNIX_SECONDS", "UNIX_TIMESTAMP", "WEEKDAY", "WEEKOFYEAR", "WINDOW", "YEAR", "FROM_JSON", "GET_JSON_OBJECT", "JSON_ARRAY_LENGTH", "JSON_OBJECT_KEYS", "JSON_TUPLE", "SCHEMA_OF_JSON", "TO_JSON", "ABS", "ACOS", "ACOSH", "AGGREGATE", "ARRAY_SORT", "ASCII", "ASIN", "ASINH", "ASSERT_TRUE", "ATAN", "ATAN2", "ATANH", "BASE64", "BIN", "BIT_COUNT", "BIT_GET", "BIT_LENGTH", "BROUND", "BTRIM", "CARDINALITY", "CBRT", "CEIL", "CEILING", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONV", "COS", "COSH", "COT", "CRC32", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_USER", "DEGREES", "ELT", "EXP", "EXPM1", "FACTORIAL", "FIND_IN_SET", "FLOOR", "FORALL", "FORMAT_NUMBER", "FORMAT_STRING", "FROM_CSV", "GETBIT", "HASH", "HEX", "HYPOT", "INITCAP", "INLINE", "INLINE_OUTER", "INPUT_FILE_BLOCK_LENGTH", "INPUT_FILE_BLOCK_START", "INPUT_FILE_NAME", "INSTR", "ISNAN", "ISNOTNULL", "ISNULL", "JAVA_METHOD", "LCASE", "LEFT", "LENGTH", "LEVENSHTEIN", "LN", "LOCATE", "LOG", "LOG10", "LOG1P", "LOG2", "LOWER", "LPAD", "LTRIM", "MAP_FILTER", "MAP_ZIP_WITH", "MD5", "MOD", "MONOTONICALLY_INCREASING_ID", "NAMED_STRUCT", "NANVL", "NEGATIVE", "NVL", "NVL2", "OCTET_LENGTH", "OVERLAY", "PARSE_URL", "PI", "PMOD", "POSEXPLODE", "POSEXPLODE_OUTER", "POSITION", "POSITIVE", "POW", "POWER", "PRINTF", "RADIANS", "RAISE_ERROR", "RAND", "RANDN", "RANDOM", "REFLECT", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_LIKE", "REGEXP_REPLACE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RINT", "ROUND", "RPAD", "RTRIM", "SCHEMA_OF_CSV", "SENTENCES", "SHA", "SHA1", "SHA2", "SHIFTLEFT", "SHIFTRIGHT", "SHIFTRIGHTUNSIGNED", "SIGN", "SIGNUM", "SIN", "SINH", "SOUNDEX", "SPACE", "SPARK_PARTITION_ID", "SPLIT", "SQRT", "STACK", "SUBSTR", "SUBSTRING", "SUBSTRING_INDEX", "TAN", "TANH", "TO_CSV", "TRANSFORM_KEYS", "TRANSFORM_VALUES", "TRANSLATE", "TRIM", "TRY_ADD", "TRY_DIVIDE", "TYPEOF", "UCASE", "UNBASE64", "UNHEX", "UPPER", "UUID", "VERSION", "WIDTH_BUCKET", "XPATH", "XPATH_BOOLEAN", "XPATH_DOUBLE", "XPATH_FLOAT", "XPATH_INT", "XPATH_LONG", "XPATH_NUMBER", "XPATH_SHORT", "XPATH_STRING", "XXHASH64", "ZIP_WITH", "CAST", "COALESCE", "NULLIF"],
          extraParens: ["[]"],
          stringTypes: ["''-bs", '""-bs', {
            quote: "''-raw",
            prefixes: ["R", "X"],
            requirePrefix: !0
          }, {
            quote: '""-raw',
            prefixes: ["R", "X"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            allowFirstCharNumber: !0
          },
          variableTypes: [{
            quote: "{}",
            prefixes: ["$"],
            requirePrefix: !0
          }],
          operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||", "->"],
          postProcess: function(e) {
            return e.map((t, i) => {
              const r = e[i - 1] || vN,
                s = e[i + 1] || vN;
              return IN.WINDOW(t) && s.type === RN.OPEN_PAREN ? Object.assign(Object.assign({}, t), {
                type: RN.RESERVED_FUNCTION_NAME
              }) : "ITEMS" !== t.text || t.type !== RN.RESERVED_KEYWORD || "COLLECTION" === r.text && "TERMINATED" === s.text ? t : Object.assign(Object.assign({}, t), {
                type: RN.IDENTIFIER,
                text: t.raw
              })
            })
          }
        },
        formatOptions: {
          onelineClauses: [...DO, ...PO],
          tabularOnelineClauses: PO
        }
      };
    const UO = hN(["SELECT [ALL | DISTINCT]"]),
      HO = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK] INTO", "REPLACE INTO", "VALUES", "SET", "RETURNING"]),
      kO = hN(["CREATE [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"]),
      BO = hN(["CREATE [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]", "UPDATE [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK]", "ON CONFLICT", "DELETE FROM", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "ADD [COLUMN]", "DROP [COLUMN]", "RENAME [COLUMN]", "RENAME TO", "SET SCHEMA"]),
      VO = hN(["UNION [ALL]", "EXCEPT", "INTERSECT"]),
      WO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]),
      YO = hN(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE | GROUPS} BETWEEN", "DO UPDATE"]),
      KO = hN([]),
      XO = {
        name: "sqlite",
        tokenizerOptions: {
          reservedSelect: UO,
          reservedClauses: [...HO, ...kO, ...BO],
          reservedSetOperations: VO,
          reservedJoins: WO,
          reservedKeywordPhrases: YO,
          reservedDataTypePhrases: KO,
          reservedKeywords: ["ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "AND", "ARE", "ALWAYS", "ANALYZE", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FILTER", "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GENERATED", "GLOB", "GROUP", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE", "LIMIT", "MATCH", "MATERIALIZED", "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL", "NULLS", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRECEDING", "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION", "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"],
          reservedDataTypes: ["ANY", "ARRAY", "BLOB", "CHARACTER", "DECIMAL", "INT", "INTEGER", "NATIVE CHARACTER", "NCHAR", "NUMERIC", "NVARCHAR", "REAL", "TEXT", "VARCHAR", "VARYING CHARACTER"],
          reservedFunctionNames: ["ABS", "CHANGES", "CHAR", "COALESCE", "FORMAT", "GLOB", "HEX", "IFNULL", "IIF", "INSTR", "LAST_INSERT_ROWID", "LENGTH", "LIKE", "LIKELIHOOD", "LIKELY", "LOAD_EXTENSION", "LOWER", "LTRIM", "NULLIF", "PRINTF", "QUOTE", "RANDOM", "RANDOMBLOB", "REPLACE", "ROUND", "RTRIM", "SIGN", "SOUNDEX", "SQLITE_COMPILEOPTION_GET", "SQLITE_COMPILEOPTION_USED", "SQLITE_OFFSET", "SQLITE_SOURCE_ID", "SQLITE_VERSION", "SUBSTR", "SUBSTRING", "TOTAL_CHANGES", "TRIM", "TYPEOF", "UNICODE", "UNLIKELY", "UPPER", "ZEROBLOB", "AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "SUM", "TOTAL", "DATE", "TIME", "DATETIME", "JULIANDAY", "UNIXEPOCH", "STRFTIME", "row_number", "rank", "dense_rank", "percent_rank", "cume_dist", "ntile", "lag", "lead", "first_value", "last_value", "nth_value", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "CEIL", "CEILING", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG", "LOG10", "LOG2", "MOD", "PI", "POW", "POWER", "RADIANS", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "JSON", "JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_ARRAY_LENGTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_OBJECT", "JSON_PATCH", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_TYPE", "JSON_TYPE", "JSON_VALID", "JSON_QUOTE", "JSON_GROUP_ARRAY", "JSON_GROUP_OBJECT", "JSON_EACH", "JSON_TREE", "CAST"],
          stringTypes: ["''-qq", {
            quote: "''-raw",
            prefixes: ["X"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq', "``", "[]"],
          paramTypes: {
            positional: !0,
            numbered: ["?"],
            named: [":", "@", "$"]
          },
          operators: ["%", "~", "&", "|", "<<", ">>", "==", "->", "->>", "||"]
        },
        formatOptions: {
          onelineClauses: [...kO, ...BO],
          tabularOnelineClauses: BO
        }
      },
      zO = hN(["SELECT [ALL | DISTINCT]"]),
      $O = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY [ALL | DISTINCT]", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "FETCH {FIRST | NEXT}", "INSERT INTO", "VALUES", "SET"]),
      jO = hN(["CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE"]),
      JO = hN(["CREATE [RECURSIVE] VIEW", "UPDATE", "WHERE CURRENT OF", "DELETE FROM", "DROP TABLE", "ALTER TABLE", "ADD COLUMN", "DROP [COLUMN]", "RENAME COLUMN", "RENAME TO", "ALTER [COLUMN]", "{SET | DROP} DEFAULT", "ADD SCOPE", "DROP SCOPE {CASCADE | RESTRICT}", "RESTART WITH", "TRUNCATE TABLE", "SET SCHEMA"]),
      qO = hN(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]),
      QO = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]),
      ZO = hN(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]),
      eL = hN([]),
      tL = {
        name: "sql",
        tokenizerOptions: {
          reservedSelect: zO,
          reservedClauses: [...$O, ...jO, ...JO],
          reservedSetOperations: qO,
          reservedJoins: QO,
          reservedKeywordPhrases: ZO,
          reservedDataTypePhrases: eL,
          reservedKeywords: ["ALL", "ALLOCATE", "ALTER", "ANY", "ARE", "AS", "ASC", "ASENSITIVE", "ASYMMETRIC", "AT", "ATOMIC", "AUTHORIZATION", "BEGIN", "BETWEEN", "BOTH", "BY", "CALL", "CALLED", "CASCADED", "CAST", "CHECK", "CLOSE", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "CONDITION", "CONNECT", "CONSTRAINT", "CORRESPONDING", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DEFAULT_TRANSFORM_GROUP", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TRANSFORM_GROUP_FOR_TYPE", "CURRENT_USER", "CURSOR", "CYCLE", "DEALLOCATE", "DAY", "DECLARE", "DEFAULT", "DELETE", "DEREF", "DESC", "DESCRIBE", "DETERMINISTIC", "DISCONNECT", "DISTINCT", "DROP", "DYNAMIC", "EACH", "ELEMENT", "END-EXEC", "ESCAPE", "EVERY", "EXCEPT", "EXEC", "EXECUTE", "EXISTS", "EXTERNAL", "FALSE", "FETCH", "FILTER", "FOR", "FOREIGN", "FREE", "FROM", "FULL", "FUNCTION", "GET", "GLOBAL", "GRANT", "GROUP", "HAVING", "HOLD", "HOUR", "IDENTITY", "IN", "INDICATOR", "INNER", "INOUT", "INSENSITIVE", "INSERT", "INTERSECT", "INTO", "IS", "LANGUAGE", "LARGE", "LATERAL", "LEADING", "LEFT", "LIKE", "LIKE_REGEX", "LOCAL", "MATCH", "MEMBER", "MERGE", "METHOD", "MINUTE", "MODIFIES", "MODULE", "MONTH", "NATURAL", "NEW", "NO", "NONE", "NOT", "NULL", "NULLIF", "OF", "OLD", "ON", "ONLY", "OPEN", "ORDER", "OUT", "OUTER", "OVER", "OVERLAPS", "PARAMETER", "PARTITION", "PRECISION", "PREPARE", "PRIMARY", "PROCEDURE", "RANGE", "READS", "REAL", "RECURSIVE", "REF", "REFERENCES", "REFERENCING", "RELEASE", "RESULT", "RETURN", "RETURNS", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SAVEPOINT", "SCOPE", "SCROLL", "SEARCH", "SECOND", "SELECT", "SENSITIVE", "SESSION_USER", "SET", "SIMILAR", "SOME", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "START", "STATIC", "SUBMULTISET", "SYMMETRIC", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "THEN", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO", "TRAILING", "TRANSLATION", "TREAT", "TRIGGER", "TRUE", "UESCAPE", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UPDATE", "USER", "USING", "VALUE", "VALUES", "WHENEVER", "WINDOW", "WITHIN", "WITHOUT", "YEAR"],
          reservedDataTypes: ["ARRAY", "BIGINT", "BINARY LARGE OBJECT", "BINARY VARYING", "BINARY", "BLOB", "BOOLEAN", "CHAR LARGE OBJECT", "CHAR VARYING", "CHAR", "CHARACTER LARGE OBJECT", "CHARACTER VARYING", "CHARACTER", "CLOB", "DATE", "DEC", "DECIMAL", "DOUBLE", "FLOAT", "INT", "INTEGER", "INTERVAL", "MULTISET", "NATIONAL CHAR VARYING", "NATIONAL CHAR", "NATIONAL CHARACTER LARGE OBJECT", "NATIONAL CHARACTER VARYING", "NATIONAL CHARACTER", "NCHAR LARGE OBJECT", "NCHAR VARYING", "NCHAR", "NCLOB", "NUMERIC", "SMALLINT", "TIME", "TIMESTAMP", "VARBINARY", "VARCHAR"],
          reservedFunctionNames: ["GROUPING", "RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "ROW_NUMBER", "POSITION", "OCCURRENCES_REGEX", "POSITION_REGEX", "EXTRACT", "CHAR_LENGTH", "CHARACTER_LENGTH", "OCTET_LENGTH", "CARDINALITY", "ABS", "MOD", "LN", "EXP", "POWER", "SQRT", "FLOOR", "CEIL", "CEILING", "WIDTH_BUCKET", "SUBSTRING", "SUBSTRING_REGEX", "UPPER", "LOWER", "CONVERT", "TRANSLATE", "TRANSLATE_REGEX", "TRIM", "OVERLAY", "NORMALIZE", "SPECIFICTYPE", "CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "CURRENT_TIMESTAMP", "LOCALTIMESTAMP", "COUNT", "AVG", "MAX", "MIN", "SUM", "STDDEV_POP", "STDDEV_SAMP", "VAR_SAMP", "VAR_POP", "COLLECT", "FUSION", "INTERSECTION", "COVAR_POP", "COVAR_SAMP", "CORR", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "PERCENTILE_CONT", "PERCENTILE_DISC", "CAST", "COALESCE", "NULLIF", "ROUND", "SIN", "COS", "TAN", "ASIN", "ACOS", "ATAN"],
          stringTypes: [{
            quote: "''-qq-bs",
            prefixes: ["N", "U&"]
          }, {
            quote: "''-raw",
            prefixes: ["X"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq', "``"],
          paramTypes: {
            positional: !0
          },
          operators: ["||"]
        },
        formatOptions: {
          onelineClauses: [...jO, ...JO],
          tabularOnelineClauses: JO
        }
      },
      iL = hN(["SELECT [ALL | DISTINCT]"]),
      rL = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY [ALL | DISTINCT]", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "FETCH {FIRST | NEXT}", "INSERT INTO", "VALUES", "SET", "MATCH_RECOGNIZE", "MEASURES", "ONE ROW PER MATCH", "ALL ROWS PER MATCH", "AFTER MATCH", "PATTERN", "SUBSET", "DEFINE"]),
      sL = hN(["CREATE TABLE [IF NOT EXISTS]"]),
      nL = hN(["CREATE [OR REPLACE] [MATERIALIZED] VIEW", "UPDATE", "DELETE FROM", "DROP TABLE [IF EXISTS]", "ALTER TABLE [IF EXISTS]", "ADD COLUMN [IF NOT EXISTS]", "DROP COLUMN [IF EXISTS]", "RENAME COLUMN [IF EXISTS]", "RENAME TO", "SET AUTHORIZATION [USER | ROLE]", "SET PROPERTIES", "EXECUTE", "TRUNCATE TABLE", "ALTER SCHEMA", "ALTER MATERIALIZED VIEW", "ALTER VIEW", "CREATE SCHEMA", "CREATE ROLE", "DROP SCHEMA", "DROP MATERIALIZED VIEW", "DROP VIEW", "DROP ROLE", "EXPLAIN", "ANALYZE", "EXPLAIN ANALYZE", "EXPLAIN ANALYZE VERBOSE", "USE", "DESCRIBE INPUT", "DESCRIBE OUTPUT", "REFRESH MATERIALIZED VIEW", "RESET SESSION", "SET SESSION", "SET PATH", "SET TIME ZONE", "SHOW GRANTS", "SHOW CREATE TABLE", "SHOW CREATE SCHEMA", "SHOW CREATE VIEW", "SHOW CREATE MATERIALIZED VIEW", "SHOW TABLES", "SHOW SCHEMAS", "SHOW CATALOGS", "SHOW COLUMNS", "SHOW STATS FOR", "SHOW ROLES", "SHOW CURRENT ROLES", "SHOW ROLE GRANTS", "SHOW FUNCTIONS", "SHOW SESSION"]),
      oL = hN(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]),
      aL = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]),
      lL = hN(["{ROWS | RANGE | GROUPS} BETWEEN", "IS [NOT] DISTINCT FROM"]),
      cL = hN([]),
      hL = {
        name: "trino",
        tokenizerOptions: {
          reservedSelect: iL,
          reservedClauses: [...rL, ...sL, ...nL],
          reservedSetOperations: oL,
          reservedJoins: aL,
          reservedKeywordPhrases: lL,
          reservedDataTypePhrases: cL,
          reservedKeywords: ["ABSENT", "ADD", "ADMIN", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "AS", "ASC", "AT", "AUTHORIZATION", "BERNOULLI", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CATALOGS", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONDITIONAL", "CONSTRAINT", "COPARTITION", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_PATH", "CURRENT_ROLE", "DATA", "DEALLOCATE", "DEFAULT", "DEFINE", "DEFINER", "DELETE", "DENY", "DESC", "DESCRIBE", "DESCRIPTOR", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "ELSE", "EMPTY", "ENCODING", "END", "ERROR", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FINAL", "FIRST", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "GROUPS", "HAVING", "IGNORE", "IN", "INCLUDING", "INITIAL", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IO", "IS", "ISOLATION", "JOIN", "JSON", "JSON_ARRAY", "JSON_OBJECT", "KEEP", "KEY", "KEYS", "LAST", "LATERAL", "LEADING", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCAL", "LOGICAL", "MATCH", "MATCHED", "MATCHES", "MATCH_RECOGNIZE", "MATERIALIZED", "MEASURES", "NATURAL", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NOT", "NULL", "NULLS", "OBJECT", "OF", "OFFSET", "OMIT", "ON", "ONE", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "OVERFLOW", "PARTITION", "PARTITIONS", "PASSING", "PAST", "PATH", "PATTERN", "PER", "PERMUTE", "PRECEDING", "PRECISION", "PREPARE", "PRIVILEGES", "PROPERTIES", "PRUNE", "QUOTES", "RANGE", "READ", "RECURSIVE", "REFRESH", "RENAME", "REPEATABLE", "RESET", "RESPECT", "RESTRICT", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "RUNNING", "SCALAR", "SCHEMA", "SCHEMAS", "SECURITY", "SEEK", "SELECT", "SERIALIZABLE", "SESSION", "SET", "SETS", "SHOW", "SKIP", "SOME", "START", "STATS", "STRING", "SUBSET", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TRUE", "TYPE", "UESCAPE", "UNBOUNDED", "UNCOMMITTED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", "UNMATCHED", "UNNEST", "UPDATE", "USE", "USER", "USING", "UTF16", "UTF32", "UTF8", "VALIDATE", "VALUE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE", "ZONE"],
          reservedDataTypes: ["BIGINT", "INT", "INTEGER", "SMALLINT", "TINYINT", "BOOLEAN", "DATE", "DECIMAL", "REAL", "DOUBLE", "HYPERLOGLOG", "QDIGEST", "TDIGEST", "P4HYPERLOGLOG", "INTERVAL", "TIMESTAMP", "TIME", "VARBINARY", "VARCHAR", "CHAR", "ROW", "ARRAY", "MAP", "JSON", "JSON2016", "IPADDRESS", "GEOMETRY", "UUID", "SETDIGEST", "JONIREGEXP", "RE2JREGEXP", "LIKEPATTERN", "COLOR", "CODEPOINTS", "FUNCTION", "JSONPATH"],
          reservedFunctionNames: ["ABS", "ACOS", "ALL_MATCH", "ANY_MATCH", "APPROX_DISTINCT", "APPROX_MOST_FREQUENT", "APPROX_PERCENTILE", "APPROX_SET", "ARBITRARY", "ARRAYS_OVERLAP", "ARRAY_AGG", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_SORT", "ARRAY_UNION", "ASIN", "ATAN", "ATAN2", "AT_TIMEZONE", "AVG", "BAR", "BETA_CDF", "BING_TILE", "BING_TILES_AROUND", "BING_TILE_AT", "BING_TILE_COORDINATES", "BING_TILE_POLYGON", "BING_TILE_QUADKEY", "BING_TILE_ZOOM_LEVEL", "BITWISE_AND", "BITWISE_AND_AGG", "BITWISE_LEFT_SHIFT", "BITWISE_NOT", "BITWISE_OR", "BITWISE_OR_AGG", "BITWISE_RIGHT_SHIFT", "BITWISE_RIGHT_SHIFT_ARITHMETIC", "BITWISE_XOR", "BIT_COUNT", "BOOL_AND", "BOOL_OR", "CARDINALITY", "CAST", "CBRT", "CEIL", "CEILING", "CHAR2HEXINT", "CHECKSUM", "CHR", "CLASSIFY", "COALESCE", "CODEPOINT", "COLOR", "COMBINATIONS", "CONCAT", "CONCAT_WS", "CONTAINS", "CONTAINS_SEQUENCE", "CONVEX_HULL_AGG", "CORR", "COS", "COSH", "COSINE_SIMILARITY", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CRC32", "CUME_DIST", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_GROUPS", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "DATE", "DATE_ADD", "DATE_DIFF", "DATE_FORMAT", "DATE_PARSE", "DATE_TRUNC", "DAY", "DAY_OF_MONTH", "DAY_OF_WEEK", "DAY_OF_YEAR", "DEGREES", "DENSE_RANK", "DOW", "DOY", "E", "ELEMENT_AT", "EMPTY_APPROX_SET", "EVALUATE_CLASSIFIER_PREDICTIONS", "EVERY", "EXP", "EXTRACT", "FEATURES", "FILTER", "FIRST_VALUE", "FLATTEN", "FLOOR", "FORMAT", "FORMAT_DATETIME", "FORMAT_NUMBER", "FROM_BASE", "FROM_BASE32", "FROM_BASE64", "FROM_BASE64URL", "FROM_BIG_ENDIAN_32", "FROM_BIG_ENDIAN_64", "FROM_ENCODED_POLYLINE", "FROM_GEOJSON_GEOMETRY", "FROM_HEX", "FROM_IEEE754_32", "FROM_IEEE754_64", "FROM_ISO8601_DATE", "FROM_ISO8601_TIMESTAMP", "FROM_ISO8601_TIMESTAMP_NANOS", "FROM_UNIXTIME", "FROM_UNIXTIME_NANOS", "FROM_UTF8", "GEOMETRIC_MEAN", "GEOMETRY_FROM_HADOOP_SHAPE", "GEOMETRY_INVALID_REASON", "GEOMETRY_NEAREST_POINTS", "GEOMETRY_TO_BING_TILES", "GEOMETRY_UNION", "GEOMETRY_UNION_AGG", "GREATEST", "GREAT_CIRCLE_DISTANCE", "HAMMING_DISTANCE", "HASH_COUNTS", "HISTOGRAM", "HMAC_MD5", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512", "HOUR", "HUMAN_READABLE_SECONDS", "IF", "INDEX", "INFINITY", "INTERSECTION_CARDINALITY", "INVERSE_BETA_CDF", "INVERSE_NORMAL_CDF", "IS_FINITE", "IS_INFINITE", "IS_JSON_SCALAR", "IS_NAN", "JACCARD_INDEX", "JSON_ARRAY_CONTAINS", "JSON_ARRAY_GET", "JSON_ARRAY_LENGTH", "JSON_EXISTS", "JSON_EXTRACT", "JSON_EXTRACT_SCALAR", "JSON_FORMAT", "JSON_PARSE", "JSON_QUERY", "JSON_SIZE", "JSON_VALUE", "KURTOSIS", "LAG", "LAST_DAY_OF_MONTH", "LAST_VALUE", "LEAD", "LEARN_CLASSIFIER", "LEARN_LIBSVM_CLASSIFIER", "LEARN_LIBSVM_REGRESSOR", "LEARN_REGRESSOR", "LEAST", "LENGTH", "LEVENSHTEIN_DISTANCE", "LINE_INTERPOLATE_POINT", "LINE_INTERPOLATE_POINTS", "LINE_LOCATE_POINT", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM", "LUHN_CHECK", "MAKE_SET_DIGEST", "MAP", "MAP_AGG", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FILTER", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_UNION", "MAP_VALUES", "MAP_ZIP_WITH", "MAX", "MAX_BY", "MD5", "MERGE", "MERGE_SET_DIGEST", "MILLISECOND", "MIN", "MINUTE", "MIN_BY", "MOD", "MONTH", "MULTIMAP_AGG", "MULTIMAP_FROM_ENTRIES", "MURMUR3", "NAN", "NGRAMS", "NONE_MATCH", "NORMALIZE", "NORMAL_CDF", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "NUMERIC_HISTOGRAM", "OBJECTID", "OBJECTID_TIMESTAMP", "PARSE_DATA_SIZE", "PARSE_DATETIME", "PARSE_DURATION", "PERCENT_RANK", "PI", "POSITION", "POW", "POWER", "QDIGEST_AGG", "QUARTER", "RADIANS", "RAND", "RANDOM", "RANK", "REDUCE", "REDUCE_AGG", "REGEXP_COUNT", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_LIKE", "REGEXP_POSITION", "REGEXP_REPLACE", "REGEXP_SPLIT", "REGRESS", "REGR_INTERCEPT", "REGR_SLOPE", "RENDER", "REPEAT", "REPLACE", "REVERSE", "RGB", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "SECOND", "SEQUENCE", "SHA1", "SHA256", "SHA512", "SHUFFLE", "SIGN", "SIMPLIFY_GEOMETRY", "SIN", "SKEWNESS", "SLICE", "SOUNDEX", "SPATIAL_PARTITIONING", "SPATIAL_PARTITIONS", "SPLIT", "SPLIT_PART", "SPLIT_TO_MAP", "SPLIT_TO_MULTIMAP", "SPOOKY_HASH_V2_32", "SPOOKY_HASH_V2_64", "SQRT", "STARTS_WITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRPOS", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_BOUNDARY", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COORDDIM", "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_ENVELOPEASPTS", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMETRIES", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMBINARY", "ST_INTERIORRINGN", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISRING", "ST_ISSIMPLE", "ST_ISVALID", "ST_LENGTH", "ST_LINEFROMTEXT", "ST_LINESTRING", "ST_MULTIPOINT", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINT", "ST_POINTN", "ST_POINTS", "ST_POLYGON", "ST_RELATE", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "SUBSTR", "SUBSTRING", "SUM", "TAN", "TANH", "TDIGEST_AGG", "TIMESTAMP_OBJECTID", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO_BASE", "TO_BASE32", "TO_BASE64", "TO_BASE64URL", "TO_BIG_ENDIAN_32", "TO_BIG_ENDIAN_64", "TO_CHAR", "TO_DATE", "TO_ENCODED_POLYLINE", "TO_GEOJSON_GEOMETRY", "TO_GEOMETRY", "TO_HEX", "TO_IEEE754_32", "TO_IEEE754_64", "TO_ISO8601", "TO_MILLISECONDS", "TO_SPHERICAL_GEOGRAPHY", "TO_TIMESTAMP", "TO_UNIXTIME", "TO_UTF8", "TRANSFORM", "TRANSFORM_KEYS", "TRANSFORM_VALUES", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRY", "TRY_CAST", "TYPEOF", "UPPER", "URL_DECODE", "URL_ENCODE", "URL_EXTRACT_FRAGMENT", "URL_EXTRACT_HOST", "URL_EXTRACT_PARAMETER", "URL_EXTRACT_PATH", "URL_EXTRACT_PORT", "URL_EXTRACT_PROTOCOL", "URL_EXTRACT_QUERY", "UUID", "VALUES_AT_QUANTILES", "VALUE_AT_QUANTILE", "VARIANCE", "VAR_POP", "VAR_SAMP", "VERSION", "WEEK", "WEEK_OF_YEAR", "WIDTH_BUCKET", "WILSON_INTERVAL_LOWER", "WILSON_INTERVAL_UPPER", "WITH_TIMEZONE", "WORD_STEM", "XXHASH64", "YEAR", "YEAR_OF_WEEK", "YOW", "ZIP", "ZIP_WITH", "CLASSIFIER", "FIRST", "LAST", "MATCH_NUMBER", "NEXT", "PERMUTE", "PREV"],
          extraParens: ["[]", "{}"],
          stringTypes: [{
            quote: "''-qq",
            prefixes: ["U&"]
          }, {
            quote: "''-raw",
            prefixes: ["X"],
            requirePrefix: !0
          }],
          identTypes: ['""-qq'],
          paramTypes: {
            positional: !0
          },
          operators: ["%", "->", "=>", ":", "||", "|", "^", "$"]
        },
        formatOptions: {
          onelineClauses: [...sL, ...nL],
          tabularOnelineClauses: nL
        }
      },
      uL = hN(["SELECT [ALL | DISTINCT]"]),
      dL = hN(["WITH", "INTO", "FROM", "WHERE", "GROUP BY", "HAVING", "WINDOW", "PARTITION BY", "ORDER BY", "OFFSET", "FETCH {FIRST | NEXT}", "FOR {BROWSE | XML | JSON}", "OPTION", "INSERT [INTO]", "VALUES", "SET", "MERGE [INTO]", "WHEN [NOT] MATCHED [BY TARGET | BY SOURCE] [THEN]", "UPDATE SET", "CREATE [OR ALTER] {PROC | PROCEDURE}"]),
      pL = hN(["CREATE TABLE"]),
      EL = hN(["CREATE [OR ALTER] [MATERIALIZED] VIEW", "UPDATE", "WHERE CURRENT OF", "DELETE [FROM]", "DROP TABLE [IF EXISTS]", "ALTER TABLE", "ADD", "DROP COLUMN [IF EXISTS]", "ALTER COLUMN", "TRUNCATE TABLE", "CREATE [UNIQUE] [CLUSTERED] INDEX", "CREATE DATABASE", "ALTER DATABASE", "DROP DATABASE [IF EXISTS]", "ALTER {FUNCTION | PROCEDURE | PROC}", "GO", "USE", "ADD SENSITIVITY CLASSIFICATION", "ADD SIGNATURE", "AGGREGATE", "ANSI_DEFAULTS", "ANSI_NULLS", "ANSI_NULL_DFLT_OFF", "ANSI_NULL_DFLT_ON", "ANSI_PADDING", "ANSI_WARNINGS", "APPLICATION ROLE", "ARITHABORT", "ARITHIGNORE", "ASSEMBLY", "ASYMMETRIC KEY", "AUTHORIZATION", "AVAILABILITY GROUP", "BACKUP", "BACKUP CERTIFICATE", "BACKUP MASTER KEY", "BACKUP SERVICE MASTER KEY", "BEGIN CONVERSATION TIMER", "BEGIN DIALOG CONVERSATION", "BROKER PRIORITY", "BULK INSERT", "CERTIFICATE", "CLOSE MASTER KEY", "CLOSE SYMMETRIC KEY", "COLLATE", "COLUMN ENCRYPTION KEY", "COLUMN MASTER KEY", "COLUMNSTORE INDEX", "CONCAT_NULL_YIELDS_NULL", "CONTEXT_INFO", "CONTRACT", "CREDENTIAL", "CRYPTOGRAPHIC PROVIDER", "CURSOR_CLOSE_ON_COMMIT", "DATABASE", "DATABASE AUDIT SPECIFICATION", "DATABASE ENCRYPTION KEY", "DATABASE HADR", "DATABASE SCOPED CONFIGURATION", "DATABASE SCOPED CREDENTIAL", "DATABASE SET", "DATEFIRST", "DATEFORMAT", "DEADLOCK_PRIORITY", "DENY", "DENY XML", "DISABLE TRIGGER", "ENABLE TRIGGER", "END CONVERSATION", "ENDPOINT", "EVENT NOTIFICATION", "EVENT SESSION", "EXECUTE AS", "EXTERNAL DATA SOURCE", "EXTERNAL FILE FORMAT", "EXTERNAL LANGUAGE", "EXTERNAL LIBRARY", "EXTERNAL RESOURCE POOL", "EXTERNAL TABLE", "FIPS_FLAGGER", "FMTONLY", "FORCEPLAN", "FULLTEXT CATALOG", "FULLTEXT INDEX", "FULLTEXT STOPLIST", "GET CONVERSATION GROUP", "GET_TRANSMISSION_STATUS", "GRANT", "GRANT XML", "IDENTITY_INSERT", "IMPLICIT_TRANSACTIONS", "INDEX", "LANGUAGE", "LOCK_TIMEOUT", "LOGIN", "MASTER KEY", "MESSAGE TYPE", "MOVE CONVERSATION", "NOCOUNT", "NOEXEC", "NUMERIC_ROUNDABORT", "OFFSETS", "OPEN MASTER KEY", "OPEN SYMMETRIC KEY", "PARSEONLY", "PARTITION FUNCTION", "PARTITION SCHEME", "QUERY_GOVERNOR_COST_LIMIT", "QUEUE", "QUOTED_IDENTIFIER", "RECEIVE", "REMOTE SERVICE BINDING", "REMOTE_PROC_TRANSACTIONS", "RESOURCE GOVERNOR", "RESOURCE POOL", "RESTORE", "RESTORE FILELISTONLY", "RESTORE HEADERONLY", "RESTORE LABELONLY", "RESTORE MASTER KEY", "RESTORE REWINDONLY", "RESTORE SERVICE MASTER KEY", "RESTORE VERIFYONLY", "REVERT", "REVOKE", "REVOKE XML", "ROLE", "ROUTE", "ROWCOUNT", "RULE", "SCHEMA", "SEARCH PROPERTY LIST", "SECURITY POLICY", "SELECTIVE XML INDEX", "SEND", "SENSITIVITY CLASSIFICATION", "SEQUENCE", "SERVER AUDIT", "SERVER AUDIT SPECIFICATION", "SERVER CONFIGURATION", "SERVER ROLE", "SERVICE", "SERVICE MASTER KEY", "SETUSER", "SHOWPLAN_ALL", "SHOWPLAN_TEXT", "SHOWPLAN_XML", "SIGNATURE", "SPATIAL INDEX", "STATISTICS", "STATISTICS IO", "STATISTICS PROFILE", "STATISTICS TIME", "STATISTICS XML", "SYMMETRIC KEY", "SYNONYM", "TABLE", "TABLE IDENTITY", "TEXTSIZE", "TRANSACTION ISOLATION LEVEL", "TRIGGER", "TYPE", "UPDATE STATISTICS", "USER", "WORKLOAD GROUP", "XACT_ABORT", "XML INDEX", "XML SCHEMA COLLECTION"]),
      gL = hN(["UNION [ALL]", "EXCEPT", "INTERSECT"]),
      fL = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "{CROSS | OUTER} APPLY"]),
      TL = hN(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]),
      mL = hN([]),
      CL = {
        name: "transactsql",
        tokenizerOptions: {
          reservedSelect: uL,
          reservedClauses: [...dL, ...pL, ...EL],
          reservedSetOperations: gL,
          reservedJoins: fL,
          reservedKeywordPhrases: TL,
          reservedDataTypePhrases: mL,
          reservedKeywords: ["ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BEGIN", "BETWEEN", "BREAK", "BROWSE", "BULK", "BY", "CASCADE", "CHECK", "CHECKPOINT", "CLOSE", "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", "DROP", "DUMP", "ERRLVL", "ESCAPE", "EXEC", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", "FILE", "FILLFACTOR", "FOR", "FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GOTO", "GRANT", "GROUP", "HAVING", "HOLDLOCK", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INDEX", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", "LIKE", "LINENO", "LOAD", "MERGE", "NOCHECK", "NONCLUSTERED", "NOT", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", "PLAN", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "PUBLIC", "RAISERROR", "READ", "READTEXT", "RECONFIGURE", "REFERENCES", "REPLICATION", "RESTORE", "RESTRICT", "RETURN", "REVERT", "REVOKE", "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "RULE", "SAVE", "SCHEMA", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", "SOME", "STATISTICS", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TEXTSIZE", "THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRIGGER", "TRUNCATE", "TRY_CONVERT", "TSEQUAL", "UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", "VIEW", "WAITFOR", "WHERE", "WHILE", "WITH", "WITHIN GROUP", "WRITETEXT", "$ACTION"],
          reservedDataTypes: ["BINARY", "BIT", "CHAR", "CHAR", "CHARACTER", "DATE", "DATETIME2", "DATETIMEOFFSET", "DEC", "DECIMAL", "DOUBLE", "FLOAT", "INT", "INTEGER", "NATIONAL", "NCHAR", "NUMERIC", "NVARCHAR", "PRECISION", "REAL", "SMALLINT", "TIME", "TIMESTAMP", "VARBINARY", "VARCHAR"],
          reservedFunctionNames: ["APPROX_COUNT_DISTINCT", "AVG", "CHECKSUM_AGG", "COUNT", "COUNT_BIG", "GROUPING", "GROUPING_ID", "MAX", "MIN", "STDEV", "STDEVP", "SUM", "VAR", "VARP", "CUME_DIST", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "Collation - COLLATIONPROPERTY", "Collation - TERTIARY_WEIGHTS", "@@DBTS", "@@LANGID", "@@LANGUAGE", "@@LOCK_TIMEOUT", "@@MAX_CONNECTIONS", "@@MAX_PRECISION", "@@NESTLEVEL", "@@OPTIONS", "@@REMSERVER", "@@SERVERNAME", "@@SERVICENAME", "@@SPID", "@@TEXTSIZE", "@@VERSION", "CAST", "CONVERT", "PARSE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE", "ASYMKEY_ID", "ASYMKEYPROPERTY", "CERTPROPERTY", "CERT_ID", "CRYPT_GEN_RANDOM", "DECRYPTBYASYMKEY", "DECRYPTBYCERT", "DECRYPTBYKEY", "DECRYPTBYKEYAUTOASYMKEY", "DECRYPTBYKEYAUTOCERT", "DECRYPTBYPASSPHRASE", "ENCRYPTBYASYMKEY", "ENCRYPTBYCERT", "ENCRYPTBYKEY", "ENCRYPTBYPASSPHRASE", "HASHBYTES", "IS_OBJECTSIGNED", "KEY_GUID", "KEY_ID", "KEY_NAME", "SIGNBYASYMKEY", "SIGNBYCERT", "SYMKEYPROPERTY", "VERIFYSIGNEDBYCERT", "VERIFYSIGNEDBYASYMKEY", "@@CURSOR_ROWS", "@@FETCH_STATUS", "CURSOR_STATUS", "DATALENGTH", "IDENT_CURRENT", "IDENT_INCR", "IDENT_SEED", "IDENTITY", "SQL_VARIANT_PROPERTY", "@@DATEFIRST", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_TIMEZONE_ID", "DATEADD", "DATEDIFF", "DATEDIFF_BIG", "DATEFROMPARTS", "DATENAME", "DATEPART", "DATETIME2FROMPARTS", "DATETIMEFROMPARTS", "DATETIMEOFFSETFROMPARTS", "DAY", "EOMONTH", "GETDATE", "GETUTCDATE", "ISDATE", "MONTH", "SMALLDATETIMEFROMPARTS", "SWITCHOFFSET", "SYSDATETIME", "SYSDATETIMEOFFSET", "SYSUTCDATETIME", "TIMEFROMPARTS", "TODATETIMEOFFSET", "YEAR", "JSON", "ISJSON", "JSON_VALUE", "JSON_QUERY", "JSON_MODIFY", "ABS", "ACOS", "ASIN", "ATAN", "ATN2", "CEILING", "COS", "COT", "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "PI", "POWER", "RADIANS", "RAND", "ROUND", "SIGN", "SIN", "SQRT", "SQUARE", "TAN", "CHOOSE", "GREATEST", "IIF", "LEAST", "@@PROCID", "APP_NAME", "APPLOCK_MODE", "APPLOCK_TEST", "ASSEMBLYPROPERTY", "COL_LENGTH", "COL_NAME", "COLUMNPROPERTY", "DATABASEPROPERTYEX", "DB_ID", "DB_NAME", "FILE_ID", "FILE_IDEX", "FILE_NAME", "FILEGROUP_ID", "FILEGROUP_NAME", "FILEGROUPPROPERTY", "FILEPROPERTY", "FILEPROPERTYEX", "FULLTEXTCATALOGPROPERTY", "FULLTEXTSERVICEPROPERTY", "INDEX_COL", "INDEXKEY_PROPERTY", "INDEXPROPERTY", "NEXT VALUE FOR", "OBJECT_DEFINITION", "OBJECT_ID", "OBJECT_NAME", "OBJECT_SCHEMA_NAME", "OBJECTPROPERTY", "OBJECTPROPERTYEX", "ORIGINAL_DB_NAME", "PARSENAME", "SCHEMA_ID", "SCHEMA_NAME", "SCOPE_IDENTITY", "SERVERPROPERTY", "STATS_DATE", "TYPE_ID", "TYPE_NAME", "TYPEPROPERTY", "DENSE_RANK", "NTILE", "RANK", "ROW_NUMBER", "PUBLISHINGSERVERNAME", "CERTENCODED", "CERTPRIVATEKEY", "CURRENT_USER", "DATABASE_PRINCIPAL_ID", "HAS_DBACCESS", "HAS_PERMS_BY_NAME", "IS_MEMBER", "IS_ROLEMEMBER", "IS_SRVROLEMEMBER", "LOGINPROPERTY", "ORIGINAL_LOGIN", "PERMISSIONS", "PWDENCRYPT", "PWDCOMPARE", "SESSION_USER", "SESSIONPROPERTY", "SUSER_ID", "SUSER_NAME", "SUSER_SID", "SUSER_SNAME", "SYSTEM_USER", "USER", "USER_ID", "USER_NAME", "ASCII", "CHARINDEX", "CONCAT", "CONCAT_WS", "DIFFERENCE", "FORMAT", "LEFT", "LEN", "LOWER", "LTRIM", "PATINDEX", "QUOTENAME", "REPLACE", "REPLICATE", "REVERSE", "RIGHT", "RTRIM", "SOUNDEX", "SPACE", "STR", "STRING_AGG", "STRING_ESCAPE", "STUFF", "SUBSTRING", "TRANSLATE", "TRIM", "UNICODE", "UPPER", "$PARTITION", "@@ERROR", "@@IDENTITY", "@@PACK_RECEIVED", "@@ROWCOUNT", "@@TRANCOUNT", "BINARY_CHECKSUM", "CHECKSUM", "COMPRESS", "CONNECTIONPROPERTY", "CONTEXT_INFO", "CURRENT_REQUEST_ID", "CURRENT_TRANSACTION_ID", "DECOMPRESS", "ERROR_LINE", "ERROR_MESSAGE", "ERROR_NUMBER", "ERROR_PROCEDURE", "ERROR_SEVERITY", "ERROR_STATE", "FORMATMESSAGE", "GET_FILESTREAM_TRANSACTION_CONTEXT", "GETANSINULL", "HOST_ID", "HOST_NAME", "ISNULL", "ISNUMERIC", "MIN_ACTIVE_ROWVERSION", "NEWID", "NEWSEQUENTIALID", "ROWCOUNT_BIG", "SESSION_CONTEXT", "XACT_STATE", "@@CONNECTIONS", "@@CPU_BUSY", "@@IDLE", "@@IO_BUSY", "@@PACK_SENT", "@@PACKET_ERRORS", "@@TIMETICKS", "@@TOTAL_ERRORS", "@@TOTAL_READ", "@@TOTAL_WRITE", "TEXTPTR", "TEXTVALID", "COLUMNS_UPDATED", "EVENTDATA", "TRIGGER_NESTLEVEL", "UPDATE", "COALESCE", "NULLIF"],
          nestedBlockComments: !0,
          stringTypes: [{
            quote: "''-qq",
            prefixes: ["N"]
          }, "{}"],
          identTypes: ['""-qq', "[]"],
          identChars: {
            first: "#@",
            rest: "#@$"
          },
          paramTypes: {
            named: ["@"],
            quoted: ["@"]
          },
          operators: ["%", "&", "|", "^", "~", "!<", "!>", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "::", ":"],
          propertyAccessOperators: [".."]
        },
        formatOptions: {
          alwaysDenseOperators: ["::"],
          onelineClauses: [...pL, ...EL],
          tabularOnelineClauses: EL
        }
      },
      SL = hN(["SELECT [ALL | DISTINCT | DISTINCTROW]"]),
      RL = hN(["WITH", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER BY", "LIMIT", "OFFSET", "INSERT [IGNORE] [INTO]", "VALUES", "REPLACE [INTO]", "ON DUPLICATE KEY UPDATE", "SET", "CREATE [OR REPLACE] [TEMPORARY] PROCEDURE [IF NOT EXISTS]", "CREATE [OR REPLACE] [EXTERNAL] FUNCTION"]),
      AL = hN(["CREATE [ROWSTORE] [REFERENCE | TEMPORARY | GLOBAL TEMPORARY] TABLE [IF NOT EXISTS]"]),
      vL = hN(["CREATE VIEW", "UPDATE", "DELETE [FROM]", "DROP [TEMPORARY] TABLE [IF EXISTS]", "ALTER [ONLINE] TABLE", "ADD [COLUMN]", "ADD [UNIQUE] {INDEX | KEY}", "DROP [COLUMN]", "MODIFY [COLUMN]", "CHANGE", "RENAME [TO | AS]", "TRUNCATE [TABLE]", "ADD AGGREGATOR", "ADD LEAF", "AGGREGATOR SET AS MASTER", "ALTER DATABASE", "ALTER PIPELINE", "ALTER RESOURCE POOL", "ALTER USER", "ALTER VIEW", "ANALYZE TABLE", "ATTACH DATABASE", "ATTACH LEAF", "ATTACH LEAF ALL", "BACKUP DATABASE", "BINLOG", "BOOTSTRAP AGGREGATOR", "CACHE INDEX", "CALL", "CHANGE", "CHANGE MASTER TO", "CHANGE REPLICATION FILTER", "CHANGE REPLICATION SOURCE TO", "CHECK BLOB CHECKSUM", "CHECK TABLE", "CHECKSUM TABLE", "CLEAR ORPHAN DATABASES", "CLONE", "COMMIT", "CREATE DATABASE", "CREATE GROUP", "CREATE INDEX", "CREATE LINK", "CREATE MILESTONE", "CREATE PIPELINE", "CREATE RESOURCE POOL", "CREATE ROLE", "CREATE USER", "DEALLOCATE PREPARE", "DESCRIBE", "DETACH DATABASE", "DETACH PIPELINE", "DROP DATABASE", "DROP FUNCTION", "DROP INDEX", "DROP LINK", "DROP PIPELINE", "DROP PROCEDURE", "DROP RESOURCE POOL", "DROP ROLE", "DROP USER", "DROP VIEW", "EXECUTE", "EXPLAIN", "FLUSH", "FORCE", "GRANT", "HANDLER", "HELP", "KILL CONNECTION", "KILLALL QUERIES", "LOAD DATA", "LOAD INDEX INTO CACHE", "LOAD XML", "LOCK INSTANCE FOR BACKUP", "LOCK TABLES", "MASTER_POS_WAIT", "OPTIMIZE TABLE", "PREPARE", "PURGE BINARY LOGS", "REBALANCE PARTITIONS", "RELEASE SAVEPOINT", "REMOVE AGGREGATOR", "REMOVE LEAF", "REPAIR TABLE", "REPLACE", "REPLICATE DATABASE", "RESET", "RESET MASTER", "RESET PERSIST", "RESET REPLICA", "RESET SLAVE", "RESTART", "RESTORE DATABASE", "RESTORE REDUNDANCY", "REVOKE", "ROLLBACK", "ROLLBACK TO SAVEPOINT", "SAVEPOINT", "SET CHARACTER SET", "SET DEFAULT ROLE", "SET NAMES", "SET PASSWORD", "SET RESOURCE GROUP", "SET ROLE", "SET TRANSACTION", "SHOW", "SHOW CHARACTER SET", "SHOW COLLATION", "SHOW COLUMNS", "SHOW CREATE DATABASE", "SHOW CREATE FUNCTION", "SHOW CREATE PIPELINE", "SHOW CREATE PROCEDURE", "SHOW CREATE TABLE", "SHOW CREATE USER", "SHOW CREATE VIEW", "SHOW DATABASES", "SHOW ENGINE", "SHOW ENGINES", "SHOW ERRORS", "SHOW FUNCTION CODE", "SHOW FUNCTION STATUS", "SHOW GRANTS", "SHOW INDEX", "SHOW MASTER STATUS", "SHOW OPEN TABLES", "SHOW PLUGINS", "SHOW PRIVILEGES", "SHOW PROCEDURE CODE", "SHOW PROCEDURE STATUS", "SHOW PROCESSLIST", "SHOW PROFILE", "SHOW PROFILES", "SHOW RELAYLOG EVENTS", "SHOW REPLICA STATUS", "SHOW REPLICAS", "SHOW SLAVE", "SHOW SLAVE HOSTS", "SHOW STATUS", "SHOW TABLE STATUS", "SHOW TABLES", "SHOW VARIABLES", "SHOW WARNINGS", "SHUTDOWN", "SNAPSHOT DATABASE", "SOURCE_POS_WAIT", "START GROUP_REPLICATION", "START PIPELINE", "START REPLICA", "START SLAVE", "START TRANSACTION", "STOP GROUP_REPLICATION", "STOP PIPELINE", "STOP REPLICA", "STOP REPLICATING", "STOP SLAVE", "TEST PIPELINE", "UNLOCK INSTANCE", "UNLOCK TABLES", "USE", "XA", "ITERATE", "LEAVE", "LOOP", "REPEAT", "RETURN", "WHILE"]),
      NL = hN(["UNION [ALL | DISTINCT]", "EXCEPT", "INTERSECT", "MINUS"]),
      IL = hN(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL {LEFT | RIGHT} [OUTER] JOIN", "STRAIGHT_JOIN"]),
      OL = hN(["ON DELETE", "ON UPDATE", "CHARACTER SET", "{ROWS | RANGE} BETWEEN", "IDENTIFIED BY"]),
      LL = hN([]),
      _L = {
        name: "singlestoredb",
        tokenizerOptions: {
          reservedSelect: SL,
          reservedClauses: [...RL, ...AL, ...vL],
          reservedSetOperations: NL,
          reservedJoins: IL,
          reservedKeywordPhrases: OL,
          reservedDataTypePhrases: LL,
          reservedKeywords: ["ADD", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ASENSITIVE", "BEFORE", "BETWEEN", "_BINARY", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DROP", "DUAL", "EACH", "ELSE", "ELSEIF", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "EXTRA_JOIN", "FALSE", "FETCH", "FOR", "FORCE", "FORCE_COMPILED_MODE", "FORCE_INTERPRETER_MODE", "FOREIGN", "FROM", "FULL", "FULLTEXT", "GRANT", "GROUP", "HAVING", "HEARTBEAT_NO_LOGGING", "HIGH_PRIORITY", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSENSITIVE", "INSERT", "IN", "_INTERNAL_DYNAMIC_TYPECAST", "INTERSECT", "INTERVAL", "INTO", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINES", "LOAD", "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LOOP", "LOW_PRIORITY", "MATCH", "MAXVALUE", "MINUS", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MOD", "MODIFIES", "NATURAL", "NO_QUERY_REWRITE", "NOT", "NO_WRITE_TO_BINLOG", "NO_QUERY_REWRITE", "NULL", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESTRICT", "RETURN", "REVOKE", "RIGHT", "RIGHT_ANTI_JOIN", "RIGHT_SEMI_JOIN", "RIGHT_STRAIGHT_JOIN", "RLIKE", "SCHEMA", "SCHEMAS", "SECOND_MICROSECOND", "SELECT", "SEMI_JOIN", "SENSITIVE", "SEPARATOR", "SET", "SHOW", "SIGNAL", "SPATIAL", "SPECIFIC", "SQL", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS", "SQLEXCEPTION", "SQL_NO_CACHE", "SQL_NO_LOGGING", "SQL_SMALL_RESULT", "SQLSTATE", "SQLWARNING", "STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNBOUNDED", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UPDATE", "USAGE", "USE", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "_UTF8", "VALUES", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WRITE", "XOR", "YEAR_MONTH", "ZEROFILL"],
          reservedDataTypes: ["BIGINT", "BINARY", "BIT", "BLOB", "CHAR", "CHARACTER", "DATETIME", "DEC", "DECIMAL", "DOUBLE PRECISION", "DOUBLE", "ENUM", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "LONG", "LONGBLOB", "LONGTEXT", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MIDDLEINT", "NATIONAL CHAR", "NATIONAL VARCHAR", "NUMERIC", "PRECISION", "REAL", "SMALLINT", "TEXT", "TIME", "TIMESTAMP", "TINYBLOB", "TINYINT", "TINYTEXT", "UNSIGNED", "VARBINARY", "VARCHAR", "VARCHARACTER", "YEAR"],
          reservedFunctionNames: ["ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "ANY_VALUE", "APPROX_COUNT_DISTINCT", "APPROX_COUNT_DISTINCT_ACCUMULATE", "APPROX_COUNT_DISTINCT_COMBINE", "APPROX_COUNT_DISTINCT_ESTIMATE", "APPROX_GEOGRAPHY_INTERSECTS", "APPROX_PERCENTILE", "ASCII", "ASIN", "ATAN", "ATAN2", "AVG", "BIN", "BINARY", "BIT_AND", "BIT_COUNT", "BIT_OR", "BIT_XOR", "CAST", "CEIL", "CEILING", "CHAR", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHARSET", "COALESCE", "COERCIBILITY", "COLLATION", "COLLECT", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT", "CONVERT_TZ", "COS", "COT", "COUNT", "CUME_DIST", "CURDATE", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURTIME", "DATABASE", "DATE", "DATE_ADD", "DATEDIFF", "DATE_FORMAT", "DATE_SUB", "DATE_TRUNC", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEFAULT", "DEGREES", "DENSE_RANK", "DIV", "DOT_PRODUCT", "ELT", "EUCLIDEAN_DISTANCE", "EXP", "EXTRACT", "FIELD", "FIRST", "FIRST_VALUE", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOGRAPHY_AREA", "GEOGRAPHY_CONTAINS", "GEOGRAPHY_DISTANCE", "GEOGRAPHY_INTERSECTS", "GEOGRAPHY_LATITUDE", "GEOGRAPHY_LENGTH", "GEOGRAPHY_LONGITUDE", "GEOGRAPHY_POINT", "GEOGRAPHY_WITHIN_DISTANCE", "GEOMETRY_AREA", "GEOMETRY_CONTAINS", "GEOMETRY_DISTANCE", "GEOMETRY_FILTER", "GEOMETRY_INTERSECTS", "GEOMETRY_LENGTH", "GEOMETRY_POINT", "GEOMETRY_WITHIN_DISTANCE", "GEOMETRY_X", "GEOMETRY_Y", "GREATEST", "GROUPING", "GROUP_CONCAT", "HEX", "HIGHLIGHT", "HOUR", "ICU_VERSION", "IF", "IFNULL", "INET_ATON", "INET_NTOA", "INET6_ATON", "INET6_NTOA", "INITCAP", "INSERT", "INSTR", "INTERVAL", "IS", "IS NULL", "JSON_AGG", "JSON_ARRAY_CONTAINS_DOUBLE", "JSON_ARRAY_CONTAINS_JSON", "JSON_ARRAY_CONTAINS_STRING", "JSON_ARRAY_PUSH_DOUBLE", "JSON_ARRAY_PUSH_JSON", "JSON_ARRAY_PUSH_STRING", "JSON_DELETE_KEY", "JSON_EXTRACT_DOUBLE", "JSON_EXTRACT_JSON", "JSON_EXTRACT_STRING", "JSON_EXTRACT_BIGINT", "JSON_GET_TYPE", "JSON_LENGTH", "JSON_SET_DOUBLE", "JSON_SET_JSON", "JSON_SET_STRING", "JSON_SPLICE_DOUBLE", "JSON_SPLICE_JSON", "JSON_SPLICE_STRING", "LAG", "LAST_DAY", "LAST_VALUE", "LCASE", "LEAD", "LEAST", "LEFT", "LENGTH", "LIKE", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOCATE", "LOG", "LOG10", "LOG2", "LPAD", "LTRIM", "MATCH", "MAX", "MD5", "MEDIAN", "MICROSECOND", "MIN", "MINUTE", "MOD", "MONTH", "MONTHNAME", "MONTHS_BETWEEN", "NOT", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "OCTET_LENGTH", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PI", "PIVOT", "POSITION", "POW", "POWER", "QUARTER", "QUOTE", "RADIANS", "RAND", "RANK", "REGEXP", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RLIKE", "ROUND", "ROW_COUNT", "ROW_NUMBER", "RPAD", "RTRIM", "SCALAR", "SCHEMA", "SEC_TO_TIME", "SHA1", "SHA2", "SIGMOID", "SIGN", "SIN", "SLEEP", "SPLIT", "SOUNDEX", "SOUNDS LIKE", "SOURCE_POS_WAIT", "SPACE", "SQRT", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STR_TO_DATE", "SUBDATE", "SUBSTR", "SUBSTRING", "SUBSTRING_INDEX", "SUM", "SYS_GUID", "TAN", "TIME", "TIMEDIFF", "TIME_BUCKET", "TIME_FORMAT", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_TO_SEC", "TO_BASE64", "TO_CHAR", "TO_DAYS", "TO_JSON", "TO_NUMBER", "TO_SECONDS", "TO_TIMESTAMP", "TRIM", "TRUNC", "TRUNCATE", "UCASE", "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "UUID", "VALUES", "VARIANCE", "VAR_POP", "VAR_SAMP", "VECTOR_SUB", "VERSION", "WEEK", "WEEKDAY", "WEEKOFYEAR", "YEAR"],
          stringTypes: ['""-qq-bs', "''-qq-bs", {
            quote: "''-raw",
            prefixes: ["B", "X"],
            requirePrefix: !0
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$",
            allowFirstCharNumber: !0
          },
          variableTypes: [{
            regex: "@@?[A-Za-z0-9_$]+"
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: !0
          }],
          lineCommentTypes: ["--", "#"],
          operators: [":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "::", "::$", "::%", ":>", "!:>", "*.*"],
          postProcess: SI
        },
        formatOptions: {
          alwaysDenseOperators: ["::", "::$", "::%"],
          onelineClauses: [...AL, ...vL],
          tabularOnelineClauses: vL
        }
      },
      yL = hN(["SELECT [ALL | DISTINCT]"]),
      wL = hN(["WITH [RECURSIVE]", "FROM", "WHERE", "GROUP BY", "HAVING", "PARTITION BY", "ORDER BY", "QUALIFY", "LIMIT", "OFFSET", "FETCH [FIRST | NEXT]", "INSERT [OVERWRITE] [ALL INTO | INTO | ALL | FIRST]", "{THEN | ELSE} INTO", "VALUES", "SET", "CLUSTER BY", "[WITH] {MASKING POLICY | TAG | ROW ACCESS POLICY}", "COPY GRANTS", "USING TEMPLATE", "MERGE INTO", "WHEN MATCHED [AND]", "THEN {UPDATE SET | DELETE}", "WHEN NOT MATCHED THEN INSERT"]),
      DL = hN(["CREATE [OR REPLACE] [VOLATILE] TABLE [IF NOT EXISTS]", "CREATE [OR REPLACE] [LOCAL | GLOBAL] {TEMP|TEMPORARY} TABLE [IF NOT EXISTS]"]),
      PL = hN(["CREATE [OR REPLACE] [SECURE] [RECURSIVE] VIEW [IF NOT EXISTS]", "UPDATE", "DELETE FROM", "DROP TABLE [IF EXISTS]", "ALTER TABLE [IF EXISTS]", "RENAME TO", "SWAP WITH", "[SUSPEND | RESUME] RECLUSTER", "DROP CLUSTERING KEY", "ADD [COLUMN]", "RENAME COLUMN", "{ALTER | MODIFY} [COLUMN]", "DROP [COLUMN]", "{ADD | ALTER | MODIFY | DROP} [CONSTRAINT]", "RENAME CONSTRAINT", "{ADD | DROP} SEARCH OPTIMIZATION", "{SET | UNSET} TAG", "{ADD | DROP} ROW ACCESS POLICY", "DROP ALL ROW ACCESS POLICIES", "{SET | DROP} DEFAULT", "{SET | DROP} NOT NULL", "SET DATA TYPE", "UNSET COMMENT", "{SET | UNSET} MASKING POLICY", "TRUNCATE [TABLE] [IF EXISTS]", "ALTER ACCOUNT", "ALTER API INTEGRATION", "ALTER CONNECTION", "ALTER DATABASE", "ALTER EXTERNAL TABLE", "ALTER FAILOVER GROUP", "ALTER FILE FORMAT", "ALTER FUNCTION", "ALTER INTEGRATION", "ALTER MASKING POLICY", "ALTER MATERIALIZED VIEW", "ALTER NETWORK POLICY", "ALTER NOTIFICATION INTEGRATION", "ALTER PIPE", "ALTER PROCEDURE", "ALTER REPLICATION GROUP", "ALTER RESOURCE MONITOR", "ALTER ROLE", "ALTER ROW ACCESS POLICY", "ALTER SCHEMA", "ALTER SECURITY INTEGRATION", "ALTER SEQUENCE", "ALTER SESSION", "ALTER SESSION POLICY", "ALTER SHARE", "ALTER STAGE", "ALTER STORAGE INTEGRATION", "ALTER STREAM", "ALTER TAG", "ALTER TASK", "ALTER USER", "ALTER VIEW", "ALTER WAREHOUSE", "BEGIN", "CALL", "COMMIT", "COPY INTO", "CREATE ACCOUNT", "CREATE API INTEGRATION", "CREATE CONNECTION", "CREATE DATABASE", "CREATE EXTERNAL FUNCTION", "CREATE EXTERNAL TABLE", "CREATE FAILOVER GROUP", "CREATE FILE FORMAT", "CREATE FUNCTION", "CREATE INTEGRATION", "CREATE MANAGED ACCOUNT", "CREATE MASKING POLICY", "CREATE MATERIALIZED VIEW", "CREATE NETWORK POLICY", "CREATE NOTIFICATION INTEGRATION", "CREATE PIPE", "CREATE PROCEDURE", "CREATE REPLICATION GROUP", "CREATE RESOURCE MONITOR", "CREATE ROLE", "CREATE ROW ACCESS POLICY", "CREATE SCHEMA", "CREATE SECURITY INTEGRATION", "CREATE SEQUENCE", "CREATE SESSION POLICY", "CREATE SHARE", "CREATE STAGE", "CREATE STORAGE INTEGRATION", "CREATE STREAM", "CREATE TAG", "CREATE TASK", "CREATE USER", "CREATE WAREHOUSE", "DELETE", "DESCRIBE DATABASE", "DESCRIBE EXTERNAL TABLE", "DESCRIBE FILE FORMAT", "DESCRIBE FUNCTION", "DESCRIBE INTEGRATION", "DESCRIBE MASKING POLICY", "DESCRIBE MATERIALIZED VIEW", "DESCRIBE NETWORK POLICY", "DESCRIBE PIPE", "DESCRIBE PROCEDURE", "DESCRIBE RESULT", "DESCRIBE ROW ACCESS POLICY", "DESCRIBE SCHEMA", "DESCRIBE SEQUENCE", "DESCRIBE SESSION POLICY", "DESCRIBE SHARE", "DESCRIBE STAGE", "DESCRIBE STREAM", "DESCRIBE TABLE", "DESCRIBE TASK", "DESCRIBE TRANSACTION", "DESCRIBE USER", "DESCRIBE VIEW", "DESCRIBE WAREHOUSE", "DROP CONNECTION", "DROP DATABASE", "DROP EXTERNAL TABLE", "DROP FAILOVER GROUP", "DROP FILE FORMAT", "DROP FUNCTION", "DROP INTEGRATION", "DROP MANAGED ACCOUNT", "DROP MASKING POLICY", "DROP MATERIALIZED VIEW", "DROP NETWORK POLICY", "DROP PIPE", "DROP PROCEDURE", "DROP REPLICATION GROUP", "DROP RESOURCE MONITOR", "DROP ROLE", "DROP ROW ACCESS POLICY", "DROP SCHEMA", "DROP SEQUENCE", "DROP SESSION POLICY", "DROP SHARE", "DROP STAGE", "DROP STREAM", "DROP TAG", "DROP TASK", "DROP USER", "DROP VIEW", "DROP WAREHOUSE", "EXECUTE IMMEDIATE", "EXECUTE TASK", "EXPLAIN", "GET", "GRANT OWNERSHIP", "GRANT ROLE", "INSERT", "LIST", "MERGE", "PUT", "REMOVE", "REVOKE ROLE", "ROLLBACK", "SHOW COLUMNS", "SHOW CONNECTIONS", "SHOW DATABASES", "SHOW DATABASES IN FAILOVER GROUP", "SHOW DATABASES IN REPLICATION GROUP", "SHOW DELEGATED AUTHORIZATIONS", "SHOW EXTERNAL FUNCTIONS", "SHOW EXTERNAL TABLES", "SHOW FAILOVER GROUPS", "SHOW FILE FORMATS", "SHOW FUNCTIONS", "SHOW GLOBAL ACCOUNTS", "SHOW GRANTS", "SHOW INTEGRATIONS", "SHOW LOCKS", "SHOW MANAGED ACCOUNTS", "SHOW MASKING POLICIES", "SHOW MATERIALIZED VIEWS", "SHOW NETWORK POLICIES", "SHOW OBJECTS", "SHOW ORGANIZATION ACCOUNTS", "SHOW PARAMETERS", "SHOW PIPES", "SHOW PRIMARY KEYS", "SHOW PROCEDURES", "SHOW REGIONS", "SHOW REPLICATION ACCOUNTS", "SHOW REPLICATION DATABASES", "SHOW REPLICATION GROUPS", "SHOW RESOURCE MONITORS", "SHOW ROLES", "SHOW ROW ACCESS POLICIES", "SHOW SCHEMAS", "SHOW SEQUENCES", "SHOW SESSION POLICIES", "SHOW SHARES", "SHOW SHARES IN FAILOVER GROUP", "SHOW SHARES IN REPLICATION GROUP", "SHOW STAGES", "SHOW STREAMS", "SHOW TABLES", "SHOW TAGS", "SHOW TASKS", "SHOW TRANSACTIONS", "SHOW USER FUNCTIONS", "SHOW USERS", "SHOW VARIABLES", "SHOW VIEWS", "SHOW WAREHOUSES", "TRUNCATE MATERIALIZED VIEW", "UNDROP DATABASE", "UNDROP SCHEMA", "UNDROP TABLE", "UNDROP TAG", "UNSET", "USE DATABASE", "USE ROLE", "USE SCHEMA", "USE SECONDARY ROLES", "USE WAREHOUSE"]),
      bL = hN(["UNION [ALL]", "MINUS", "EXCEPT", "INTERSECT"]),
      ML = hN(["[INNER] JOIN", "[NATURAL] {LEFT | RIGHT | FULL} [OUTER] JOIN", "{CROSS | NATURAL} JOIN"]),
      FL = hN(["{ROWS | RANGE} BETWEEN", "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]"]),
      xL = hN([]),
      GL = {
        name: "snowflake",
        tokenizerOptions: {
          reservedSelect: yL,
          reservedClauses: [...wL, ...DL, ...PL],
          reservedSetOperations: bL,
          reservedJoins: ML,
          reservedKeywordPhrases: FL,
          reservedDataTypePhrases: xL,
          reservedKeywords: ["ACCOUNT", "ALL", "ALTER", "AND", "ANY", "AS", "BETWEEN", "BY", "CASE", "CAST", "CHECK", "COLUMN", "CONNECT", "CONNECTION", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATABASE", "DELETE", "DISTINCT", "DROP", "ELSE", "EXISTS", "FALSE", "FOLLOWING", "FOR", "FROM", "FULL", "GRANT", "GROUP", "GSCLUSTER", "HAVING", "ILIKE", "IN", "INCREMENT", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "ISSUE", "JOIN", "LATERAL", "LEFT", "LIKE", "LOCALTIME", "LOCALTIMESTAMP", "MINUS", "NATURAL", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "ORGANIZATION", "QUALIFY", "REGEXP", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "SAMPLE", "SCHEMA", "SELECT", "SET", "SOME", "START", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRIGGER", "TRUE", "TRY_CAST", "UNION", "UNIQUE", "UPDATE", "USING", "VALUES", "VIEW", "WHEN", "WHENEVER", "WHERE", "WITH", "COMMENT"],
          reservedDataTypes: ["NUMBER", "DECIMAL", "NUMERIC", "INT", "INTEGER", "BIGINT", "SMALLINT", "TINYINT", "BYTEINT", "FLOAT", "FLOAT4", "FLOAT8", "DOUBLE", "DOUBLE PRECISION", "REAL", "VARCHAR", "CHAR", "CHARACTER", "STRING", "TEXT", "BINARY", "VARBINARY", "BOOLEAN", "DATE", "DATETIME", "TIME", "TIMESTAMP", "TIMESTAMP_LTZ", "TIMESTAMP_NTZ", "TIMESTAMP", "TIMESTAMP_TZ", "VARIANT", "OBJECT", "ARRAY", "GEOGRAPHY", "GEOMETRY"],
          reservedFunctionNames: ["ABS", "ACOS", "ACOSH", "ADD_MONTHS", "ALL_USER_NAMES", "ANY_VALUE", "APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "APPROX_PERCENTILE_ACCUMULATE", "APPROX_PERCENTILE_COMBINE", "APPROX_PERCENTILE_ESTIMATE", "APPROX_TOP_K", "APPROX_TOP_K_ACCUMULATE", "APPROX_TOP_K_COMBINE", "APPROX_TOP_K_ESTIMATE", "APPROXIMATE_JACCARD_INDEX", "APPROXIMATE_SIMILARITY", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_COMPACT", "ARRAY_CONSTRUCT", "ARRAY_CONSTRUCT_COMPACT", "ARRAY_CONTAINS", "ARRAY_INSERT", "ARRAY_INTERSECTION", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_SIZE", "ARRAY_SLICE", "ARRAY_TO_STRING", "ARRAY_UNION_AGG", "ARRAY_UNIQUE_AGG", "ARRAYS_OVERLAP", "AS_ARRAY", "AS_BINARY", "AS_BOOLEAN", "AS_CHAR", "AS_VARCHAR", "AS_DATE", "AS_DECIMAL", "AS_NUMBER", "AS_DOUBLE", "AS_REAL", "AS_INTEGER", "AS_OBJECT", "AS_TIME", "AS_TIMESTAMP_LTZ", "AS_TIMESTAMP_NTZ", "AS_TIMESTAMP_TZ", "ASCII", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AUTO_REFRESH_REGISTRATION_HISTORY", "AUTOMATIC_CLUSTERING_HISTORY", "AVG", "BASE64_DECODE_BINARY", "BASE64_DECODE_STRING", "BASE64_ENCODE", "BIT_LENGTH", "BITAND", "BITAND_AGG", "BITMAP_BIT_POSITION", "BITMAP_BUCKET_NUMBER", "BITMAP_CONSTRUCT_AGG", "BITMAP_COUNT", "BITMAP_OR_AGG", "BITNOT", "BITOR", "BITOR_AGG", "BITSHIFTLEFT", "BITSHIFTRIGHT", "BITXOR", "BITXOR_AGG", "BOOLAND", "BOOLAND_AGG", "BOOLNOT", "BOOLOR", "BOOLOR_AGG", "BOOLXOR", "BOOLXOR_AGG", "BUILD_SCOPED_FILE_URL", "BUILD_STAGE_FILE_URL", "CASE", "CAST", "CBRT", "CEIL", "CHARINDEX", "CHECK_JSON", "CHECK_XML", "CHR", "CHAR", "COALESCE", "COLLATE", "COLLATION", "COMPLETE_TASK_GRAPHS", "COMPRESS", "CONCAT", "CONCAT_WS", "CONDITIONAL_CHANGE_EVENT", "CONDITIONAL_TRUE_EVENT", "CONTAINS", "CONVERT_TIMEZONE", "COPY_HISTORY", "CORR", "COS", "COSH", "COT", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "CURRENT_ACCOUNT", "CURRENT_AVAILABLE_ROLES", "CURRENT_CLIENT", "CURRENT_DATABASE", "CURRENT_DATE", "CURRENT_IP_ADDRESS", "CURRENT_REGION", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_SECONDARY_ROLES", "CURRENT_SESSION", "CURRENT_STATEMENT", "CURRENT_TASK_GRAPHS", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TRANSACTION", "CURRENT_USER", "CURRENT_VERSION", "CURRENT_WAREHOUSE", "DATA_TRANSFER_HISTORY", "DATABASE_REFRESH_HISTORY", "DATABASE_REFRESH_PROGRESS", "DATABASE_REFRESH_PROGRESS_BY_JOB", "DATABASE_STORAGE_USAGE_HISTORY", "DATE_FROM_PARTS", "DATE_PART", "DATE_TRUNC", "DATEADD", "DATEDIFF", "DAYNAME", "DECODE", "DECOMPRESS_BINARY", "DECOMPRESS_STRING", "DECRYPT", "DECRYPT_RAW", "DEGREES", "DENSE_RANK", "DIV0", "EDITDISTANCE", "ENCRYPT", "ENCRYPT_RAW", "ENDSWITH", "EQUAL_NULL", "EXP", "EXPLAIN_JSON", "EXTERNAL_FUNCTIONS_HISTORY", "EXTERNAL_TABLE_FILES", "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY", "EXTRACT", "EXTRACT_SEMANTIC_CATEGORIES", "FACTORIAL", "FILTER", "FIRST_VALUE", "FLATTEN", "FLOOR", "GENERATE_COLUMN_DESCRIPTION", "GENERATOR", "GET", "GET_ABSOLUTE_PATH", "GET_DDL", "GET_IGNORE_CASE", "GET_OBJECT_REFERENCES", "GET_PATH", "GET_PRESIGNED_URL", "GET_RELATIVE_PATH", "GET_STAGE_LOCATION", "GETBIT", "GREATEST", "GREATEST_IGNORE_NULLS", "GROUPING", "GROUPING_ID", "HASH", "HASH_AGG", "HAVERSINE", "HEX_DECODE_BINARY", "HEX_DECODE_STRING", "HEX_ENCODE", "HLL", "HLL_ACCUMULATE", "HLL_COMBINE", "HLL_ESTIMATE", "HLL_EXPORT", "HLL_IMPORT", "HOUR", "MINUTE", "SECOND", "IDENTIFIER", "IFF", "IFNULL", "ILIKE", "ILIKE ANY", "INFER_SCHEMA", "INITCAP", "INSERT", "INVOKER_ROLE", "INVOKER_SHARE", "IS_ARRAY", "IS_BINARY", "IS_BOOLEAN", "IS_CHAR", "IS_VARCHAR", "IS_DATE", "IS_DATE_VALUE", "IS_DECIMAL", "IS_DOUBLE", "IS_REAL", "IS_GRANTED_TO_INVOKER_ROLE", "IS_INTEGER", "IS_NULL_VALUE", "IS_OBJECT", "IS_ROLE_IN_SESSION", "IS_TIME", "IS_TIMESTAMP_LTZ", "IS_TIMESTAMP_NTZ", "IS_TIMESTAMP_TZ", "JAROWINKLER_SIMILARITY", "JSON_EXTRACT_PATH_TEXT", "KURTOSIS", "LAG", "LAST_DAY", "LAST_QUERY_ID", "LAST_TRANSACTION", "LAST_VALUE", "LEAD", "LEAST", "LEFT", "LENGTH", "LEN", "LIKE", "LIKE ALL", "LIKE ANY", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOGIN_HISTORY", "LOGIN_HISTORY_BY_USER", "LOWER", "LPAD", "LTRIM", "MATERIALIZED_VIEW_REFRESH_HISTORY", "MD5", "MD5_HEX", "MD5_BINARY", "MD5_NUMBER — Obsoleted", "MD5_NUMBER_LOWER64", "MD5_NUMBER_UPPER64", "MEDIAN", "MIN", "MAX", "MINHASH", "MINHASH_COMBINE", "MOD", "MODE", "MONTHNAME", "MONTHS_BETWEEN", "NEXT_DAY", "NORMAL", "NTH_VALUE", "NTILE", "NULLIF", "NULLIFZERO", "NVL", "NVL2", "OBJECT_AGG", "OBJECT_CONSTRUCT", "OBJECT_CONSTRUCT_KEEP_NULL", "OBJECT_DELETE", "OBJECT_INSERT", "OBJECT_KEYS", "OBJECT_PICK", "OCTET_LENGTH", "PARSE_IP", "PARSE_JSON", "PARSE_URL", "PARSE_XML", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PI", "PIPE_USAGE_HISTORY", "POLICY_CONTEXT", "POLICY_REFERENCES", "POSITION", "POW", "POWER", "PREVIOUS_DAY", "QUERY_ACCELERATION_HISTORY", "QUERY_HISTORY", "QUERY_HISTORY_BY_SESSION", "QUERY_HISTORY_BY_USER", "QUERY_HISTORY_BY_WAREHOUSE", "RADIANS", "RANDOM", "RANDSTR", "RANK", "RATIO_TO_REPORT", "REGEXP", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REGEXP_SUBSTR_ALL", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REGR_VALX", "REGR_VALY", "REPEAT", "REPLACE", "REPLICATION_GROUP_REFRESH_HISTORY", "REPLICATION_GROUP_REFRESH_PROGRESS", "REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB", "REPLICATION_GROUP_USAGE_HISTORY", "REPLICATION_USAGE_HISTORY", "REST_EVENT_HISTORY", "RESULT_SCAN", "REVERSE", "RIGHT", "RLIKE", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "RTRIMMED_LENGTH", "SEARCH_OPTIMIZATION_HISTORY", "SEQ1", "SEQ2", "SEQ4", "SEQ8", "SERVERLESS_TASK_HISTORY", "SHA1", "SHA1_HEX", "SHA1_BINARY", "SHA2", "SHA2_HEX", "SHA2_BINARY", "SIGN", "SIN", "SINH", "SKEW", "SOUNDEX", "SPACE", "SPLIT", "SPLIT_PART", "SPLIT_TO_TABLE", "SQRT", "SQUARE", "ST_AREA", "ST_ASEWKB", "ST_ASEWKT", "ST_ASGEOJSON", "ST_ASWKB", "ST_ASBINARY", "ST_ASWKT", "ST_ASTEXT", "ST_AZIMUTH", "ST_CENTROID", "ST_COLLECT", "ST_CONTAINS", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DWITHIN", "ST_ENDPOINT", "ST_ENVELOPE", "ST_GEOGFROMGEOHASH", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOGRAPHYFROMWKB", "ST_GEOGRAPHYFROMWKT", "ST_GEOHASH", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYFROMWKT", "ST_HAUSDORFFDISTANCE", "ST_INTERSECTION", "ST_INTERSECTS", "ST_LENGTH", "ST_MAKEGEOMPOINT", "ST_GEOM_POINT", "ST_MAKELINE", "ST_MAKEPOINT", "ST_POINT", "ST_MAKEPOLYGON", "ST_POLYGON", "ST_NPOINTS", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SETSRID", "ST_SIMPLIFY", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY", "STAGE_STORAGE_USAGE_HISTORY", "STARTSWITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRIP_NULL_VALUE", "STRTOK", "STRTOK_SPLIT_TO_TABLE", "STRTOK_TO_ARRAY", "SUBSTR", "SUBSTRING", "SUM", "SYSDATE", "SYSTEM$ABORT_SESSION", "SYSTEM$ABORT_TRANSACTION", "SYSTEM$AUTHORIZE_PRIVATELINK", "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS", "SYSTEM$CANCEL_ALL_QUERIES", "SYSTEM$CANCEL_QUERY", "SYSTEM$CLUSTERING_DEPTH", "SYSTEM$CLUSTERING_INFORMATION", "SYSTEM$CLUSTERING_RATIO ", "SYSTEM$CURRENT_USER_TASK_NAME", "SYSTEM$DATABASE_REFRESH_HISTORY ", "SYSTEM$DATABASE_REFRESH_PROGRESS", "SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB ", "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$DISABLE_DATABASE_REPLICATION", "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$ESTIMATE_QUERY_ACCELERATION", "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS", "SYSTEM$EXPLAIN_JSON_TO_TEXT", "SYSTEM$EXPLAIN_PLAN_JSON", "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS", "SYSTEM$GENERATE_SAML_CSR", "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN", "SYSTEM$GET_AWS_SNS_IAM_POLICY", "SYSTEM$GET_PREDECESSOR_RETURN_VALUE", "SYSTEM$GET_PRIVATELINK", "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS", "SYSTEM$GET_PRIVATELINK_CONFIG", "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO", "SYSTEM$GET_TAG", "SYSTEM$GET_TAG_ALLOWED_VALUES", "SYSTEM$GET_TAG_ON_CURRENT_COLUMN", "SYSTEM$GET_TAG_ON_CURRENT_TABLE", "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER", "SYSTEM$LAST_CHANGE_COMMIT_TIME", "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME", "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION", "SYSTEM$PIPE_FORCE_RESUME", "SYSTEM$PIPE_STATUS", "SYSTEM$REVOKE_PRIVATELINK", "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$SET_RETURN_VALUE", "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS", "SYSTEM$STREAM_GET_TABLE_TIMESTAMP", "SYSTEM$STREAM_HAS_DATA", "SYSTEM$TASK_DEPENDENTS_ENABLE", "SYSTEM$TYPEOF", "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS", "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN", "SYSTEM$WAIT", "SYSTEM$WHITELIST", "SYSTEM$WHITELIST_PRIVATELINK", "TAG_REFERENCES", "TAG_REFERENCES_ALL_COLUMNS", "TAG_REFERENCES_WITH_LINEAGE", "TAN", "TANH", "TASK_DEPENDENTS", "TASK_HISTORY", "TIME_FROM_PARTS", "TIME_SLICE", "TIMEADD", "TIMEDIFF", "TIMESTAMP_FROM_PARTS", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_ARRAY", "TO_BINARY", "TO_BOOLEAN", "TO_CHAR", "TO_VARCHAR", "TO_DATE", "DATE", "TO_DECIMAL", "TO_NUMBER", "TO_NUMERIC", "TO_DOUBLE", "TO_GEOGRAPHY", "TO_GEOMETRY", "TO_JSON", "TO_OBJECT", "TO_TIME", "TIME", "TO_TIMESTAMP", "TO_TIMESTAMP_LTZ", "TO_TIMESTAMP_NTZ", "TO_TIMESTAMP_TZ", "TO_VARIANT", "TO_XML", "TRANSLATE", "TRIM", "TRUNCATE", "TRUNC", "TRUNC", "TRY_BASE64_DECODE_BINARY", "TRY_BASE64_DECODE_STRING", "TRY_CAST", "TRY_HEX_DECODE_BINARY", "TRY_HEX_DECODE_STRING", "TRY_PARSE_JSON", "TRY_TO_BINARY", "TRY_TO_BOOLEAN", "TRY_TO_DATE", "TRY_TO_DECIMAL", "TRY_TO_NUMBER", "TRY_TO_NUMERIC", "TRY_TO_DOUBLE", "TRY_TO_GEOGRAPHY", "TRY_TO_GEOMETRY", "TRY_TO_TIME", "TRY_TO_TIMESTAMP", "TRY_TO_TIMESTAMP_LTZ", "TRY_TO_TIMESTAMP_NTZ", "TRY_TO_TIMESTAMP_TZ", "TYPEOF", "UNICODE", "UNIFORM", "UPPER", "UUID_STRING", "VALIDATE", "VALIDATE_PIPE_LOAD", "VAR_POP", "VAR_SAMP", "VARIANCE", "VARIANCE_SAMP", "VARIANCE_POP", "WAREHOUSE_LOAD_HISTORY", "WAREHOUSE_METERING_HISTORY", "WIDTH_BUCKET", "XMLGET", "YEAR", "YEAROFWEEK", "YEAROFWEEKISO", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEKISO", "DAYOFYEAR", "WEEK", "WEEK", "WEEKOFYEAR", "WEEKISO", "MONTH", "QUARTER", "ZEROIFNULL", "ZIPF"],
          stringTypes: ["$$", "''-qq-bs"],
          identTypes: ['""-qq'],
          variableTypes: [{
            regex: "[$][1-9]\\d*"
          }, {
            regex: "[$][_a-zA-Z][_a-zA-Z0-9$]*"
          }],
          extraParens: ["[]"],
          identChars: {
            rest: "$"
          },
          lineCommentTypes: ["--", "//"],
          operators: ["%", "::", "||", "=>", ":=", "->"],
          propertyAccessOperators: [":"]
        },
        formatOptions: {
          alwaysDenseOperators: ["::"],
          onelineClauses: [...DL, ...PL],
          tabularOnelineClauses: PL
        }
      },
      UL = e => e[e.length - 1],
      HL = e => e.sort((e, t) => t.length - e.length || e.localeCompare(t)),
      kL = e => e.replace(/\s+/gu, " "),
      BL = e => /\n/.test(e),
      VL = e => e.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&"),
      WL = /\s+/uy,
      YL = e => new RegExp(`(?:${e})`, "uy"),
      KL = e => e.split("").map(e => / /gu.test(e) ? "\\s+" : `[${e.toUpperCase()}${e.toLowerCase()}]`).join(""),
      XL = (e, t = []) => {
        const i = "open" === e ? 0 : 1,
          r = ["()", ...t].map(e => e[i]);
        return YL(r.map(VL).join("|"))
      },
      zL = e => YL(`${HL(e).map(VL).join("|")}`),
      $L = (e, t = {}) => {
        if (0 === e.length) return /^\b$/u;
        const i = (({
            rest: e,
            dashes: t
          }) => e || t ? `(?![${e||""}${t?"-":""}])` : "")(t),
          r = HL(e).map(VL).join("|").replace(/ /gu, "\\s+");
        return new RegExp(`(?:${r})${i}\\b`, "iuy")
      },
      jL = (e, t) => {
        if (!e.length) return;
        const i = e.map(VL).join("|");
        return YL(`(?:${i})(?:${t})`)
      },
      JL = {
        "``": "(?:`[^`]*`)+",
        "[]": String.raw`(?:\[[^\]]*\])(?:\][^\]]*\])*`,
        '""-qq': String.raw`(?:"[^"]*")+`,
        '""-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")`,
        '""-qq-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")+`,
        '""-raw': String.raw`(?:"[^"]*")`,
        "''-qq": String.raw`(?:'[^']*')+`,
        "''-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')`,
        "''-qq-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')+`,
        "''-raw": String.raw`(?:'[^']*')`,
        $$: String.raw`(?<tag>\$\w*\$)[\s\S]*?\k<tag>`,
        "'''..'''": String.raw`'''[^\\]*?(?:\\.[^\\]*?)*?'''`,
        '""".."""': String.raw`"""[^\\]*?(?:\\.[^\\]*?)*?"""`,
        "{}": String.raw`(?:\{[^\}]*\})`,
        "q''": (() => {
          const e = {
              "<": ">",
              "[": "]",
              "(": ")",
              "{": "}"
            },
            t = Object.entries(e).map(([e, t]) => "{left}(?:(?!{right}').)*?{right}".replace(/{left}/g, VL(e)).replace(/{right}/g, VL(t))),
            i = VL(Object.keys(e).join(""));
          return `[Qq]'(?:${String.raw`(?<tag>[^\s${i}])(?:(?!\k<tag>').)*?\k<tag>`}|${t.join("|")})'`
        })()
      },
      qL = e => "string" == typeof e ? JL[e] : "regex" in e ? e.regex : (({
        prefixes: e,
        requirePrefix: t
      }) => `(?:${e.map(KL).join("|")}${t?"":"|"})`)(e) + JL[e.quote],
      QL = e => e.map(qL).join("|"),
      ZL = e => YL(QL(e)),
      e_ = (e = {}) => YL(t_(e)),
      t_ = ({
        first: e,
        rest: t,
        dashes: i,
        allowFirstCharNumber: r
      } = {}) => {
        const s = "\\p{Alphabetic}\\p{Mark}_",
          n = "\\p{Decimal_Number}",
          o = VL(null != e ? e : ""),
          a = VL(null != t ? t : ""),
          l = r ? `[${s}${n}${o}][${s}${n}${a}]*` : `[${s}${o}][${s}${n}${a}]*`;
        return i ? (e => e + "(?:-" + e + ")*")(l) : l
      };

    function i_(e, t) {
      const i = e.slice(0, t).split(/\n/);
      return {
        line: i.length,
        col: i[i.length - 1].length + 1
      }
    }
    class r_ {
      constructor(e, t) {
        this.rules = e, this.dialectName = t, this.input = "", this.index = 0
      }
      tokenize(e) {
        this.input = e, this.index = 0;
        const t = [];
        let i;
        for (; this.index < this.input.length;) {
          const e = this.getWhitespace();
          if (this.index < this.input.length) {
            if (i = this.getNextToken(), !i) throw this.createParseError();
            t.push(Object.assign(Object.assign({}, i), {
              precedingWhitespace: e
            }))
          }
        }
        return t
      }
      createParseError() {
        const e = this.input.slice(this.index, this.index + 10),
          {
            line: t,
            col: i
          } = i_(this.input, this.index);
        return new Error(`Parse error: Unexpected "${e}" at line ${t} column ${i}.\n${this.dialectInfo()}`)
      }
      dialectInfo() {
        return "sql" === this.dialectName ? 'This likely happens because you\'re using the default "sql" dialect.\nIf possible, please select a more specific dialect (like sqlite, postgresql, etc).' : `SQL dialect used: "${this.dialectName}".`
      }
      getWhitespace() {
        WL.lastIndex = this.index;
        const e = WL.exec(this.input);
        if (e) return this.index += e[0].length, e[0]
      }
      getNextToken() {
        for (const e of this.rules) {
          const t = this.match(e);
          if (t) return t
        }
      }
      match(e) {
        e.regex.lastIndex = this.index;
        const t = e.regex.exec(this.input);
        if (t) {
          const i = t[0],
            r = {
              type: e.type,
              raw: i,
              text: e.text ? e.text(i) : i,
              start: this.index
            };
          return e.key && (r.key = e.key(i)), this.index += i.length, r
        }
      }
    }
    const s_ = /\/\*/uy,
      n_ = /[\s\S]/uy,
      o_ = /\*\//uy;
    class a_ {
      constructor() {
        this.lastIndex = 0
      }
      exec(e) {
        let t, i = "",
          r = 0;
        if (!(t = this.matchSection(s_, e))) return null;
        for (i += t, r++; r > 0;)
          if (t = this.matchSection(s_, e)) i += t, r++;
          else if (t = this.matchSection(o_, e)) i += t, r--;
        else {
          if (!(t = this.matchSection(n_, e))) return null;
          i += t
        }
        return [i]
      }
      matchSection(e, t) {
        e.lastIndex = this.lastIndex;
        const i = e.exec(t);
        return i && (this.lastIndex += i[0].length), i ? i[0] : null
      }
    }
    class l_ {
      constructor(e, t) {
        this.cfg = e, this.dialectName = t, this.rulesBeforeParams = this.buildRulesBeforeParams(e), this.rulesAfterParams = this.buildRulesAfterParams(e)
      }
      tokenize(e, t) {
        const i = [...this.rulesBeforeParams, ...this.buildParamRules(this.cfg, t), ...this.rulesAfterParams],
          r = new r_(i, this.dialectName).tokenize(e);
        return this.cfg.postProcess ? this.cfg.postProcess(r) : r
      }
      buildRulesBeforeParams(e) {
        var t, i, r, s;
        return this.validRules([{
          type: RN.BLOCK_COMMENT,
          regex: /(\/\* *sql-formatter-disable *\*\/[\s\S]*?(?:\/\* *sql-formatter-enable *\*\/|$))/uy
        }, {
          type: RN.BLOCK_COMMENT,
          regex: e.nestedBlockComments ? new a_ : /(\/\*[^]*?\*\/)/uy
        }, {
          type: RN.LINE_COMMENT,
          regex: (s = null !== (t = e.lineCommentTypes) && void 0 !== t ? t : ["--"], new RegExp(`(?:${s.map(VL).join("|")}).*?(?=\r\n|\r|\n|$)`, "uy"))
        }, {
          type: RN.QUOTED_IDENTIFIER,
          regex: ZL(e.identTypes)
        }, {
          type: RN.NUMBER,
          regex: e.underscoresInNumbers ? /(?:0x[0-9a-fA-F_]+|0b[01_]+|(?:-\s*)?(?:[0-9_]*\.[0-9_]+|[0-9_]+(?:\.[0-9_]*)?)(?:[eE][-+]?[0-9_]+(?:\.[0-9_]+)?)?)(?![\w\p{Alphabetic}])/uy : /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\s*)?(?:[0-9]*\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][-+]?[0-9]+(?:\.[0-9]+)?)?)(?![\w\p{Alphabetic}])/uy
        }, {
          type: RN.RESERVED_KEYWORD_PHRASE,
          regex: $L(null !== (i = e.reservedKeywordPhrases) && void 0 !== i ? i : [], e.identChars),
          text: c_
        }, {
          type: RN.RESERVED_DATA_TYPE_PHRASE,
          regex: $L(null !== (r = e.reservedDataTypePhrases) && void 0 !== r ? r : [], e.identChars),
          text: c_
        }, {
          type: RN.CASE,
          regex: /CASE\b/iuy,
          text: c_
        }, {
          type: RN.END,
          regex: /END\b/iuy,
          text: c_
        }, {
          type: RN.BETWEEN,
          regex: /BETWEEN\b/iuy,
          text: c_
        }, {
          type: RN.LIMIT,
          regex: e.reservedClauses.includes("LIMIT") ? /LIMIT\b/iuy : void 0,
          text: c_
        }, {
          type: RN.RESERVED_CLAUSE,
          regex: $L(e.reservedClauses, e.identChars),
          text: c_
        }, {
          type: RN.RESERVED_SELECT,
          regex: $L(e.reservedSelect, e.identChars),
          text: c_
        }, {
          type: RN.RESERVED_SET_OPERATION,
          regex: $L(e.reservedSetOperations, e.identChars),
          text: c_
        }, {
          type: RN.WHEN,
          regex: /WHEN\b/iuy,
          text: c_
        }, {
          type: RN.ELSE,
          regex: /ELSE\b/iuy,
          text: c_
        }, {
          type: RN.THEN,
          regex: /THEN\b/iuy,
          text: c_
        }, {
          type: RN.RESERVED_JOIN,
          regex: $L(e.reservedJoins, e.identChars),
          text: c_
        }, {
          type: RN.AND,
          regex: /AND\b/iuy,
          text: c_
        }, {
          type: RN.OR,
          regex: /OR\b/iuy,
          text: c_
        }, {
          type: RN.XOR,
          regex: e.supportsXor ? /XOR\b/iuy : void 0,
          text: c_
        }, ...e.operatorKeyword ? [{
          type: RN.OPERATOR,
          regex: /OPERATOR *\([^)]+\)/iuy
        }] : [], {
          type: RN.RESERVED_FUNCTION_NAME,
          regex: $L(e.reservedFunctionNames, e.identChars),
          text: c_
        }, {
          type: RN.RESERVED_DATA_TYPE,
          regex: $L(e.reservedDataTypes, e.identChars),
          text: c_
        }, {
          type: RN.RESERVED_KEYWORD,
          regex: $L(e.reservedKeywords, e.identChars),
          text: c_
        }])
      }
      buildRulesAfterParams(e) {
        var t, i, r;
        return this.validRules([{
          type: RN.VARIABLE,
          regex: e.variableTypes ? (r = e.variableTypes, YL(r.map(e => "regex" in e ? e.regex : qL(e)).join("|"))) : void 0
        }, {
          type: RN.STRING,
          regex: ZL(e.stringTypes)
        }, {
          type: RN.IDENTIFIER,
          regex: e_(e.identChars)
        }, {
          type: RN.DELIMITER,
          regex: /[;]/uy
        }, {
          type: RN.COMMA,
          regex: /[,]/y
        }, {
          type: RN.OPEN_PAREN,
          regex: XL("open", e.extraParens)
        }, {
          type: RN.CLOSE_PAREN,
          regex: XL("close", e.extraParens)
        }, {
          type: RN.OPERATOR,
          regex: zL(["+", "-", "/", ">", "<", "=", "<>", "<=", ">=", "!=", ...null !== (t = e.operators) && void 0 !== t ? t : []])
        }, {
          type: RN.ASTERISK,
          regex: /[*]/uy
        }, {
          type: RN.PROPERTY_ACCESS_OPERATOR,
          regex: zL([".", ...null !== (i = e.propertyAccessOperators) && void 0 !== i ? i : []])
        }])
      }
      buildParamRules(e, t) {
        var i, r, s, n, o;
        const a = {
          named: (null == t ? void 0 : t.named) || (null === (i = e.paramTypes) || void 0 === i ? void 0 : i.named) || [],
          quoted: (null == t ? void 0 : t.quoted) || (null === (r = e.paramTypes) || void 0 === r ? void 0 : r.quoted) || [],
          numbered: (null == t ? void 0 : t.numbered) || (null === (s = e.paramTypes) || void 0 === s ? void 0 : s.numbered) || [],
          positional: "boolean" == typeof(null == t ? void 0 : t.positional) ? t.positional : null === (n = e.paramTypes) || void 0 === n ? void 0 : n.positional,
          custom: (null == t ? void 0 : t.custom) || (null === (o = e.paramTypes) || void 0 === o ? void 0 : o.custom) || []
        };
        return this.validRules([{
          type: RN.NAMED_PARAMETER,
          regex: jL(a.named, t_(e.paramChars || e.identChars)),
          key: e => e.slice(1)
        }, {
          type: RN.QUOTED_PARAMETER,
          regex: jL(a.quoted, QL(e.identTypes)),
          key: e => (({
            tokenKey: e,
            quoteChar: t
          }) => e.replace(new RegExp(VL("\\" + t), "gu"), t))({
            tokenKey: e.slice(2, -1),
            quoteChar: e.slice(-1)
          })
        }, {
          type: RN.NUMBERED_PARAMETER,
          regex: jL(a.numbered, "[0-9]+"),
          key: e => e.slice(1)
        }, {
          type: RN.POSITIONAL_PARAMETER,
          regex: a.positional ? /[?]/y : void 0
        }, ...a.custom.map(e => {
          var t;
          return {
            type: RN.CUSTOM_PARAMETER,
            regex: YL(e.regex),
            key: null !== (t = e.key) && void 0 !== t ? t : e => e
          }
        })])
      }
      validRules(e) {
        return e.filter(e => Boolean(e.regex))
      }
    }
    const c_ = e => kL(e.toUpperCase()),
      h_ = new Map,
      u_ = e => ({
        tokenizer: new l_(e.tokenizerOptions, e.name),
        formatOptions: d_(e.formatOptions)
      }),
      d_ = e => {
        var t;
        return {
          alwaysDenseOperators: e.alwaysDenseOperators || [],
          onelineClauses: Object.fromEntries(e.onelineClauses.map(e => [e, !0])),
          tabularOnelineClauses: Object.fromEntries((null !== (t = e.tabularOnelineClauses) && void 0 !== t ? t : e.onelineClauses).map(e => [e, !0]))
        }
      };

    function p_(e) {
      return "tabularLeft" === e.indentStyle || "tabularRight" === e.indentStyle
    }
    class E_ {
      constructor(e) {
        this.params = e, this.index = 0
      }
      get({
        key: e,
        text: t
      }) {
        return this.params ? e ? this.params[e] : this.params[this.index++] : t
      }
      getPositionalParameterIndex() {
        return this.index
      }
      setPositionalParameterIndex(e) {
        this.index = e
      }
    }
    var g_ = i(515);
    const f_ = (e, t, i) => {
        if (ON(e.type)) {
          const r = R_(i, t);
          if (r && r.type === RN.PROPERTY_ACCESS_OPERATOR) return Object.assign(Object.assign({}, e), {
            type: RN.IDENTIFIER,
            text: e.raw
          });
          const s = A_(i, t);
          if (s && s.type === RN.PROPERTY_ACCESS_OPERATOR) return Object.assign(Object.assign({}, e), {
            type: RN.IDENTIFIER,
            text: e.raw
          })
        }
        return e
      },
      T_ = (e, t, i) => {
        if (e.type === RN.RESERVED_FUNCTION_NAME) {
          const r = A_(i, t);
          if (!r || !v_(r)) return Object.assign(Object.assign({}, e), {
            type: RN.IDENTIFIER,
            text: e.raw
          })
        }
        return e
      },
      m_ = (e, t, i) => {
        if (e.type === RN.RESERVED_DATA_TYPE) {
          const r = A_(i, t);
          if (r && v_(r)) return Object.assign(Object.assign({}, e), {
            type: RN.RESERVED_PARAMETERIZED_DATA_TYPE
          })
        }
        return e
      },
      C_ = (e, t, i) => {
        if (e.type === RN.IDENTIFIER) {
          const r = A_(i, t);
          if (r && N_(r)) return Object.assign(Object.assign({}, e), {
            type: RN.ARRAY_IDENTIFIER
          })
        }
        return e
      },
      S_ = (e, t, i) => {
        if (e.type === RN.RESERVED_DATA_TYPE) {
          const r = A_(i, t);
          if (r && N_(r)) return Object.assign(Object.assign({}, e), {
            type: RN.ARRAY_KEYWORD
          })
        }
        return e
      },
      R_ = (e, t) => A_(e, t, -1),
      A_ = (e, t, i = 1) => {
        let r = 1;
        for (; e[t + r * i] && I_(e[t + r * i]);) r++;
        return e[t + r * i]
      },
      v_ = e => e.type === RN.OPEN_PAREN && "(" === e.text,
      N_ = e => e.type === RN.OPEN_PAREN && "[" === e.text,
      I_ = e => e.type === RN.BLOCK_COMMENT || e.type === RN.LINE_COMMENT;
    class O_ {
      constructor(e) {
        this.tokenize = e, this.index = 0, this.tokens = [], this.input = ""
      }
      reset(e, t) {
        this.input = e, this.index = 0, this.tokens = this.tokenize(e)
      }
      next() {
        return this.tokens[this.index++]
      }
      save() {}
      formatError(e) {
        const {
          line: t,
          col: i
        } = i_(this.input, e.start);
        return `Parse error at token: ${e.text} at line ${t} column ${i}`
      }
      has(e) {
        return e in RN
      }
    }
    var L_;

    function __(e) {
      return e[0]
    }! function(e) {
      e.statement = "statement", e.clause = "clause", e.set_operation = "set_operation", e.function_call = "function_call", e.parameterized_data_type = "parameterized_data_type", e.array_subscript = "array_subscript", e.property_access = "property_access", e.parenthesis = "parenthesis", e.between_predicate = "between_predicate", e.case_expression = "case_expression", e.case_when = "case_when", e.case_else = "case_else", e.limit_clause = "limit_clause", e.all_columns_asterisk = "all_columns_asterisk", e.literal = "literal", e.identifier = "identifier", e.keyword = "keyword", e.data_type = "data_type", e.parameter = "parameter", e.operator = "operator", e.comma = "comma", e.line_comment = "line_comment", e.block_comment = "block_comment", e.disable_comment = "disable_comment"
    }(L_ = L_ || (L_ = {}));
    const y_ = new O_(e => []),
      w_ = ([
        [e]
      ]) => e,
      D_ = e => ({
        type: L_.keyword,
        tokenType: e.type,
        text: e.text,
        raw: e.raw
      }),
      P_ = e => ({
        type: L_.data_type,
        text: e.text,
        raw: e.raw
      }),
      b_ = (e, {
        leading: t,
        trailing: i
      }) => ((null == t ? void 0 : t.length) && (e = Object.assign(Object.assign({}, e), {
        leadingComments: t
      })), (null == i ? void 0 : i.length) && (e = Object.assign(Object.assign({}, e), {
        trailingComments: i
      })), e),
      M_ = (e, {
        leading: t,
        trailing: i
      }) => {
        if (null == t ? void 0 : t.length) {
          const [i, ...r] = e;
          e = [b_(i, {
            leading: t
          }), ...r]
        }
        if (null == i ? void 0 : i.length) {
          const t = e.slice(0, -1),
            r = e[e.length - 1];
          e = [...t, b_(r, {
            trailing: i
          })]
        }
        return e
      },
      F_ = {
        Lexer: y_,
        ParserRules: [{
          name: "main$ebnf$1",
          symbols: []
        }, {
          name: "main$ebnf$1",
          symbols: ["main$ebnf$1", "statement"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "main",
          symbols: ["main$ebnf$1"],
          postprocess: ([e]) => {
            const t = e[e.length - 1];
            return t && !t.hasSemicolon ? t.children.length > 0 ? e : e.slice(0, -1) : e
          }
        }, {
          name: "statement$subexpression$1",
          symbols: [y_.has("DELIMITER") ? {
            type: "DELIMITER"
          } : DELIMITER]
        }, {
          name: "statement$subexpression$1",
          symbols: [y_.has("EOF") ? {
            type: "EOF"
          } : EOF]
        }, {
          name: "statement",
          symbols: ["expressions_or_clauses", "statement$subexpression$1"],
          postprocess: ([e, [t]]) => ({
            type: L_.statement,
            children: e,
            hasSemicolon: t.type === RN.DELIMITER
          })
        }, {
          name: "expressions_or_clauses$ebnf$1",
          symbols: []
        }, {
          name: "expressions_or_clauses$ebnf$1",
          symbols: ["expressions_or_clauses$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "expressions_or_clauses$ebnf$2",
          symbols: []
        }, {
          name: "expressions_or_clauses$ebnf$2",
          symbols: ["expressions_or_clauses$ebnf$2", "clause"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "expressions_or_clauses",
          symbols: ["expressions_or_clauses$ebnf$1", "expressions_or_clauses$ebnf$2"],
          postprocess: ([e, t]) => [...e, ...t]
        }, {
          name: "clause$subexpression$1",
          symbols: ["limit_clause"]
        }, {
          name: "clause$subexpression$1",
          symbols: ["select_clause"]
        }, {
          name: "clause$subexpression$1",
          symbols: ["other_clause"]
        }, {
          name: "clause$subexpression$1",
          symbols: ["set_operation"]
        }, {
          name: "clause",
          symbols: ["clause$subexpression$1"],
          postprocess: w_
        }, {
          name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
          symbols: ["free_form_sql"]
        }, {
          name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
          symbols: ["limit_clause$ebnf$1$subexpression$1$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "limit_clause$ebnf$1$subexpression$1",
          symbols: [y_.has("COMMA") ? {
            type: "COMMA"
          } : COMMA, "limit_clause$ebnf$1$subexpression$1$ebnf$1"]
        }, {
          name: "limit_clause$ebnf$1",
          symbols: ["limit_clause$ebnf$1$subexpression$1"],
          postprocess: __
        }, {
          name: "limit_clause$ebnf$1",
          symbols: [],
          postprocess: () => null
        }, {
          name: "limit_clause",
          symbols: [y_.has("LIMIT") ? {
            type: "LIMIT"
          } : LIMIT, "_", "expression_chain_", "limit_clause$ebnf$1"],
          postprocess: ([e, t, i, r]) => {
            if (r) {
              const [s, n] = r;
              return {
                type: L_.limit_clause,
                limitKw: b_(D_(e), {
                  trailing: t
                }),
                offset: i,
                count: n
              }
            }
            return {
              type: L_.limit_clause,
              limitKw: b_(D_(e), {
                trailing: t
              }),
              count: i
            }
          }
        }, {
          name: "select_clause$subexpression$1$ebnf$1",
          symbols: []
        }, {
          name: "select_clause$subexpression$1$ebnf$1",
          symbols: ["select_clause$subexpression$1$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "select_clause$subexpression$1",
          symbols: ["all_columns_asterisk", "select_clause$subexpression$1$ebnf$1"]
        }, {
          name: "select_clause$subexpression$1$ebnf$2",
          symbols: []
        }, {
          name: "select_clause$subexpression$1$ebnf$2",
          symbols: ["select_clause$subexpression$1$ebnf$2", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "select_clause$subexpression$1",
          symbols: ["asteriskless_free_form_sql", "select_clause$subexpression$1$ebnf$2"]
        }, {
          name: "select_clause",
          symbols: [y_.has("RESERVED_SELECT") ? {
            type: "RESERVED_SELECT"
          } : RESERVED_SELECT, "select_clause$subexpression$1"],
          postprocess: ([e, [t, i]]) => ({
            type: L_.clause,
            nameKw: D_(e),
            children: [t, ...i]
          })
        }, {
          name: "select_clause",
          symbols: [y_.has("RESERVED_SELECT") ? {
            type: "RESERVED_SELECT"
          } : RESERVED_SELECT],
          postprocess: ([e]) => ({
            type: L_.clause,
            nameKw: D_(e),
            children: []
          })
        }, {
          name: "all_columns_asterisk",
          symbols: [y_.has("ASTERISK") ? {
            type: "ASTERISK"
          } : ASTERISK],
          postprocess: () => ({
            type: L_.all_columns_asterisk
          })
        }, {
          name: "other_clause$ebnf$1",
          symbols: []
        }, {
          name: "other_clause$ebnf$1",
          symbols: ["other_clause$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "other_clause",
          symbols: [y_.has("RESERVED_CLAUSE") ? {
            type: "RESERVED_CLAUSE"
          } : RESERVED_CLAUSE, "other_clause$ebnf$1"],
          postprocess: ([e, t]) => ({
            type: L_.clause,
            nameKw: D_(e),
            children: t
          })
        }, {
          name: "set_operation$ebnf$1",
          symbols: []
        }, {
          name: "set_operation$ebnf$1",
          symbols: ["set_operation$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "set_operation",
          symbols: [y_.has("RESERVED_SET_OPERATION") ? {
            type: "RESERVED_SET_OPERATION"
          } : RESERVED_SET_OPERATION, "set_operation$ebnf$1"],
          postprocess: ([e, t]) => ({
            type: L_.set_operation,
            nameKw: D_(e),
            children: t
          })
        }, {
          name: "expression_chain_$ebnf$1",
          symbols: ["expression_with_comments_"]
        }, {
          name: "expression_chain_$ebnf$1",
          symbols: ["expression_chain_$ebnf$1", "expression_with_comments_"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "expression_chain_",
          symbols: ["expression_chain_$ebnf$1"],
          postprocess: __
        }, {
          name: "expression_chain$ebnf$1",
          symbols: []
        }, {
          name: "expression_chain$ebnf$1",
          symbols: ["expression_chain$ebnf$1", "_expression_with_comments"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "expression_chain",
          symbols: ["expression", "expression_chain$ebnf$1"],
          postprocess: ([e, t]) => [e, ...t]
        }, {
          name: "andless_expression_chain$ebnf$1",
          symbols: []
        }, {
          name: "andless_expression_chain$ebnf$1",
          symbols: ["andless_expression_chain$ebnf$1", "_andless_expression_with_comments"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "andless_expression_chain",
          symbols: ["andless_expression", "andless_expression_chain$ebnf$1"],
          postprocess: ([e, t]) => [e, ...t]
        }, {
          name: "expression_with_comments_",
          symbols: ["expression", "_"],
          postprocess: ([e, t]) => b_(e, {
            trailing: t
          })
        }, {
          name: "_expression_with_comments",
          symbols: ["_", "expression"],
          postprocess: ([e, t]) => b_(t, {
            leading: e
          })
        }, {
          name: "_andless_expression_with_comments",
          symbols: ["_", "andless_expression"],
          postprocess: ([e, t]) => b_(t, {
            leading: e
          })
        }, {
          name: "free_form_sql$subexpression$1",
          symbols: ["asteriskless_free_form_sql"]
        }, {
          name: "free_form_sql$subexpression$1",
          symbols: ["asterisk"]
        }, {
          name: "free_form_sql",
          symbols: ["free_form_sql$subexpression$1"],
          postprocess: w_
        }, {
          name: "asteriskless_free_form_sql$subexpression$1",
          symbols: ["asteriskless_andless_expression"]
        }, {
          name: "asteriskless_free_form_sql$subexpression$1",
          symbols: ["logic_operator"]
        }, {
          name: "asteriskless_free_form_sql$subexpression$1",
          symbols: ["comma"]
        }, {
          name: "asteriskless_free_form_sql$subexpression$1",
          symbols: ["comment"]
        }, {
          name: "asteriskless_free_form_sql$subexpression$1",
          symbols: ["other_keyword"]
        }, {
          name: "asteriskless_free_form_sql",
          symbols: ["asteriskless_free_form_sql$subexpression$1"],
          postprocess: w_
        }, {
          name: "expression$subexpression$1",
          symbols: ["andless_expression"]
        }, {
          name: "expression$subexpression$1",
          symbols: ["logic_operator"]
        }, {
          name: "expression",
          symbols: ["expression$subexpression$1"],
          postprocess: w_
        }, {
          name: "andless_expression$subexpression$1",
          symbols: ["asteriskless_andless_expression"]
        }, {
          name: "andless_expression$subexpression$1",
          symbols: ["asterisk"]
        }, {
          name: "andless_expression",
          symbols: ["andless_expression$subexpression$1"],
          postprocess: w_
        }, {
          name: "asteriskless_andless_expression$subexpression$1",
          symbols: ["atomic_expression"]
        }, {
          name: "asteriskless_andless_expression$subexpression$1",
          symbols: ["between_predicate"]
        }, {
          name: "asteriskless_andless_expression$subexpression$1",
          symbols: ["case_expression"]
        }, {
          name: "asteriskless_andless_expression",
          symbols: ["asteriskless_andless_expression$subexpression$1"],
          postprocess: w_
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["array_subscript"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["function_call"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["property_access"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["parenthesis"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["curly_braces"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["square_brackets"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["operator"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["identifier"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["parameter"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["literal"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["data_type"]
        }, {
          name: "atomic_expression$subexpression$1",
          symbols: ["keyword"]
        }, {
          name: "atomic_expression",
          symbols: ["atomic_expression$subexpression$1"],
          postprocess: w_
        }, {
          name: "array_subscript",
          symbols: [y_.has("ARRAY_IDENTIFIER") ? {
            type: "ARRAY_IDENTIFIER"
          } : ARRAY_IDENTIFIER, "_", "square_brackets"],
          postprocess: ([e, t, i]) => ({
            type: L_.array_subscript,
            array: b_({
              type: L_.identifier,
              quoted: !1,
              text: e.text
            }, {
              trailing: t
            }),
            parenthesis: i
          })
        }, {
          name: "array_subscript",
          symbols: [y_.has("ARRAY_KEYWORD") ? {
            type: "ARRAY_KEYWORD"
          } : ARRAY_KEYWORD, "_", "square_brackets"],
          postprocess: ([e, t, i]) => ({
            type: L_.array_subscript,
            array: b_(D_(e), {
              trailing: t
            }),
            parenthesis: i
          })
        }, {
          name: "function_call",
          symbols: [y_.has("RESERVED_FUNCTION_NAME") ? {
            type: "RESERVED_FUNCTION_NAME"
          } : RESERVED_FUNCTION_NAME, "_", "parenthesis"],
          postprocess: ([e, t, i]) => ({
            type: L_.function_call,
            nameKw: b_(D_(e), {
              trailing: t
            }),
            parenthesis: i
          })
        }, {
          name: "parenthesis",
          symbols: [{
            literal: "("
          }, "expressions_or_clauses", {
            literal: ")"
          }],
          postprocess: ([e, t, i]) => ({
            type: L_.parenthesis,
            children: t,
            openParen: "(",
            closeParen: ")"
          })
        }, {
          name: "curly_braces$ebnf$1",
          symbols: []
        }, {
          name: "curly_braces$ebnf$1",
          symbols: ["curly_braces$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "curly_braces",
          symbols: [{
            literal: "{"
          }, "curly_braces$ebnf$1", {
            literal: "}"
          }],
          postprocess: ([e, t, i]) => ({
            type: L_.parenthesis,
            children: t,
            openParen: "{",
            closeParen: "}"
          })
        }, {
          name: "square_brackets$ebnf$1",
          symbols: []
        }, {
          name: "square_brackets$ebnf$1",
          symbols: ["square_brackets$ebnf$1", "free_form_sql"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "square_brackets",
          symbols: [{
            literal: "["
          }, "square_brackets$ebnf$1", {
            literal: "]"
          }],
          postprocess: ([e, t, i]) => ({
            type: L_.parenthesis,
            children: t,
            openParen: "[",
            closeParen: "]"
          })
        }, {
          name: "property_access$subexpression$1",
          symbols: ["identifier"]
        }, {
          name: "property_access$subexpression$1",
          symbols: ["array_subscript"]
        }, {
          name: "property_access$subexpression$1",
          symbols: ["all_columns_asterisk"]
        }, {
          name: "property_access$subexpression$1",
          symbols: ["parameter"]
        }, {
          name: "property_access",
          symbols: ["atomic_expression", "_", y_.has("PROPERTY_ACCESS_OPERATOR") ? {
            type: "PROPERTY_ACCESS_OPERATOR"
          } : PROPERTY_ACCESS_OPERATOR, "_", "property_access$subexpression$1"],
          postprocess: ([e, t, i, r, [s]]) => ({
            type: L_.property_access,
            object: b_(e, {
              trailing: t
            }),
            operator: i.text,
            property: b_(s, {
              leading: r
            })
          })
        }, {
          name: "between_predicate",
          symbols: [y_.has("BETWEEN") ? {
            type: "BETWEEN"
          } : BETWEEN, "_", "andless_expression_chain", "_", y_.has("AND") ? {
            type: "AND"
          } : AND, "_", "andless_expression"],
          postprocess: ([e, t, i, r, s, n, o]) => ({
            type: L_.between_predicate,
            betweenKw: D_(e),
            expr1: M_(i, {
              leading: t,
              trailing: r
            }),
            andKw: D_(s),
            expr2: [b_(o, {
              leading: n
            })]
          })
        }, {
          name: "case_expression$ebnf$1",
          symbols: ["expression_chain_"],
          postprocess: __
        }, {
          name: "case_expression$ebnf$1",
          symbols: [],
          postprocess: () => null
        }, {
          name: "case_expression$ebnf$2",
          symbols: []
        }, {
          name: "case_expression$ebnf$2",
          symbols: ["case_expression$ebnf$2", "case_clause"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "case_expression",
          symbols: [y_.has("CASE") ? {
            type: "CASE"
          } : CASE, "_", "case_expression$ebnf$1", "case_expression$ebnf$2", y_.has("END") ? {
            type: "END"
          } : END],
          postprocess: ([e, t, i, r, s]) => ({
            type: L_.case_expression,
            caseKw: b_(D_(e), {
              trailing: t
            }),
            endKw: D_(s),
            expr: i || [],
            clauses: r
          })
        }, {
          name: "case_clause",
          symbols: [y_.has("WHEN") ? {
            type: "WHEN"
          } : WHEN, "_", "expression_chain_", y_.has("THEN") ? {
            type: "THEN"
          } : THEN, "_", "expression_chain_"],
          postprocess: ([e, t, i, r, s, n]) => ({
            type: L_.case_when,
            whenKw: b_(D_(e), {
              trailing: t
            }),
            thenKw: b_(D_(r), {
              trailing: s
            }),
            condition: i,
            result: n
          })
        }, {
          name: "case_clause",
          symbols: [y_.has("ELSE") ? {
            type: "ELSE"
          } : ELSE, "_", "expression_chain_"],
          postprocess: ([e, t, i]) => ({
            type: L_.case_else,
            elseKw: b_(D_(e), {
              trailing: t
            }),
            result: i
          })
        }, {
          name: "comma$subexpression$1",
          symbols: [y_.has("COMMA") ? {
            type: "COMMA"
          } : COMMA]
        }, {
          name: "comma",
          symbols: ["comma$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.comma
          })
        }, {
          name: "asterisk$subexpression$1",
          symbols: [y_.has("ASTERISK") ? {
            type: "ASTERISK"
          } : ASTERISK]
        }, {
          name: "asterisk",
          symbols: ["asterisk$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.operator,
            text: e.text
          })
        }, {
          name: "operator$subexpression$1",
          symbols: [y_.has("OPERATOR") ? {
            type: "OPERATOR"
          } : OPERATOR]
        }, {
          name: "operator",
          symbols: ["operator$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.operator,
            text: e.text
          })
        }, {
          name: "identifier$subexpression$1",
          symbols: [y_.has("IDENTIFIER") ? {
            type: "IDENTIFIER"
          } : IDENTIFIER]
        }, {
          name: "identifier$subexpression$1",
          symbols: [y_.has("QUOTED_IDENTIFIER") ? {
            type: "QUOTED_IDENTIFIER"
          } : QUOTED_IDENTIFIER]
        }, {
          name: "identifier$subexpression$1",
          symbols: [y_.has("VARIABLE") ? {
            type: "VARIABLE"
          } : VARIABLE]
        }, {
          name: "identifier",
          symbols: ["identifier$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.identifier,
            quoted: "IDENTIFIER" !== e.type,
            text: e.text
          })
        }, {
          name: "parameter$subexpression$1",
          symbols: [y_.has("NAMED_PARAMETER") ? {
            type: "NAMED_PARAMETER"
          } : NAMED_PARAMETER]
        }, {
          name: "parameter$subexpression$1",
          symbols: [y_.has("QUOTED_PARAMETER") ? {
            type: "QUOTED_PARAMETER"
          } : QUOTED_PARAMETER]
        }, {
          name: "parameter$subexpression$1",
          symbols: [y_.has("NUMBERED_PARAMETER") ? {
            type: "NUMBERED_PARAMETER"
          } : NUMBERED_PARAMETER]
        }, {
          name: "parameter$subexpression$1",
          symbols: [y_.has("POSITIONAL_PARAMETER") ? {
            type: "POSITIONAL_PARAMETER"
          } : POSITIONAL_PARAMETER]
        }, {
          name: "parameter$subexpression$1",
          symbols: [y_.has("CUSTOM_PARAMETER") ? {
            type: "CUSTOM_PARAMETER"
          } : CUSTOM_PARAMETER]
        }, {
          name: "parameter",
          symbols: ["parameter$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.parameter,
            key: e.key,
            text: e.text
          })
        }, {
          name: "literal$subexpression$1",
          symbols: [y_.has("NUMBER") ? {
            type: "NUMBER"
          } : NUMBER]
        }, {
          name: "literal$subexpression$1",
          symbols: [y_.has("STRING") ? {
            type: "STRING"
          } : STRING]
        }, {
          name: "literal",
          symbols: ["literal$subexpression$1"],
          postprocess: ([
            [e]
          ]) => ({
            type: L_.literal,
            text: e.text
          })
        }, {
          name: "keyword$subexpression$1",
          symbols: [y_.has("RESERVED_KEYWORD") ? {
            type: "RESERVED_KEYWORD"
          } : RESERVED_KEYWORD]
        }, {
          name: "keyword$subexpression$1",
          symbols: [y_.has("RESERVED_KEYWORD_PHRASE") ? {
            type: "RESERVED_KEYWORD_PHRASE"
          } : RESERVED_KEYWORD_PHRASE]
        }, {
          name: "keyword$subexpression$1",
          symbols: [y_.has("RESERVED_JOIN") ? {
            type: "RESERVED_JOIN"
          } : RESERVED_JOIN]
        }, {
          name: "keyword",
          symbols: ["keyword$subexpression$1"],
          postprocess: ([
            [e]
          ]) => D_(e)
        }, {
          name: "data_type$subexpression$1",
          symbols: [y_.has("RESERVED_DATA_TYPE") ? {
            type: "RESERVED_DATA_TYPE"
          } : RESERVED_DATA_TYPE]
        }, {
          name: "data_type$subexpression$1",
          symbols: [y_.has("RESERVED_DATA_TYPE_PHRASE") ? {
            type: "RESERVED_DATA_TYPE_PHRASE"
          } : RESERVED_DATA_TYPE_PHRASE]
        }, {
          name: "data_type",
          symbols: ["data_type$subexpression$1"],
          postprocess: ([
            [e]
          ]) => P_(e)
        }, {
          name: "data_type",
          symbols: [y_.has("RESERVED_PARAMETERIZED_DATA_TYPE") ? {
            type: "RESERVED_PARAMETERIZED_DATA_TYPE"
          } : RESERVED_PARAMETERIZED_DATA_TYPE, "_", "parenthesis"],
          postprocess: ([e, t, i]) => ({
            type: L_.parameterized_data_type,
            dataType: b_(P_(e), {
              trailing: t
            }),
            parenthesis: i
          })
        }, {
          name: "logic_operator$subexpression$1",
          symbols: [y_.has("AND") ? {
            type: "AND"
          } : AND]
        }, {
          name: "logic_operator$subexpression$1",
          symbols: [y_.has("OR") ? {
            type: "OR"
          } : OR]
        }, {
          name: "logic_operator$subexpression$1",
          symbols: [y_.has("XOR") ? {
            type: "XOR"
          } : XOR]
        }, {
          name: "logic_operator",
          symbols: ["logic_operator$subexpression$1"],
          postprocess: ([
            [e]
          ]) => D_(e)
        }, {
          name: "other_keyword$subexpression$1",
          symbols: [y_.has("WHEN") ? {
            type: "WHEN"
          } : WHEN]
        }, {
          name: "other_keyword$subexpression$1",
          symbols: [y_.has("THEN") ? {
            type: "THEN"
          } : THEN]
        }, {
          name: "other_keyword$subexpression$1",
          symbols: [y_.has("ELSE") ? {
            type: "ELSE"
          } : ELSE]
        }, {
          name: "other_keyword$subexpression$1",
          symbols: [y_.has("END") ? {
            type: "END"
          } : END]
        }, {
          name: "other_keyword",
          symbols: ["other_keyword$subexpression$1"],
          postprocess: ([
            [e]
          ]) => D_(e)
        }, {
          name: "_$ebnf$1",
          symbols: []
        }, {
          name: "_$ebnf$1",
          symbols: ["_$ebnf$1", "comment"],
          postprocess: e => e[0].concat([e[1]])
        }, {
          name: "_",
          symbols: ["_$ebnf$1"],
          postprocess: ([e]) => e
        }, {
          name: "comment",
          symbols: [y_.has("LINE_COMMENT") ? {
            type: "LINE_COMMENT"
          } : LINE_COMMENT],
          postprocess: ([e]) => ({
            type: L_.line_comment,
            text: e.text,
            precedingWhitespace: e.precedingWhitespace
          })
        }, {
          name: "comment",
          symbols: [y_.has("BLOCK_COMMENT") ? {
            type: "BLOCK_COMMENT"
          } : BLOCK_COMMENT],
          postprocess: ([e]) => ({
            type: L_.block_comment,
            text: e.text,
            precedingWhitespace: e.precedingWhitespace
          })
        }, {
          name: "comment",
          symbols: [y_.has("DISABLE_COMMENT") ? {
            type: "DISABLE_COMMENT"
          } : DISABLE_COMMENT],
          postprocess: ([e]) => ({
            type: L_.disable_comment,
            text: e.text,
            precedingWhitespace: e.precedingWhitespace
          })
        }],
        ParserStart: "main"
      },
      x_ = F_,
      {
        Parser: G_,
        Grammar: U_
      } = g_;
    var H_;
    ! function(e) {
      e[e.SPACE = 0] = "SPACE", e[e.NO_SPACE = 1] = "NO_SPACE", e[e.NO_NEWLINE = 2] = "NO_NEWLINE", e[e.NEWLINE = 3] = "NEWLINE", e[e.MANDATORY_NEWLINE = 4] = "MANDATORY_NEWLINE", e[e.INDENT = 5] = "INDENT", e[e.SINGLE_INDENT = 6] = "SINGLE_INDENT"
    }(H_ = H_ || (H_ = {}));
    class k_ {
      constructor(e) {
        this.indentation = e, this.items = []
      }
      add(...e) {
        for (const t of e) switch (t) {
          case H_.SPACE:
            this.items.push(H_.SPACE);
            break;
          case H_.NO_SPACE:
            this.trimHorizontalWhitespace();
            break;
          case H_.NO_NEWLINE:
            this.trimWhitespace();
            break;
          case H_.NEWLINE:
            this.trimHorizontalWhitespace(), this.addNewline(H_.NEWLINE);
            break;
          case H_.MANDATORY_NEWLINE:
            this.trimHorizontalWhitespace(), this.addNewline(H_.MANDATORY_NEWLINE);
            break;
          case H_.INDENT:
            this.addIndentation();
            break;
          case H_.SINGLE_INDENT:
            this.items.push(H_.SINGLE_INDENT);
            break;
          default:
            this.items.push(t)
        }
      }
      trimHorizontalWhitespace() {
        for (; B_(UL(this.items));) this.items.pop()
      }
      trimWhitespace() {
        for (; V_(UL(this.items));) this.items.pop()
      }
      addNewline(e) {
        if (this.items.length > 0) switch (UL(this.items)) {
          case H_.NEWLINE:
            this.items.pop(), this.items.push(e);
            break;
          case H_.MANDATORY_NEWLINE:
            break;
          default:
            this.items.push(e)
        }
      }
      addIndentation() {
        for (let e = 0; e < this.indentation.getLevel(); e++) this.items.push(H_.SINGLE_INDENT)
      }
      toString() {
        return this.items.map(e => this.itemToString(e)).join("")
      }
      getLayoutItems() {
        return this.items
      }
      itemToString(e) {
        switch (e) {
          case H_.SPACE:
            return " ";
          case H_.NEWLINE:
          case H_.MANDATORY_NEWLINE:
            return "\n";
          case H_.SINGLE_INDENT:
            return this.indentation.getSingleIndent();
          default:
            return e
        }
      }
    }
    const B_ = e => e === H_.SPACE || e === H_.SINGLE_INDENT,
      V_ = e => e === H_.SPACE || e === H_.SINGLE_INDENT || e === H_.NEWLINE;

    function W_(e, t) {
      if ("standard" === t) return e;
      let i = [];
      return e.length >= 10 && e.includes(" ") && ([e, ...i] = e.split(" ")), (e = "tabularLeft" === t ? e.padEnd(9, " ") : e.padStart(9, " ")) + ["", ...i].join(" ")
    }

    function Y_(e) {
      return (e => e === RN.AND || e === RN.OR || e === RN.XOR)(e) || e === RN.RESERVED_CLAUSE || e === RN.RESERVED_SELECT || e === RN.RESERVED_SET_OPERATION || e === RN.RESERVED_JOIN || e === RN.LIMIT
    }
    const K_ = "top-level";
    class X_ {
      constructor(e) {
        this.indent = e, this.indentTypes = []
      }
      getSingleIndent() {
        return this.indent
      }
      getLevel() {
        return this.indentTypes.length
      }
      increaseTopLevel() {
        this.indentTypes.push(K_)
      }
      increaseBlockLevel() {
        this.indentTypes.push("block-level")
      }
      decreaseTopLevel() {
        this.indentTypes.length > 0 && UL(this.indentTypes) === K_ && this.indentTypes.pop()
      }
      decreaseBlockLevel() {
        for (; this.indentTypes.length > 0;) {
          if (this.indentTypes.pop() !== K_) break
        }
      }
    }
    class z_ extends k_ {
      constructor(e) {
        super(new X_("")), this.expressionWidth = e, this.length = 0, this.trailingSpace = !1
      }
      add(...e) {
        if (e.forEach(e => this.addToLength(e)), this.length > this.expressionWidth) throw new $_;
        super.add(...e)
      }
      addToLength(e) {
        if ("string" == typeof e) this.length += e.length, this.trailingSpace = !1;
        else {
          if (e === H_.MANDATORY_NEWLINE || e === H_.NEWLINE) throw new $_;
          e === H_.INDENT || e === H_.SINGLE_INDENT || e === H_.SPACE ? this.trailingSpace || (this.length++, this.trailingSpace = !0) : e !== H_.NO_NEWLINE && e !== H_.NO_SPACE || this.trailingSpace && (this.trailingSpace = !1, this.length--)
        }
      }
    }
    class $_ extends Error {}
    class j_ {
      constructor({
        cfg: e,
        dialectCfg: t,
        params: i,
        layout: r,
        inline: s = !1
      }) {
        this.inline = !1, this.nodes = [], this.index = -1, this.cfg = e, this.dialectCfg = t, this.inline = s, this.params = i, this.layout = r
      }
      format(e) {
        for (this.nodes = e, this.index = 0; this.index < this.nodes.length; this.index++) this.formatNode(this.nodes[this.index]);
        return this.layout
      }
      formatNode(e) {
        this.formatComments(e.leadingComments), this.formatNodeWithoutComments(e), this.formatComments(e.trailingComments)
      }
      formatNodeWithoutComments(e) {
        switch (e.type) {
          case L_.function_call:
            return this.formatFunctionCall(e);
          case L_.parameterized_data_type:
            return this.formatParameterizedDataType(e);
          case L_.array_subscript:
            return this.formatArraySubscript(e);
          case L_.property_access:
            return this.formatPropertyAccess(e);
          case L_.parenthesis:
            return this.formatParenthesis(e);
          case L_.between_predicate:
            return this.formatBetweenPredicate(e);
          case L_.case_expression:
            return this.formatCaseExpression(e);
          case L_.case_when:
            return this.formatCaseWhen(e);
          case L_.case_else:
            return this.formatCaseElse(e);
          case L_.clause:
            return this.formatClause(e);
          case L_.set_operation:
            return this.formatSetOperation(e);
          case L_.limit_clause:
            return this.formatLimitClause(e);
          case L_.all_columns_asterisk:
            return this.formatAllColumnsAsterisk(e);
          case L_.literal:
            return this.formatLiteral(e);
          case L_.identifier:
            return this.formatIdentifier(e);
          case L_.parameter:
            return this.formatParameter(e);
          case L_.operator:
            return this.formatOperator(e);
          case L_.comma:
            return this.formatComma(e);
          case L_.line_comment:
            return this.formatLineComment(e);
          case L_.block_comment:
          case L_.disable_comment:
            return this.formatBlockComment(e);
          case L_.data_type:
            return this.formatDataType(e);
          case L_.keyword:
            return this.formatKeywordNode(e)
        }
      }
      formatFunctionCall(e) {
        this.withComments(e.nameKw, () => {
          this.layout.add(this.showFunctionKw(e.nameKw))
        }), this.formatNode(e.parenthesis)
      }
      formatParameterizedDataType(e) {
        this.withComments(e.dataType, () => {
          this.layout.add(this.showDataType(e.dataType))
        }), this.formatNode(e.parenthesis)
      }
      formatArraySubscript(e) {
        let t;
        switch (e.array.type) {
          case L_.data_type:
            t = this.showDataType(e.array);
            break;
          case L_.keyword:
            t = this.showKw(e.array);
            break;
          default:
            t = this.showIdentifier(e.array)
        }
        this.withComments(e.array, () => {
          this.layout.add(t)
        }), this.formatNode(e.parenthesis)
      }
      formatPropertyAccess(e) {
        this.formatNode(e.object), this.layout.add(H_.NO_SPACE, e.operator), this.formatNode(e.property)
      }
      formatParenthesis(e) {
        const t = this.formatInlineExpression(e.children);
        t ? (this.layout.add(e.openParen), this.layout.add(...t.getLayoutItems()), this.layout.add(H_.NO_SPACE, e.closeParen, H_.SPACE)) : (this.layout.add(e.openParen, H_.NEWLINE), p_(this.cfg) ? (this.layout.add(H_.INDENT), this.layout = this.formatSubExpression(e.children)) : (this.layout.indentation.increaseBlockLevel(), this.layout.add(H_.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseBlockLevel()), this.layout.add(H_.NEWLINE, H_.INDENT, e.closeParen, H_.SPACE))
      }
      formatBetweenPredicate(e) {
        this.layout.add(this.showKw(e.betweenKw), H_.SPACE), this.layout = this.formatSubExpression(e.expr1), this.layout.add(H_.NO_SPACE, H_.SPACE, this.showNonTabularKw(e.andKw), H_.SPACE), this.layout = this.formatSubExpression(e.expr2), this.layout.add(H_.SPACE)
      }
      formatCaseExpression(e) {
        this.formatNode(e.caseKw), this.layout.indentation.increaseBlockLevel(), this.layout = this.formatSubExpression(e.expr), this.layout = this.formatSubExpression(e.clauses), this.layout.indentation.decreaseBlockLevel(), this.layout.add(H_.NEWLINE, H_.INDENT), this.formatNode(e.endKw)
      }
      formatCaseWhen(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT), this.formatNode(e.whenKw), this.layout = this.formatSubExpression(e.condition), this.formatNode(e.thenKw), this.layout = this.formatSubExpression(e.result)
      }
      formatCaseElse(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT), this.formatNode(e.elseKw), this.layout = this.formatSubExpression(e.result)
      }
      formatClause(e) {
        this.isOnelineClause(e) ? this.formatClauseInOnelineStyle(e) : p_(this.cfg) ? this.formatClauseInTabularStyle(e) : this.formatClauseInIndentedStyle(e)
      }
      isOnelineClause(e) {
        return p_(this.cfg) ? this.dialectCfg.tabularOnelineClauses[e.nameKw.text] : this.dialectCfg.onelineClauses[e.nameKw.text]
      }
      formatClauseInIndentedStyle(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e.nameKw), H_.NEWLINE), this.layout.indentation.increaseTopLevel(), this.layout.add(H_.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel()
      }
      formatClauseInOnelineStyle(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e.nameKw), H_.SPACE), this.layout = this.formatSubExpression(e.children)
      }
      formatClauseInTabularStyle(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e.nameKw), H_.SPACE), this.layout.indentation.increaseTopLevel(), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel()
      }
      formatSetOperation(e) {
        this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e.nameKw), H_.NEWLINE), this.layout.add(H_.INDENT), this.layout = this.formatSubExpression(e.children)
      }
      formatLimitClause(e) {
        this.withComments(e.limitKw, () => {
          this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e.limitKw))
        }), this.layout.indentation.increaseTopLevel(), p_(this.cfg) ? this.layout.add(H_.SPACE) : this.layout.add(H_.NEWLINE, H_.INDENT), e.offset ? (this.layout = this.formatSubExpression(e.offset), this.layout.add(H_.NO_SPACE, ",", H_.SPACE), this.layout = this.formatSubExpression(e.count)) : this.layout = this.formatSubExpression(e.count), this.layout.indentation.decreaseTopLevel()
      }
      formatAllColumnsAsterisk(e) {
        this.layout.add("*", H_.SPACE)
      }
      formatLiteral(e) {
        this.layout.add(e.text, H_.SPACE)
      }
      formatIdentifier(e) {
        this.layout.add(this.showIdentifier(e), H_.SPACE)
      }
      formatParameter(e) {
        this.layout.add(this.params.get(e), H_.SPACE)
      }
      formatOperator({
        text: e
      }) {
        this.cfg.denseOperators || this.dialectCfg.alwaysDenseOperators.includes(e) ? this.layout.add(H_.NO_SPACE, e) : ":" === e ? this.layout.add(H_.NO_SPACE, e, H_.SPACE) : this.layout.add(e, H_.SPACE)
      }
      formatComma(e) {
        this.inline ? this.layout.add(H_.NO_SPACE, ",", H_.SPACE) : this.layout.add(H_.NO_SPACE, ",", H_.NEWLINE, H_.INDENT)
      }
      withComments(e, t) {
        this.formatComments(e.leadingComments), t(), this.formatComments(e.trailingComments)
      }
      formatComments(e) {
        e && e.forEach(e => {
          e.type === L_.line_comment ? this.formatLineComment(e) : this.formatBlockComment(e)
        })
      }
      formatLineComment(e) {
        BL(e.precedingWhitespace || "") ? this.layout.add(H_.NEWLINE, H_.INDENT, e.text, H_.MANDATORY_NEWLINE, H_.INDENT) : this.layout.getLayoutItems().length > 0 ? this.layout.add(H_.NO_NEWLINE, H_.SPACE, e.text, H_.MANDATORY_NEWLINE, H_.INDENT) : this.layout.add(e.text, H_.MANDATORY_NEWLINE, H_.INDENT)
      }
      formatBlockComment(e) {
        e.type === L_.block_comment && this.isMultilineBlockComment(e) ? (this.splitBlockComment(e.text).forEach(e => {
          this.layout.add(H_.NEWLINE, H_.INDENT, e)
        }), this.layout.add(H_.NEWLINE, H_.INDENT)) : this.layout.add(e.text, H_.SPACE)
      }
      isMultilineBlockComment(e) {
        return BL(e.text) || BL(e.precedingWhitespace || "")
      }
      isDocComment(e) {
        const t = e.split(/\n/);
        return /^\/\*\*?$/.test(t[0]) && t.slice(1, t.length - 1).every(e => /^\s*\*/.test(e)) && /^\s*\*\/$/.test(UL(t))
      }
      splitBlockComment(e) {
        return this.isDocComment(e) ? e.split(/\n/).map(e => /^\s*\*/.test(e) ? " " + e.replace(/^\s*/, "") : e) : e.split(/\n/).map(e => e.replace(/^\s*/, ""))
      }
      formatSubExpression(e) {
        return new j_({
          cfg: this.cfg,
          dialectCfg: this.dialectCfg,
          params: this.params,
          layout: this.layout,
          inline: this.inline
        }).format(e)
      }
      formatInlineExpression(e) {
        const t = this.params.getPositionalParameterIndex();
        try {
          return new j_({
            cfg: this.cfg,
            dialectCfg: this.dialectCfg,
            params: this.params,
            layout: new z_(this.cfg.expressionWidth),
            inline: !0
          }).format(e)
        } catch (e) {
          if (e instanceof $_) return void this.params.setPositionalParameterIndex(t);
          throw e
        }
      }
      formatKeywordNode(e) {
        switch (e.tokenType) {
          case RN.RESERVED_JOIN:
            return this.formatJoin(e);
          case RN.AND:
          case RN.OR:
          case RN.XOR:
            return this.formatLogicalOperator(e);
          default:
            return this.formatKeyword(e)
        }
      }
      formatJoin(e) {
        p_(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e), H_.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e), H_.SPACE)
      }
      formatKeyword(e) {
        this.layout.add(this.showKw(e), H_.SPACE)
      }
      formatLogicalOperator(e) {
        "before" === this.cfg.logicalOperatorNewline ? p_(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e), H_.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(H_.NEWLINE, H_.INDENT, this.showKw(e), H_.SPACE) : this.layout.add(this.showKw(e), H_.NEWLINE, H_.INDENT)
      }
      formatDataType(e) {
        this.layout.add(this.showDataType(e), H_.SPACE)
      }
      showKw(e) {
        return Y_(e.tokenType) ? W_(this.showNonTabularKw(e), this.cfg.indentStyle) : this.showNonTabularKw(e)
      }
      showNonTabularKw(e) {
        switch (this.cfg.keywordCase) {
          case "preserve":
            return kL(e.raw);
          case "upper":
            return e.text;
          case "lower":
            return e.text.toLowerCase()
        }
      }
      showFunctionKw(e) {
        return Y_(e.tokenType) ? W_(this.showNonTabularFunctionKw(e), this.cfg.indentStyle) : this.showNonTabularFunctionKw(e)
      }
      showNonTabularFunctionKw(e) {
        switch (this.cfg.functionCase) {
          case "preserve":
            return kL(e.raw);
          case "upper":
            return e.text;
          case "lower":
            return e.text.toLowerCase()
        }
      }
      showIdentifier(e) {
        if (e.quoted) return e.text;
        switch (this.cfg.identifierCase) {
          case "preserve":
            return e.text;
          case "upper":
            return e.text.toUpperCase();
          case "lower":
            return e.text.toLowerCase()
        }
      }
      showDataType(e) {
        switch (this.cfg.dataTypeCase) {
          case "preserve":
            return kL(e.raw);
          case "upper":
            return e.text;
          case "lower":
            return e.text.toLowerCase()
        }
      }
    }
    class J_ {
      constructor(e, t) {
        this.dialect = e, this.cfg = t, this.params = new E_(this.cfg.params)
      }
      format(e) {
        const t = this.parse(e);
        return this.formatAst(t).trimEnd()
      }
      parse(e) {
        return function(e) {
          let t = {};
          const i = new O_(i => {
              return [...(r = e.tokenize(i, t), r.map(f_).map(T_).map(m_).map(C_).map(S_)), AN(i.length)];
              var r
            }),
            r = new G_(U_.fromCompiled(x_), {
              lexer: i
            });
          return {
            parse: (e, i) => {
              t = i;
              const {
                results: s
              } = r.feed(e);
              if (1 === s.length) return s[0];
              throw 0 === s.length ? new Error("Parse error: Invalid SQL") : new Error(`Parse error: Ambiguous grammar\n${JSON.stringify(s,void 0,2)}`)
            }
          }
        }(this.dialect.tokenizer).parse(e, this.cfg.paramTypes || {})
      }
      formatAst(e) {
        return e.map(e => this.formatStatement(e)).join("\n".repeat(this.cfg.linesBetweenQueries + 1))
      }
      formatStatement(e) {
        const t = new j_({
          cfg: this.cfg,
          dialectCfg: this.dialect.formatOptions,
          params: this.params,
          layout: new k_(new X_((i = this.cfg, "tabularLeft" === i.indentStyle || "tabularRight" === i.indentStyle ? " ".repeat(10) : i.useTabs ? "\t" : " ".repeat(i.tabWidth))))
        }).format(e.children);
        var i;
        return e.hasSemicolon && (this.cfg.newlineBeforeSemicolon ? t.add(H_.NEWLINE, ";") : t.add(H_.NO_NEWLINE, ";")), t.toString()
      }
    }
    class q_ extends Error {}

    function Q_(e) {
      const t = ["multilineLists", "newlineBeforeOpenParen", "newlineBeforeCloseParen", "aliasAs", "commaPosition", "tabulateAlias"];
      for (const i of t)
        if (i in e) throw new q_(`${i} config is no more supported.`);
      if (e.expressionWidth <= 0) throw new q_(`expressionWidth config must be positive number. Received ${e.expressionWidth} instead.`);
      var i;
      if (e.params && !((i = e.params) instanceof Array ? i : Object.values(i)).every(e => "string" == typeof e) && console.warn('WARNING: All "params" option values should be strings.'), e.paramTypes && ! function(e) {
          if (e.custom && Array.isArray(e.custom)) return e.custom.every(e => "" !== e.regex);
          return !0
        }(e.paramTypes)) throw new q_("Empty regex given in custom paramTypes. That would result in matching infinite amount of parameters.");
      return e
    }
    var Z_ = function(e, t) {
      var i = {};
      for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (i[r] = e[r]);
      if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
        var s = 0;
        for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (i[r[s]] = e[r[s]])
      }
      return i
    };
    const ey = {
        bigquery: "bigquery",
        db2: "db2",
        db2i: "db2i",
        duckdb: "duckdb",
        hive: "hive",
        mariadb: "mariadb",
        mysql: "mysql",
        n1ql: "n1ql",
        plsql: "plsql",
        postgresql: "postgresql",
        redshift: "redshift",
        spark: "spark",
        sqlite: "sqlite",
        sql: "sql",
        tidb: "tidb",
        trino: "trino",
        transactsql: "transactsql",
        tsql: "transactsql",
        singlestoredb: "singlestoredb",
        snowflake: "snowflake"
      },
      ty = Object.keys(ey),
      iy = {
        tabWidth: 2,
        useTabs: !1,
        keywordCase: "preserve",
        identifierCase: "preserve",
        dataTypeCase: "preserve",
        functionCase: "preserve",
        indentStyle: "standard",
        logicalOperatorNewline: "before",
        expressionWidth: 50,
        linesBetweenQueries: 1,
        denseOperators: !1,
        newlineBeforeSemicolon: !1
      },
      ry = (e, t) => {
        var {
          dialect: i
        } = t, r = Z_(t, ["dialect"]);
        if ("string" != typeof e) throw new Error("Invalid query argument. Expected string, instead got " + typeof e);
        const s = Q_(Object.assign(Object.assign({}, iy), r));
        return new J_((e => {
          let t = h_.get(e);
          return t || (t = u_(e), h_.set(e, t)), t
        })(i), s).format(e)
      };
    window.$ = window.jQuery = s(), window.bootstrap = n, window.CodeMirror = a(), window.agGrid = {
      createGrid: function(e, t, i) {
        if (!t) return j("No gridOptions provided to createGrid"), {};
        const r = (new Lh).create(e, t, t => {
          const i = new vc(e);
          t.createBean(i)
        }, void 0, i);
        if (!Object.isFrozen(t) && !(null == i ? void 0 : i.frameworkOverrides)) {
          const e = "https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api";
          Object.defineProperty(t, "api", {
            get: () => {
              j(`gridOptions.api is no longer supported. See ${e}.`)
            },
            configurable: !0
          }), Object.defineProperty(t, "columnApi", {
            get: () => {
              j(`gridOptions.columnApi is no longer supported and all methods moved to the grid api. See ${e}.`)
            },
            configurable: !0
          })
        }
        return r
      }
    }, window.XLSX = e, window.sqlFormatter = {
      format: (e, i = {}) => {
        if ("string" == typeof i.language && !ty.includes(i.language)) throw new q_(`Unsupported SQL dialect: ${i.language}`);
        const r = ey[i.language || "sql"];
        return ry(e, Object.assign(Object.assign({}, i), {
          dialect: t[r]
        }))
      }
    }, console.log("Multi-DB SQL Tool: Vendor libraries loaded")
  })()
})(window);